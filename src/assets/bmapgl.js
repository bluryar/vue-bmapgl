/* eslint-disable */
// @prettierignore
// @ts-nocheck

window.TILE_VERSION = {
  ditu: {
    normal: {
      version: "088",
      updateDate: "20230616"
    },
    satellite: {
      version: "009",
      updateDate: "20230616"
    },
    normalTraffic: {
      version: "081",
      updateDate: "20230616"
    },
    satelliteTraffic: {
      version: "083",
      updateDate: "20230616"
    },
    mapJS: {
      version: "104",
      updateDate: "20230616"
    },
    satelliteStreet: {
      version: "083",
      updateDate: "20230616"
    },
    earthVector: {
      version: "001",
      updateDate: "20230616"
    }
  },
  webapp: {
    high_normal: {
      version: "001",
      updateDate: "20230616"
    },
    lower_normal: {
      version: "002",
      updateDate: "20230616"
    }
  },
  api_for_mobile: {
    vector: {
      version: "002",
      updateDate: "20230616"
    },
    vectorIcon: {
      version: "002",
      updateDate: "20230616"
    }
  }
};
window.MSV = {
  mapstyle: {
    version: "001",
    updateDate: "20230616"
  }
};
window.BMAP_AUTHENTIC_KEY = window.BMAP_AUTHENTIC_KEY || "";
(function (t) {
  "use strict";

  function e(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
  }
  function n(t, e) {
    t(e = {
      exports: {}
    }, e.exports);
    return e.exports;
  }
  if (!Object.values) {
    Object.values = function (t) {
      if (t !== Object(t)) {
        throw new TypeError("Object.values called on a non-object");
      }
      var e;
      var n = [];
      for (e in t) {
        if (Object.prototype.hasOwnProperty.call(t, e)) {
          n.push(t[e]);
        }
      }
      return n;
    };
  }
  if (typeof Object.assign != "function") {
    Object.defineProperty(Object, "assign", {
      value: function (t) {
        if (t == null) {
          throw new TypeError("Cannot convert undefined or null to object");
        }
        for (var e = Object(t), n = 0; n < (arguments.length <= 1 ? 0 : arguments.length - 1); n++) {
          var r = n + 1 < 1 || arguments.length <= n + 1 ? undefined : arguments[n + 1];
          if (r != null) {
            for (var i in r) {
              if (Object.prototype.hasOwnProperty.call(r, i)) {
                e[i] = r[i];
              }
            }
          }
        }
        return e;
      },
      writable: true,
      configurable: true
    });
  }
  var r = n(function (t) {
    function e(n) {
      t.exports = e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (t) {
        return typeof t;
      } : function (t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
      };
      t.exports.__esModule = true;
      t.exports.default = t.exports;
      return e(n);
    }
    t.exports = e;
    t.exports.__esModule = true;
    t.exports.default = t.exports;
  });
  var i = e(r);
  var o = e(n(function (t) {
    function e(t, e) {
      for (var n = 0; n < e.length; n++) {
        var r = e[n];
        r.enumerable = r.enumerable || false;
        r.configurable = true;
        if ("value" in r) {
          r.writable = true;
        }
        Object.defineProperty(t, r.key, r);
      }
    }
    t.exports = function (t, n, r) {
      if (n) {
        e(t.prototype, n);
      }
      if (r) {
        e(t, r);
      }
      Object.defineProperty(t, "prototype", {
        writable: false
      });
      return t;
    };
    t.exports.__esModule = true;
    t.exports.default = t.exports;
  }));
  var a = e(n(function (t) {
    t.exports = function (t) {
      if (t === undefined) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return t;
    };
    t.exports.__esModule = true;
    t.exports.default = t.exports;
  }));
  var s = n(function (t) {
    function e(n, r) {
      t.exports = e = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
        t.__proto__ = e;
        return t;
      };
      t.exports.__esModule = true;
      t.exports.default = t.exports;
      return e(n, r);
    }
    t.exports = e;
    t.exports.__esModule = true;
    t.exports.default = t.exports;
  });
  e(s);
  var u;
  var h;
  var c = e(n(function (t) {
    t.exports = function (t, e) {
      t.prototype = Object.create(e.prototype);
      t.prototype.constructor = t;
      s(t, e);
    };
    t.exports.__esModule = true;
    t.exports.default = t.exports;
  }));
  var l = function (t, e) {
    var n = this;
    this.width = undefined;
    this.height = undefined;
    this.equals = function (t) {
      return t && n.width === t.width && n.height === t.height;
    };
    this.width = t || 0;
    this.height = e || 0;
  };
  var f = function () {
    function t(t, e) {
      this.lng = undefined;
      this.lat = undefined;
      this.lng = +t;
      this.lat = +e;
    }
    t.prototype.equals = function (t) {
      return t && this.lat === t.lat && this.lng === t.lng;
    };
    return t;
  }();
  var d = {
    REFRESH: "refresh",
    DATA_LOADED: "dataload",
    THUMB_LOADED: "thumb_loaded",
    SET_POV: "set_pov",
    POV_CHANGED: "pov_changed",
    POV_CHANGED_END: "pov_changed_end",
    ZOOM_CHANGED: "zoom_changed",
    SIZE_CHANGED: "size_changed",
    SET_ID: "set_id",
    SET_POSITION: "set_position",
    ID_CHANGED: "id_changed",
    POSITION_CHANGED: "position_changed",
    TOUCH_START: "touchstart",
    TOUCH_END: "touchend",
    CLICK: "click",
    DOUBLE_CLICK: "dblclick",
    LINK_CLICK: "link_click",
    OVERLAY_ADD: "overlay_add",
    OVERLAY_REMOVE: "overlay_remove",
    OVERLAYS_CLEAR: "overlays_clear",
    PANO_ERROR: "pano_error",
    LINK_VISIBLE_CHANGE: "links_visible_changed",
    DESTROY: "destroy",
    SCENE_CHANGE_END: "scene_change_end"
  };
  var p = {
    TYPE_INNER: "inter",
    TYPE_STREET: "street",
    RADIUS: 3000,
    COLS: 16,
    ROWS: 8,
    TILE_MAX_ZOOM: 4,
    TILE_MIN_ZOOM: 1,
    MIN_PITCH: -90,
    MAX_PITCH: 90,
    MAX_ZOOM: 4,
    MIN_ZOOM: 1,
    TILE_BASE_URLS: ["//apisv0.bdimg.com/", "//apisv1.bdimg.com/"],
    TOPO_ARROW_TEXTURE: "//webmap0.bdimg.com/wolfman/static/pano/images/webgl/topo_arrow_06f0f2e.png",
    FISHEYE_DURATION: 1500,
    FISHEYE_DELAY: 2000
  };
  u = {};
  h = (navigator.userAgent || "").toLowerCase();
  u.isAndroid = h.includes("android");
  u.isFirefox = h.includes("firefox");
  u.isIos = /ip(hone|ad|od)/i.test(h);
  u.isWeixin = h.includes("micromessenger");
  u.isWeibo = h.includes("weibo");
  u.isWeChatOrWeiBo = u.isWeixin && u.isWeibo;
  u.isBaiduMap = h.includes("baidumap_");
  u.isMobile = /android|webos|ip(hone|ad|od)|opera (mini|mobi|tablet)|iemobile|windows.+(phone|touch)|mobile|fennec|kindle (Fire)|Silk|maemo|blackberry|playbook; (touch|kbd)|Symbian(OS)|Ubuntu Touch/i.test(h);
  u.isPc = !u.isMobile;
  var v = u;
  var m = function (t) {
    for (var e = arguments.length <= 1 ? 0 : arguments.length - 1, n = 0; n < e; n++) {
      var r = n + 1 < 1 || arguments.length <= n + 1 ? undefined : arguments[n + 1];
      for (var i in r) {
        if (Object.prototype.hasOwnProperty.call(r, i)) {
          t[i] = r[i];
        }
      }
    }
    return t;
  };
  var g = function (t) {
    return t * Math.PI / 180;
  };
  var y = function (t) {
    return 180 * t / Math.PI;
  };
  var _ = function (t) {
    return t - 360 * Math.floor(t / 360);
  };
  var x = function () {
    return Date.now();
  };
  var b = function t() {
    var e = t;
    if (typeof e._supportWebGL == "boolean") {
      return e._supportWebGL;
    }
    if (!window.WebGLRenderingContext) {
      e._supportWebGL = false;
      return false;
    }
    var n = null;
    var r = document.createElement("canvas");
    try {
      if ((n = r.getContext("webgl") || r.getContext("experimental-webgl")) && n instanceof WebGLRenderingContext) {
        e._supportWebGL = true;
      }
    } catch (t) {
      e._supportWebGL = false;
    }
    if (n === null) {
      e._supportWebGL = false;
    }
    return e._supportWebGL;
  };
  var M = function (t) {
    for (var e, n = Number.MAX_VALUE, r = -Number.MAX_VALUE, i = t.length - 1; i >= 0; i--) {
      if (n > (e = t[i])) {
        n = e;
      }
      if (r < e) {
        r = e;
      }
    }
    return {
      min: n,
      max: r
    };
  };
  var w = {
    g: function (t) {
      return typeof t == "string" || t instanceof String ? document.getElementById(t) : t && t.nodeName && (t.nodeType === 1 || t.nodeType === 9) ? t : null;
    },
    show: function (t) {
      var e = w.g(t);
      if (e) {
        e.style.display = "";
      }
      return e;
    },
    hide: function (t) {
      var e = w.g(t);
      if (e) {
        e.style.display = "none";
      }
      return t;
    },
    create: function (t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var n = document.createElement(t);
      for (var r in e) {
        if (Object.prototype.hasOwnProperty.call(e, r)) {
          n.setAttribute(r, e[r]);
        }
      }
      return n;
    },
    getCurrentStyle: function (t) {
      return window.getComputedStyle(t, null);
    }
  };
  function E() {
    var t;
    var e;
    var n = function (t, e) {
      var n;
      var r;
      var i = "eii";
      var o = "dac";
      var a = "hem";
      var s = "llm";
      var u = function (t, e) {
        return t + e;
      };
      var h = "constructor";
      var c = function (t, e) {
        return t(e);
      };
      var l = function (t, e) {
        return t + e;
      };
      function f(t, e) {
        for (var n = i; n !== "mill";) {
          switch (n) {
            case "llm":
              return c;
            case "eii":
              var r = t.length;
              n = o;
              break;
            case a:
              for (var u = 0; u < r; u++) {
                var h = e(t[u]);
                c.push(h);
              }
              n = s;
              break;
            case "dac":
              var c = [];
              n = a;
          }
        }
      }
      var d = decodeURIComponent;
      b = "de";
      r = l("fr", "o") + "m";
      n = l("Co", b);
      var p = function (t) {
        return u(t, "")[h][u(r, "Char") + n](t);
      };
      var v = function (t) {
        return f(t, function (t) {
          return c(p, t);
        });
      };
      var m = v.call(p, [39, 34, 37, 96, 60, 120, 97, 65, 98, 66, 99, 67, 100, 68, 101, 69, 102, 70, 103, 110, 109, 111, 112, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57]);
      var g = f([28782, 27702, 26416, 25167, 24183], function (t) {
        return c(d, t);
      });
      var y = v.call(g, [22354, 22749, 24415, 23346, 22257, 22688, 24306, 25174, 23595, 25547, 22984, 25690, 22212, 27547, 21594, 27210, 23090, 29193, 22394, 29368, 29532, 29459, 29530, 24146, 24500, 26352, 27441, 28788, 29370, 27673, 26925, 25249, 24430]);
      var _ = {};
      g = c(v, g);
      for (var x = new RegExp(g.join("|")), b = 0; b < m.length; b++) {
        _[y[b]] = m[b];
      }
      e = f(e.split(""), function (t) {
        return _[t] || t;
      }).join("");
      return f(e.split(x), function (t) {
        return d(t);
      });
    }(0, "su尫stri犸坺幷囄獜呚囄獜扏su尫str氶h廲廲呚l灮i犸囄呚墠O娲氶呚呚廲廲廲朰墠h姈i囄朰彟曰氙si坺犸彟欱殛");
    t = n;
    e = 265;
    (function (e) {
      for (; --e;) {
        t.push(t.shift());
      }
    })(++e);
    var r = function (t, e) {
      return n[t -= 0];
    };
    return function (t) {
      var e = {
        dmedm: "F5L2O6R6AD8990O",
        haael: function (t, e) {
          return t + e;
        },
        eeaaa: function (t, e) {
          return t(e);
        },
        xhcid: function (t, e) {
          return t + e;
        },
        deiic: function (t, e) {
          return t - e;
        }
      };
      var n = e[r("0x0")];
      var i = t[r("0x1")](e[r("0x2")](t[r("0x3")]("?"), 1));
      var o = e[r("0x4")](md5, e[r("0x5")](md5(i + n), "H0A9P8P7Y6ABQO0"));
      return r("0x6") + o[r("0x7")](e.deiic(o.length, 12));
    };
  }
  var T = function (t, e, n) {
    var r;
    var o;
    var a = "";
    var s = [];
    var u = "jsonp" + Math.ceil(100000 * Math.random());
    var h = t.indexOf("?") > 0 ? "&" : "?";
    n = Object.assign({}, {
      jsonpCallback: "jsonp",
      timeout: 50000,
      jsonp: "callback"
    }, n);
    for (var c in e) {
      if ({}.hasOwnProperty.call(e, c)) {
        a = i(e[c]) === "object" ? c + "=" + JSON.stringify(e[c]) : c + "=" + e[c];
        s.push(a);
      }
    }
    function l() {
      if (r.parentNode) {
        r.parentNode.removeChild(r);
      }
      window[u] = null;
    }
    t += h + s.join("&");
    o = document.getElementsByTagName("script")[0] || document.head;
    t = t + "&" + n.jsonp + "=" + u;
    t += E()(t);
    (r = document.createElement("script")).src = t;
    r.type = "text/javascript";
    o.parentNode.appendChild(r, o);
    return new Promise(function (t, e) {
      window[u] = function (e) {
        if (e && typeof e == "string") {
          try {
            e = JSON.parse(e);
          } catch (t) {
            e = {};
            console.error("[ERROR] Parse Error.");
          }
        }
        t(e);
        l();
      };
      r.onerror = function (t) {
        l();
        e({
          errno: -2,
          errmsg: "[ERROR] Load Error: ".concat(t),
          data: {}
        });
      };
    });
  };
  var A = function () {
    function t() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this._size = 0;
      this._cache = undefined;
      this.keyList = [];
      this._options = undefined;
      this._size = t;
      this._cache = new window.Map();
      var n = {
        clearCallback: null
      };
      this._options = Object.assign({}, n, e);
    }
    var e = t.prototype;
    e.setData = function (t, e) {
      if (this._size !== 0) {
        if (this._cache.size >= this._size) {
          this._removeOld();
        }
        if (!this._cache.has(t)) {
          this.keyList.push(t);
        }
        this._cache.set(t, e);
      }
    };
    e.getData = function (t) {
      return this._cache.get(t);
    };
    e._removeOld = function () {
      for (var t = Math.round(0.6 * this._size), e = 0; e < t; e++) {
        var n = this.keyList[e];
        if (this._options.clearCallback) {
          this._options.clearCallback(this.getData(n));
        }
        this._cache.delete(n);
      }
      this.keyList.splice(0, t);
    };
    e.clear = function () {
      this._cache.clear();
      this.keyList = [];
    };
    o(t, [{
      key: "cacheCount",
      get: function () {
        return this._cache.size;
      }
    }]);
    return t;
  }();
  var C = function () {
    function t() {
      var t = this;
      this.rid = "";
      this.roadName = "";
      this.roadWidth = 5;
      this.isCurrentRoad = 0;
      this.pointList = [];
      this.getTopoInRoad = function (e) {
        var n = [];
        var r = t.pointList;
        var i = r.length;
        var o = t.getPointByPanoId(e);
        if (!o || i <= 1) {
          return n;
        }
        var a = o.order;
        if (a === 0) {
          n.push(t.generateTopoData(o.dir, r[1]));
        } else if (a === i - 1) {
          n.push(t.generateTopoData(r[a - 1].dir + 180, r[a - 1]));
        } else {
          n.push(t.generateTopoData((r[a - 1].dir + 180) % 360, r[a - 1]));
          n.push(t.generateTopoData(r[a].dir, r[a + 1]));
        }
        return n;
      };
      this.getPointByPanoId = function (e) {
        for (var n, r = t.pointList, i = 0, o = r.length; i < o; i++) {
          if (r[i].panoId === e) {
            n = r[i];
            break;
          }
        }
        return n;
      };
    }
    t.prototype.generateTopoData = function (t, e) {
      if (e !== undefined) {
        e.topoDir = t;
        e.roadName = this.roadName;
      }
      return e;
    };
    return t;
  }();
  var R = function () {
    var t = this;
    this.image = undefined;
    this.panoId = "";
    this.iid = "";
    this.panoType = "";
    this.panoX = 0;
    this.panoY = 0;
    this.panoZ = 0;
    this.heading = 0;
    this.pitch = 0;
    this.defaultHeading = undefined;
    this.defaultPitch = undefined;
    this.northDir = 0;
    this.fixHeading = 0;
    this.fixPitch = 0;
    this.fixRoll = 0;
    this.deviceHeight = 0;
    this.date = "20130822";
    this.time = "";
    this.provider = 1;
    this.admission = "GS(2013)6021";
    this.photos = [];
    this.roadName = "";
    this.roads = [];
    this.vpoints = [];
    this.topoArray = undefined;
    this.currentRoad = undefined;
    this.roadWidth = undefined;
    this.getCurrentRoad = function () {
      if (t.currentRoad) {
        return t.currentRoad;
      }
      for (var e = t.roads, n = 0, r = e.length; n < r; n++) {
        if (e[n].isCurrentRoad) {
          t.currentRoad = e[n];
          break;
        }
      }
      return t.currentRoad;
    };
    this.getTopos = function () {
      if (t.topoArray) {
        return t.topoArray;
      }
      if (!t.currentRoad) {
        t.currentRoad = t.getCurrentRoad();
      }
      if (!t.currentRoad) {
        return [];
      }
      t.topoArray = t.currentRoad.getTopoInRoad(t.panoId);
      if (t.vpoints.length < 1) {
        return t.topoArray;
      }
      for (var e, n = t.vpoints.length - 1; n >= 0; n--) {
        (e = t.vpoints[n]).topoDir = e.dir;
        t.topoArray.push(e);
      }
      return t.topoArray;
    };
    this.getRoadWidth = function () {
      if (t.roadWidth === undefined) {
        if (!t.currentRoad) {
          t.currentRoad = t.getCurrentRoad();
        }
        if (t.currentRoad) {
          t.roadWidth = t.currentRoad.roadWidth;
        } else {
          t.roadWidth = 0;
        }
      }
      return t.roadWidth;
    };
  };
  function S(t) {
    var e = {};
    e.panoId = t.PID;
    e.panoType = t.Type;
    e.rid = t.RID;
    e.dir = t.DIR;
    e.roadName = t.RoadName;
    e.order = t.Order;
    e.panoX = t.X / 100;
    e.panoY = t.Y / 100;
    if (t.CPointX !== undefined && t.CPointY !== undefined) {
      e.cPoint = {
        x: t.CPointX / 100,
        y: t.CPointY / 100
      };
    }
    return e;
  }
  function P(t) {
    if (!t) {
      console.error("Get none from server");
      return null;
    }
    var e = t.result;
    if (e && e.error !== 0) {
      console.error("Get error from server");
      return null;
    }
    var n = t.content;
    if (n === undefined || n.length === 0 || n[0] === undefined) {
      console.error("Get empty data from server");
      return null;
    }
    var r = n[0];
    var i = new R();
    var o = r.Roll;
    var a = {};
    i.panoId = r.ID;
    if (r.Inters instanceof Array) {
      var s = r.Inters[0];
      if (s !== undefined) {
        i.iid = s.IID;
      }
    }
    i.panoType = r.Type;
    i.panoX = (r.X || 0) / 100;
    i.panoY = (r.Y || 0) / 100;
    i.panoZ = (r.Z || 0) / 100;
    i.heading = r.MoveDir !== undefined ? r.MoveDir : 0;
    i.northDir = r.NorthDir;
    i.fixHeading = r.Heading !== undefined ? r.Heading : 270 - r.NorthDir;
    i.fixPitch = r.Pitch;
    i.fixRoll = o > 90 || o < -90 ? 0 : o;
    i.deviceHeight = r.DeviceHeight;
    i.date = r.Date || i.date;
    i.time = r.Time;
    i.provider = r.Provider !== undefined ? r.Provider : i.provider;
    i.admission = r.Admission || i.admission;
    i.timeLine = r.TimeLine || [];
    i.roadName = r.Rname;
    if (r.Roads) {
      var u = r.Roads;
      i.roads = u.map(function (t) {
        a[t.ID] = t.Name;
        return function (t) {
          var e = new C();
          e.rid = t.ID;
          e.roadName = t.Name;
          e.roadWidth = t.Width !== undefined ? t.Width / 100 : 0;
          e.isCurrentRoad = t.IsCurrent || 0;
          if (t.Panos) {
            for (var n = t.Panos, r = 0, i = n.length; r < i; r++) {
              e.pointList.push(S(n[r]));
            }
          }
          return e;
        }(t);
      });
    }
    if (r.Links) {
      for (var h = r.Links, c = h.length, l = 0; l < c; l++) {
        var f = h[l];
        f.RoadName = a[f.RID];
        i.vpoints.push(S(f));
      }
    }
    i.photos = r.Photos || [];
    return i;
  }
  function D(t, e) {
    var n = (65535 & t) + (65535 & e);
    return (t >> 16) + (e >> 16) + (n >> 16) << 16 | 65535 & n;
  }
  function O(t, e, n, r, i, o) {
    return D((a = D(D(e, t), D(r, o))) << (s = i) | a >>> 32 - s, n);
    var a;
    var s;
  }
  function I(t, e, n, r, i, o, a) {
    return O(e & n | ~e & r, t, e, i, o, a);
  }
  function L(t, e, n, r, i, o, a) {
    return O(e & r | n & ~r, t, e, i, o, a);
  }
  function B(t, e, n, r, i, o, a) {
    return O(e ^ n ^ r, t, e, i, o, a);
  }
  function k(t, e, n, r, i, o, a) {
    return O(n ^ (e | ~r), t, e, i, o, a);
  }
  function U(t, e) {
    var n;
    var r;
    var i;
    var o;
    var a;
    t[e >> 5] |= 128 << e % 32;
    t[14 + (e + 64 >>> 9 << 4)] = e;
    var s = 1732584193;
    var u = -271733879;
    var h = -1732584194;
    var c = 271733878;
    for (n = 0; n < t.length; n += 16) {
      r = s;
      i = u;
      o = h;
      a = c;
      s = I(s, u, h, c, t[n], 7, -680876936);
      c = I(c, s, u, h, t[n + 1], 12, -389564586);
      h = I(h, c, s, u, t[n + 2], 17, 606105819);
      u = I(u, h, c, s, t[n + 3], 22, -1044525330);
      s = I(s, u, h, c, t[n + 4], 7, -176418897);
      c = I(c, s, u, h, t[n + 5], 12, 1200080426);
      h = I(h, c, s, u, t[n + 6], 17, -1473231341);
      u = I(u, h, c, s, t[n + 7], 22, -45705983);
      s = I(s, u, h, c, t[n + 8], 7, 1770035416);
      c = I(c, s, u, h, t[n + 9], 12, -1958414417);
      h = I(h, c, s, u, t[n + 10], 17, -42063);
      u = I(u, h, c, s, t[n + 11], 22, -1990404162);
      s = I(s, u, h, c, t[n + 12], 7, 1804603682);
      c = I(c, s, u, h, t[n + 13], 12, -40341101);
      h = I(h, c, s, u, t[n + 14], 17, -1502002290);
      s = L(s, u = I(u, h, c, s, t[n + 15], 22, 1236535329), h, c, t[n + 1], 5, -165796510);
      c = L(c, s, u, h, t[n + 6], 9, -1069501632);
      h = L(h, c, s, u, t[n + 11], 14, 643717713);
      u = L(u, h, c, s, t[n], 20, -373897302);
      s = L(s, u, h, c, t[n + 5], 5, -701558691);
      c = L(c, s, u, h, t[n + 10], 9, 38016083);
      h = L(h, c, s, u, t[n + 15], 14, -660478335);
      u = L(u, h, c, s, t[n + 4], 20, -405537848);
      s = L(s, u, h, c, t[n + 9], 5, 568446438);
      c = L(c, s, u, h, t[n + 14], 9, -1019803690);
      h = L(h, c, s, u, t[n + 3], 14, -187363961);
      u = L(u, h, c, s, t[n + 8], 20, 1163531501);
      s = L(s, u, h, c, t[n + 13], 5, -1444681467);
      c = L(c, s, u, h, t[n + 2], 9, -51403784);
      h = L(h, c, s, u, t[n + 7], 14, 1735328473);
      s = B(s, u = L(u, h, c, s, t[n + 12], 20, -1926607734), h, c, t[n + 5], 4, -378558);
      c = B(c, s, u, h, t[n + 8], 11, -2022574463);
      h = B(h, c, s, u, t[n + 11], 16, 1839030562);
      u = B(u, h, c, s, t[n + 14], 23, -35309556);
      s = B(s, u, h, c, t[n + 1], 4, -1530992060);
      c = B(c, s, u, h, t[n + 4], 11, 1272893353);
      h = B(h, c, s, u, t[n + 7], 16, -155497632);
      u = B(u, h, c, s, t[n + 10], 23, -1094730640);
      s = B(s, u, h, c, t[n + 13], 4, 681279174);
      c = B(c, s, u, h, t[n], 11, -358537222);
      h = B(h, c, s, u, t[n + 3], 16, -722521979);
      u = B(u, h, c, s, t[n + 6], 23, 76029189);
      s = B(s, u, h, c, t[n + 9], 4, -640364487);
      c = B(c, s, u, h, t[n + 12], 11, -421815835);
      h = B(h, c, s, u, t[n + 15], 16, 530742520);
      s = k(s, u = B(u, h, c, s, t[n + 2], 23, -995338651), h, c, t[n], 6, -198630844);
      c = k(c, s, u, h, t[n + 7], 10, 1126891415);
      h = k(h, c, s, u, t[n + 14], 15, -1416354905);
      u = k(u, h, c, s, t[n + 5], 21, -57434055);
      s = k(s, u, h, c, t[n + 12], 6, 1700485571);
      c = k(c, s, u, h, t[n + 3], 10, -1894986606);
      h = k(h, c, s, u, t[n + 10], 15, -1051523);
      u = k(u, h, c, s, t[n + 1], 21, -2054922799);
      s = k(s, u, h, c, t[n + 8], 6, 1873313359);
      c = k(c, s, u, h, t[n + 15], 10, -30611744);
      h = k(h, c, s, u, t[n + 6], 15, -1560198380);
      u = k(u, h, c, s, t[n + 13], 21, 1309151649);
      s = k(s, u, h, c, t[n + 4], 6, -145523070);
      c = k(c, s, u, h, t[n + 11], 10, -1120210379);
      h = k(h, c, s, u, t[n + 2], 15, 718787259);
      u = k(u, h, c, s, t[n + 9], 21, -343485551);
      s = D(s, r);
      u = D(u, i);
      h = D(h, o);
      c = D(c, a);
    }
    return [s, u, h, c];
  }
  function N(t) {
    var e;
    var n = "";
    var r = 32 * t.length;
    for (e = 0; e < r; e += 8) {
      n += String.fromCharCode(t[e >> 5] >>> e % 32 & 255);
    }
    return n;
  }
  function F(t) {
    var e;
    var n = [];
    for (n[(t.length >> 2) - 1] = undefined, e = 0; e < n.length; e += 1) {
      n[e] = 0;
    }
    var r = 8 * t.length;
    for (e = 0; e < r; e += 8) {
      n[e >> 5] |= (255 & t.charCodeAt(e / 8)) << e % 32;
    }
    return n;
  }
  function j(t) {
    var e;
    var n;
    var r = "0123456789abcdef";
    var i = "";
    for (n = 0; n < t.length; n += 1) {
      e = t.charCodeAt(n);
      i += r.charAt(e >>> 4 & 15) + r.charAt(15 & e);
    }
    return i;
  }
  function z(t) {
    return unescape(encodeURIComponent(t));
  }
  function V(t) {
    return function (t) {
      return N(U(F(t), 8 * t.length));
    }(z(t));
  }
  function G(t, e) {
    return function (t, e) {
      var n;
      var r;
      var i = F(t);
      var o = [];
      var a = [];
      for (o[15] = a[15] = undefined, i.length > 16 && (i = U(i, 8 * t.length)), n = 0; n < 16; n += 1) {
        o[n] = 909522486 ^ i[n];
        a[n] = 1549556828 ^ i[n];
      }
      r = U(o.concat(F(e)), 512 + 8 * e.length);
      return N(U(a.concat(r), 640));
    }(z(t), z(e));
  }
  var W;
  var H;
  var Z;
  var q;
  var Y = function (t, e, n) {
    return e ? n ? G(e, t) : j(G(e, t)) : n ? V(t) : j(V(t));
  };
  var X = function (t, e) {
    return T(t, {}, {
      jsonp: "fn"
    });
  };
  var K = function (t, e) {
    if (t === "PANORAMA") {
      var n = "https://api.map.baidu.com/?qt=pano_entry&v=gl&ak=" + window.BMAP_AUTHENTIC_KEY;
      if (typeof e == "function") {
        X(n).then(function (t) {
          e();
        }).catch(function (t) {});
      } else {
        X(n + "&callback=" + e);
      }
    }
  };
  var Q = function (t) {
    if (t === "PANORAMA") {
      alert("您需要申请全景地图服务使用权限");
    }
  };
  H = null;
  Z = 0;
  q = W || 5000;
  var J = function (t) {
    var e = (100000 * Math.random()).toFixed(0);
    window["cbk" + e] = function (t) {
      if (!(t && t.error !== undefined && t.error === 0)) {
        K("PANORAMA", function (t) {
          if (!(t && t.error !== undefined && t.error === 0)) {
            Q("PANORAMA");
          }
        });
      }
    };
    Z += t;
    if (!H) {
      H = setTimeout(function () {
        var t = "https://api.map.baidu.com/?qt=pano_count&v=gl&ak=" + window.BMAP_AUTHENTIC_KEY + "&consume=" + Z;
        X(t + "&callback=window.cbk" + e);
        Z = 0;
        H = null;
      }, q);
    }
  };
  var $ = function (t, e) {
    var n = (e = e || {}).counter ? e.counter : 1;
    var r = e.isCounter !== false;
    var i = Date.parse(new Date());
    var o = i / 1000;
    var a = t + "-" + (o + 1800) + "-" + i + "-" + window.BMAP_AUTHENTIC_KEY + "-SJvEY5h37ZDh5pHS";
    var s = Y(a);
    var u = "auth_key=" + (o + 1800) + "-" + i + "-" + window.BMAP_AUTHENTIC_KEY + "-" + s;
    if (r) {
      J(n);
    }
    return u;
  };
  var tt = function () {
    function t(e) {
      var n = this;
      this.getPanoById = function (e) {
        var r;
        r = "".concat(t.SERVICE_URL, "?qt=sdata&sid=").concat(e, "&").concat($("/"));
        n.getDataByUrl(r).then(function (t) {
          var e = P(t);
          if (e === null) {
            throw new Error("数据解析异常");
          }
          n._cache.setData(r, t);
          n._pano.dispatchEvent(d.DATA_LOADED, {
            data: e
          });
          n._pano.dispatchEvent(d.ID_CHANGED, e.panoId);
          n._pano.dispatchEvent(d.POSITION_CHANGED, new f(e.panoX, e.panoY));
          return e;
        }).catch(function (t) {
          n._pano.dispatchEvent({
            type: d.PANO_ERROR,
            data: t
          });
        });
      };
      this.getPanoByLocation = function (e, r) {
        var i;
        i = "".concat(t.SERVICE_URL, "?qt=qsdata&x=").concat(e.lng, "&y=").concat(e.lat).concat(r ? "&r=" + r : "", "&action=1&").concat($("/"));
        n.getDataByUrl(i).then(function (t) {
          var r = P(t);
          n._cache.setData(i, t);
          n._pano.dispatchEvent(d.DATA_LOADED, {
            data: r
          });
          n._pano.dispatchEvent(d.POSITION_CHANGED, e);
        }).catch(function (t) {
          n._pano.dispatchEvent({
            type: d.PANO_ERROR,
            data: t
          });
        });
      };
      this._pano = e;
      this._cache = new A(10);
    }
    t.prototype.getDataByUrl = function (t) {
      var e = this._cache.getData(t);
      return e ? Promise.resolve(e) : T(t, {}, {
        jsonp: "fn"
      });
    };
    return t;
  }();
  tt.SERVICE_URL = "//apisv0.bdimg.com/";
  var et = n(function (t) {
    function e(t, e, n, r, i, o, a) {
      try {
        var s = t[o](a);
        var u = s.value;
      } catch (t) {
        return void n(t);
      }
      if (s.done) {
        e(u);
      } else {
        Promise.resolve(u).then(r, i);
      }
    }
    t.exports = function (t) {
      return function () {
        var n = this;
        var r = arguments;
        return new Promise(function (i, o) {
          var a = t.apply(n, r);
          function s(t) {
            e(a, i, o, s, u, "next", t);
          }
          function u(t) {
            e(a, i, o, s, u, "throw", t);
          }
          s(undefined);
        });
      };
    };
    t.exports.__esModule = true;
    t.exports.default = t.exports;
  });
  var nt = e(et);
  var rt = n(function (t) {
    var e = r.default;
    function n() {
      /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
      t.exports = n = function () {
        return r;
      };
      t.exports.__esModule = true;
      t.exports.default = t.exports;
      var r = {};
      var i = Object.prototype;
      var o = i.hasOwnProperty;
      var a = typeof Symbol == "function" ? Symbol : {};
      var s = a.iterator || "@@iterator";
      var u = a.asyncIterator || "@@asyncIterator";
      var h = a.toStringTag || "@@toStringTag";
      function c(t, e, n) {
        Object.defineProperty(t, e, {
          value: n,
          enumerable: true,
          configurable: true,
          writable: true
        });
        return t[e];
      }
      try {
        c({}, "");
      } catch (t) {
        c = function (t, e, n) {
          return t[e] = n;
        };
      }
      function l(t, e, n, r) {
        var i = e && e.prototype instanceof p ? e : p;
        var o = Object.create(i.prototype);
        var a = new A(r || []);
        o._invoke = function (t, e, n) {
          var r = "suspendedStart";
          return function (i, o) {
            if (r === "executing") {
              throw new Error("Generator is already running");
            }
            if (r === "completed") {
              if (i === "throw") {
                throw o;
              }
              return R();
            }
            for (n.method = i, n.arg = o;;) {
              var a = n.delegate;
              if (a) {
                var s = w(a, n);
                if (s) {
                  if (s === d) {
                    continue;
                  }
                  return s;
                }
              }
              if (n.method === "next") {
                n.sent = n._sent = n.arg;
              } else if (n.method === "throw") {
                if (r === "suspendedStart") {
                  throw r = "completed", n.arg;
                }
                n.dispatchException(n.arg);
              } else if (n.method === "return") {
                n.abrupt("return", n.arg);
              }
              r = "executing";
              var u = f(t, e, n);
              if (u.type === "normal") {
                r = n.done ? "completed" : "suspendedYield";
                if (u.arg === d) {
                  continue;
                }
                return {
                  value: u.arg,
                  done: n.done
                };
              }
              if (u.type === "throw") {
                r = "completed";
                n.method = "throw";
                n.arg = u.arg;
              }
            }
          };
        }(t, n, a);
        return o;
      }
      function f(t, e, n) {
        try {
          return {
            type: "normal",
            arg: t.call(e, n)
          };
        } catch (t) {
          return {
            type: "throw",
            arg: t
          };
        }
      }
      r.wrap = l;
      var d = {};
      function p() {}
      function v() {}
      function m() {}
      var g = {};
      c(g, s, function () {
        return this;
      });
      var y = Object.getPrototypeOf;
      var _ = y && y(y(C([])));
      if (_ && _ !== i && o.call(_, s)) {
        g = _;
      }
      var x = m.prototype = p.prototype = Object.create(g);
      function b(t) {
        ["next", "throw", "return"].forEach(function (e) {
          c(t, e, function (t) {
            return this._invoke(e, t);
          });
        });
      }
      function M(t, n) {
        function r(i, a, s, u) {
          var h = f(t[i], t, a);
          if (h.type !== "throw") {
            var c = h.arg;
            var l = c.value;
            return l && e(l) == "object" && o.call(l, "__await") ? n.resolve(l.__await).then(function (t) {
              r("next", t, s, u);
            }, function (t) {
              r("throw", t, s, u);
            }) : n.resolve(l).then(function (t) {
              c.value = t;
              s(c);
            }, function (t) {
              return r("throw", t, s, u);
            });
          }
          u(h.arg);
        }
        var i;
        this._invoke = function (t, e) {
          function o() {
            return new n(function (n, i) {
              r(t, e, n, i);
            });
          }
          return i = i ? i.then(o, o) : o();
        };
      }
      function w(t, e) {
        var n = t.iterator[e.method];
        if (n === undefined) {
          e.delegate = null;
          if (e.method === "throw") {
            if (t.iterator.return && (e.method = "return", e.arg = undefined, w(t, e), e.method === "throw")) {
              return d;
            }
            e.method = "throw";
            e.arg = new TypeError("The iterator does not provide a 'throw' method");
          }
          return d;
        }
        var r = f(n, t.iterator, e.arg);
        if (r.type === "throw") {
          e.method = "throw";
          e.arg = r.arg;
          e.delegate = null;
          return d;
        }
        var i = r.arg;
        return i ? i.done ? (e[t.resultName] = i.value, e.next = t.nextLoc, e.method !== "return" && (e.method = "next", e.arg = undefined), e.delegate = null, d) : i : (e.method = "throw", e.arg = new TypeError("iterator result is not an object"), e.delegate = null, d);
      }
      function E(t) {
        var e = {
          tryLoc: t[0]
        };
        if (1 in t) {
          e.catchLoc = t[1];
        }
        if (2 in t) {
          e.finallyLoc = t[2];
          e.afterLoc = t[3];
        }
        this.tryEntries.push(e);
      }
      function T(t) {
        var e = t.completion || {};
        e.type = "normal";
        delete e.arg;
        t.completion = e;
      }
      function A(t) {
        this.tryEntries = [{
          tryLoc: "root"
        }];
        t.forEach(E, this);
        this.reset(true);
      }
      function C(t) {
        if (t) {
          var e = t[s];
          if (e) {
            return e.call(t);
          }
          if (typeof t.next == "function") {
            return t;
          }
          if (!isNaN(t.length)) {
            var n = -1;
            var r = function e() {
              for (; ++n < t.length;) {
                if (o.call(t, n)) {
                  e.value = t[n];
                  e.done = false;
                  return e;
                }
              }
              e.value = undefined;
              e.done = true;
              return e;
            };
            return r.next = r;
          }
        }
        return {
          next: R
        };
      }
      function R() {
        return {
          value: undefined,
          done: true
        };
      }
      v.prototype = m;
      c(x, "constructor", m);
      c(m, "constructor", v);
      v.displayName = c(m, h, "GeneratorFunction");
      r.isGeneratorFunction = function (t) {
        var e = typeof t == "function" && t.constructor;
        return !!e && (e === v || (e.displayName || e.name) === "GeneratorFunction");
      };
      r.mark = function (t) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(t, m);
        } else {
          t.__proto__ = m;
          c(t, h, "GeneratorFunction");
        }
        t.prototype = Object.create(x);
        return t;
      };
      r.awrap = function (t) {
        return {
          __await: t
        };
      };
      b(M.prototype);
      c(M.prototype, u, function () {
        return this;
      });
      r.AsyncIterator = M;
      r.async = function (t, e, n, i, o) {
        if (o === undefined) {
          o = Promise;
        }
        var a = new M(l(t, e, n, i), o);
        return r.isGeneratorFunction(e) ? a : a.next().then(function (t) {
          return t.done ? t.value : a.next();
        });
      };
      b(x);
      c(x, h, "Generator");
      c(x, s, function () {
        return this;
      });
      c(x, "toString", function () {
        return "[object Generator]";
      });
      r.keys = function (t) {
        var e = [];
        for (var n in t) {
          e.push(n);
        }
        e.reverse();
        return function n() {
          for (; e.length;) {
            var r = e.pop();
            if (r in t) {
              n.value = r;
              n.done = false;
              return n;
            }
          }
          n.done = true;
          return n;
        };
      };
      r.values = C;
      A.prototype = {
        constructor: A,
        reset: function (t) {
          this.prev = 0;
          this.next = 0;
          this.sent = this._sent = undefined;
          this.done = false;
          this.delegate = null;
          this.method = "next";
          this.arg = undefined;
          this.tryEntries.forEach(T);
          if (!t) {
            for (var e in this) {
              if (e.charAt(0) === "t" && o.call(this, e) && !isNaN(+e.slice(1))) {
                this[e] = undefined;
              }
            }
          }
        },
        stop: function () {
          this.done = true;
          var t = this.tryEntries[0].completion;
          if (t.type === "throw") {
            throw t.arg;
          }
          return this.rval;
        },
        dispatchException: function (t) {
          if (this.done) {
            throw t;
          }
          var e = this;
          function n(n, r) {
            a.type = "throw";
            a.arg = t;
            e.next = n;
            if (r) {
              e.method = "next";
              e.arg = undefined;
            }
            return !!r;
          }
          for (var r = this.tryEntries.length - 1; r >= 0; --r) {
            var i = this.tryEntries[r];
            var a = i.completion;
            if (i.tryLoc === "root") {
              return n("end");
            }
            if (i.tryLoc <= this.prev) {
              var s = o.call(i, "catchLoc");
              var u = o.call(i, "finallyLoc");
              if (s && u) {
                if (this.prev < i.catchLoc) {
                  return n(i.catchLoc, true);
                }
                if (this.prev < i.finallyLoc) {
                  return n(i.finallyLoc);
                }
              } else if (s) {
                if (this.prev < i.catchLoc) {
                  return n(i.catchLoc, true);
                }
              } else {
                if (!u) {
                  throw new Error("try statement without catch or finally");
                }
                if (this.prev < i.finallyLoc) {
                  return n(i.finallyLoc);
                }
              }
            }
          }
        },
        abrupt: function (t, e) {
          for (var n = this.tryEntries.length - 1; n >= 0; --n) {
            var r = this.tryEntries[n];
            if (r.tryLoc <= this.prev && o.call(r, "finallyLoc") && this.prev < r.finallyLoc) {
              var i = r;
              break;
            }
          }
          if (i && (t === "break" || t === "continue") && i.tryLoc <= e && e <= i.finallyLoc) {
            i = null;
          }
          var a = i ? i.completion : {};
          a.type = t;
          a.arg = e;
          return i ? (this.method = "next", this.next = i.finallyLoc, d) : this.complete(a);
        },
        complete: function (t, e) {
          if (t.type === "throw") {
            throw t.arg;
          }
          if (t.type === "break" || t.type === "continue") {
            this.next = t.arg;
          } else if (t.type === "return") {
            this.rval = this.arg = t.arg;
            this.method = "return";
            this.next = "end";
          } else if (t.type === "normal" && e) {
            this.next = e;
          }
          return d;
        },
        finish: function (t) {
          for (var e = this.tryEntries.length - 1; e >= 0; --e) {
            var n = this.tryEntries[e];
            if (n.finallyLoc === t) {
              this.complete(n.completion, n.afterLoc);
              T(n);
              return d;
            }
          }
        },
        catch: function (t) {
          for (var e = this.tryEntries.length - 1; e >= 0; --e) {
            var n = this.tryEntries[e];
            if (n.tryLoc === t) {
              var r = n.completion;
              if (r.type === "throw") {
                var i = r.arg;
                T(n);
              }
              return i;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function (t, e, n) {
          this.delegate = {
            iterator: C(t),
            resultName: e,
            nextLoc: n
          };
          if (this.method === "next") {
            this.arg = undefined;
          }
          return d;
        }
      };
      return r;
    }
    t.exports = n;
    t.exports.__esModule = true;
    t.exports.default = t.exports;
  });
  e(rt);
  var it = rt();
  var ot = it;
  try {
    regeneratorRuntime = it;
  } catch (t) {
    if (typeof globalThis == "object") {
      globalThis.regeneratorRuntime = it;
    } else {
      Function("r", "regeneratorRuntime = r")(it);
    }
  }
  function at(t, e) {
    if (!t) {
      throw new Error("math.gl assertion ".concat(e));
    }
  }
  const st = {
    EPSILON: 1e-12,
    debug: false,
    precision: 4,
    printTypes: false,
    printDegrees: false,
    printRowMajor: true
  };
  function ut(t, {
    precision: e = st.precision
  } = {}) {
    t = function (t) {
      return Math.round(t / st.EPSILON) * st.EPSILON;
    }(t);
    return "".concat(parseFloat(t.toPrecision(e)));
  }
  function ht(t) {
    return Array.isArray(t) || ArrayBuffer.isView(t) && !(t instanceof DataView);
  }
  function ct(t, e, n) {
    const r = st.EPSILON;
    if (n) {
      st.EPSILON = n;
    }
    try {
      if (t === e) {
        return true;
      }
      if (ht(t) && ht(e)) {
        if (t.length !== e.length) {
          return false;
        }
        for (let n = 0; n < t.length; ++n) {
          if (!ct(t[n], e[n])) {
            return false;
          }
        }
        return true;
      }
      return t && t.equals ? t.equals(e) : e && e.equals ? e.equals(t) : typeof t == "number" && typeof e == "number" && Math.abs(t - e) <= st.EPSILON * Math.max(1, Math.abs(t), Math.abs(e));
    } finally {
      st.EPSILON = r;
    }
  }
  class lt extends function (t) {
    function e() {
      var e = Reflect.construct(t, Array.from(arguments));
      Object.setPrototypeOf(e, Object.getPrototypeOf(this));
      return e;
    }
    e.prototype = Object.create(t.prototype, {
      constructor: {
        value: t,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(e, t);
    } else {
      e.__proto__ = t;
    }
    return e;
  }(Array) {
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(t, e = 0) {
      for (let n = 0; n < this.ELEMENTS; ++n) {
        this[n] = t[n + e];
      }
      return this.check();
    }
    toArray(t = [], e = 0) {
      for (let n = 0; n < this.ELEMENTS; ++n) {
        t[e + n] = this[n];
      }
      return t;
    }
    from(t) {
      return Array.isArray(t) ? this.copy(t) : this.fromObject(t);
    }
    to(t) {
      return t === this ? this : ht(t) ? this.toArray(t) : this.toObject(t);
    }
    toTarget(t) {
      return t ? this.to(t) : this;
    }
    toFloat32Array() {
      return new Float32Array(this);
    }
    toString() {
      return this.formatString(st);
    }
    formatString(t) {
      let e = "";
      for (let n = 0; n < this.ELEMENTS; ++n) {
        e += (n > 0 ? ", " : "") + ut(this[n], t);
      }
      return "".concat(t.printTypes ? this.constructor.name : "", "[").concat(e, "]");
    }
    equals(t) {
      if (!t || this.length !== t.length) {
        return false;
      }
      for (let e = 0; e < this.ELEMENTS; ++e) {
        if (!ct(this[e], t[e])) {
          return false;
        }
      }
      return true;
    }
    exactEquals(t) {
      if (!t || this.length !== t.length) {
        return false;
      }
      for (let e = 0; e < this.ELEMENTS; ++e) {
        if (this[e] !== t[e]) {
          return false;
        }
      }
      return true;
    }
    negate() {
      for (let t = 0; t < this.ELEMENTS; ++t) {
        this[t] = -this[t];
      }
      return this.check();
    }
    lerp(t, e, n) {
      if (n === undefined) {
        return this.lerp(this, t, e);
      }
      for (let r = 0; r < this.ELEMENTS; ++r) {
        const i = t[r];
        this[r] = i + n * (e[r] - i);
      }
      return this.check();
    }
    min(t) {
      for (let e = 0; e < this.ELEMENTS; ++e) {
        this[e] = Math.min(t[e], this[e]);
      }
      return this.check();
    }
    max(t) {
      for (let e = 0; e < this.ELEMENTS; ++e) {
        this[e] = Math.max(t[e], this[e]);
      }
      return this.check();
    }
    clamp(t, e) {
      for (let n = 0; n < this.ELEMENTS; ++n) {
        this[n] = Math.min(Math.max(this[n], t[n]), e[n]);
      }
      return this.check();
    }
    add(...t) {
      for (const e of t) {
        for (let t = 0; t < this.ELEMENTS; ++t) {
          this[t] += e[t];
        }
      }
      return this.check();
    }
    subtract(...t) {
      for (const e of t) {
        for (let t = 0; t < this.ELEMENTS; ++t) {
          this[t] -= e[t];
        }
      }
      return this.check();
    }
    scale(t) {
      if (typeof t == "number") {
        for (let e = 0; e < this.ELEMENTS; ++e) {
          this[e] *= t;
        }
      } else {
        for (let e = 0; e < this.ELEMENTS && e < t.length; ++e) {
          this[e] *= t[e];
        }
      }
      return this.check();
    }
    multiplyByScalar(t) {
      for (let e = 0; e < this.ELEMENTS; ++e) {
        this[e] *= t;
      }
      return this.check();
    }
    check() {
      if (st.debug && !this.validate()) {
        throw new Error("math.gl: ".concat(this.constructor.name, " some fields set to invalid numbers'"));
      }
      return this;
    }
    validate() {
      let t = this.length === this.ELEMENTS;
      for (let e = 0; e < this.ELEMENTS; ++e) {
        t = t && Number.isFinite(this[e]);
      }
      return t;
    }
    sub(t) {
      return this.subtract(t);
    }
    setScalar(t) {
      for (let e = 0; e < this.ELEMENTS; ++e) {
        this[e] = t;
      }
      return this.check();
    }
    addScalar(t) {
      for (let e = 0; e < this.ELEMENTS; ++e) {
        this[e] += t;
      }
      return this.check();
    }
    subScalar(t) {
      return this.addScalar(-t);
    }
    multiplyScalar(t) {
      for (let e = 0; e < this.ELEMENTS; ++e) {
        this[e] *= t;
      }
      return this.check();
    }
    divideScalar(t) {
      return this.multiplyByScalar(1 / t);
    }
    clampScalar(t, e) {
      for (let n = 0; n < this.ELEMENTS; ++n) {
        this[n] = Math.min(Math.max(this[n], t), e);
      }
      return this.check();
    }
    get elements() {
      return this;
    }
  }
  function ft(t) {
    if (!Number.isFinite(t)) {
      throw new Error("Invalid number ".concat(t));
    }
    return t;
  }
  function dt(t, e, n = "") {
    if (st.debug && !function (t, e) {
      if (t.length !== e) {
        return false;
      }
      for (let e = 0; e < t.length; ++e) {
        if (!Number.isFinite(t[e])) {
          return false;
        }
      }
      return true;
    }(t, e)) {
      throw new Error("math.gl: ".concat(n, " some fields set to invalid numbers'"));
    }
    return t;
  }
  class pt extends lt {
    get x() {
      return this[0];
    }
    set x(t) {
      this[0] = ft(t);
    }
    get y() {
      return this[1];
    }
    set y(t) {
      this[1] = ft(t);
    }
    len() {
      return Math.sqrt(this.lengthSquared());
    }
    magnitude() {
      return this.len();
    }
    lengthSquared() {
      let t = 0;
      for (let e = 0; e < this.ELEMENTS; ++e) {
        t += this[e] * this[e];
      }
      return t;
    }
    magnitudeSquared() {
      return this.lengthSquared();
    }
    distance(t) {
      return Math.sqrt(this.distanceSquared(t));
    }
    distanceSquared(t) {
      let e = 0;
      for (let n = 0; n < this.ELEMENTS; ++n) {
        const r = this[n] - t[n];
        e += r * r;
      }
      return ft(e);
    }
    dot(t) {
      let e = 0;
      for (let n = 0; n < this.ELEMENTS; ++n) {
        e += this[n] * t[n];
      }
      return ft(e);
    }
    normalize() {
      const t = this.magnitude();
      if (t !== 0) {
        for (let e = 0; e < this.ELEMENTS; ++e) {
          this[e] /= t;
        }
      }
      return this.check();
    }
    multiply(...t) {
      for (const e of t) {
        for (let t = 0; t < this.ELEMENTS; ++t) {
          this[t] *= e[t];
        }
      }
      return this.check();
    }
    divide(...t) {
      for (const e of t) {
        for (let t = 0; t < this.ELEMENTS; ++t) {
          this[t] /= e[t];
        }
      }
      return this.check();
    }
    lengthSq() {
      return this.lengthSquared();
    }
    distanceTo(t) {
      return this.distance(t);
    }
    distanceToSquared(t) {
      return this.distanceSquared(t);
    }
    getComponent(t) {
      at(t >= 0 && t < this.ELEMENTS, "index is out of range");
      return ft(this[t]);
    }
    setComponent(t, e) {
      at(t >= 0 && t < this.ELEMENTS, "index is out of range");
      this[t] = e;
      return this.check();
    }
    addVectors(t, e) {
      return this.copy(t).add(e);
    }
    subVectors(t, e) {
      return this.copy(t).subtract(e);
    }
    multiplyVectors(t, e) {
      return this.copy(t).multiply(e);
    }
    addScaledVector(t, e) {
      return this.add(new this.constructor(t).multiplyScalar(e));
    }
  }
  var vt = 0.000001;
  var mt = typeof Float32Array != "undefined" ? Float32Array : Array;
  var gt = Math.random;
  function yt() {
    var t = new mt(2);
    if (mt != Float32Array) {
      t[0] = 0;
      t[1] = 0;
    }
    return t;
  }
  function _t(t, e) {
    var n = new mt(2);
    n[0] = t;
    n[1] = e;
    return n;
  }
  function xt(t, e, n) {
    t[0] = e[0] - n[0];
    t[1] = e[1] - n[1];
    return t;
  }
  function bt(t, e, n) {
    t[0] = e[0] * n[0];
    t[1] = e[1] * n[1];
    return t;
  }
  function Mt(t, e, n) {
    t[0] = e[0] / n[0];
    t[1] = e[1] / n[1];
    return t;
  }
  function wt(t, e) {
    var n = e[0] - t[0];
    var r = e[1] - t[1];
    return Math.hypot(n, r);
  }
  function Et(t, e) {
    var n = e[0] - t[0];
    var r = e[1] - t[1];
    return n * n + r * r;
  }
  function Tt(t) {
    var e = t[0];
    var n = t[1];
    return Math.hypot(e, n);
  }
  function At(t) {
    var e = t[0];
    var n = t[1];
    return e * e + n * n;
  }
  function Ct(t, e, n) {
    var r = e[0];
    var i = e[1];
    t[0] = n[0] * r + n[4] * i + n[12];
    t[1] = n[1] * r + n[5] * i + n[13];
    return t;
  }
  if (!Math.hypot) {
    Math.hypot = function () {
      for (var t = 0, e = arguments.length; e--;) {
        t += arguments[e] * arguments[e];
      }
      return Math.sqrt(t);
    };
  }
  var Rt;
  var St = Tt;
  var Pt = xt;
  var Dt = bt;
  var Ot = Mt;
  var It = wt;
  var Lt = Et;
  var Bt = At;
  Rt = yt();
  var kt = function (t, e, n, r, i, o) {
    var a;
    var s;
    for (e || (e = 2), n || (n = 0), s = r ? Math.min(r * e + n, t.length) : t.length, a = n; a < s; a += e) {
      Rt[0] = t[a];
      Rt[1] = t[a + 1];
      i(Rt, Rt, o);
      t[a] = Rt[0];
      t[a + 1] = Rt[1];
    }
    return t;
  };
  var Ut = Object.freeze({
    __proto__: null,
    create: yt,
    clone: function (t) {
      var e = new mt(2);
      e[0] = t[0];
      e[1] = t[1];
      return e;
    },
    fromValues: _t,
    copy: function (t, e) {
      t[0] = e[0];
      t[1] = e[1];
      return t;
    },
    set: function (t, e, n) {
      t[0] = e;
      t[1] = n;
      return t;
    },
    add: function (t, e, n) {
      t[0] = e[0] + n[0];
      t[1] = e[1] + n[1];
      return t;
    },
    subtract: xt,
    multiply: bt,
    divide: Mt,
    ceil: function (t, e) {
      t[0] = Math.ceil(e[0]);
      t[1] = Math.ceil(e[1]);
      return t;
    },
    floor: function (t, e) {
      t[0] = Math.floor(e[0]);
      t[1] = Math.floor(e[1]);
      return t;
    },
    min: function (t, e, n) {
      t[0] = Math.min(e[0], n[0]);
      t[1] = Math.min(e[1], n[1]);
      return t;
    },
    max: function (t, e, n) {
      t[0] = Math.max(e[0], n[0]);
      t[1] = Math.max(e[1], n[1]);
      return t;
    },
    round: function (t, e) {
      t[0] = Math.round(e[0]);
      t[1] = Math.round(e[1]);
      return t;
    },
    scale: function (t, e, n) {
      t[0] = e[0] * n;
      t[1] = e[1] * n;
      return t;
    },
    scaleAndAdd: function (t, e, n, r) {
      t[0] = e[0] + n[0] * r;
      t[1] = e[1] + n[1] * r;
      return t;
    },
    distance: wt,
    squaredDistance: Et,
    length: Tt,
    squaredLength: At,
    negate: function (t, e) {
      t[0] = -e[0];
      t[1] = -e[1];
      return t;
    },
    inverse: function (t, e) {
      t[0] = 1 / e[0];
      t[1] = 1 / e[1];
      return t;
    },
    normalize: function (t, e) {
      var n = e[0];
      var r = e[1];
      var i = n * n + r * r;
      if (i > 0) {
        i = 1 / Math.sqrt(i);
      }
      t[0] = e[0] * i;
      t[1] = e[1] * i;
      return t;
    },
    dot: function (t, e) {
      return t[0] * e[0] + t[1] * e[1];
    },
    cross: function (t, e, n) {
      var r = e[0] * n[1] - e[1] * n[0];
      t[0] = t[1] = 0;
      t[2] = r;
      return t;
    },
    lerp: function (t, e, n, r) {
      var i = e[0];
      var o = e[1];
      t[0] = i + r * (n[0] - i);
      t[1] = o + r * (n[1] - o);
      return t;
    },
    random: function (t, e) {
      e = e || 1;
      var n = 2 * gt() * Math.PI;
      t[0] = Math.cos(n) * e;
      t[1] = Math.sin(n) * e;
      return t;
    },
    transformMat2: function (t, e, n) {
      var r = e[0];
      var i = e[1];
      t[0] = n[0] * r + n[2] * i;
      t[1] = n[1] * r + n[3] * i;
      return t;
    },
    transformMat2d: function (t, e, n) {
      var r = e[0];
      var i = e[1];
      t[0] = n[0] * r + n[2] * i + n[4];
      t[1] = n[1] * r + n[3] * i + n[5];
      return t;
    },
    transformMat3: function (t, e, n) {
      var r = e[0];
      var i = e[1];
      t[0] = n[0] * r + n[3] * i + n[6];
      t[1] = n[1] * r + n[4] * i + n[7];
      return t;
    },
    transformMat4: Ct,
    rotate: function (t, e, n, r) {
      var i = e[0] - n[0];
      var o = e[1] - n[1];
      var a = Math.sin(r);
      var s = Math.cos(r);
      t[0] = i * s - o * a + n[0];
      t[1] = i * a + o * s + n[1];
      return t;
    },
    angle: function (t, e) {
      var n = t[0];
      var r = t[1];
      var i = e[0];
      var o = e[1];
      var a = Math.sqrt(n * n + r * r) * Math.sqrt(i * i + o * o);
      var s = a && (n * i + r * o) / a;
      return Math.acos(Math.min(Math.max(s, -1), 1));
    },
    zero: function (t) {
      t[0] = 0;
      t[1] = 0;
      return t;
    },
    str: function (t) {
      return "vec2(" + t[0] + ", " + t[1] + ")";
    },
    exactEquals: function (t, e) {
      return t[0] === e[0] && t[1] === e[1];
    },
    equals: function (t, e) {
      var n = t[0];
      var r = t[1];
      var i = e[0];
      var o = e[1];
      return Math.abs(n - i) <= vt * Math.max(1, Math.abs(n), Math.abs(i)) && Math.abs(r - o) <= vt * Math.max(1, Math.abs(r), Math.abs(o));
    },
    len: St,
    sub: Pt,
    mul: Dt,
    div: Ot,
    dist: It,
    sqrDist: Lt,
    sqrLen: Bt,
    forEach: kt
  });
  function Nt(t, e, n) {
    const r = e[0];
    const i = e[1];
    const o = e[2];
    const a = n[3] * r + n[7] * i + n[11] * o || 1;
    t[0] = (n[0] * r + n[4] * i + n[8] * o) / a;
    t[1] = (n[1] * r + n[5] * i + n[9] * o) / a;
    t[2] = (n[2] * r + n[6] * i + n[10] * o) / a;
    return t;
  }
  function Ft() {
    var t = new mt(3);
    if (mt != Float32Array) {
      t[0] = 0;
      t[1] = 0;
      t[2] = 0;
    }
    return t;
  }
  function jt(t) {
    var e = new mt(3);
    e[0] = t[0];
    e[1] = t[1];
    e[2] = t[2];
    return e;
  }
  function zt(t) {
    var e = t[0];
    var n = t[1];
    var r = t[2];
    return Math.hypot(e, n, r);
  }
  function Vt(t, e, n) {
    var r = new mt(3);
    r[0] = t;
    r[1] = e;
    r[2] = n;
    return r;
  }
  function Gt(t, e) {
    t[0] = e[0];
    t[1] = e[1];
    t[2] = e[2];
    return t;
  }
  function Wt(t, e, n) {
    t[0] = e[0] + n[0];
    t[1] = e[1] + n[1];
    t[2] = e[2] + n[2];
    return t;
  }
  function Ht(t, e, n) {
    t[0] = e[0] - n[0];
    t[1] = e[1] - n[1];
    t[2] = e[2] - n[2];
    return t;
  }
  function Zt(t, e, n) {
    t[0] = e[0] * n[0];
    t[1] = e[1] * n[1];
    t[2] = e[2] * n[2];
    return t;
  }
  function qt(t, e, n) {
    t[0] = e[0] / n[0];
    t[1] = e[1] / n[1];
    t[2] = e[2] / n[2];
    return t;
  }
  function Yt(t, e, n) {
    t[0] = e[0] * n;
    t[1] = e[1] * n;
    t[2] = e[2] * n;
    return t;
  }
  function Xt(t, e) {
    var n = e[0] - t[0];
    var r = e[1] - t[1];
    var i = e[2] - t[2];
    return Math.hypot(n, r, i);
  }
  function Kt(t, e) {
    var n = e[0] - t[0];
    var r = e[1] - t[1];
    var i = e[2] - t[2];
    return n * n + r * r + i * i;
  }
  function Qt(t) {
    var e = t[0];
    var n = t[1];
    var r = t[2];
    return e * e + n * n + r * r;
  }
  function Jt(t, e) {
    var n = e[0];
    var r = e[1];
    var i = e[2];
    var o = n * n + r * r + i * i;
    if (o > 0) {
      o = 1 / Math.sqrt(o);
    }
    t[0] = e[0] * o;
    t[1] = e[1] * o;
    t[2] = e[2] * o;
    return t;
  }
  function $t(t, e) {
    return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];
  }
  function te(t, e, n) {
    var r = e[0];
    var i = e[1];
    var o = e[2];
    var a = n[0];
    var s = n[1];
    var u = n[2];
    t[0] = i * u - o * s;
    t[1] = o * a - r * u;
    t[2] = r * s - i * a;
    return t;
  }
  function ee(t, e, n) {
    var r = e[0];
    var i = e[1];
    var o = e[2];
    var a = n[3] * r + n[7] * i + n[11] * o + n[15];
    a = a || 1;
    t[0] = (n[0] * r + n[4] * i + n[8] * o + n[12]) / a;
    t[1] = (n[1] * r + n[5] * i + n[9] * o + n[13]) / a;
    t[2] = (n[2] * r + n[6] * i + n[10] * o + n[14]) / a;
    return t;
  }
  function ne(t, e, n) {
    var r = e[0];
    var i = e[1];
    var o = e[2];
    t[0] = r * n[0] + i * n[3] + o * n[6];
    t[1] = r * n[1] + i * n[4] + o * n[7];
    t[2] = r * n[2] + i * n[5] + o * n[8];
    return t;
  }
  function re(t, e, n) {
    var r = n[0];
    var i = n[1];
    var o = n[2];
    var a = n[3];
    var s = e[0];
    var u = e[1];
    var h = e[2];
    var c = i * h - o * u;
    var l = o * s - r * h;
    var f = r * u - i * s;
    var d = i * f - o * l;
    var p = o * c - r * f;
    var v = r * l - i * c;
    var m = 2 * a;
    c *= m;
    l *= m;
    f *= m;
    d *= 2;
    p *= 2;
    v *= 2;
    t[0] = s + c + d;
    t[1] = u + l + p;
    t[2] = h + f + v;
    return t;
  }
  function ie(t, e, n, r) {
    var i = [];
    var o = [];
    i[0] = e[0] - n[0];
    i[1] = e[1] - n[1];
    i[2] = e[2] - n[2];
    o[0] = i[0];
    o[1] = i[1] * Math.cos(r) - i[2] * Math.sin(r);
    o[2] = i[1] * Math.sin(r) + i[2] * Math.cos(r);
    t[0] = o[0] + n[0];
    t[1] = o[1] + n[1];
    t[2] = o[2] + n[2];
    return t;
  }
  function oe(t, e, n, r) {
    var i = [];
    var o = [];
    i[0] = e[0] - n[0];
    i[1] = e[1] - n[1];
    i[2] = e[2] - n[2];
    o[0] = i[2] * Math.sin(r) + i[0] * Math.cos(r);
    o[1] = i[1];
    o[2] = i[2] * Math.cos(r) - i[0] * Math.sin(r);
    t[0] = o[0] + n[0];
    t[1] = o[1] + n[1];
    t[2] = o[2] + n[2];
    return t;
  }
  function ae(t, e, n, r) {
    var i = [];
    var o = [];
    i[0] = e[0] - n[0];
    i[1] = e[1] - n[1];
    i[2] = e[2] - n[2];
    o[0] = i[0] * Math.cos(r) - i[1] * Math.sin(r);
    o[1] = i[0] * Math.sin(r) + i[1] * Math.cos(r);
    o[2] = i[2];
    t[0] = o[0] + n[0];
    t[1] = o[1] + n[1];
    t[2] = o[2] + n[2];
    return t;
  }
  function se(t, e) {
    var n = t[0];
    var r = t[1];
    var i = t[2];
    var o = e[0];
    var a = e[1];
    var s = e[2];
    var u = Math.sqrt(n * n + r * r + i * i) * Math.sqrt(o * o + a * a + s * s);
    var h = u && $t(t, e) / u;
    return Math.acos(Math.min(Math.max(h, -1), 1));
  }
  function ue(t, e) {
    var n = t[0];
    var r = t[1];
    var i = t[2];
    var o = e[0];
    var a = e[1];
    var s = e[2];
    return Math.abs(n - o) <= vt * Math.max(1, Math.abs(n), Math.abs(o)) && Math.abs(r - a) <= vt * Math.max(1, Math.abs(r), Math.abs(a)) && Math.abs(i - s) <= vt * Math.max(1, Math.abs(i), Math.abs(s));
  }
  var he = Ht;
  var ce = Zt;
  var le = qt;
  var fe = Xt;
  var de = Kt;
  var pe = zt;
  var ve = Qt;
  var me = function () {
    var t = Ft();
    return function (e, n, r, i, o, a) {
      var s;
      var u;
      for (n || (n = 3), r || (r = 0), u = i ? Math.min(i * n + r, e.length) : e.length, s = r; s < u; s += n) {
        t[0] = e[s];
        t[1] = e[s + 1];
        t[2] = e[s + 2];
        o(t, t, a);
        e[s] = t[0];
        e[s + 1] = t[1];
        e[s + 2] = t[2];
      }
      return e;
    };
  }();
  var ge = Object.freeze({
    __proto__: null,
    create: Ft,
    clone: jt,
    length: zt,
    fromValues: Vt,
    copy: Gt,
    set: function (t, e, n, r) {
      t[0] = e;
      t[1] = n;
      t[2] = r;
      return t;
    },
    add: Wt,
    subtract: Ht,
    multiply: Zt,
    divide: qt,
    ceil: function (t, e) {
      t[0] = Math.ceil(e[0]);
      t[1] = Math.ceil(e[1]);
      t[2] = Math.ceil(e[2]);
      return t;
    },
    floor: function (t, e) {
      t[0] = Math.floor(e[0]);
      t[1] = Math.floor(e[1]);
      t[2] = Math.floor(e[2]);
      return t;
    },
    min: function (t, e, n) {
      t[0] = Math.min(e[0], n[0]);
      t[1] = Math.min(e[1], n[1]);
      t[2] = Math.min(e[2], n[2]);
      return t;
    },
    max: function (t, e, n) {
      t[0] = Math.max(e[0], n[0]);
      t[1] = Math.max(e[1], n[1]);
      t[2] = Math.max(e[2], n[2]);
      return t;
    },
    round: function (t, e) {
      t[0] = Math.round(e[0]);
      t[1] = Math.round(e[1]);
      t[2] = Math.round(e[2]);
      return t;
    },
    scale: Yt,
    scaleAndAdd: function (t, e, n, r) {
      t[0] = e[0] + n[0] * r;
      t[1] = e[1] + n[1] * r;
      t[2] = e[2] + n[2] * r;
      return t;
    },
    distance: Xt,
    squaredDistance: Kt,
    squaredLength: Qt,
    negate: function (t, e) {
      t[0] = -e[0];
      t[1] = -e[1];
      t[2] = -e[2];
      return t;
    },
    inverse: function (t, e) {
      t[0] = 1 / e[0];
      t[1] = 1 / e[1];
      t[2] = 1 / e[2];
      return t;
    },
    normalize: Jt,
    dot: $t,
    cross: te,
    lerp: function (t, e, n, r) {
      var i = e[0];
      var o = e[1];
      var a = e[2];
      t[0] = i + r * (n[0] - i);
      t[1] = o + r * (n[1] - o);
      t[2] = a + r * (n[2] - a);
      return t;
    },
    hermite: function (t, e, n, r, i, o) {
      var a = o * o;
      var s = a * (2 * o - 3) + 1;
      var u = a * (o - 2) + o;
      var h = a * (o - 1);
      var c = a * (3 - 2 * o);
      t[0] = e[0] * s + n[0] * u + r[0] * h + i[0] * c;
      t[1] = e[1] * s + n[1] * u + r[1] * h + i[1] * c;
      t[2] = e[2] * s + n[2] * u + r[2] * h + i[2] * c;
      return t;
    },
    bezier: function (t, e, n, r, i, o) {
      var a = 1 - o;
      var s = a * a;
      var u = o * o;
      var h = s * a;
      var c = 3 * o * s;
      var l = 3 * u * a;
      var f = u * o;
      t[0] = e[0] * h + n[0] * c + r[0] * l + i[0] * f;
      t[1] = e[1] * h + n[1] * c + r[1] * l + i[1] * f;
      t[2] = e[2] * h + n[2] * c + r[2] * l + i[2] * f;
      return t;
    },
    random: function (t, e) {
      e = e || 1;
      var n = 2 * gt() * Math.PI;
      var r = 2 * gt() - 1;
      var i = Math.sqrt(1 - r * r) * e;
      t[0] = Math.cos(n) * i;
      t[1] = Math.sin(n) * i;
      t[2] = r * e;
      return t;
    },
    transformMat4: ee,
    transformMat3: ne,
    transformQuat: re,
    rotateX: ie,
    rotateY: oe,
    rotateZ: ae,
    angle: se,
    zero: function (t) {
      t[0] = 0;
      t[1] = 0;
      t[2] = 0;
      return t;
    },
    str: function (t) {
      return "vec3(" + t[0] + ", " + t[1] + ", " + t[2] + ")";
    },
    exactEquals: function (t, e) {
      return t[0] === e[0] && t[1] === e[1] && t[2] === e[2];
    },
    equals: ue,
    sub: he,
    mul: ce,
    div: le,
    dist: fe,
    sqrDist: de,
    len: pe,
    sqrLen: ve,
    forEach: me
  });
  const ye = [0, 0, 0];
  let _e;
  let xe;
  class be extends pt {
    static get ZERO() {
      if (!_e) {
        _e = new be(0, 0, 0);
        Object.freeze(_e);
      }
      return _e;
    }
    constructor(t = 0, e = 0, n = 0) {
      super(0, 0, 0);
      if (arguments.length === 1 && ht(t)) {
        this.copy(t);
      } else {
        if (st.debug) {
          ft(t);
          ft(e);
          ft(n);
        }
        this[0] = t;
        this[1] = e;
        this[2] = n;
      }
    }
    set(t, e, n) {
      this[0] = t;
      this[1] = e;
      this[2] = n;
      return this.check();
    }
    copy(t) {
      this[0] = t[0];
      this[1] = t[1];
      this[2] = t[2];
      return this.check();
    }
    fromObject(t) {
      if (st.debug) {
        ft(t.x);
        ft(t.y);
        ft(t.z);
      }
      this[0] = t.x;
      this[1] = t.y;
      this[2] = t.z;
      return this.check();
    }
    toObject(t) {
      t.x = this[0];
      t.y = this[1];
      t.z = this[2];
      return t;
    }
    get ELEMENTS() {
      return 3;
    }
    get z() {
      return this[2];
    }
    set z(t) {
      this[2] = ft(t);
    }
    angle(t) {
      return se(this, t);
    }
    cross(t) {
      te(this, this, t);
      return this.check();
    }
    rotateX({
      radians: t,
      origin: e = ye
    }) {
      ie(this, this, e, t);
      return this.check();
    }
    rotateY({
      radians: t,
      origin: e = ye
    }) {
      oe(this, this, e, t);
      return this.check();
    }
    rotateZ({
      radians: t,
      origin: e = ye
    }) {
      ae(this, this, e, t);
      return this.check();
    }
    transform(t) {
      return this.transformAsPoint(t);
    }
    transformAsPoint(t) {
      ee(this, this, t);
      return this.check();
    }
    transformAsVector(t) {
      Nt(this, this, t);
      return this.check();
    }
    transformByMatrix3(t) {
      ne(this, this, t);
      return this.check();
    }
    transformByMatrix2(t) {
      (function (t, e, n) {
        const r = e[0];
        const i = e[1];
        t[0] = n[0] * r + n[2] * i;
        t[1] = n[1] * r + n[3] * i;
        t[2] = e[2];
      })(this, this, t);
      return this.check();
    }
    transformByQuaternion(t) {
      re(this, this, t);
      return this.check();
    }
  }
  class Me extends pt {
    static get ZERO() {
      if (!xe) {
        xe = new Me(0, 0, 0, 0);
        Object.freeze(xe);
      }
      return xe;
    }
    constructor(t = 0, e = 0, n = 0, r = 0) {
      super(0, 0, 0, 0);
      if (ht(t) && arguments.length === 1) {
        this.copy(t);
      } else {
        if (st.debug) {
          ft(t);
          ft(e);
          ft(n);
          ft(r);
        }
        this[0] = t;
        this[1] = e;
        this[2] = n;
        this[3] = r;
      }
    }
    set(t, e, n, r) {
      this[0] = t;
      this[1] = e;
      this[2] = n;
      this[3] = r;
      return this.check();
    }
    copy(t) {
      this[0] = t[0];
      this[1] = t[1];
      this[2] = t[2];
      this[3] = t[3];
      return this.check();
    }
    fromObject(t) {
      if (st.debug) {
        ft(t.x);
        ft(t.y);
        ft(t.z);
        ft(t.w);
      }
      this[0] = t.x;
      this[1] = t.y;
      this[2] = t.z;
      this[3] = t.w;
      return this;
    }
    toObject(t) {
      t.x = this[0];
      t.y = this[1];
      t.z = this[2];
      t.w = this[3];
      return t;
    }
    get ELEMENTS() {
      return 4;
    }
    get z() {
      return this[2];
    }
    set z(t) {
      this[2] = ft(t);
    }
    get w() {
      return this[3];
    }
    set w(t) {
      this[3] = ft(t);
    }
    transform(t) {
      ee(this, this, t);
      return this.check();
    }
    transformByMatrix3(t) {
      (function (t, e, n) {
        const r = e[0];
        const i = e[1];
        const o = e[2];
        t[0] = n[0] * r + n[3] * i + n[6] * o;
        t[1] = n[1] * r + n[4] * i + n[7] * o;
        t[2] = n[2] * r + n[5] * i + n[8] * o;
        t[3] = e[3];
      })(this, this, t);
      return this.check();
    }
    transformByMatrix2(t) {
      (function (t, e, n) {
        const r = e[0];
        const i = e[1];
        t[0] = n[0] * r + n[2] * i;
        t[1] = n[1] * r + n[3] * i;
        t[2] = e[2];
        t[3] = e[3];
      })(this, this, t);
      return this.check();
    }
    transformByQuaternion(t) {
      re(this, this, t);
      return this.check();
    }
    applyMatrix4(t) {
      t.transform(this, this);
      return this;
    }
  }
  class we extends lt {
    toString() {
      let t = "[";
      if (st.printRowMajor) {
        t += "row-major:";
        for (let e = 0; e < this.RANK; ++e) {
          for (let n = 0; n < this.RANK; ++n) {
            t += " ".concat(this[n * this.RANK + e]);
          }
        }
      } else {
        t += "column-major:";
        for (let e = 0; e < this.ELEMENTS; ++e) {
          t += " ".concat(this[e]);
        }
      }
      t += "]";
      return t;
    }
    getElementIndex(t, e) {
      return e * this.RANK + t;
    }
    getElement(t, e) {
      return this[e * this.RANK + t];
    }
    setElement(t, e, n) {
      this[e * this.RANK + t] = ft(n);
      return this;
    }
    getColumn(t, e = new Array(this.RANK).fill(0)) {
      const n = t * this.RANK;
      for (let t = 0; t < this.RANK; ++t) {
        e[t] = this[n + t];
      }
      return e;
    }
    setColumn(t, e) {
      const n = t * this.RANK;
      for (let t = 0; t < this.RANK; ++t) {
        this[n + t] = e[t];
      }
      return this;
    }
  }
  function Ee() {
    var t = new mt(9);
    if (mt != Float32Array) {
      t[1] = 0;
      t[2] = 0;
      t[3] = 0;
      t[5] = 0;
      t[6] = 0;
      t[7] = 0;
    }
    t[0] = 1;
    t[4] = 1;
    t[8] = 1;
    return t;
  }
  function Te(t, e, n) {
    var r = e[0];
    var i = e[1];
    var o = e[2];
    var a = e[3];
    var s = e[4];
    var u = e[5];
    var h = e[6];
    var c = e[7];
    var l = e[8];
    var f = n[0];
    var d = n[1];
    var p = n[2];
    var v = n[3];
    var m = n[4];
    var g = n[5];
    var y = n[6];
    var _ = n[7];
    var x = n[8];
    t[0] = f * r + d * a + p * h;
    t[1] = f * i + d * s + p * c;
    t[2] = f * o + d * u + p * l;
    t[3] = v * r + m * a + g * h;
    t[4] = v * i + m * s + g * c;
    t[5] = v * o + m * u + g * l;
    t[6] = y * r + _ * a + x * h;
    t[7] = y * i + _ * s + x * c;
    t[8] = y * o + _ * u + x * l;
    return t;
  }
  function Ae(t, e, n) {
    t[0] = e[0] - n[0];
    t[1] = e[1] - n[1];
    t[2] = e[2] - n[2];
    t[3] = e[3] - n[3];
    t[4] = e[4] - n[4];
    t[5] = e[5] - n[5];
    t[6] = e[6] - n[6];
    t[7] = e[7] - n[7];
    t[8] = e[8] - n[8];
    return t;
  }
  var Ce = Te;
  var Re = Ae;
  var Se = Object.freeze({
    __proto__: null,
    create: Ee,
    fromMat4: function (t, e) {
      t[0] = e[0];
      t[1] = e[1];
      t[2] = e[2];
      t[3] = e[4];
      t[4] = e[5];
      t[5] = e[6];
      t[6] = e[8];
      t[7] = e[9];
      t[8] = e[10];
      return t;
    },
    clone: function (t) {
      var e = new mt(9);
      e[0] = t[0];
      e[1] = t[1];
      e[2] = t[2];
      e[3] = t[3];
      e[4] = t[4];
      e[5] = t[5];
      e[6] = t[6];
      e[7] = t[7];
      e[8] = t[8];
      return e;
    },
    copy: function (t, e) {
      t[0] = e[0];
      t[1] = e[1];
      t[2] = e[2];
      t[3] = e[3];
      t[4] = e[4];
      t[5] = e[5];
      t[6] = e[6];
      t[7] = e[7];
      t[8] = e[8];
      return t;
    },
    fromValues: function (t, e, n, r, i, o, a, s, u) {
      var h = new mt(9);
      h[0] = t;
      h[1] = e;
      h[2] = n;
      h[3] = r;
      h[4] = i;
      h[5] = o;
      h[6] = a;
      h[7] = s;
      h[8] = u;
      return h;
    },
    set: function (t, e, n, r, i, o, a, s, u, h) {
      t[0] = e;
      t[1] = n;
      t[2] = r;
      t[3] = i;
      t[4] = o;
      t[5] = a;
      t[6] = s;
      t[7] = u;
      t[8] = h;
      return t;
    },
    identity: function (t) {
      t[0] = 1;
      t[1] = 0;
      t[2] = 0;
      t[3] = 0;
      t[4] = 1;
      t[5] = 0;
      t[6] = 0;
      t[7] = 0;
      t[8] = 1;
      return t;
    },
    transpose: function (t, e) {
      if (t === e) {
        var n = e[1];
        var r = e[2];
        var i = e[5];
        t[1] = e[3];
        t[2] = e[6];
        t[3] = n;
        t[5] = e[7];
        t[6] = r;
        t[7] = i;
      } else {
        t[0] = e[0];
        t[1] = e[3];
        t[2] = e[6];
        t[3] = e[1];
        t[4] = e[4];
        t[5] = e[7];
        t[6] = e[2];
        t[7] = e[5];
        t[8] = e[8];
      }
      return t;
    },
    invert: function (t, e) {
      var n = e[0];
      var r = e[1];
      var i = e[2];
      var o = e[3];
      var a = e[4];
      var s = e[5];
      var u = e[6];
      var h = e[7];
      var c = e[8];
      var l = c * a - s * h;
      var f = -c * o + s * u;
      var d = h * o - a * u;
      var p = n * l + r * f + i * d;
      return p ? (p = 1 / p, t[0] = l * p, t[1] = (-c * r + i * h) * p, t[2] = (s * r - i * a) * p, t[3] = f * p, t[4] = (c * n - i * u) * p, t[5] = (-s * n + i * o) * p, t[6] = d * p, t[7] = (-h * n + r * u) * p, t[8] = (a * n - r * o) * p, t) : null;
    },
    adjoint: function (t, e) {
      var n = e[0];
      var r = e[1];
      var i = e[2];
      var o = e[3];
      var a = e[4];
      var s = e[5];
      var u = e[6];
      var h = e[7];
      var c = e[8];
      t[0] = a * c - s * h;
      t[1] = i * h - r * c;
      t[2] = r * s - i * a;
      t[3] = s * u - o * c;
      t[4] = n * c - i * u;
      t[5] = i * o - n * s;
      t[6] = o * h - a * u;
      t[7] = r * u - n * h;
      t[8] = n * a - r * o;
      return t;
    },
    determinant: function (t) {
      var e = t[0];
      var n = t[1];
      var r = t[2];
      var i = t[3];
      var o = t[4];
      var a = t[5];
      var s = t[6];
      var u = t[7];
      var h = t[8];
      return e * (h * o - a * u) + n * (-h * i + a * s) + r * (u * i - o * s);
    },
    multiply: Te,
    translate: function (t, e, n) {
      var r = e[0];
      var i = e[1];
      var o = e[2];
      var a = e[3];
      var s = e[4];
      var u = e[5];
      var h = e[6];
      var c = e[7];
      var l = e[8];
      var f = n[0];
      var d = n[1];
      t[0] = r;
      t[1] = i;
      t[2] = o;
      t[3] = a;
      t[4] = s;
      t[5] = u;
      t[6] = f * r + d * a + h;
      t[7] = f * i + d * s + c;
      t[8] = f * o + d * u + l;
      return t;
    },
    rotate: function (t, e, n) {
      var r = e[0];
      var i = e[1];
      var o = e[2];
      var a = e[3];
      var s = e[4];
      var u = e[5];
      var h = e[6];
      var c = e[7];
      var l = e[8];
      var f = Math.sin(n);
      var d = Math.cos(n);
      t[0] = d * r + f * a;
      t[1] = d * i + f * s;
      t[2] = d * o + f * u;
      t[3] = d * a - f * r;
      t[4] = d * s - f * i;
      t[5] = d * u - f * o;
      t[6] = h;
      t[7] = c;
      t[8] = l;
      return t;
    },
    scale: function (t, e, n) {
      var r = n[0];
      var i = n[1];
      t[0] = r * e[0];
      t[1] = r * e[1];
      t[2] = r * e[2];
      t[3] = i * e[3];
      t[4] = i * e[4];
      t[5] = i * e[5];
      t[6] = e[6];
      t[7] = e[7];
      t[8] = e[8];
      return t;
    },
    fromTranslation: function (t, e) {
      t[0] = 1;
      t[1] = 0;
      t[2] = 0;
      t[3] = 0;
      t[4] = 1;
      t[5] = 0;
      t[6] = e[0];
      t[7] = e[1];
      t[8] = 1;
      return t;
    },
    fromRotation: function (t, e) {
      var n = Math.sin(e);
      var r = Math.cos(e);
      t[0] = r;
      t[1] = n;
      t[2] = 0;
      t[3] = -n;
      t[4] = r;
      t[5] = 0;
      t[6] = 0;
      t[7] = 0;
      t[8] = 1;
      return t;
    },
    fromScaling: function (t, e) {
      t[0] = e[0];
      t[1] = 0;
      t[2] = 0;
      t[3] = 0;
      t[4] = e[1];
      t[5] = 0;
      t[6] = 0;
      t[7] = 0;
      t[8] = 1;
      return t;
    },
    fromMat2d: function (t, e) {
      t[0] = e[0];
      t[1] = e[1];
      t[2] = 0;
      t[3] = e[2];
      t[4] = e[3];
      t[5] = 0;
      t[6] = e[4];
      t[7] = e[5];
      t[8] = 1;
      return t;
    },
    fromQuat: function (t, e) {
      var n = e[0];
      var r = e[1];
      var i = e[2];
      var o = e[3];
      var a = n + n;
      var s = r + r;
      var u = i + i;
      var h = n * a;
      var c = r * a;
      var l = r * s;
      var f = i * a;
      var d = i * s;
      var p = i * u;
      var v = o * a;
      var m = o * s;
      var g = o * u;
      t[0] = 1 - l - p;
      t[3] = c - g;
      t[6] = f + m;
      t[1] = c + g;
      t[4] = 1 - h - p;
      t[7] = d - v;
      t[2] = f - m;
      t[5] = d + v;
      t[8] = 1 - h - l;
      return t;
    },
    normalFromMat4: function (t, e) {
      var n = e[0];
      var r = e[1];
      var i = e[2];
      var o = e[3];
      var a = e[4];
      var s = e[5];
      var u = e[6];
      var h = e[7];
      var c = e[8];
      var l = e[9];
      var f = e[10];
      var d = e[11];
      var p = e[12];
      var v = e[13];
      var m = e[14];
      var g = e[15];
      var y = n * s - r * a;
      var _ = n * u - i * a;
      var x = n * h - o * a;
      var b = r * u - i * s;
      var M = r * h - o * s;
      var w = i * h - o * u;
      var E = c * v - l * p;
      var T = c * m - f * p;
      var A = c * g - d * p;
      var C = l * m - f * v;
      var R = l * g - d * v;
      var S = f * g - d * m;
      var P = y * S - _ * R + x * C + b * A - M * T + w * E;
      return P ? (P = 1 / P, t[0] = (s * S - u * R + h * C) * P, t[1] = (u * A - a * S - h * T) * P, t[2] = (a * R - s * A + h * E) * P, t[3] = (i * R - r * S - o * C) * P, t[4] = (n * S - i * A + o * T) * P, t[5] = (r * A - n * R - o * E) * P, t[6] = (v * w - m * M + g * b) * P, t[7] = (m * x - p * w - g * _) * P, t[8] = (p * M - v * x + g * y) * P, t) : null;
    },
    projection: function (t, e, n) {
      t[0] = 2 / e;
      t[1] = 0;
      t[2] = 0;
      t[3] = 0;
      t[4] = -2 / n;
      t[5] = 0;
      t[6] = -1;
      t[7] = 1;
      t[8] = 1;
      return t;
    },
    str: function (t) {
      return "mat3(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ")";
    },
    frob: function (t) {
      return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8]);
    },
    add: function (t, e, n) {
      t[0] = e[0] + n[0];
      t[1] = e[1] + n[1];
      t[2] = e[2] + n[2];
      t[3] = e[3] + n[3];
      t[4] = e[4] + n[4];
      t[5] = e[5] + n[5];
      t[6] = e[6] + n[6];
      t[7] = e[7] + n[7];
      t[8] = e[8] + n[8];
      return t;
    },
    subtract: Ae,
    multiplyScalar: function (t, e, n) {
      t[0] = e[0] * n;
      t[1] = e[1] * n;
      t[2] = e[2] * n;
      t[3] = e[3] * n;
      t[4] = e[4] * n;
      t[5] = e[5] * n;
      t[6] = e[6] * n;
      t[7] = e[7] * n;
      t[8] = e[8] * n;
      return t;
    },
    multiplyScalarAndAdd: function (t, e, n, r) {
      t[0] = e[0] + n[0] * r;
      t[1] = e[1] + n[1] * r;
      t[2] = e[2] + n[2] * r;
      t[3] = e[3] + n[3] * r;
      t[4] = e[4] + n[4] * r;
      t[5] = e[5] + n[5] * r;
      t[6] = e[6] + n[6] * r;
      t[7] = e[7] + n[7] * r;
      t[8] = e[8] + n[8] * r;
      return t;
    },
    exactEquals: function (t, e) {
      return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5] && t[6] === e[6] && t[7] === e[7] && t[8] === e[8];
    },
    equals: function (t, e) {
      var n = t[0];
      var r = t[1];
      var i = t[2];
      var o = t[3];
      var a = t[4];
      var s = t[5];
      var u = t[6];
      var h = t[7];
      var c = t[8];
      var l = e[0];
      var f = e[1];
      var d = e[2];
      var p = e[3];
      var v = e[4];
      var m = e[5];
      var g = e[6];
      var y = e[7];
      var _ = e[8];
      return Math.abs(n - l) <= vt * Math.max(1, Math.abs(n), Math.abs(l)) && Math.abs(r - f) <= vt * Math.max(1, Math.abs(r), Math.abs(f)) && Math.abs(i - d) <= vt * Math.max(1, Math.abs(i), Math.abs(d)) && Math.abs(o - p) <= vt * Math.max(1, Math.abs(o), Math.abs(p)) && Math.abs(a - v) <= vt * Math.max(1, Math.abs(a), Math.abs(v)) && Math.abs(s - m) <= vt * Math.max(1, Math.abs(s), Math.abs(m)) && Math.abs(u - g) <= vt * Math.max(1, Math.abs(u), Math.abs(g)) && Math.abs(h - y) <= vt * Math.max(1, Math.abs(h), Math.abs(y)) && Math.abs(c - _) <= vt * Math.max(1, Math.abs(c), Math.abs(_));
    },
    mul: Ce,
    sub: Re
  });
  function Pe() {
    var t = new mt(16);
    if (mt != Float32Array) {
      t[1] = 0;
      t[2] = 0;
      t[3] = 0;
      t[4] = 0;
      t[6] = 0;
      t[7] = 0;
      t[8] = 0;
      t[9] = 0;
      t[11] = 0;
      t[12] = 0;
      t[13] = 0;
      t[14] = 0;
    }
    t[0] = 1;
    t[5] = 1;
    t[10] = 1;
    t[15] = 1;
    return t;
  }
  function De(t) {
    var e = new mt(16);
    e[0] = t[0];
    e[1] = t[1];
    e[2] = t[2];
    e[3] = t[3];
    e[4] = t[4];
    e[5] = t[5];
    e[6] = t[6];
    e[7] = t[7];
    e[8] = t[8];
    e[9] = t[9];
    e[10] = t[10];
    e[11] = t[11];
    e[12] = t[12];
    e[13] = t[13];
    e[14] = t[14];
    e[15] = t[15];
    return e;
  }
  function Oe(t, e) {
    t[0] = e[0];
    t[1] = e[1];
    t[2] = e[2];
    t[3] = e[3];
    t[4] = e[4];
    t[5] = e[5];
    t[6] = e[6];
    t[7] = e[7];
    t[8] = e[8];
    t[9] = e[9];
    t[10] = e[10];
    t[11] = e[11];
    t[12] = e[12];
    t[13] = e[13];
    t[14] = e[14];
    t[15] = e[15];
    return t;
  }
  function Ie(t) {
    t[0] = 1;
    t[1] = 0;
    t[2] = 0;
    t[3] = 0;
    t[4] = 0;
    t[5] = 1;
    t[6] = 0;
    t[7] = 0;
    t[8] = 0;
    t[9] = 0;
    t[10] = 1;
    t[11] = 0;
    t[12] = 0;
    t[13] = 0;
    t[14] = 0;
    t[15] = 1;
    return t;
  }
  function Le(t, e) {
    if (t === e) {
      var n = e[1];
      var r = e[2];
      var i = e[3];
      var o = e[6];
      var a = e[7];
      var s = e[11];
      t[1] = e[4];
      t[2] = e[8];
      t[3] = e[12];
      t[4] = n;
      t[6] = e[9];
      t[7] = e[13];
      t[8] = r;
      t[9] = o;
      t[11] = e[14];
      t[12] = i;
      t[13] = a;
      t[14] = s;
    } else {
      t[0] = e[0];
      t[1] = e[4];
      t[2] = e[8];
      t[3] = e[12];
      t[4] = e[1];
      t[5] = e[5];
      t[6] = e[9];
      t[7] = e[13];
      t[8] = e[2];
      t[9] = e[6];
      t[10] = e[10];
      t[11] = e[14];
      t[12] = e[3];
      t[13] = e[7];
      t[14] = e[11];
      t[15] = e[15];
    }
    return t;
  }
  function Be(t, e) {
    var n = e[0];
    var r = e[1];
    var i = e[2];
    var o = e[3];
    var a = e[4];
    var s = e[5];
    var u = e[6];
    var h = e[7];
    var c = e[8];
    var l = e[9];
    var f = e[10];
    var d = e[11];
    var p = e[12];
    var v = e[13];
    var m = e[14];
    var g = e[15];
    var y = n * s - r * a;
    var _ = n * u - i * a;
    var x = n * h - o * a;
    var b = r * u - i * s;
    var M = r * h - o * s;
    var w = i * h - o * u;
    var E = c * v - l * p;
    var T = c * m - f * p;
    var A = c * g - d * p;
    var C = l * m - f * v;
    var R = l * g - d * v;
    var S = f * g - d * m;
    var P = y * S - _ * R + x * C + b * A - M * T + w * E;
    return P ? (P = 1 / P, t[0] = (s * S - u * R + h * C) * P, t[1] = (i * R - r * S - o * C) * P, t[2] = (v * w - m * M + g * b) * P, t[3] = (f * M - l * w - d * b) * P, t[4] = (u * A - a * S - h * T) * P, t[5] = (n * S - i * A + o * T) * P, t[6] = (m * x - p * w - g * _) * P, t[7] = (c * w - f * x + d * _) * P, t[8] = (a * R - s * A + h * E) * P, t[9] = (r * A - n * R - o * E) * P, t[10] = (p * M - v * x + g * y) * P, t[11] = (l * x - c * M - d * y) * P, t[12] = (s * T - a * C - u * E) * P, t[13] = (n * C - r * T + i * E) * P, t[14] = (v * _ - p * b - m * y) * P, t[15] = (c * b - l * _ + f * y) * P, t) : null;
  }
  function ke(t) {
    var e = t[0];
    var n = t[1];
    var r = t[2];
    var i = t[3];
    var o = t[4];
    var a = t[5];
    var s = t[6];
    var u = t[7];
    var h = t[8];
    var c = t[9];
    var l = t[10];
    var f = t[11];
    var d = t[12];
    var p = t[13];
    var v = t[14];
    var m = t[15];
    return (e * a - n * o) * (l * m - f * v) - (e * s - r * o) * (c * m - f * p) + (e * u - i * o) * (c * v - l * p) + (n * s - r * a) * (h * m - f * d) - (n * u - i * a) * (h * v - l * d) + (r * u - i * s) * (h * p - c * d);
  }
  function Ue(t, e, n) {
    var r = e[0];
    var i = e[1];
    var o = e[2];
    var a = e[3];
    var s = e[4];
    var u = e[5];
    var h = e[6];
    var c = e[7];
    var l = e[8];
    var f = e[9];
    var d = e[10];
    var p = e[11];
    var v = e[12];
    var m = e[13];
    var g = e[14];
    var y = e[15];
    var _ = n[0];
    var x = n[1];
    var b = n[2];
    var M = n[3];
    t[0] = _ * r + x * s + b * l + M * v;
    t[1] = _ * i + x * u + b * f + M * m;
    t[2] = _ * o + x * h + b * d + M * g;
    t[3] = _ * a + x * c + b * p + M * y;
    _ = n[4];
    x = n[5];
    b = n[6];
    M = n[7];
    t[4] = _ * r + x * s + b * l + M * v;
    t[5] = _ * i + x * u + b * f + M * m;
    t[6] = _ * o + x * h + b * d + M * g;
    t[7] = _ * a + x * c + b * p + M * y;
    _ = n[8];
    x = n[9];
    b = n[10];
    M = n[11];
    t[8] = _ * r + x * s + b * l + M * v;
    t[9] = _ * i + x * u + b * f + M * m;
    t[10] = _ * o + x * h + b * d + M * g;
    t[11] = _ * a + x * c + b * p + M * y;
    _ = n[12];
    x = n[13];
    b = n[14];
    M = n[15];
    t[12] = _ * r + x * s + b * l + M * v;
    t[13] = _ * i + x * u + b * f + M * m;
    t[14] = _ * o + x * h + b * d + M * g;
    t[15] = _ * a + x * c + b * p + M * y;
    return t;
  }
  function Ne(t, e, n) {
    var r;
    var i;
    var o;
    var a;
    var s;
    var u;
    var h;
    var c;
    var l;
    var f;
    var d;
    var p;
    var v = n[0];
    var m = n[1];
    var g = n[2];
    if (e === t) {
      t[12] = e[0] * v + e[4] * m + e[8] * g + e[12];
      t[13] = e[1] * v + e[5] * m + e[9] * g + e[13];
      t[14] = e[2] * v + e[6] * m + e[10] * g + e[14];
      t[15] = e[3] * v + e[7] * m + e[11] * g + e[15];
    } else {
      r = e[0];
      i = e[1];
      o = e[2];
      a = e[3];
      s = e[4];
      u = e[5];
      h = e[6];
      c = e[7];
      l = e[8];
      f = e[9];
      d = e[10];
      p = e[11];
      t[0] = r;
      t[1] = i;
      t[2] = o;
      t[3] = a;
      t[4] = s;
      t[5] = u;
      t[6] = h;
      t[7] = c;
      t[8] = l;
      t[9] = f;
      t[10] = d;
      t[11] = p;
      t[12] = r * v + s * m + l * g + e[12];
      t[13] = i * v + u * m + f * g + e[13];
      t[14] = o * v + h * m + d * g + e[14];
      t[15] = a * v + c * m + p * g + e[15];
    }
    return t;
  }
  function Fe(t, e, n) {
    var r = n[0];
    var i = n[1];
    var o = n[2];
    t[0] = e[0] * r;
    t[1] = e[1] * r;
    t[2] = e[2] * r;
    t[3] = e[3] * r;
    t[4] = e[4] * i;
    t[5] = e[5] * i;
    t[6] = e[6] * i;
    t[7] = e[7] * i;
    t[8] = e[8] * o;
    t[9] = e[9] * o;
    t[10] = e[10] * o;
    t[11] = e[11] * o;
    t[12] = e[12];
    t[13] = e[13];
    t[14] = e[14];
    t[15] = e[15];
    return t;
  }
  function je(t, e, n, r) {
    var i;
    var o;
    var a;
    var s;
    var u;
    var h;
    var c;
    var l;
    var f;
    var d;
    var p;
    var v;
    var m;
    var g;
    var y;
    var _;
    var x;
    var b;
    var M;
    var w;
    var E;
    var T;
    var A;
    var C;
    var R = r[0];
    var S = r[1];
    var P = r[2];
    var D = Math.hypot(R, S, P);
    return D < vt ? null : (R *= D = 1 / D, S *= D, P *= D, i = Math.sin(n), a = 1 - (o = Math.cos(n)), s = e[0], u = e[1], h = e[2], c = e[3], l = e[4], f = e[5], d = e[6], p = e[7], v = e[8], m = e[9], g = e[10], y = e[11], _ = R * R * a + o, x = S * R * a + P * i, b = P * R * a - S * i, M = R * S * a - P * i, w = S * S * a + o, E = P * S * a + R * i, T = R * P * a + S * i, A = S * P * a - R * i, C = P * P * a + o, t[0] = s * _ + l * x + v * b, t[1] = u * _ + f * x + m * b, t[2] = h * _ + d * x + g * b, t[3] = c * _ + p * x + y * b, t[4] = s * M + l * w + v * E, t[5] = u * M + f * w + m * E, t[6] = h * M + d * w + g * E, t[7] = c * M + p * w + y * E, t[8] = s * T + l * A + v * C, t[9] = u * T + f * A + m * C, t[10] = h * T + d * A + g * C, t[11] = c * T + p * A + y * C, e !== t && (t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t);
  }
  function ze(t, e, n) {
    var r = Math.sin(n);
    var i = Math.cos(n);
    var o = e[4];
    var a = e[5];
    var s = e[6];
    var u = e[7];
    var h = e[8];
    var c = e[9];
    var l = e[10];
    var f = e[11];
    if (e !== t) {
      t[0] = e[0];
      t[1] = e[1];
      t[2] = e[2];
      t[3] = e[3];
      t[12] = e[12];
      t[13] = e[13];
      t[14] = e[14];
      t[15] = e[15];
    }
    t[4] = o * i + h * r;
    t[5] = a * i + c * r;
    t[6] = s * i + l * r;
    t[7] = u * i + f * r;
    t[8] = h * i - o * r;
    t[9] = c * i - a * r;
    t[10] = l * i - s * r;
    t[11] = f * i - u * r;
    return t;
  }
  function Ve(t, e, n) {
    var r = Math.sin(n);
    var i = Math.cos(n);
    var o = e[0];
    var a = e[1];
    var s = e[2];
    var u = e[3];
    var h = e[8];
    var c = e[9];
    var l = e[10];
    var f = e[11];
    if (e !== t) {
      t[4] = e[4];
      t[5] = e[5];
      t[6] = e[6];
      t[7] = e[7];
      t[12] = e[12];
      t[13] = e[13];
      t[14] = e[14];
      t[15] = e[15];
    }
    t[0] = o * i - h * r;
    t[1] = a * i - c * r;
    t[2] = s * i - l * r;
    t[3] = u * i - f * r;
    t[8] = o * r + h * i;
    t[9] = a * r + c * i;
    t[10] = s * r + l * i;
    t[11] = u * r + f * i;
    return t;
  }
  function Ge(t, e, n) {
    var r = Math.sin(n);
    var i = Math.cos(n);
    var o = e[0];
    var a = e[1];
    var s = e[2];
    var u = e[3];
    var h = e[4];
    var c = e[5];
    var l = e[6];
    var f = e[7];
    if (e !== t) {
      t[8] = e[8];
      t[9] = e[9];
      t[10] = e[10];
      t[11] = e[11];
      t[12] = e[12];
      t[13] = e[13];
      t[14] = e[14];
      t[15] = e[15];
    }
    t[0] = o * i + h * r;
    t[1] = a * i + c * r;
    t[2] = s * i + l * r;
    t[3] = u * i + f * r;
    t[4] = h * i - o * r;
    t[5] = c * i - a * r;
    t[6] = l * i - s * r;
    t[7] = f * i - u * r;
    return t;
  }
  function We(t, e, n) {
    var r = e[0];
    var i = e[1];
    var o = e[2];
    var a = e[3];
    var s = r + r;
    var u = i + i;
    var h = o + o;
    var c = r * s;
    var l = r * u;
    var f = r * h;
    var d = i * u;
    var p = i * h;
    var v = o * h;
    var m = a * s;
    var g = a * u;
    var y = a * h;
    t[0] = 1 - (d + v);
    t[1] = l + y;
    t[2] = f - g;
    t[3] = 0;
    t[4] = l - y;
    t[5] = 1 - (c + v);
    t[6] = p + m;
    t[7] = 0;
    t[8] = f + g;
    t[9] = p - m;
    t[10] = 1 - (c + d);
    t[11] = 0;
    t[12] = n[0];
    t[13] = n[1];
    t[14] = n[2];
    t[15] = 1;
    return t;
  }
  function He(t, e) {
    var n = e[0];
    var r = e[1];
    var i = e[2];
    var o = e[4];
    var a = e[5];
    var s = e[6];
    var u = e[8];
    var h = e[9];
    var c = e[10];
    t[0] = Math.hypot(n, r, i);
    t[1] = Math.hypot(o, a, s);
    t[2] = Math.hypot(u, h, c);
    return t;
  }
  function Ze(t, e) {
    var n = new mt(3);
    He(n, e);
    var r = 1 / n[0];
    var i = 1 / n[1];
    var o = 1 / n[2];
    var a = e[0] * r;
    var s = e[1] * i;
    var u = e[2] * o;
    var h = e[4] * r;
    var c = e[5] * i;
    var l = e[6] * o;
    var f = e[8] * r;
    var d = e[9] * i;
    var p = e[10] * o;
    var v = a + c + p;
    var m = 0;
    if (v > 0) {
      m = 2 * Math.sqrt(v + 1);
      t[3] = 0.25 * m;
      t[0] = (l - d) / m;
      t[1] = (f - u) / m;
      t[2] = (s - h) / m;
    } else if (a > c && a > p) {
      m = 2 * Math.sqrt(1 + a - c - p);
      t[3] = (l - d) / m;
      t[0] = 0.25 * m;
      t[1] = (s + h) / m;
      t[2] = (f + u) / m;
    } else if (c > p) {
      m = 2 * Math.sqrt(1 + c - a - p);
      t[3] = (f - u) / m;
      t[0] = (s + h) / m;
      t[1] = 0.25 * m;
      t[2] = (l + d) / m;
    } else {
      m = 2 * Math.sqrt(1 + p - a - c);
      t[3] = (s - h) / m;
      t[0] = (f + u) / m;
      t[1] = (l + d) / m;
      t[2] = 0.25 * m;
    }
    return t;
  }
  function qe(t, e, n, r) {
    var i = e[0];
    var o = e[1];
    var a = e[2];
    var s = e[3];
    var u = i + i;
    var h = o + o;
    var c = a + a;
    var l = i * u;
    var f = i * h;
    var d = i * c;
    var p = o * h;
    var v = o * c;
    var m = a * c;
    var g = s * u;
    var y = s * h;
    var _ = s * c;
    var x = r[0];
    var b = r[1];
    var M = r[2];
    t[0] = (1 - (p + m)) * x;
    t[1] = (f + _) * x;
    t[2] = (d - y) * x;
    t[3] = 0;
    t[4] = (f - _) * b;
    t[5] = (1 - (l + m)) * b;
    t[6] = (v + g) * b;
    t[7] = 0;
    t[8] = (d + y) * M;
    t[9] = (v - g) * M;
    t[10] = (1 - (l + p)) * M;
    t[11] = 0;
    t[12] = n[0];
    t[13] = n[1];
    t[14] = n[2];
    t[15] = 1;
    return t;
  }
  function Ye(t, e) {
    var n = e[0];
    var r = e[1];
    var i = e[2];
    var o = e[3];
    var a = n + n;
    var s = r + r;
    var u = i + i;
    var h = n * a;
    var c = r * a;
    var l = r * s;
    var f = i * a;
    var d = i * s;
    var p = i * u;
    var v = o * a;
    var m = o * s;
    var g = o * u;
    t[0] = 1 - l - p;
    t[1] = c + g;
    t[2] = f - m;
    t[3] = 0;
    t[4] = c - g;
    t[5] = 1 - h - p;
    t[6] = d + v;
    t[7] = 0;
    t[8] = f + m;
    t[9] = d - v;
    t[10] = 1 - h - l;
    t[11] = 0;
    t[12] = 0;
    t[13] = 0;
    t[14] = 0;
    t[15] = 1;
    return t;
  }
  function Xe(t, e, n, r, i, o, a) {
    var s = 1 / (n - e);
    var u = 1 / (i - r);
    var h = 1 / (o - a);
    t[0] = 2 * o * s;
    t[1] = 0;
    t[2] = 0;
    t[3] = 0;
    t[4] = 0;
    t[5] = 2 * o * u;
    t[6] = 0;
    t[7] = 0;
    t[8] = (n + e) * s;
    t[9] = (i + r) * u;
    t[10] = (a + o) * h;
    t[11] = -1;
    t[12] = 0;
    t[13] = 0;
    t[14] = a * o * 2 * h;
    t[15] = 0;
    return t;
  }
  function Ke(t, e, n, r, i) {
    var o;
    var a = 1 / Math.tan(e / 2);
    t[0] = a / n;
    t[1] = 0;
    t[2] = 0;
    t[3] = 0;
    t[4] = 0;
    t[5] = a;
    t[6] = 0;
    t[7] = 0;
    t[8] = 0;
    t[9] = 0;
    t[11] = -1;
    t[12] = 0;
    t[13] = 0;
    t[15] = 0;
    if (i != null && i !== 1 / 0) {
      o = 1 / (r - i);
      t[10] = (i + r) * o;
      t[14] = 2 * i * r * o;
    } else {
      t[10] = -1;
      t[14] = -2 * r;
    }
    return t;
  }
  var Qe = Ke;
  function Je(t, e, n, r, i, o, a) {
    var s = 1 / (e - n);
    var u = 1 / (r - i);
    var h = 1 / (o - a);
    t[0] = -2 * s;
    t[1] = 0;
    t[2] = 0;
    t[3] = 0;
    t[4] = 0;
    t[5] = -2 * u;
    t[6] = 0;
    t[7] = 0;
    t[8] = 0;
    t[9] = 0;
    t[10] = 2 * h;
    t[11] = 0;
    t[12] = (e + n) * s;
    t[13] = (i + r) * u;
    t[14] = (a + o) * h;
    t[15] = 1;
    return t;
  }
  var $e = Je;
  function tn(t, e, n, r) {
    var i;
    var o;
    var a;
    var s;
    var u;
    var h;
    var c;
    var l;
    var f;
    var d;
    var p = e[0];
    var v = e[1];
    var m = e[2];
    var g = r[0];
    var y = r[1];
    var _ = r[2];
    var x = n[0];
    var b = n[1];
    var M = n[2];
    return Math.abs(p - x) < vt && Math.abs(v - b) < vt && Math.abs(m - M) < vt ? Ie(t) : (c = p - x, l = v - b, f = m - M, i = y * (f *= d = 1 / Math.hypot(c, l, f)) - _ * (l *= d), o = _ * (c *= d) - g * f, a = g * l - y * c, (d = Math.hypot(i, o, a)) ? (i *= d = 1 / d, o *= d, a *= d) : (i = 0, o = 0, a = 0), s = l * a - f * o, u = f * i - c * a, h = c * o - l * i, (d = Math.hypot(s, u, h)) ? (s *= d = 1 / d, u *= d, h *= d) : (s = 0, u = 0, h = 0), t[0] = i, t[1] = s, t[2] = c, t[3] = 0, t[4] = o, t[5] = u, t[6] = l, t[7] = 0, t[8] = a, t[9] = h, t[10] = f, t[11] = 0, t[12] = -(i * p + o * v + a * m), t[13] = -(s * p + u * v + h * m), t[14] = -(c * p + l * v + f * m), t[15] = 1, t);
  }
  function en(t, e, n, r) {
    var i = e[0];
    var o = e[1];
    var a = e[2];
    var s = r[0];
    var u = r[1];
    var h = r[2];
    var c = i - n[0];
    var l = o - n[1];
    var f = a - n[2];
    var d = c * c + l * l + f * f;
    if (d > 0) {
      c *= d = 1 / Math.sqrt(d);
      l *= d;
      f *= d;
    }
    var p = u * f - h * l;
    var v = h * c - s * f;
    var m = s * l - u * c;
    if ((d = p * p + v * v + m * m) > 0) {
      p *= d = 1 / Math.sqrt(d);
      v *= d;
      m *= d;
    }
    t[0] = p;
    t[1] = v;
    t[2] = m;
    t[3] = 0;
    t[4] = l * m - f * v;
    t[5] = f * p - c * m;
    t[6] = c * v - l * p;
    t[7] = 0;
    t[8] = c;
    t[9] = l;
    t[10] = f;
    t[11] = 0;
    t[12] = i;
    t[13] = o;
    t[14] = a;
    t[15] = 1;
    return t;
  }
  function nn(t, e, n) {
    t[0] = e[0] - n[0];
    t[1] = e[1] - n[1];
    t[2] = e[2] - n[2];
    t[3] = e[3] - n[3];
    t[4] = e[4] - n[4];
    t[5] = e[5] - n[5];
    t[6] = e[6] - n[6];
    t[7] = e[7] - n[7];
    t[8] = e[8] - n[8];
    t[9] = e[9] - n[9];
    t[10] = e[10] - n[10];
    t[11] = e[11] - n[11];
    t[12] = e[12] - n[12];
    t[13] = e[13] - n[13];
    t[14] = e[14] - n[14];
    t[15] = e[15] - n[15];
    return t;
  }
  var rn = Ue;
  var on = nn;
  var an = Object.freeze({
    __proto__: null,
    create: Pe,
    clone: De,
    copy: Oe,
    fromValues: function (t, e, n, r, i, o, a, s, u, h, c, l, f, d, p, v) {
      var m = new mt(16);
      m[0] = t;
      m[1] = e;
      m[2] = n;
      m[3] = r;
      m[4] = i;
      m[5] = o;
      m[6] = a;
      m[7] = s;
      m[8] = u;
      m[9] = h;
      m[10] = c;
      m[11] = l;
      m[12] = f;
      m[13] = d;
      m[14] = p;
      m[15] = v;
      return m;
    },
    set: function (t, e, n, r, i, o, a, s, u, h, c, l, f, d, p, v, m) {
      t[0] = e;
      t[1] = n;
      t[2] = r;
      t[3] = i;
      t[4] = o;
      t[5] = a;
      t[6] = s;
      t[7] = u;
      t[8] = h;
      t[9] = c;
      t[10] = l;
      t[11] = f;
      t[12] = d;
      t[13] = p;
      t[14] = v;
      t[15] = m;
      return t;
    },
    identity: Ie,
    transpose: Le,
    invert: Be,
    adjoint: function (t, e) {
      var n = e[0];
      var r = e[1];
      var i = e[2];
      var o = e[3];
      var a = e[4];
      var s = e[5];
      var u = e[6];
      var h = e[7];
      var c = e[8];
      var l = e[9];
      var f = e[10];
      var d = e[11];
      var p = e[12];
      var v = e[13];
      var m = e[14];
      var g = e[15];
      t[0] = s * (f * g - d * m) - l * (u * g - h * m) + v * (u * d - h * f);
      t[1] = -(r * (f * g - d * m) - l * (i * g - o * m) + v * (i * d - o * f));
      t[2] = r * (u * g - h * m) - s * (i * g - o * m) + v * (i * h - o * u);
      t[3] = -(r * (u * d - h * f) - s * (i * d - o * f) + l * (i * h - o * u));
      t[4] = -(a * (f * g - d * m) - c * (u * g - h * m) + p * (u * d - h * f));
      t[5] = n * (f * g - d * m) - c * (i * g - o * m) + p * (i * d - o * f);
      t[6] = -(n * (u * g - h * m) - a * (i * g - o * m) + p * (i * h - o * u));
      t[7] = n * (u * d - h * f) - a * (i * d - o * f) + c * (i * h - o * u);
      t[8] = a * (l * g - d * v) - c * (s * g - h * v) + p * (s * d - h * l);
      t[9] = -(n * (l * g - d * v) - c * (r * g - o * v) + p * (r * d - o * l));
      t[10] = n * (s * g - h * v) - a * (r * g - o * v) + p * (r * h - o * s);
      t[11] = -(n * (s * d - h * l) - a * (r * d - o * l) + c * (r * h - o * s));
      t[12] = -(a * (l * m - f * v) - c * (s * m - u * v) + p * (s * f - u * l));
      t[13] = n * (l * m - f * v) - c * (r * m - i * v) + p * (r * f - i * l);
      t[14] = -(n * (s * m - u * v) - a * (r * m - i * v) + p * (r * u - i * s));
      t[15] = n * (s * f - u * l) - a * (r * f - i * l) + c * (r * u - i * s);
      return t;
    },
    determinant: ke,
    multiply: Ue,
    translate: Ne,
    scale: Fe,
    rotate: je,
    rotateX: ze,
    rotateY: Ve,
    rotateZ: Ge,
    fromTranslation: function (t, e) {
      t[0] = 1;
      t[1] = 0;
      t[2] = 0;
      t[3] = 0;
      t[4] = 0;
      t[5] = 1;
      t[6] = 0;
      t[7] = 0;
      t[8] = 0;
      t[9] = 0;
      t[10] = 1;
      t[11] = 0;
      t[12] = e[0];
      t[13] = e[1];
      t[14] = e[2];
      t[15] = 1;
      return t;
    },
    fromScaling: function (t, e) {
      t[0] = e[0];
      t[1] = 0;
      t[2] = 0;
      t[3] = 0;
      t[4] = 0;
      t[5] = e[1];
      t[6] = 0;
      t[7] = 0;
      t[8] = 0;
      t[9] = 0;
      t[10] = e[2];
      t[11] = 0;
      t[12] = 0;
      t[13] = 0;
      t[14] = 0;
      t[15] = 1;
      return t;
    },
    fromRotation: function (t, e, n) {
      var r;
      var i;
      var o;
      var a = n[0];
      var s = n[1];
      var u = n[2];
      var h = Math.hypot(a, s, u);
      return h < vt ? null : (a *= h = 1 / h, s *= h, u *= h, r = Math.sin(e), o = 1 - (i = Math.cos(e)), t[0] = a * a * o + i, t[1] = s * a * o + u * r, t[2] = u * a * o - s * r, t[3] = 0, t[4] = a * s * o - u * r, t[5] = s * s * o + i, t[6] = u * s * o + a * r, t[7] = 0, t[8] = a * u * o + s * r, t[9] = s * u * o - a * r, t[10] = u * u * o + i, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t);
    },
    fromXRotation: function (t, e) {
      var n = Math.sin(e);
      var r = Math.cos(e);
      t[0] = 1;
      t[1] = 0;
      t[2] = 0;
      t[3] = 0;
      t[4] = 0;
      t[5] = r;
      t[6] = n;
      t[7] = 0;
      t[8] = 0;
      t[9] = -n;
      t[10] = r;
      t[11] = 0;
      t[12] = 0;
      t[13] = 0;
      t[14] = 0;
      t[15] = 1;
      return t;
    },
    fromYRotation: function (t, e) {
      var n = Math.sin(e);
      var r = Math.cos(e);
      t[0] = r;
      t[1] = 0;
      t[2] = -n;
      t[3] = 0;
      t[4] = 0;
      t[5] = 1;
      t[6] = 0;
      t[7] = 0;
      t[8] = n;
      t[9] = 0;
      t[10] = r;
      t[11] = 0;
      t[12] = 0;
      t[13] = 0;
      t[14] = 0;
      t[15] = 1;
      return t;
    },
    fromZRotation: function (t, e) {
      var n = Math.sin(e);
      var r = Math.cos(e);
      t[0] = r;
      t[1] = n;
      t[2] = 0;
      t[3] = 0;
      t[4] = -n;
      t[5] = r;
      t[6] = 0;
      t[7] = 0;
      t[8] = 0;
      t[9] = 0;
      t[10] = 1;
      t[11] = 0;
      t[12] = 0;
      t[13] = 0;
      t[14] = 0;
      t[15] = 1;
      return t;
    },
    fromRotationTranslation: We,
    fromQuat2: function (t, e) {
      var n = new mt(3);
      var r = -e[0];
      var i = -e[1];
      var o = -e[2];
      var a = e[3];
      var s = e[4];
      var u = e[5];
      var h = e[6];
      var c = e[7];
      var l = r * r + i * i + o * o + a * a;
      if (l > 0) {
        n[0] = 2 * (s * a + c * r + u * o - h * i) / l;
        n[1] = 2 * (u * a + c * i + h * r - s * o) / l;
        n[2] = 2 * (h * a + c * o + s * i - u * r) / l;
      } else {
        n[0] = 2 * (s * a + c * r + u * o - h * i);
        n[1] = 2 * (u * a + c * i + h * r - s * o);
        n[2] = 2 * (h * a + c * o + s * i - u * r);
      }
      We(t, e, n);
      return t;
    },
    getTranslation: function (t, e) {
      t[0] = e[12];
      t[1] = e[13];
      t[2] = e[14];
      return t;
    },
    getScaling: He,
    getRotation: Ze,
    fromRotationTranslationScale: qe,
    fromRotationTranslationScaleOrigin: function (t, e, n, r, i) {
      var o = e[0];
      var a = e[1];
      var s = e[2];
      var u = e[3];
      var h = o + o;
      var c = a + a;
      var l = s + s;
      var f = o * h;
      var d = o * c;
      var p = o * l;
      var v = a * c;
      var m = a * l;
      var g = s * l;
      var y = u * h;
      var _ = u * c;
      var x = u * l;
      var b = r[0];
      var M = r[1];
      var w = r[2];
      var E = i[0];
      var T = i[1];
      var A = i[2];
      var C = (1 - (v + g)) * b;
      var R = (d + x) * b;
      var S = (p - _) * b;
      var P = (d - x) * M;
      var D = (1 - (f + g)) * M;
      var O = (m + y) * M;
      var I = (p + _) * w;
      var L = (m - y) * w;
      var B = (1 - (f + v)) * w;
      t[0] = C;
      t[1] = R;
      t[2] = S;
      t[3] = 0;
      t[4] = P;
      t[5] = D;
      t[6] = O;
      t[7] = 0;
      t[8] = I;
      t[9] = L;
      t[10] = B;
      t[11] = 0;
      t[12] = n[0] + E - (C * E + P * T + I * A);
      t[13] = n[1] + T - (R * E + D * T + L * A);
      t[14] = n[2] + A - (S * E + O * T + B * A);
      t[15] = 1;
      return t;
    },
    fromQuat: Ye,
    frustum: Xe,
    perspectiveNO: Ke,
    perspective: Qe,
    perspectiveZO: function (t, e, n, r, i) {
      var o;
      var a = 1 / Math.tan(e / 2);
      t[0] = a / n;
      t[1] = 0;
      t[2] = 0;
      t[3] = 0;
      t[4] = 0;
      t[5] = a;
      t[6] = 0;
      t[7] = 0;
      t[8] = 0;
      t[9] = 0;
      t[11] = -1;
      t[12] = 0;
      t[13] = 0;
      t[15] = 0;
      if (i != null && i !== 1 / 0) {
        o = 1 / (r - i);
        t[10] = i * o;
        t[14] = i * r * o;
      } else {
        t[10] = -1;
        t[14] = -r;
      }
      return t;
    },
    perspectiveFromFieldOfView: function (t, e, n, r) {
      var i = Math.tan(e.upDegrees * Math.PI / 180);
      var o = Math.tan(e.downDegrees * Math.PI / 180);
      var a = Math.tan(e.leftDegrees * Math.PI / 180);
      var s = Math.tan(e.rightDegrees * Math.PI / 180);
      var u = 2 / (a + s);
      var h = 2 / (i + o);
      t[0] = u;
      t[1] = 0;
      t[2] = 0;
      t[3] = 0;
      t[4] = 0;
      t[5] = h;
      t[6] = 0;
      t[7] = 0;
      t[8] = -(a - s) * u * 0.5;
      t[9] = (i - o) * h * 0.5;
      t[10] = r / (n - r);
      t[11] = -1;
      t[12] = 0;
      t[13] = 0;
      t[14] = r * n / (n - r);
      t[15] = 0;
      return t;
    },
    orthoNO: Je,
    ortho: $e,
    orthoZO: function (t, e, n, r, i, o, a) {
      var s = 1 / (e - n);
      var u = 1 / (r - i);
      var h = 1 / (o - a);
      t[0] = -2 * s;
      t[1] = 0;
      t[2] = 0;
      t[3] = 0;
      t[4] = 0;
      t[5] = -2 * u;
      t[6] = 0;
      t[7] = 0;
      t[8] = 0;
      t[9] = 0;
      t[10] = h;
      t[11] = 0;
      t[12] = (e + n) * s;
      t[13] = (i + r) * u;
      t[14] = o * h;
      t[15] = 1;
      return t;
    },
    lookAt: tn,
    targetTo: en,
    str: function (t) {
      return "mat4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ", " + t[9] + ", " + t[10] + ", " + t[11] + ", " + t[12] + ", " + t[13] + ", " + t[14] + ", " + t[15] + ")";
    },
    frob: function (t) {
      return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15]);
    },
    add: function (t, e, n) {
      t[0] = e[0] + n[0];
      t[1] = e[1] + n[1];
      t[2] = e[2] + n[2];
      t[3] = e[3] + n[3];
      t[4] = e[4] + n[4];
      t[5] = e[5] + n[5];
      t[6] = e[6] + n[6];
      t[7] = e[7] + n[7];
      t[8] = e[8] + n[8];
      t[9] = e[9] + n[9];
      t[10] = e[10] + n[10];
      t[11] = e[11] + n[11];
      t[12] = e[12] + n[12];
      t[13] = e[13] + n[13];
      t[14] = e[14] + n[14];
      t[15] = e[15] + n[15];
      return t;
    },
    subtract: nn,
    multiplyScalar: function (t, e, n) {
      t[0] = e[0] * n;
      t[1] = e[1] * n;
      t[2] = e[2] * n;
      t[3] = e[3] * n;
      t[4] = e[4] * n;
      t[5] = e[5] * n;
      t[6] = e[6] * n;
      t[7] = e[7] * n;
      t[8] = e[8] * n;
      t[9] = e[9] * n;
      t[10] = e[10] * n;
      t[11] = e[11] * n;
      t[12] = e[12] * n;
      t[13] = e[13] * n;
      t[14] = e[14] * n;
      t[15] = e[15] * n;
      return t;
    },
    multiplyScalarAndAdd: function (t, e, n, r) {
      t[0] = e[0] + n[0] * r;
      t[1] = e[1] + n[1] * r;
      t[2] = e[2] + n[2] * r;
      t[3] = e[3] + n[3] * r;
      t[4] = e[4] + n[4] * r;
      t[5] = e[5] + n[5] * r;
      t[6] = e[6] + n[6] * r;
      t[7] = e[7] + n[7] * r;
      t[8] = e[8] + n[8] * r;
      t[9] = e[9] + n[9] * r;
      t[10] = e[10] + n[10] * r;
      t[11] = e[11] + n[11] * r;
      t[12] = e[12] + n[12] * r;
      t[13] = e[13] + n[13] * r;
      t[14] = e[14] + n[14] * r;
      t[15] = e[15] + n[15] * r;
      return t;
    },
    exactEquals: function (t, e) {
      return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5] && t[6] === e[6] && t[7] === e[7] && t[8] === e[8] && t[9] === e[9] && t[10] === e[10] && t[11] === e[11] && t[12] === e[12] && t[13] === e[13] && t[14] === e[14] && t[15] === e[15];
    },
    equals: function (t, e) {
      var n = t[0];
      var r = t[1];
      var i = t[2];
      var o = t[3];
      var a = t[4];
      var s = t[5];
      var u = t[6];
      var h = t[7];
      var c = t[8];
      var l = t[9];
      var f = t[10];
      var d = t[11];
      var p = t[12];
      var v = t[13];
      var m = t[14];
      var g = t[15];
      var y = e[0];
      var _ = e[1];
      var x = e[2];
      var b = e[3];
      var M = e[4];
      var w = e[5];
      var E = e[6];
      var T = e[7];
      var A = e[8];
      var C = e[9];
      var R = e[10];
      var S = e[11];
      var P = e[12];
      var D = e[13];
      var O = e[14];
      var I = e[15];
      return Math.abs(n - y) <= vt * Math.max(1, Math.abs(n), Math.abs(y)) && Math.abs(r - _) <= vt * Math.max(1, Math.abs(r), Math.abs(_)) && Math.abs(i - x) <= vt * Math.max(1, Math.abs(i), Math.abs(x)) && Math.abs(o - b) <= vt * Math.max(1, Math.abs(o), Math.abs(b)) && Math.abs(a - M) <= vt * Math.max(1, Math.abs(a), Math.abs(M)) && Math.abs(s - w) <= vt * Math.max(1, Math.abs(s), Math.abs(w)) && Math.abs(u - E) <= vt * Math.max(1, Math.abs(u), Math.abs(E)) && Math.abs(h - T) <= vt * Math.max(1, Math.abs(h), Math.abs(T)) && Math.abs(c - A) <= vt * Math.max(1, Math.abs(c), Math.abs(A)) && Math.abs(l - C) <= vt * Math.max(1, Math.abs(l), Math.abs(C)) && Math.abs(f - R) <= vt * Math.max(1, Math.abs(f), Math.abs(R)) && Math.abs(d - S) <= vt * Math.max(1, Math.abs(d), Math.abs(S)) && Math.abs(p - P) <= vt * Math.max(1, Math.abs(p), Math.abs(P)) && Math.abs(v - D) <= vt * Math.max(1, Math.abs(v), Math.abs(D)) && Math.abs(m - O) <= vt * Math.max(1, Math.abs(m), Math.abs(O)) && Math.abs(g - I) <= vt * Math.max(1, Math.abs(g), Math.abs(I));
    },
    mul: rn,
    sub: on
  });
  function sn() {
    var t = new mt(4);
    if (mt != Float32Array) {
      t[0] = 0;
      t[1] = 0;
      t[2] = 0;
      t[3] = 0;
    }
    return t;
  }
  function un(t) {
    var e = new mt(4);
    e[0] = t[0];
    e[1] = t[1];
    e[2] = t[2];
    e[3] = t[3];
    return e;
  }
  function hn(t, e, n, r) {
    var i = new mt(4);
    i[0] = t;
    i[1] = e;
    i[2] = n;
    i[3] = r;
    return i;
  }
  function cn(t, e) {
    t[0] = e[0];
    t[1] = e[1];
    t[2] = e[2];
    t[3] = e[3];
    return t;
  }
  function ln(t, e, n, r, i) {
    t[0] = e;
    t[1] = n;
    t[2] = r;
    t[3] = i;
    return t;
  }
  function fn(t, e, n) {
    t[0] = e[0] + n[0];
    t[1] = e[1] + n[1];
    t[2] = e[2] + n[2];
    t[3] = e[3] + n[3];
    return t;
  }
  function dn(t, e, n) {
    t[0] = e[0] - n[0];
    t[1] = e[1] - n[1];
    t[2] = e[2] - n[2];
    t[3] = e[3] - n[3];
    return t;
  }
  function pn(t, e, n) {
    t[0] = e[0] * n[0];
    t[1] = e[1] * n[1];
    t[2] = e[2] * n[2];
    t[3] = e[3] * n[3];
    return t;
  }
  function vn(t, e, n) {
    t[0] = e[0] / n[0];
    t[1] = e[1] / n[1];
    t[2] = e[2] / n[2];
    t[3] = e[3] / n[3];
    return t;
  }
  function mn(t, e, n) {
    t[0] = e[0] * n;
    t[1] = e[1] * n;
    t[2] = e[2] * n;
    t[3] = e[3] * n;
    return t;
  }
  function gn(t, e) {
    var n = e[0] - t[0];
    var r = e[1] - t[1];
    var i = e[2] - t[2];
    var o = e[3] - t[3];
    return Math.hypot(n, r, i, o);
  }
  function yn(t, e) {
    var n = e[0] - t[0];
    var r = e[1] - t[1];
    var i = e[2] - t[2];
    var o = e[3] - t[3];
    return n * n + r * r + i * i + o * o;
  }
  function _n(t) {
    var e = t[0];
    var n = t[1];
    var r = t[2];
    var i = t[3];
    return Math.hypot(e, n, r, i);
  }
  function xn(t) {
    var e = t[0];
    var n = t[1];
    var r = t[2];
    var i = t[3];
    return e * e + n * n + r * r + i * i;
  }
  function bn(t, e) {
    var n = e[0];
    var r = e[1];
    var i = e[2];
    var o = e[3];
    var a = n * n + r * r + i * i + o * o;
    if (a > 0) {
      a = 1 / Math.sqrt(a);
    }
    t[0] = n * a;
    t[1] = r * a;
    t[2] = i * a;
    t[3] = o * a;
    return t;
  }
  function Mn(t, e) {
    return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3];
  }
  function wn(t, e, n, r) {
    var i = e[0];
    var o = e[1];
    var a = e[2];
    var s = e[3];
    t[0] = i + r * (n[0] - i);
    t[1] = o + r * (n[1] - o);
    t[2] = a + r * (n[2] - a);
    t[3] = s + r * (n[3] - s);
    return t;
  }
  function En(t, e, n) {
    var r = e[0];
    var i = e[1];
    var o = e[2];
    var a = e[3];
    t[0] = n[0] * r + n[4] * i + n[8] * o + n[12] * a;
    t[1] = n[1] * r + n[5] * i + n[9] * o + n[13] * a;
    t[2] = n[2] * r + n[6] * i + n[10] * o + n[14] * a;
    t[3] = n[3] * r + n[7] * i + n[11] * o + n[15] * a;
    return t;
  }
  function Tn(t, e) {
    return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3];
  }
  function An(t, e) {
    var n = t[0];
    var r = t[1];
    var i = t[2];
    var o = t[3];
    var a = e[0];
    var s = e[1];
    var u = e[2];
    var h = e[3];
    return Math.abs(n - a) <= vt * Math.max(1, Math.abs(n), Math.abs(a)) && Math.abs(r - s) <= vt * Math.max(1, Math.abs(r), Math.abs(s)) && Math.abs(i - u) <= vt * Math.max(1, Math.abs(i), Math.abs(u)) && Math.abs(o - h) <= vt * Math.max(1, Math.abs(o), Math.abs(h));
  }
  var Cn;
  var Rn = dn;
  var Sn = pn;
  var Pn = vn;
  var Dn = gn;
  var On = yn;
  var In = _n;
  var Ln = xn;
  var Bn = function () {
    var t = sn();
    return function (e, n, r, i, o, a) {
      var s;
      var u;
      for (n || (n = 4), r || (r = 0), u = i ? Math.min(i * n + r, e.length) : e.length, s = r; s < u; s += n) {
        t[0] = e[s];
        t[1] = e[s + 1];
        t[2] = e[s + 2];
        t[3] = e[s + 3];
        o(t, t, a);
        e[s] = t[0];
        e[s + 1] = t[1];
        e[s + 2] = t[2];
        e[s + 3] = t[3];
      }
      return e;
    };
  }();
  var kn = Object.freeze({
    __proto__: null,
    create: sn,
    clone: un,
    fromValues: hn,
    copy: cn,
    set: ln,
    add: fn,
    subtract: dn,
    multiply: pn,
    divide: vn,
    ceil: function (t, e) {
      t[0] = Math.ceil(e[0]);
      t[1] = Math.ceil(e[1]);
      t[2] = Math.ceil(e[2]);
      t[3] = Math.ceil(e[3]);
      return t;
    },
    floor: function (t, e) {
      t[0] = Math.floor(e[0]);
      t[1] = Math.floor(e[1]);
      t[2] = Math.floor(e[2]);
      t[3] = Math.floor(e[3]);
      return t;
    },
    min: function (t, e, n) {
      t[0] = Math.min(e[0], n[0]);
      t[1] = Math.min(e[1], n[1]);
      t[2] = Math.min(e[2], n[2]);
      t[3] = Math.min(e[3], n[3]);
      return t;
    },
    max: function (t, e, n) {
      t[0] = Math.max(e[0], n[0]);
      t[1] = Math.max(e[1], n[1]);
      t[2] = Math.max(e[2], n[2]);
      t[3] = Math.max(e[3], n[3]);
      return t;
    },
    round: function (t, e) {
      t[0] = Math.round(e[0]);
      t[1] = Math.round(e[1]);
      t[2] = Math.round(e[2]);
      t[3] = Math.round(e[3]);
      return t;
    },
    scale: mn,
    scaleAndAdd: function (t, e, n, r) {
      t[0] = e[0] + n[0] * r;
      t[1] = e[1] + n[1] * r;
      t[2] = e[2] + n[2] * r;
      t[3] = e[3] + n[3] * r;
      return t;
    },
    distance: gn,
    squaredDistance: yn,
    length: _n,
    squaredLength: xn,
    negate: function (t, e) {
      t[0] = -e[0];
      t[1] = -e[1];
      t[2] = -e[2];
      t[3] = -e[3];
      return t;
    },
    inverse: function (t, e) {
      t[0] = 1 / e[0];
      t[1] = 1 / e[1];
      t[2] = 1 / e[2];
      t[3] = 1 / e[3];
      return t;
    },
    normalize: bn,
    dot: Mn,
    cross: function (t, e, n, r) {
      var i = n[0] * r[1] - n[1] * r[0];
      var o = n[0] * r[2] - n[2] * r[0];
      var a = n[0] * r[3] - n[3] * r[0];
      var s = n[1] * r[2] - n[2] * r[1];
      var u = n[1] * r[3] - n[3] * r[1];
      var h = n[2] * r[3] - n[3] * r[2];
      var c = e[0];
      var l = e[1];
      var f = e[2];
      var d = e[3];
      t[0] = l * h - f * u + d * s;
      t[1] = -c * h + f * a - d * o;
      t[2] = c * u - l * a + d * i;
      t[3] = -c * s + l * o - f * i;
      return t;
    },
    lerp: wn,
    random: function (t, e) {
      var n;
      var r;
      var i;
      var o;
      var a;
      var s;
      e = e || 1;
      do {
        a = (n = 2 * gt() - 1) * n + (r = 2 * gt() - 1) * r;
      } while (a >= 1);
      do {
        s = (i = 2 * gt() - 1) * i + (o = 2 * gt() - 1) * o;
      } while (s >= 1);
      var u = Math.sqrt((1 - a) / s);
      t[0] = e * n;
      t[1] = e * r;
      t[2] = e * i * u;
      t[3] = e * o * u;
      return t;
    },
    transformMat4: En,
    transformQuat: function (t, e, n) {
      var r = e[0];
      var i = e[1];
      var o = e[2];
      var a = n[0];
      var s = n[1];
      var u = n[2];
      var h = n[3];
      var c = h * r + s * o - u * i;
      var l = h * i + u * r - a * o;
      var f = h * o + a * i - s * r;
      var d = -a * r - s * i - u * o;
      t[0] = c * h + d * -a + l * -u - f * -s;
      t[1] = l * h + d * -s + f * -a - c * -u;
      t[2] = f * h + d * -u + c * -s - l * -a;
      t[3] = e[3];
      return t;
    },
    zero: function (t) {
      t[0] = 0;
      t[1] = 0;
      t[2] = 0;
      t[3] = 0;
      return t;
    },
    str: function (t) {
      return "vec4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")";
    },
    exactEquals: Tn,
    equals: An,
    sub: Rn,
    mul: Sn,
    div: Pn,
    dist: Dn,
    sqrDist: On,
    len: In,
    sqrLen: Ln,
    forEach: Bn
  });
  !function (t) {
    t[t.COL0ROW0 = 0] = "COL0ROW0";
    t[t.COL0ROW1 = 1] = "COL0ROW1";
    t[t.COL0ROW2 = 2] = "COL0ROW2";
    t[t.COL0ROW3 = 3] = "COL0ROW3";
    t[t.COL1ROW0 = 4] = "COL1ROW0";
    t[t.COL1ROW1 = 5] = "COL1ROW1";
    t[t.COL1ROW2 = 6] = "COL1ROW2";
    t[t.COL1ROW3 = 7] = "COL1ROW3";
    t[t.COL2ROW0 = 8] = "COL2ROW0";
    t[t.COL2ROW1 = 9] = "COL2ROW1";
    t[t.COL2ROW2 = 10] = "COL2ROW2";
    t[t.COL2ROW3 = 11] = "COL2ROW3";
    t[t.COL3ROW0 = 12] = "COL3ROW0";
    t[t.COL3ROW1 = 13] = "COL3ROW1";
    t[t.COL3ROW2 = 14] = "COL3ROW2";
    t[t.COL3ROW3 = 15] = "COL3ROW3";
  }(Cn || (Cn = {}));
  const Un = 45 * Math.PI / 180;
  const Nn = 1;
  const Fn = 0.1;
  const jn = 500;
  const zn = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  class Vn extends we {
    static get IDENTITY() {
      return function () {
        if (!Wn) {
          Wn = new Vn();
          Object.freeze(Wn);
        }
        return Wn;
      }();
    }
    static get ZERO() {
      return function () {
        if (!Gn) {
          Gn = new Vn([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
          Object.freeze(Gn);
        }
        return Gn;
      }();
    }
    get ELEMENTS() {
      return 16;
    }
    get RANK() {
      return 4;
    }
    get INDICES() {
      return Cn;
    }
    constructor(t) {
      super(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      if (arguments.length === 1 && Array.isArray(t)) {
        this.copy(t);
      } else {
        this.identity();
      }
    }
    copy(t) {
      this[0] = t[0];
      this[1] = t[1];
      this[2] = t[2];
      this[3] = t[3];
      this[4] = t[4];
      this[5] = t[5];
      this[6] = t[6];
      this[7] = t[7];
      this[8] = t[8];
      this[9] = t[9];
      this[10] = t[10];
      this[11] = t[11];
      this[12] = t[12];
      this[13] = t[13];
      this[14] = t[14];
      this[15] = t[15];
      return this.check();
    }
    set(t, e, n, r, i, o, a, s, u, h, c, l, f, d, p, v) {
      this[0] = t;
      this[1] = e;
      this[2] = n;
      this[3] = r;
      this[4] = i;
      this[5] = o;
      this[6] = a;
      this[7] = s;
      this[8] = u;
      this[9] = h;
      this[10] = c;
      this[11] = l;
      this[12] = f;
      this[13] = d;
      this[14] = p;
      this[15] = v;
      return this.check();
    }
    setRowMajor(t, e, n, r, i, o, a, s, u, h, c, l, f, d, p, v) {
      this[0] = t;
      this[1] = i;
      this[2] = u;
      this[3] = f;
      this[4] = e;
      this[5] = o;
      this[6] = h;
      this[7] = d;
      this[8] = n;
      this[9] = a;
      this[10] = c;
      this[11] = p;
      this[12] = r;
      this[13] = s;
      this[14] = l;
      this[15] = v;
      return this.check();
    }
    toRowMajor(t) {
      t[0] = this[0];
      t[1] = this[4];
      t[2] = this[8];
      t[3] = this[12];
      t[4] = this[1];
      t[5] = this[5];
      t[6] = this[9];
      t[7] = this[13];
      t[8] = this[2];
      t[9] = this[6];
      t[10] = this[10];
      t[11] = this[14];
      t[12] = this[3];
      t[13] = this[7];
      t[14] = this[11];
      t[15] = this[15];
      return t;
    }
    identity() {
      return this.copy(zn);
    }
    fromObject(t) {
      return this.check();
    }
    fromQuaternion(t) {
      Ye(this, t);
      return this.check();
    }
    frustum(t) {
      const {
        left: e,
        right: n,
        bottom: r,
        top: i,
        near: o = Fn,
        far: a = jn
      } = t;
      if (a === 1 / 0) {
        (function (t, e, n, r, i, o) {
          const a = 2 * o / (n - e);
          const s = 2 * o / (i - r);
          const u = (n + e) / (n - e);
          const h = (i + r) / (i - r);
          const c = -1;
          const l = -1;
          const f = -2 * o;
          t[0] = a;
          t[1] = 0;
          t[2] = 0;
          t[3] = 0;
          t[4] = 0;
          t[5] = s;
          t[6] = 0;
          t[7] = 0;
          t[8] = u;
          t[9] = h;
          t[10] = c;
          t[11] = l;
          t[12] = 0;
          t[13] = 0;
          t[14] = f;
          t[15] = 0;
        })(this, e, n, r, i, o);
      } else {
        Xe(this, e, n, r, i, o, a);
      }
      return this.check();
    }
    lookAt(t) {
      const {
        eye: e,
        center: n = [0, 0, 0],
        up: r = [0, 1, 0]
      } = t;
      tn(this, e, n, r);
      return this.check();
    }
    ortho(t) {
      const {
        left: e,
        right: n,
        bottom: r,
        top: i,
        near: o = Fn,
        far: a = jn
      } = t;
      $e(this, e, n, r, i, o, a);
      return this.check();
    }
    orthographic(t) {
      const {
        fovy: e = Un,
        aspect: n = Nn,
        focalDistance: r = 1,
        near: i = Fn,
        far: o = jn
      } = t;
      Hn(e);
      const a = e / 2;
      const s = r * Math.tan(a);
      const u = s * n;
      return this.ortho({
        left: -u,
        right: u,
        bottom: -s,
        top: s,
        near: i,
        far: o
      });
    }
    perspective(t) {
      const {
        fovy: e = 45 * Math.PI / 180,
        aspect: n = 1,
        near: r = 0.1,
        far: i = 500
      } = t;
      Hn(e);
      Qe(this, e, n, r, i);
      return this.check();
    }
    determinant() {
      return ke(this);
    }
    getScale(t = [0, 0, 0]) {
      t[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
      t[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);
      t[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
      return t;
    }
    getTranslation(t = [0, 0, 0]) {
      t[0] = this[12];
      t[1] = this[13];
      t[2] = this[14];
      return t;
    }
    getRotation(t, e) {
      t = t || [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      e = e || [0, 0, 0];
      const n = this.getScale(e);
      const r = 1 / n[0];
      const i = 1 / n[1];
      const o = 1 / n[2];
      t[0] = this[0] * r;
      t[1] = this[1] * i;
      t[2] = this[2] * o;
      t[3] = 0;
      t[4] = this[4] * r;
      t[5] = this[5] * i;
      t[6] = this[6] * o;
      t[7] = 0;
      t[8] = this[8] * r;
      t[9] = this[9] * i;
      t[10] = this[10] * o;
      t[11] = 0;
      t[12] = 0;
      t[13] = 0;
      t[14] = 0;
      t[15] = 1;
      return t;
    }
    getRotationMatrix3(t, e) {
      t = t || [0, 0, 0, 0, 0, 0, 0, 0, 0];
      e = e || [0, 0, 0];
      const n = this.getScale(e);
      const r = 1 / n[0];
      const i = 1 / n[1];
      const o = 1 / n[2];
      t[0] = this[0] * r;
      t[1] = this[1] * i;
      t[2] = this[2] * o;
      t[3] = this[4] * r;
      t[4] = this[5] * i;
      t[5] = this[6] * o;
      t[6] = this[8] * r;
      t[7] = this[9] * i;
      t[8] = this[10] * o;
      return t;
    }
    transpose() {
      Le(this, this);
      return this.check();
    }
    invert() {
      Be(this, this);
      return this.check();
    }
    multiplyLeft(t) {
      Ue(this, t, this);
      return this.check();
    }
    multiplyRight(t) {
      Ue(this, this, t);
      return this.check();
    }
    rotateX(t) {
      ze(this, this, t);
      return this.check();
    }
    rotateY(t) {
      Ve(this, this, t);
      return this.check();
    }
    rotateZ(t) {
      Ge(this, this, t);
      return this.check();
    }
    rotateXYZ(t) {
      return this.rotateX(t[0]).rotateY(t[1]).rotateZ(t[2]);
    }
    rotateAxis(t, e) {
      je(this, this, t, e);
      return this.check();
    }
    scale(t) {
      Fe(this, this, Array.isArray(t) ? t : [t, t, t]);
      return this.check();
    }
    translate(t) {
      Ne(this, this, t);
      return this.check();
    }
    transform(t, e) {
      return t.length === 4 ? (dt(e = En(e || [0, 0, 0, 0], t, this), 4), e) : this.transformAsPoint(t, e);
    }
    transformAsPoint(t, e) {
      const {
        length: n
      } = t;
      let r;
      switch (n) {
        case 2:
          r = Ct(e || [0, 0], t, this);
          break;
        case 3:
          r = ee(e || [0, 0, 0], t, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      dt(r, t.length);
      return r;
    }
    transformAsVector(t, e) {
      let n;
      switch (t.length) {
        case 2:
          n = function (t, e, n) {
            const r = e[0];
            const i = e[1];
            const o = n[3] * r + n[7] * i || 1;
            t[0] = (n[0] * r + n[4] * i) / o;
            t[1] = (n[1] * r + n[5] * i) / o;
            return t;
          }(e || [0, 0], t, this);
          break;
        case 3:
          n = Nt(e || [0, 0, 0], t, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      dt(n, t.length);
      return n;
    }
    transformPoint(t, e) {
      return this.transformAsPoint(t, e);
    }
    transformVector(t, e) {
      return this.transformAsPoint(t, e);
    }
    transformDirection(t, e) {
      return this.transformAsVector(t, e);
    }
    makeRotationX(t) {
      return this.identity().rotateX(t);
    }
    makeTranslation(t, e, n) {
      return this.identity().translate([t, e, n]);
    }
  }
  let Gn;
  let Wn;
  function Hn(t) {
    if (t > 2 * Math.PI) {
      throw Error("expected radians");
    }
  }
  function Zn() {
    var t = new mt(4);
    if (mt != Float32Array) {
      t[0] = 0;
      t[1] = 0;
      t[2] = 0;
    }
    t[3] = 1;
    return t;
  }
  function qn(t) {
    t[0] = 0;
    t[1] = 0;
    t[2] = 0;
    t[3] = 1;
    return t;
  }
  function Yn(t, e, n) {
    n *= 0.5;
    var r = Math.sin(n);
    t[0] = r * e[0];
    t[1] = r * e[1];
    t[2] = r * e[2];
    t[3] = Math.cos(n);
    return t;
  }
  function Xn(t, e, n) {
    var r = e[0];
    var i = e[1];
    var o = e[2];
    var a = e[3];
    var s = n[0];
    var u = n[1];
    var h = n[2];
    var c = n[3];
    t[0] = r * c + a * s + i * h - o * u;
    t[1] = i * c + a * u + o * s - r * h;
    t[2] = o * c + a * h + r * u - i * s;
    t[3] = a * c - r * s - i * u - o * h;
    return t;
  }
  function Kn(t, e) {
    var n = e[0];
    var r = e[1];
    var i = e[2];
    var o = e[3];
    var a = Math.sqrt(n * n + r * r + i * i);
    var s = Math.exp(o);
    var u = a > 0 ? s * Math.sin(a) / a : 0;
    t[0] = n * u;
    t[1] = r * u;
    t[2] = i * u;
    t[3] = s * Math.cos(a);
    return t;
  }
  function Qn(t, e) {
    var n = e[0];
    var r = e[1];
    var i = e[2];
    var o = e[3];
    var a = Math.sqrt(n * n + r * r + i * i);
    var s = a > 0 ? Math.atan2(a, o) / a : 0;
    t[0] = n * s;
    t[1] = r * s;
    t[2] = i * s;
    t[3] = 0.5 * Math.log(n * n + r * r + i * i + o * o);
    return t;
  }
  function Jn(t, e, n, r) {
    var i;
    var o;
    var a;
    var s;
    var u;
    var h = e[0];
    var c = e[1];
    var l = e[2];
    var f = e[3];
    var d = n[0];
    var p = n[1];
    var v = n[2];
    var m = n[3];
    if ((o = h * d + c * p + l * v + f * m) < 0) {
      o = -o;
      d = -d;
      p = -p;
      v = -v;
      m = -m;
    }
    if (1 - o > vt) {
      i = Math.acos(o);
      a = Math.sin(i);
      s = Math.sin((1 - r) * i) / a;
      u = Math.sin(r * i) / a;
    } else {
      s = 1 - r;
      u = r;
    }
    t[0] = s * h + u * d;
    t[1] = s * c + u * p;
    t[2] = s * l + u * v;
    t[3] = s * f + u * m;
    return t;
  }
  function $n(t, e) {
    var n;
    var r = e[0] + e[4] + e[8];
    if (r > 0) {
      n = Math.sqrt(r + 1);
      t[3] = 0.5 * n;
      n = 0.5 / n;
      t[0] = (e[5] - e[7]) * n;
      t[1] = (e[6] - e[2]) * n;
      t[2] = (e[1] - e[3]) * n;
    } else {
      var i = 0;
      if (e[4] > e[0]) {
        i = 1;
      }
      if (e[8] > e[3 * i + i]) {
        i = 2;
      }
      var o = (i + 1) % 3;
      var a = (i + 2) % 3;
      n = Math.sqrt(e[3 * i + i] - e[3 * o + o] - e[3 * a + a] + 1);
      t[i] = 0.5 * n;
      n = 0.5 / n;
      t[3] = (e[3 * o + a] - e[3 * a + o]) * n;
      t[o] = (e[3 * o + i] + e[3 * i + o]) * n;
      t[a] = (e[3 * a + i] + e[3 * i + a]) * n;
    }
    return t;
  }
  function tr(t, e, n, r) {
    var i = 0.5 * Math.PI / 180;
    e *= i;
    n *= i;
    r *= i;
    var o = Math.sin(e);
    var a = Math.cos(e);
    var s = Math.sin(n);
    var u = Math.cos(n);
    var h = Math.sin(r);
    var c = Math.cos(r);
    t[0] = o * u * c - a * s * h;
    t[1] = a * s * c + o * u * h;
    t[2] = a * u * h - o * s * c;
    t[3] = a * u * c + o * s * h;
    return t;
  }
  var er;
  var nr;
  var rr;
  var ir;
  var or;
  var ar;
  var sr = un;
  var ur = hn;
  var hr = cn;
  var cr = ln;
  var lr = fn;
  var fr = Xn;
  var dr = mn;
  var pr = Mn;
  var vr = wn;
  var mr = _n;
  var gr = mr;
  var yr = xn;
  var _r = yr;
  var xr = bn;
  var br = Tn;
  var Mr = An;
  er = Ft();
  nr = Vt(1, 0, 0);
  rr = Vt(0, 1, 0);
  var wr = function (t, e, n) {
    var r = $t(e, n);
    return r < -0.999999 ? (te(er, nr, e), pe(er) < 0.000001 && te(er, rr, e), Jt(er, er), Yn(t, er, Math.PI), t) : r > 0.999999 ? (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t) : (te(er, e, n), t[0] = er[0], t[1] = er[1], t[2] = er[2], t[3] = 1 + r, xr(t, t));
  };
  ir = Zn();
  or = Zn();
  var Er = function (t, e, n, r, i, o) {
    Jn(ir, e, i, o);
    Jn(or, n, r, o);
    Jn(t, ir, or, 2 * o * (1 - o));
    return t;
  };
  ar = Ee();
  var Tr = function (t, e, n, r) {
    ar[0] = n[0];
    ar[3] = n[1];
    ar[6] = n[2];
    ar[1] = r[0];
    ar[4] = r[1];
    ar[7] = r[2];
    ar[2] = -e[0];
    ar[5] = -e[1];
    ar[8] = -e[2];
    return xr(t, $n(t, ar));
  };
  var Ar = Object.freeze({
    __proto__: null,
    create: Zn,
    identity: qn,
    setAxisAngle: Yn,
    getAxisAngle: function (t, e) {
      var n = 2 * Math.acos(e[3]);
      var r = Math.sin(n / 2);
      if (r > vt) {
        t[0] = e[0] / r;
        t[1] = e[1] / r;
        t[2] = e[2] / r;
      } else {
        t[0] = 1;
        t[1] = 0;
        t[2] = 0;
      }
      return n;
    },
    getAngle: function (t, e) {
      var n = pr(t, e);
      return Math.acos(2 * n * n - 1);
    },
    multiply: Xn,
    rotateX: function (t, e, n) {
      n *= 0.5;
      var r = e[0];
      var i = e[1];
      var o = e[2];
      var a = e[3];
      var s = Math.sin(n);
      var u = Math.cos(n);
      t[0] = r * u + a * s;
      t[1] = i * u + o * s;
      t[2] = o * u - i * s;
      t[3] = a * u - r * s;
      return t;
    },
    rotateY: function (t, e, n) {
      n *= 0.5;
      var r = e[0];
      var i = e[1];
      var o = e[2];
      var a = e[3];
      var s = Math.sin(n);
      var u = Math.cos(n);
      t[0] = r * u - o * s;
      t[1] = i * u + a * s;
      t[2] = o * u + r * s;
      t[3] = a * u - i * s;
      return t;
    },
    rotateZ: function (t, e, n) {
      n *= 0.5;
      var r = e[0];
      var i = e[1];
      var o = e[2];
      var a = e[3];
      var s = Math.sin(n);
      var u = Math.cos(n);
      t[0] = r * u + i * s;
      t[1] = i * u - r * s;
      t[2] = o * u + a * s;
      t[3] = a * u - o * s;
      return t;
    },
    calculateW: function (t, e) {
      var n = e[0];
      var r = e[1];
      var i = e[2];
      t[0] = n;
      t[1] = r;
      t[2] = i;
      t[3] = Math.sqrt(Math.abs(1 - n * n - r * r - i * i));
      return t;
    },
    exp: Kn,
    ln: Qn,
    pow: function (t, e, n) {
      Qn(t, e);
      dr(t, t, n);
      Kn(t, t);
      return t;
    },
    slerp: Jn,
    random: function (t) {
      var e = gt();
      var n = gt();
      var r = gt();
      var i = Math.sqrt(1 - e);
      var o = Math.sqrt(e);
      t[0] = i * Math.sin(2 * Math.PI * n);
      t[1] = i * Math.cos(2 * Math.PI * n);
      t[2] = o * Math.sin(2 * Math.PI * r);
      t[3] = o * Math.cos(2 * Math.PI * r);
      return t;
    },
    invert: function (t, e) {
      var n = e[0];
      var r = e[1];
      var i = e[2];
      var o = e[3];
      var a = n * n + r * r + i * i + o * o;
      var s = a ? 1 / a : 0;
      t[0] = -n * s;
      t[1] = -r * s;
      t[2] = -i * s;
      t[3] = o * s;
      return t;
    },
    conjugate: function (t, e) {
      t[0] = -e[0];
      t[1] = -e[1];
      t[2] = -e[2];
      t[3] = e[3];
      return t;
    },
    fromMat3: $n,
    fromEuler: tr,
    str: function (t) {
      return "quat(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")";
    },
    clone: sr,
    fromValues: ur,
    copy: hr,
    set: cr,
    add: lr,
    mul: fr,
    scale: dr,
    dot: pr,
    lerp: vr,
    length: mr,
    len: gr,
    squaredLength: yr,
    sqrLen: _r,
    normalize: xr,
    exactEquals: br,
    equals: Mr,
    rotationTo: wr,
    sqlerp: Er,
    setAxes: Tr
  });
  function Cr(t) {
    Cr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (t) {
      return typeof t;
    } : function (t) {
      return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
    };
    return Cr(t);
  }
  var Rr = function (t) {
    return Object.prototype.toString.call(t) === "[object String]";
  };
  var Sr = function (t) {
    var e = Object.prototype.toString.call(t) === "[object Function]";
    var n = Object.prototype.toString.call(t) === "[object AsyncFunction]";
    return e || n;
  };
  var Pr = 365611;
  function Dr(t, e) {
    this.type = t;
    this.returnValue = true;
    this.target = e || null;
    this.currentTarget = null;
  }
  var Or = function () {
    function t() {
      this.__listeners = undefined;
    }
    var e = t.prototype;
    e.on = function () {
      for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) {
        e[n] = arguments[n];
      }
      this.alias("addEventListener")(e);
    };
    e.off = function () {
      for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) {
        e[n] = arguments[n];
      }
      this.alias("removeEventListener")(e);
    };
    e.emit = function () {
      for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) {
        e[n] = arguments[n];
      }
      this.alias("dispatchEvent")(e);
    };
    e.addEventListener = function (t, e, n) {
      if (Sr(e)) {
        var r;
        if (!this.__listeners) {
          this.__listeners = {};
        }
        var i = this.__listeners;
        if (typeof n == "string" && n) {
          if (/[^\w-]/.test(n)) {
            throw "nonstandard key:" + n;
          }
          e.hashCode = n;
          r = n;
        }
        if (!t.startsWith("on")) {
          t = "on" + t;
        }
        if (Cr(i[t]) !== "object") {
          i[t] = {};
        }
        r = r || (++Pr).toString();
        e.hashCode = r;
        i[t][r] = e;
      }
    };
    e.removeEventListener = function (t, e) {
      if (Sr(e)) {
        e = e.hashCode;
      } else if (!Rr(e)) {
        return;
      }
      if (!this.__listeners) {
        this.__listeners = {};
      }
      if (!t.startsWith("on")) {
        t = "on" + t;
      }
      var n = this.__listeners;
      if (n[t] && n[t][e]) {
        delete n[t][e];
      }
    };
    e.dispatchEvent = function (t, e) {
      if (Rr(t)) {
        t = new Dr(t);
      }
      if (!this.__listeners) {
        this.__listeners = {};
      }
      var n = this.__listeners;
      var r = t.type;
      var i = e || t;
      t.target = t.target || this;
      t.currentTarget = this;
      if (r.indexOf("on") !== 0) {
        r = "on".concat(r);
      }
      if (Sr(n[r])) {
        n[r].call(this, i);
      }
      if (Cr(n[r]) === "object") {
        for (var o in n[r]) {
          if (Object.prototype.hasOwnProperty.call(n[r], o)) {
            n[r][o].call(this, i);
          }
        }
      }
      return t.returnValue;
    };
    e.alias = function (t) {
      var e = this;
      return function (n) {
        return e[t].apply(e, n);
      };
    };
    return t;
  }();
  function Ir(t, e) {
    var n = e[2];
    var r = e[0];
    var i = e[1];
    var o = e[3];
    var a = o * o;
    var s = n * n;
    var u = r * r;
    var h = i * i;
    var c = i * n - r * o;
    var l = 0.4999999;
    if (c < -l) {
      t[0] = Math.PI / 2;
      t[1] = 2 * Math.atan2(i, o);
      t[2] = 0;
    } else if (c > l) {
      t[0] = -Math.PI / 2;
      t[1] = 2 * Math.atan2(i, o);
      t[2] = 0;
    } else {
      t[0] = Math.asin(-2 * (n * i - r * o));
      t[1] = Math.atan2(2 * (n * r + i * o), s - u - h + a);
      t[2] = Math.atan2(2 * (r * i + n * o), -s - u + h + a);
    }
    return t;
  }
  var Lr = function () {
    function t() {
      var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : t.DefaultOrder;
      this.isEuler = true;
      this._x = undefined;
      this._y = undefined;
      this._z = undefined;
      this._order = undefined;
      this._onChangeCallback = undefined;
      this._x = e;
      this._y = n;
      this._z = r;
      this._order = i;
      this._onChangeCallback = function () {};
    }
    var e = t.prototype;
    e.set = function (t, e, n) {
      var r = !(arguments.length > 3 && arguments[3] !== undefined) || arguments[3];
      this._x = t;
      this._y = e;
      this._z = n;
      if (r) {
        this._onChangeCallback();
      }
      return this;
    };
    e.clone = function () {
      return new t(this._x, this._y, this._z, this._order);
    };
    e.copy = function (t) {
      return t.isEuler ? (this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this) : this;
    };
    e.equals = function (t) {
      return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
    };
    e.toVector3 = function () {
      return Vt(this._x, this._y, this._z);
    };
    e.onChange = function (t) {
      if (typeof t == "function") {
        this._onChangeCallback = t;
      }
    };
    o(t, [{
      key: "x",
      get: function () {
        return this._x;
      },
      set: function (t) {
        this._x = t;
        this._onChangeCallback();
      }
    }, {
      key: "y",
      get: function () {
        return this._y;
      },
      set: function (t) {
        this._y = t;
        this._onChangeCallback();
      }
    }, {
      key: "z",
      get: function () {
        return this._z;
      },
      set: function (t) {
        this._z = t;
        this._onChangeCallback();
      }
    }, {
      key: "order",
      get: function () {
        return this._order;
      },
      set: function (t) {
        this._order = t;
        this._onChangeCallback();
      }
    }]);
    return t;
  }();
  function Br() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (t) {
      var e = 16 * Math.random() | 0;
      return (t === "x" ? e : 3 & e | 8).toString(16);
    });
  }
  Lr.DefaultOrder = "XYZ";
  var kr = function (t) {
    return 180 * t / Math.PI;
  };
  var Ur = function (t) {
    function e() {
      var n;
      (n = t.call(this) || this).isObject3D = true;
      n.uuid = Br();
      n.name = "";
      n.parent = null;
      n.children = [];
      n.visible = true;
      n.position = Ft();
      n.rotation = new Lr();
      n.scale = Vt(1, 1, 1);
      n.quaternion = Zn();
      n.up = jt(e.DefaultUp);
      n.modelMatrix = Pe();
      n.worldMatrix = Pe();
      n.modelMatrixNeedUpdate = false;
      n.worldMatrixNeedsUpdate = false;
      n.rotation.onChange(function () {
        n.modelMatrixNeedUpdate = true;
      });
      return n;
    }
    c(e, t);
    var n = e.prototype;
    n.rotateX = function (t) {
      this.rotation.x = t;
    };
    n.rotateY = function (t) {
      this.rotation.y = t;
    };
    n.rotateZ = function (t) {
      this.rotation.z = t;
    };
    n.translate = function (t, e, n) {
      var r = Vt(t, e, n);
      this.position = Wt(this.position, this.position, r);
      this.modelMatrixNeedUpdate = true;
      return this;
    };
    n.setPosition = function (t, e, n) {
      var r = Vt(t, e, n);
      if (!ue(this.position, r)) {
        this.position = r;
        this.modelMatrixNeedUpdate = true;
      }
      return this;
    };
    n.lookAt = function (t, e, n) {
      var r = this.up;
      var i = this.position;
      var o = Vt(t, e, n);
      var a = en(Pe(), i, o, r);
      var s = Ze(Zn(), a);
      var u = Ir(Ft(), s);
      this.rotation.set(kr(u[0]), kr(u[1]), kr(u[2]));
    };
    n.setVisible = function (t) {
      var e = arguments.length > 1 && arguments[1] !== undefined && arguments[1];
      if (this.visible !== t && (this.visible = t, e)) {
        for (var n = 0, r = this.children.length; n < r; n++) {
          this.children[n].setVisible(t, e);
        }
      }
    };
    n.setScale = function (t, e, n) {
      var r = Vt(t, e, n);
      if (!ue(this.scale, r)) {
        this.scale = r;
        this.modelMatrixNeedUpdate = true;
      }
      return this;
    };
    n.updateMatrix = function () {
      Ie(this.modelMatrix);
      qn(this.quaternion);
      tr(this.quaternion, this.rotation.x, this.rotation.y, this.rotation.z);
      qe(this.modelMatrix, this.quaternion, this.position, this.scale);
      this.modelMatrixNeedUpdate = false;
      this.worldMatrixNeedsUpdate = true;
    };
    n.updateWorldMatrix = function () {
      var t = arguments.length > 0 && arguments[0] !== undefined && arguments[0];
      if (!(this.modelMatrixNeedUpdate !== true && t !== true)) {
        this.updateMatrix();
      }
      if (this.worldMatrixNeedsUpdate === true) {
        if (this.parent) {
          Ue(this.worldMatrix, this.parent.worldMatrix, this.modelMatrix);
        } else {
          Oe(this.worldMatrix, this.modelMatrix);
        }
        this.worldMatrixNeedsUpdate = false;
        t = true;
      }
      for (var e = 0, n = this.children.length; e < n; e++) {
        this.children[e].updateWorldMatrix(t);
      }
    };
    n.add = function (t) {
      if (t === this) {
        console.error("object3D.add: object can't be added as a child of itself. ==> ".concat(t));
        return this;
      }
      if (t instanceof Array) {
        for (var e = 0, n = t.length; e < n; e++) {
          this.add(t[e]);
        }
        return this;
      }
      if (t && t.isObject3D) {
        if (t.parent !== null) {
          t.parent.remove(t);
        }
        t.parent = this;
        this.children.push(t);
      } else {
        console.error("Object3D.add: object not an instance of Object3D.", t);
      }
      return this;
    };
    n.remove = function (t) {
      if (t instanceof Array) {
        for (var e = 0, n = t.length; e < n; e++) {
          this.remove(t[e]);
        }
        return this;
      }
      var r = this.children.indexOf(t);
      if (r !== -1) {
        t.parent = null;
        this.children.splice(r, 1);
      }
      return this;
    };
    n.traverse = function (t) {
      t(this);
      if (this.children && this.children.length > 0) {
        this.children.forEach(function (e) {
          e.traverse(t);
        });
      }
    };
    n.clone = function () {
      var t = arguments.length > 0 && arguments[0] !== undefined && arguments[0];
      var n = new e();
      n.up = jt(this.up);
      n.scale = jt(this.scale);
      n.position = jt(this.position);
      n.rotation = this.rotation.clone();
      n.quaternion = sr(this.quaternion);
      n.modelMatrix = De(this.modelMatrix);
      n.worldMatrix = De(this.worldMatrix);
      n.visible = this.visible;
      if (this.children.length && t) {
        for (var r = 0, i = this.children.length; r < i; r++) {
          n.add(this.children[r].clone());
        }
      }
      return n;
    };
    n.raycast = function (t) {
      return null;
    };
    return e;
  }(Or);
  Ur.DefaultUp = Vt(0, 1, 0);
  var Nr = function () {
    function t(t, e) {
      this.isBox = true;
      this.min = undefined;
      this.max = undefined;
      this.min = t !== undefined ? t : Vt(1 / 0, 1 / 0, 1 / 0);
      this.max = e !== undefined ? e : Vt(-1 / 0, -1 / 0, -1 / 0);
    }
    var e = t.prototype;
    e.set = function (t, e) {
      Gt(this.min, t);
      Gt(this.max, e);
      return this;
    };
    e.setFromBufferAttribute = function (t) {
      for (var e = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, o = -1 / 0, a = -1 / 0, s = t.array, u = t.count, h = t.itemSize, c = 0; c < u; c++) {
        var l = s[c * h];
        var f = s[c * h + 1];
        var d = s[c * h + 2];
        if (l < e) {
          e = l;
        }
        if (f < n) {
          n = f;
        }
        if (d < r) {
          r = d;
        }
        if (l > i) {
          i = l;
        }
        if (f > o) {
          o = f;
        }
        if (d > a) {
          a = d;
        }
      }
      var p = Vt(e, n, r);
      var v = Vt(i, o, a);
      this.set(p, v);
      return this;
    };
    e.getCenter = function () {
      return this.isInvalid() ? Ft() : Vt((this.max[0] + this.min[0]) / 2, (this.max[1] + this.min[1]) / 2, (this.max[2] + this.min[2]) / 2);
    };
    e.isInvalid = function () {
      return this.max[0] < this.min[0] || this.max[1] < this.min[1] || this.max[2] < this.min[2];
    };
    return t;
  }();
  var Fr = function () {
    function t(e, n, r) {
      var i = arguments.length > 3 && arguments[3] !== undefined && arguments[3];
      this.isBufferAttribute = true;
      this.name = "";
      this.type = undefined;
      this.array = undefined;
      this.itemSize = undefined;
      this.count = undefined;
      this.normalized = undefined;
      this.usage = undefined;
      this.needUpdate = undefined;
      if (Array.isArray(e)) {
        throw new TypeError("BufferAttribute: array should be a Typed Array.");
      }
      this.name = "BufferAttribute";
      this.array = e;
      this.itemSize = n;
      this.count = e !== undefined ? e.length / n : 0;
      this.normalized = i === true;
      this.usage = 35044;
      this.needUpdate = true;
      if (r === undefined) {
        var o = this.array;
        this.type = t.FLOAT;
        if (o instanceof Int8Array) {
          this.type = t.BYTE;
        } else if (o instanceof Uint8Array) {
          this.type = t.UNSIGNED_BYTE;
        } else if (o instanceof Int16Array) {
          this.type = t.SHORT;
        } else if (o instanceof Uint16Array) {
          this.type = t.UNSIGNED_SHORT;
        } else if (o instanceof Int32Array) {
          this.type = t.INT;
        } else if (o instanceof Uint32Array) {
          this.type = t.UNSIGNED_INT;
        }
      } else {
        this.type = r;
      }
    }
    t.isBufferAttribute = function (e) {
      var n = false;
      if (e && e instanceof t) {
        n = true;
      }
      return n;
    };
    var e = t.prototype;
    e.setUsage = function (t) {
      this.usage = t;
      return this;
    };
    e.setArray = function (t) {
      this.array.set(t);
      return this;
    };
    return t;
  }();
  Fr.BYTE = 5120;
  Fr.UNSIGNED_BYTE = 5121;
  Fr.SHORT = 5122;
  Fr.UNSIGNED_SHORT = 5123;
  Fr.INT = 5124;
  Fr.UNSIGNED_INT = 5125;
  Fr.FLOAT = 5126;
  var jr = function (t) {
    function e(e, n, r, i) {
      var o;
      (o = t.call(this, new Uint8Array(e), n, r, i) || this).name = "Uint8BufferAttribute";
      return o;
    }
    c(e, t);
    return e;
  }(Fr);
  var zr = function (t) {
    function e(e, n, r, i) {
      var o;
      (o = t.call(this, new Uint16Array(e), n, r, i) || this).name = "Uint16BufferAttribute";
      return o;
    }
    c(e, t);
    return e;
  }(Fr);
  var Vr = function (t) {
    function e(e, n, r, i) {
      var o;
      (o = t.call(this, new Uint32Array(e), n, r, i) || this).name = "Uint32BufferAttribute";
      return o;
    }
    c(e, t);
    return e;
  }(Fr);
  var Gr = function (t) {
    function e(e, n, r, i) {
      var o;
      (o = t.call(this, new Float32Array(e), n, r, i) || this).name = "Float32ArrayAttribute";
      return o;
    }
    c(e, t);
    return e;
  }(Fr);
  var Wr = function (t) {
    function e(e, n, r, i) {
      var o;
      if (Array.isArray(e)) {
        var a = function (t) {
          for (var e, n = Number.MAX_VALUE, r = -Number.MAX_VALUE, i = t.length - 1; i >= 0; i--) {
            if (n > (e = t[i])) {
              n = e;
            }
            if (r < e) {
              r = e;
            }
          }
          return {
            min: n,
            max: r
          };
        }(e);
        o = new (a.max > 65535 ? Uint32Array : Uint16Array)(e);
      } else {
        o = e;
      }
      return t.call(this, o, n, r, i) || this;
    }
    c(e, t);
    return e;
  }(Fr);
  var Hr = 0;
  var Zr = function (t) {
    function e() {
      for (var e, n = arguments.length, r = new Array(n), i = 0; i < n; i++) {
        r[i] = arguments[i];
      }
      (e = t.call.apply(t, [this].concat(r)) || this).id = Hr++;
      e.uuid = Br();
      e.name = "";
      e.type = "BufferGeometry";
      e.indexes = null;
      e.attributes = {};
      e.__webglInit = false;
      e.groupsNeedUpdate = false;
      e.boundingBox = null;
      return e;
    }
    c(e, t);
    var n = e.prototype;
    n.getIndexes = function () {
      return this.indexes;
    };
    n.getCenter = function () {
      this.computeBoundingBox();
      return this.boundingBox ? this.boundingBox.getCenter() : undefined;
    };
    n.setIndexes = function (t) {
      if (Array.isArray(t) || ArrayBuffer.isView(t)) {
        this.indexes = new Wr(t, 1);
      } else if (Wr.isBufferAttribute(t)) {
        this.indexes = t;
      }
      return this;
    };
    n.getAttribute = function (t) {
      return t ? this.attributes[t] : this.attributes;
    };
    n.setAttribute = function (t, e) {
      if (t && Fr.isBufferAttribute(e)) {
        this.attributes[t] = e;
      }
      return this;
    };
    n.deleteAttribute = function (t) {
      if (this.attributes[t]) {
        delete this.attributes[t];
      }
      return this;
    };
    n.computeBoundingBox = function () {
      if (this.boundingBox === null) {
        this.boundingBox = new Nr();
      }
      var t = this.attributes.position;
      if (t && t.isBufferAttribute) {
        this.boundingBox.setFromBufferAttribute(t);
      }
    };
    return e;
  }(Or);
  var qr = new be();
  var Yr = new be();
  var Xr = new be();
  var Kr = function (t) {
    function e(e, n) {
      var r;
      (r = t.call(this) || this).type = "Mesh";
      r.geometry = undefined;
      r.material = undefined;
      r.materialChanged = undefined;
      r.__webglInit = false;
      r.geometry = e !== undefined ? e : new Zr();
      r.material = n !== undefined ? n : null;
      r.materialChanged = false;
      return r;
    }
    c(e, t);
    var n = e.prototype;
    n.updateMaterial = function (t) {
      if (this.material && t.isMaterial && t.uuid !== this.material.uuid) {
        this.material = t;
        this.materialChanged = true;
      }
    };
    n.raycast = function (t) {
      var e = this.geometry;
      var n = e.indexes && e.indexes.array;
      var r = e.attributes.position.array;
      if (!n) {
        return null;
      }
      for (var i = 0; i < n.length; i += 3) {
        var o = 3 * n[i];
        var a = 3 * n[i + 1];
        var s = 3 * n[i + 2];
        var u = qr.set(r[o], r[o + 1], r[o + 2]).transform(this.worldMatrix);
        var h = Yr.set(r[a], r[a + 1], r[a + 2]).transform(this.worldMatrix);
        var c = Xr.set(r[s], r[s + 1], r[s + 2]).transform(this.worldMatrix);
        var l = t.intersectTriangle(u, h, c);
        if (l) {
          return {
            distance: l.distance,
            point: l.point,
            object: this
          };
        }
      }
      return null;
    };
    return e;
  }(Ur);
  var Qr = function (t) {
    function e() {
      for (var e, n = arguments.length, r = new Array(n), i = 0; i < n; i++) {
        r[i] = arguments[i];
      }
      (e = t.call.apply(t, [this].concat(r)) || this).type = "Scene";
      e.isScene = true;
      e.autoUpdate = true;
      return e;
    }
    c(e, t);
    var n = e.prototype;
    n.updateWorldMatrix = function () {
      var e = arguments.length > 0 && arguments[0] !== undefined && arguments[0];
      if (this.autoUpdate === true) {
        t.prototype.updateWorldMatrix.call(this, e);
      }
    };
    n.clone = function (n) {
      if (n === undefined) {
        n = new e();
      }
      t.prototype.clone.call(this, n);
      n.autoUpdate = this.autoUpdate;
      return n;
    };
    return e;
  }(Ur);
  var Jr = function (t) {
    function e() {
      var e;
      (e = t.call(this) || this).type = "Geometry";
      e.vertices = [];
      e.verticesBufferData = new Float32Array();
      e.indicesBufferData = new Uint16Array();
      e.uvtsBufferData = new Float32Array();
      e.groupsNeedUpdate = false;
      return e;
    }
    c(e, t);
    return e;
  }(Or);
  var $r = new be();
  var ti = new be();
  var ei = new be();
  var ni = new be();
  var ri = new be();
  var ii = function () {
    function t(t, e) {
      this.origin = undefined;
      this.direction = undefined;
      this.origin = t || new be();
      this.direction = e || new be(0, 0, -1);
    }
    var e = t.prototype;
    e.set = function (t, e) {
      this.origin.copy(t);
      this.direction.copy(e);
      return this;
    };
    e.setFromCamera = function (t, e) {
      var n = new be(e.position[0], e.position[1], e.position[2]);
      var r = new Vn().fromArray(e.projectionMatrix);
      var i = e.worldMatrix;
      var o = new Me(t[0], t[1], 0.5, 1).transform(r).transform(i);
      var a = o.x;
      var s = o.y;
      var u = o.z;
      var h = new be(a, s, u).sub(n).normalize();
      this.set(n, h);
    };
    e.getPointByLen = function (t, e) {
      var n = e !== undefined ? e : new be();
      n.copy(this.direction);
      n.scale(t);
      n.add(this.origin);
      return n;
    };
    e.intersectTriangle_Old = function (t, e, n) {
      var r;
      var i = arguments.length > 3 && arguments[3] !== undefined && arguments[3];
      var o = arguments.length > 4 ? arguments[4] : undefined;
      var a = $r.copy(e).subtract(t);
      var s = ti.copy(n).subtract(t);
      var u = ei.copy(a).cross(s);
      var h = ni.copy(this.origin).subtract(t);
      var c = this.direction.dot(u);
      if (c > 0) {
        if (i) {
          return null;
        }
        r = 1;
      } else {
        if (!(c < 0)) {
          return null;
        }
        r = -1;
        c = -c;
      }
      s.copy(new be().copy(h).cross(s));
      var l = r * this.direction.dot(s);
      if (l < 0) {
        return null;
      }
      var f = r * this.direction.dot(new be().copy(h).cross(a));
      if (f < 0) {
        return null;
      }
      if (l + f > c) {
        return null;
      }
      var d = -r * h.dot(u);
      return d < 0 ? null : this.getPointByLen(d / c, o);
    };
    e.intersectTriangle = function (t, e, n) {
      var r = arguments.length > 4 ? arguments[4] : undefined;
      var i = 0.000001;
      var o = $r.subVectors(e, t);
      var a = ti.subVectors(n, t);
      var s = ei.copy(this.direction).cross(a);
      var u = o.dot(s);
      if (u > -i && u < i) {
        return null;
      }
      var h = 1 / u;
      var c = ni.subVectors(this.origin, t);
      var l = h * c.dot(s);
      if (l < 0 || l > 1) {
        return null;
      }
      var f = ri.copy(c).cross(o);
      var d = h * this.direction.dot(f);
      if (d < 0 || l + d > 1) {
        return null;
      }
      var p = a.dot(f) * h;
      return p > i ? {
        distance: p,
        point: this.getPointByLen(p, r)
      } : null;
    };
    e.intersectSphere = function (t, e, n) {
      var r = new be().subtract(t, this.origin);
      var i = r.dot(this.direction);
      var o = r.dot(r) - i * i;
      var a = e * e;
      if (o > a) {
        return null;
      }
      var s = Math.sqrt(a - o);
      var u = i - s;
      var h = i + s;
      return u < 0 && h < 0 ? null : u < 0 ? this.getPointByLen(h, n) : this.getPointByLen(u, n);
    };
    return t;
  }();
  function oi(t, e) {
    var n = typeof Symbol != "undefined" && t[Symbol.iterator] || t["@@iterator"];
    if (!n) {
      if (Array.isArray(t) || (n = function (t, e) {
        if (!t) {
          return;
        }
        if (typeof t == "string") {
          return ai(t, e);
        }
        var n = Object.prototype.toString.call(t).slice(8, -1);
        if (n === "Object" && t.constructor) {
          n = t.constructor.name;
        }
        if (n === "Map" || n === "Set") {
          return Array.from(t);
        }
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
          return ai(t, e);
        }
      }(t)) || e && t && typeof t.length == "number") {
        if (n) {
          t = n;
        }
        var r = 0;
        var i = function () {};
        return {
          s: i,
          n: function () {
            return r >= t.length ? {
              done: true
            } : {
              done: false,
              value: t[r++]
            };
          },
          e: function (t) {
            throw t;
          },
          f: i
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var o;
    var a = true;
    var s = false;
    return {
      s: function () {
        n = n.call(t);
      },
      n: function () {
        var t = n.next();
        a = t.done;
        return t;
      },
      e: function (t) {
        s = true;
        o = t;
      },
      f: function () {
        try {
          if (!(a || n.return == null)) {
            n.return();
          }
        } finally {
          if (s) {
            throw o;
          }
        }
      }
    };
  }
  function ai(t, e) {
    if (e == null || e > t.length) {
      e = t.length;
    }
    for (var n = 0, r = new Array(e); n < e; n++) {
      r[n] = t[n];
    }
    return r;
  }
  var si = function () {
    function t(t, e, n, r) {
      this.ray = undefined;
      this.near = undefined;
      this.far = undefined;
      this.ray = new ii(t, e);
      this.near = n || 0;
      this.far = r || 1 / 0;
    }
    var e = t.prototype;
    e.set = function (t, e) {
      this.ray.set(t, e);
    };
    e.setFromCamera = function (t, e) {
      var n = new be(e.position[0], e.position[1], e.position[2]);
      var r = new Vn().fromArray(e.projectionMatrix).invert();
      var i = e.worldMatrix;
      var o = new Me(t[0], t[1], 0.5, 1).transform(r).transform(i);
      var a = o.x;
      var s = o.y;
      var u = o.z;
      var h = new be(a, s, u).sub(n).normalize();
      this.set(n, h);
    };
    e.pick = function (t) {
      var e;
      var n = this.ray;
      var r = [];
      var i = oi([].concat(t));
      try {
        for (i.s(); !(e = i.n()).done;) {
          var o = e.value.raycast(n);
          if (o) {
            r.push(o);
          }
        }
      } catch (t) {
        i.e(t);
      } finally {
        i.f();
      }
      r.sort(function (t, e) {
        return t.distance - e.distance;
      });
      return r;
    };
    return t;
  }();
  var ui = function (t) {
    function e(n) {
      var r;
      (r = t.call(this) || this).image = undefined;
      r.flipY = true;
      r.premultiplyAlpha = false;
      r.needsUpdate = true;
      r.glTexture = null;
      r.isTexture = true;
      r.gl = null;
      r.__textureInit = false;
      r.clone = function (t) {
        if (t === undefined) {
          t = new e();
        }
        t.image = r.image;
        t.flipY = r.flipY;
        return t;
      };
      r.destory = function () {
        r.emit("destory", r.glTexture);
      };
      r.destoryTexture = function () {
        if (r.glTexture && r.gl) {
          r.off("destory", r.destoryTexture);
          r.gl.deleteTexture(r.glTexture);
        }
      };
      if (n !== undefined) {
        r.image = n;
      }
      return r;
    }
    c(e, t);
    e.prototype.init = function (t) {
      if (this.__textureInit !== true) {
        this.gl = t;
        this.glTexture = t.createTexture();
        this.on("destory", this.destoryTexture);
        this.__textureInit = true;
      }
    };
    return e;
  }(Or);
  var hi = function (t) {
    function e(e) {
      var n;
      (n = t.call(this) || this).isCube = true;
      n.image = e || [];
      n.flipY = false;
      return n;
    }
    c(e, t);
    return e;
  }(ui);
  var ci = function () {
    function t(t, e, n) {
      var r = this;
      this.gl = undefined;
      this.maxTextureSize = undefined;
      this.maxTextures = undefined;
      this.usedTextureUnits = 0;
      this.getTextureUnit = function () {
        var t = r.usedTextureUnits;
        if (r.usedTextureUnits >= r.maxTextures) {
          r.usedTextureUnits = 0;
        } else {
          r.usedTextureUnits += 1;
        }
        return t;
      };
      this.resetUsedTextureUnits = function () {
        r.usedTextureUnits = 0;
      };
      this.setTexture = function (t) {
        var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        if (t instanceof hi) {
          r.setCubeTexture(t, e);
        } else {
          var n = r.gl;
          n.activeTexture(n.TEXTURE0 + e);
          if (t.needsUpdate) {
            t.init(n);
            r.uploadTexture(n, t);
          } else {
            n.bindTexture(n.TEXTURE_2D, t.glTexture);
          }
        }
      };
      this.setTextureForRenderTarget = function (t) {
        var e = r.gl;
        t.glTexture = e.createTexture();
        e.bindTexture(e.TEXTURE_2D, t.glTexture);
        e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, t.flipY);
        e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha);
        r.setTextureParameter(e);
        var n = e.RGBA;
        var i = e.RGBA;
        var o = e.UNSIGNED_BYTE;
        e.texImage2D(e.TEXTURE_2D, 0, n, t.width, t.height, 0, i, o, null);
      };
      this.uploadTexture = function (t, e) {
        e.init(t);
        t.bindTexture(t.TEXTURE_2D, e.glTexture);
        t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e.flipY);
        t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.premultiplyAlpha);
        r.setTextureParameter(t);
        t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, e.image);
        e.needsUpdate = false;
      };
      this.setTextureParameter = function (t) {
        t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE);
        t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE);
        t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.LINEAR);
        t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR);
      };
      this.gl = t;
      this.maxTextureSize = n;
      this.maxTextures = e;
    }
    t.prototype.setCubeTexture = function (t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var n = t.image;
      if (n.length !== 6) {
        throw new Error("[setCubeTexture] CubeTexture need six images, but get\n                ".concat(n.length, "\n            "));
      }
      var r = this.gl;
      if (t.needsUpdate) {
        t.init(r);
        r.activeTexture(r.TEXTURE0 + e);
        r.bindTexture(r.TEXTURE_CUBE_MAP, t.glTexture);
        r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, t.flipY);
        r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MAG_FILTER, r.LINEAR);
        r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MIN_FILTER, r.LINEAR);
        r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE);
        r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE);
        for (var i = 0; i < 6; i++) {
          var o = n[i];
          r.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, r.RGBA, r.RGBA, r.UNSIGNED_BYTE, o);
        }
        t.needsUpdate = false;
      } else {
        r.bindTexture(r.TEXTURE_CUBE_MAP, t.glTexture);
      }
    };
    return t;
  }();
  var li = n(function (t) {
    t.exports = function (t, e) {
      if (e == null || e > t.length) {
        e = t.length;
      }
      for (var n = 0, r = new Array(e); n < e; n++) {
        r[n] = t[n];
      }
      return r;
    };
    t.exports.__esModule = true;
    t.exports.default = t.exports;
  });
  e(li);
  var fi = n(function (t) {
    t.exports = function (t) {
      if (Array.isArray(t)) {
        return li(t);
      }
    };
    t.exports.__esModule = true;
    t.exports.default = t.exports;
  });
  e(fi);
  var di = n(function (t) {
    t.exports = function (t) {
      if (typeof Symbol != "undefined" && t[Symbol.iterator] != null || t["@@iterator"] != null) {
        return Array.from(t);
      }
    };
    t.exports.__esModule = true;
    t.exports.default = t.exports;
  });
  e(di);
  var pi = n(function (t) {
    t.exports = function (t, e) {
      if (t) {
        if (typeof t == "string") {
          return li(t, e);
        }
        var n = Object.prototype.toString.call(t).slice(8, -1);
        if (n === "Object" && t.constructor) {
          n = t.constructor.name;
        }
        return n === "Map" || n === "Set" ? Array.from(t) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? li(t, e) : undefined;
      }
    };
    t.exports.__esModule = true;
    t.exports.default = t.exports;
  });
  e(pi);
  var vi = n(function (t) {
    t.exports = function () {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    };
    t.exports.__esModule = true;
    t.exports.default = t.exports;
  });
  e(vi);
  var mi = e(n(function (t) {
    t.exports = function (t) {
      return fi(t) || di(t) || pi(t) || vi();
    };
    t.exports.__esModule = true;
    t.exports.default = t.exports;
  }));
  var gi = n(function (t) {
    t.exports = function (t) {
      if (Array.isArray(t)) {
        return t;
      }
    };
    t.exports.__esModule = true;
    t.exports.default = t.exports;
  });
  e(gi);
  var yi = n(function (t) {
    t.exports = function (t, e) {
      var n = t == null ? null : typeof Symbol != "undefined" && t[Symbol.iterator] || t["@@iterator"];
      if (n != null) {
        var r;
        var i;
        var o = [];
        var a = true;
        var s = false;
        try {
          for (n = n.call(t); !(a = (r = n.next()).done) && (o.push(r.value), !e || o.length !== e); a = true) {
            ;
          }
        } catch (t) {
          s = true;
          i = t;
        } finally {
          try {
            if (!(a || n.return == null)) {
              n.return();
            }
          } finally {
            if (s) {
              throw i;
            }
          }
        }
        return o;
      }
    };
    t.exports.__esModule = true;
    t.exports.default = t.exports;
  });
  e(yi);
  var _i = n(function (t) {
    t.exports = function () {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    };
    t.exports.__esModule = true;
    t.exports.default = t.exports;
  });
  e(_i);
  var xi = e(n(function (t) {
    t.exports = function (t, e) {
      return gi(t) || yi(t, e) || pi(t, e) || _i();
    };
    t.exports.__esModule = true;
    t.exports.default = t.exports;
  }));
  var bi = function (t, e, n) {
    if (t && e && e.length) {
      for (var r = e.length, i = 0; i < r; i++) {
        var o = undefined;
        var a = undefined;
        var s = undefined;
        var u = e[i];
        var h = xi(u, 2);
        var c = h[0];
        var l = h[1];
        var f = c.type;
        var d = c.value;
        switch (c.type) {
          case "1i":
          case "1f":
            t["uniform".concat(f)](l, c.value);
            break;
          case "2f":
          case "3f":
          case "4f":
            t["uniform".concat(f)].apply(t, [l].concat(mi(d)));
            break;
          case "t":
            if (!(o = c.value) || !o.image && !o.glTexture) {
              break;
            }
            a = n.getTextureUnit();
            t.uniform1i(l, a);
            n.setTexture(o, a);
            break;
          case "tv":
            s = [];
            for (var p = c.value, v = 0, m = p.length; v < m; v++) {
              s[v] = n.getTextureUnit();
            }
            t.uniform1iv(l, s);
            for (var g = 0, y = p.length; g < y; g++) {
              if ((o = p[g]) && (o.image || o.glTexture)) {
                a = s[g];
                n.setTexture(o, a);
              }
            }
            break;
          case "mat4fv":
            t.uniformMatrix4fv(l, false, c.value);
            break;
          default:
            console.warn("[UniformOperation] Unknown uniform type: ".concat(f));
        }
      }
    }
  };
  var Mi = "\nvoid main() {\n    gl_Position = mvpMatrix * vec4(position, 1.0);\n}\n";
  var wi = "\nvoid main() {\n    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n";
  var Ei = 0;
  var Ti = function (t) {
    function e() {
      for (var e, n = arguments.length, r = new Array(n), i = 0; i < n; i++) {
        r[i] = arguments[i];
      }
      (e = t.call.apply(t, [this].concat(r)) || this).isMaterial = true;
      e.id = Ei++;
      e.type = "Material";
      e.name = "";
      e.uuid = Br();
      e.uniforms = {};
      e.vertexShader = Mi;
      e.fragmentShader = wi;
      e.program = null;
      e.depthTest = true;
      e.visible = true;
      e.opacity = 1;
      e.needsUpdate = true;
      e.uniformsList = [];
      return e;
    }
    c(e, t);
    var n = e.prototype;
    n.setValues = function (t) {
      if (t !== undefined) {
        for (var e in t) {
          if (Object.prototype.hasOwnProperty.call(t, e)) {
            var n = t[e];
            if (n === undefined) {
              console.warn("Material: '" + e + "' parameter is undefined.");
              continue;
            }
            if (this[e] === undefined) {
              console.warn("".concat(this.type, ": ").concat(e, " is not a property of this material."));
              continue;
            }
            var r = "set" + e.charAt(0).toUpperCase() + e.slice(1);
            if (typeof this[r] == "function") {
              this[r](n);
            } else {
              this[e] = n;
            }
          }
        }
      }
    };
    n.clone = function () {
      return new e().copy(this);
    };
    n.copy = function (t) {
      this.uniforms = function (t) {
        var e;
        var n = {};
        for (var r in t) {
          if (Object.prototype.hasOwnProperty.call(t, r)) {
            n[r] = {};
            for (var i in t[r]) {
              if (Object.prototype.hasOwnProperty.call(t[r], i)) {
                if ((e = t[r][i]) && e.isTexture) {
                  n[r][i] = e.clone();
                } else {
                  n[r][i] = e instanceof Array ? e.slice(0) : e;
                }
              }
            }
          }
        }
        return n;
      }(t.uniforms);
      this.depthTest = t.depthTest;
      this.visible = t.visible;
      this.fragmentShader = t.fragmentShader;
      this.vertexShader = t.vertexShader;
      return this;
    };
    o(e, [{
      key: "defines",
      get: function () {
        return "";
      }
    }]);
    return e;
  }(Or);
  var Ai = {
    useColor: "USE_COLOR",
    useUV: "NEED_UV"
  };
  var Ci = function () {
    function t() {
      this.useColor = false;
      this.useUV = false;
    }
    t.prototype.getDefines = function () {
      for (var t = [], e = 0, n = Object.keys(this); e < n.length; e++) {
        var r = n[e];
        if (Ai[r] && this[r] === true) {
          t.push("#define ".concat(Ai[r]));
        }
      }
      t.push("");
      return t.join("\n");
    };
    return t;
  }();
  var Ri = "\n#ifdef NEED_UV\n    varying vec2 vUV;\n#endif\nvoid main(void) {\n    gl_Position = mvpMatrix * vec4(position, 1.0);\n    #ifdef NEED_UV\n        vUV = uv;\n    #endif\n}\n";
  var Si = "\nprecision mediump float;\n#ifdef NEED_UV\n    varying vec2 vUV;\n    uniform sampler2D uSampler;\n#endif\n#ifdef USE_COLOR\n    uniform vec4 uColor;\n#endif\nuniform float uOpacity;\nvoid main(void) {\n    vec4 finalColor;\n    vec4 defaultColor = vec4(1.0, 0.0, 0.0, 1.0);\n    finalColor = defaultColor;\n    #ifdef USE_COLOR\n        finalColor = uColor;\n    #endif\n    #ifdef NEED_UV\n        finalColor = texture2D(uSampler, vUV);\n    #endif\n    gl_FragColor = vec4(finalColor.rgb, finalColor.a * uOpacity);\n}\n";
  var Pi = function (t) {
    function e() {
      var e;
      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      (e = t.call(this) || this).map = null;
      e.color = [1, 0, 0, 1];
      e.type = "BasicMaterial";
      e.opacity = 1;
      e.depthTest = true;
      e.vertexShader = Ri;
      e.fragmentShader = Si;
      e.uniforms = {
        uSampler: {
          type: "t",
          value: null
        },
        uColor: {
          type: "4f",
          value: [1, 0, 0, 1]
        },
        uOpacity: {
          type: "1f",
          value: e.opacity
        }
      };
      e.setValues(n);
      return e;
    }
    c(e, t);
    var n = e.prototype;
    n.setOpacity = function (t) {
      this.uniforms.uOpacity.value = t;
      this.opacity = t;
    };
    n.setColor = function (t) {
      if (!(!Array.isArray(t) || t.length < 4)) {
        this.uniforms.uColor.value = t;
        this.color = t;
      }
    };
    n.setMap = function (t) {
      var e = this;
      if (t) {
        if (t instanceof Promise) {
          t.then(function (t) {
            e.uniforms.uSampler.value = t instanceof ui == true ? t : new ui(t);
          }).catch(function (t) {
            return console.error(t);
          });
        } else if (t.isTexture === true) {
          this.uniforms.uSampler.value = t;
        }
        this.map = t;
      }
    };
    o(e, [{
      key: "defines",
      get: function () {
        var t = new Ci();
        t.useColor = !!this.color;
        t.useUV = !!this.map;
        return t.getDefines();
      }
    }]);
    return e;
  }(Ti);
  var Di = function (t) {
    var e = this;
    this.gl = undefined;
    this.newAttributes = new Uint8Array(16);
    this.enabledAttributes = new Uint8Array(16);
    this.currentDepthTest = false;
    this.currentDepthWrite = true;
    this.currentColorWrite = true;
    this.currentDoubleSided = false;
    this.currentFlipSided = false;
    this.initAttributes = function () {
      for (var t = 0, n = e.newAttributes.length; t < n; t++) {
        e.newAttributes[t] = 0;
      }
    };
    this.enableAttribute = function (t) {
      var n = e.gl;
      var r = e.newAttributes;
      var i = e.enabledAttributes;
      r[t] = 1;
      if (i[t] === 0) {
        n.enableVertexAttribArray(t);
        i[t] = 1;
      }
    };
    this.disableAttribute = function (t) {
      var n = e.gl;
      var r = e.newAttributes;
      var i = e.enabledAttributes;
      r[t] = 0;
      if (i[t] === 1) {
        n.disableVertexAttribArray(t);
        i[t] = 0;
      }
    };
    this.disableUnusedAttributes = function () {
      for (var t = e.gl, n = e.newAttributes, r = e.enabledAttributes, i = 0, o = r.length; i < o; i++) {
        if (r[i] !== n[i]) {
          t.disableVertexAttribArray(i);
          r[i] = 0;
        }
      }
    };
    this.setDepthTest = function (t) {
      var n = e.gl;
      if (e.currentDepthTest !== t) {
        if (t) {
          n.enable(n.DEPTH_TEST);
        } else {
          n.disable(n.DEPTH_TEST);
        }
        e.currentDepthTest = t;
      }
    };
    this.setDepthWrite = function (t) {
      var n = e.gl;
      if (e.currentDepthWrite !== t) {
        n.depthMask(t);
        e.currentDepthWrite = t;
      }
    };
    this.setColorWrite = function (t) {
      var n = e.gl;
      if (e.currentColorWrite !== t) {
        n.colorMask(t, t, t, t);
        e.currentColorWrite = t;
      }
    };
    this.setDefaultGLState = function (t, n, r, i) {
      var o = e.gl;
      o.clearColor(229 / 255, 227 / 255, 223 / 255, 1);
      o.clear(o.COLOR_BUFFER_BIT | o.DEPTH_BUFFER_BIT);
      o.clearDepth(1);
      o.clearStencil(0);
      o.disable(o.DEPTH_TEST);
      o.depthFunc(o.LEQUAL);
      o.frontFace(o.CCW);
      o.disable(o.CULL_FACE);
      o.depthMask(true);
      o.enable(o.BLEND);
      o.blendFunc(o.SRC_ALPHA, o.ONE_MINUS_SRC_ALPHA);
      o.viewport(t, n, r, i);
    };
    this.setDoubleSided = function (t) {
      var n = e.gl;
      if (e.currentDoubleSided !== t) {
        if (t) {
          n.disable(n.CULL_FACE);
        } else {
          n.enable(n.CULL_FACE);
        }
        e.currentDoubleSided = t;
      }
    };
    this.setFlipSided = function (t) {
      var n = e.gl;
      if (e.currentFlipSided !== t) {
        if (t) {
          n.frontFace(n.CW);
        } else {
          n.frontFace(n.CCW);
        }
        e.currentFlipSided = t;
      }
    };
    this.reset = function () {
      for (var t = e.enabledAttributes, n = 0; n < t.length; n++) {
        t[n] = 0;
      }
      e.currentDepthTest = false;
      e.currentDepthWrite = true;
      e.currentColorWrite = true;
      e.currentDoubleSided = false;
      e.currentFlipSided = false;
    };
    this.gl = t;
  };
  var Oi = function (t) {
    var e = this;
    this.maxTextures = undefined;
    this.maxTextureSize = undefined;
    this.maxVerticesOneDraw = undefined;
    this.maxVertexShaderTextureUnits = undefined;
    this.maxFragmentShaderTextureUnits = undefined;
    this.gl = undefined;
    this.getMaxTextures = function () {
      var t = e.gl;
      return t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    };
    this.getLineWidthRange = function () {
      var t = e.gl;
      return t.getParameter(t.ALIASED_LINE_WIDTH_RANGE);
    };
    this.getMaxVertexShaderTextureUnits = function () {
      var t = e.gl;
      return t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
    };
    this.getMaxFragmentShaderTextureUnits = function () {
      var t = e.gl;
      return t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
    };
    this.getMaxTextureSize = function () {
      var t = e.gl;
      return t.getParameter(t.MAX_TEXTURE_SIZE);
    };
    this.getMaxVerticesOneDraw = function () {
      return e.gl.getExtension("OES_element_index_uint") ? 4294967296 : 65535;
    };
    this.getLegalPrecision = function (t) {
      var n = e.gl;
      var r = n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT);
      var i = n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT);
      var o = n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT);
      var a = n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT);
      var s = r && o && r.precision > 0 && o.precision > 0;
      var u = i && a && i.precision > 0 && a.precision > 0;
      if (t !== "highp" || s) {
        if (!(t !== "mediump" || u)) {
          t = "lowp";
          console.warn("[WebGLCapability] mediump is not supported, using lowp by default.");
        }
      } else if (u) {
        t = "mediump";
        console.warn("[WebGLCapability] highp is not supported, using mediump by default.");
      } else {
        t = "lowp";
        console.warn("[WebGLCapability] highp and mediump is not supported, using lowp by default.");
      }
      return t;
    };
    this.gl = t;
    this.maxTextures = this.getMaxTextures();
    this.maxVertexShaderTextureUnits = this.getMaxVertexShaderTextureUnits();
    this.maxFragmentShaderTextureUnits = this.getMaxFragmentShaderTextureUnits();
    this.maxTextureSize = this.getMaxTextureSize();
    this.maxVerticesOneDraw = this.getMaxVerticesOneDraw();
  };
  var Ii = 0;
  var Li = function (t, e, n) {
    var r = t.createShader(n);
    if (!r) {
      throw new Error("Something went wrong while compile the shader.");
    }
    t.shaderSource(r, e);
    t.compileShader(r);
    if (!t.getShaderParameter(r, t.COMPILE_STATUS)) {
      console.error("Error compiling shader: ".concat(t.getShaderInfoLog(r)));
    }
    return r;
  };
  var Bi = function () {
    function t(t, e, n) {
      this.usedTimes = undefined;
      this.id = undefined;
      this.code = undefined;
      this.program = undefined;
      this.attributes = undefined;
      this.uniforms = undefined;
      this.gl = undefined;
      this.parameters = undefined;
      this.precision = undefined;
      this.gl = t;
      this.parameters = e;
      this.precision = n.precision || "highp";
      this.usedTimes = 1;
      this.id = Ii++;
      var r = e.defines;
      var i = r === undefined ? "" : r;
      var o = e.vertexShader;
      var a = e.fragmentShader;
      this.code = i + o + a;
      this.program = this.createProgram(t, e, this.precision);
      this.attributes = this.fetchAttributes(t, this.program);
      this.uniforms = function (t, e) {
        var n;
        var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        var i = {};
        var o = r.length;
        if (!o) {
          return i;
        }
        for (var a = 0; a < o; a++) {
          i[n = r[a]] = t.getUniformLocation(e, n);
        }
        return i;
      }(t, this.program, this.getFullUniforms(e.uniforms));
    }
    var e = t.prototype;
    e.getAttributes = function () {
      return this.attributes;
    };
    e.getUniforms = function () {
      return this.uniforms;
    };
    e.createProgram = function (t, e) {
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "highp";
      var r = e.vertexShader;
      var i = e.fragmentShader;
      var o = e.defines;
      var a = o === undefined ? "" : o;
      var s = ["precision ".concat(n, " float;"), "uniform mat4 modelMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat4 mvpMatrix;", "attribute vec3 position;", "attribute vec2 uv;", ""].join("\n");
      var u = t.createProgram();
      var h = ["precision ".concat(n, " float;"), ""].join("\n");
      var c = Li(t, s + a + r, t.VERTEX_SHADER);
      var l = Li(t, h + a + i, t.FRAGMENT_SHADER);
      if (!u) {
        throw new Error("Something went wrong while createProgram.");
      }
      t.attachShader(u, c);
      t.attachShader(u, l);
      t.linkProgram(u);
      return u;
    };
    e.fetchAttributes = function (t, e) {
      for (var n = {}, r = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES), i = 0; i < r; i++) {
        var o = t.getActiveAttrib(e, i);
        if (!o) {
          throw new Error("Something went wrong while getActiveAttrib.");
        }
        var a = o.name;
        n[a] = t.getAttribLocation(e, a);
      }
      return n;
    };
    e.getFullUniforms = function (t) {
      var e = ["mvpMatrix", "modelMatrix", "projectionMatrix", "viewMatrix"];
      for (var n in t) {
        if (Object.prototype.hasOwnProperty.call(t, n)) {
          e.push(n);
        }
      }
      return e;
    };
    return t;
  }();
  var ki = {
    canvas: document.createElement("canvas"),
    context: undefined,
    width: 0,
    height: 0,
    pixelRatio: 1,
    precision: "highp",
    alpha: false,
    premultipliedAlpha: true,
    antialias: true,
    stencil: true,
    depth: true,
    preserveDrawingBuffer: false
  };
  var Ui = function () {
    function t() {
      var t = this;
      var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.state = undefined;
      this.domElement = undefined;
      this.capability = undefined;
      this.textureOperation = undefined;
      this._gl = undefined;
      this.parameters = undefined;
      this.programs = undefined;
      this.viewportInfo = undefined;
      this.autoDisposeProgram = true;
      this.currentCacheState = undefined;
      this.setSize = function (e, n) {
        var r = t.parameters;
        var i = r.canvas;
        var o = r.pixelRatio;
        i.style.width = "".concat(e, "px");
        i.style.height = "".concat(n, "px");
        i.width = e * o;
        i.height = n * o;
        t.setViewport(0, 0, e, n);
      };
      this.setViewport = function (e, n, r, i) {
        var o = t.parameters.pixelRatio;
        var a = t.viewportInfo;
        a.x = e * o;
        a.y = n * o;
        a.width = r * o;
        a.height = i * o;
        t._gl.viewport.apply(t._gl, Object.values(a));
      };
      this.setClearColor = function (e, n, r) {
        var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
        if (t.parameters.premultipliedAlpha === true) {
          e *= i;
          n *= i;
          r *= i;
        }
        t._gl.clearColor(e, n, r, i);
      };
      this.getContext = function () {
        return t._gl;
      };
      this.forceContextLoss = function () {
        try {
          var e = t._gl.getExtension("WEBGL_lose_context");
          if (e) {
            e.loseContext();
          }
        } catch (t) {
          console.error("[WebGLRenderer] WEBGL_lose_context error: ", t);
        }
      };
      this.initScene = function (e) {
        if (e.visible === true) {
          e.traverse(function (e) {
            if (e.visible === true && e instanceof Kr) {
              t.initMesh(e);
            }
          });
        }
      };
      this.initMesh = function (e) {
        if (e.visible === true) {
          if (e.__webglInit !== true) {
            e.__webglInit = true;
            e.addEventListener("removed", t.onObjectRemoved);
          }
          if (e.geometry) {
            t.checkAndUpdateGeometry(e.geometry);
          }
          if (e.children && e.children.length > 0) {
            e.children.forEach(function (e) {
              t.initMesh(e);
            });
          }
        }
      };
      this.checkAndUpdateGeometry = function (e) {
        if (e.__webglInit !== true) {
          e.__webglInit = true;
          e.addEventListener("removed", t.onGeometryRemove);
          e.groupsNeedUpdate = true;
        }
        if (e.groupsNeedUpdate === true) {
          if (e.type === "BufferGeometry") {
            t.updateBufferGeometry(e);
          } else {
            t.updateGeometryBuffer(e, t._gl.STATIC_DRAW);
          }
          e.groupsNeedUpdate = false;
        }
      };
      this.updateGeometryBuffer = function (e, n) {
        var r = e.verticesBufferData;
        var i = e.uvtsBufferData;
        var o = e.indicesBufferData;
        var a = e.borderVerticesBufferData;
        var s = t._gl;
        if (r.length > 0) {
          e.glVerticesBuffer = s.createBuffer();
          s.bindBuffer(s.ARRAY_BUFFER, e.glVerticesBuffer);
          s.bufferData(s.ARRAY_BUFFER, r, n);
        }
        if (i.length > 0) {
          e.glUvtsBuffer = s.createBuffer();
          s.bindBuffer(s.ARRAY_BUFFER, e.glUvtsBuffer);
          s.bufferData(s.ARRAY_BUFFER, i, n);
        }
        if (o.length > 0) {
          e.glIndicesBuffer = s.createBuffer();
          s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, e.glIndicesBuffer);
          s.bufferData(s.ELEMENT_ARRAY_BUFFER, o, n);
        }
        if (e.showBorder === true && a !== undefined && a.length > 0) {
          e.glBorderVerticesBuffer = s.createBuffer();
          s.bindBuffer(s.ARRAY_BUFFER, e.glBorderVerticesBuffer);
          s.bufferData(s.ARRAY_BUFFER, e.borderVerticesBufferData, n);
        }
      };
      this.renderScene = function (e, n) {
        if (e.visible === true) {
          e.traverse(function (e) {
            if (e instanceof Kr) {
              t.renderObject(e, n);
              if (e.children.length) {
                e.children.forEach(function (e) {
                  t.renderObject(e, n);
                });
              }
            }
          });
        }
      };
      this.renderObject = function (e, n) {
        var r = e.material;
        var i = e.geometry;
        if (e.visible === true && r && i && r.visible === true) {
          t.state.setDepthTest(r.depthTest);
          var o = false;
          var a = t.setProgram(n, r, e);
          o = i.type === "BufferGeometry" ? t.updateVerticesAttribute2(a, i, false) : t.updateVerticesAttribute(a, i, false);
          t.renderGeometryWithProgram(a, i, r, o);
        }
      };
      this.setProgram = function (e, n, r) {
        var i = !(arguments.length > 3 && arguments[3] !== undefined) || arguments[3];
        var o = t._gl;
        t.textureOperation.resetUsedTextureUnits();
        t.checkAndUpdateMaterial(r.material);
        var a = n.program;
        var s = a.getUniforms();
        if (a.id !== t.currentCacheState.programId) {
          o.useProgram(a.program);
          t.currentCacheState.programId = a.id;
        }
        if (i !== false) {
          bi(o, n.uniformsList, t.textureOperation);
        }
        t.updateMVPMatrix(s, e, r);
        return a;
      };
      this.checkAndUpdateMaterial = function (e) {
        if (e !== undefined) {
          if (e.__webglInit !== true) {
            e.__webglInit = true;
            e.addEventListener("removed", t.onMaterialRomove);
            e.needsUpdate = true;
          }
          if (e.needsUpdate === true) {
            t.updateMaterial(e);
            e.needsUpdate = false;
          }
        }
      };
      this.updateMaterial = function (e) {
        if (e.program) {
          t.removeMaterial(e);
        }
        for (var n = null, r = t.programs.length, i = e.defines, o = (i === undefined ? "" : i) + e.vertexShader + e.fragmentShader, a = r - 1; a >= 0; a--) {
          var s = t.programs[a];
          if (s.code === o) {
            (n = s).usedTimes++;
            break;
          }
        }
        if (n === null) {
          var u = {
            uniforms: e.uniforms,
            defines: e.defines || "",
            vertexShader: e.vertexShader,
            fragmentShader: e.fragmentShader
          };
          n = new Bi(t._gl, u, {
            precision: t.parameters.precision
          });
          t.programs.push(n);
        }
        e.program = n;
        e.uniformsList = [];
        var h = 0;
        var c = n.uniforms;
        var l = e.uniforms;
        for (var f in l) {
          if (Object.prototype.hasOwnProperty.call(l, f)) {
            var d = c[f];
            if (d) {
              e.uniformsList[h] = [l[f], d];
              h++;
            }
          }
        }
      };
      this.updateMVPMatrix = function (e, n, r) {
        if (e.mvpMatrix !== undefined) {
          var i = De(n.projectionMatrix);
          Ue(i, i, n.viewMatrix);
          Ue(i, i, r.worldMatrix);
          t._gl.uniformMatrix4fv(e.mvpMatrix, false, i);
          t._gl.uniformMatrix4fv(e.modelMatrix, false, r.worldMatrix);
          t._gl.uniformMatrix4fv(e.viewMatrix, false, n.viewMatrix);
          t._gl.uniformMatrix4fv(e.projectionMatrix, false, n.projectionMatrix);
        }
        t.currentCacheState.camera = n;
      };
      this.renderGeometryWithProgram = function (e, n, r) {
        var i = t._gl;
        var o = t.currentCacheState.curRenderTarget;
        if (e.uniforms.showDebugLine) {
          i.uniform1i(e.uniforms.showDebugLine, 0);
        }
        if (n.type === "BufferGeometry") {
          i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, n.indexesBuffer);
        } else {
          i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, n.glIndicesBuffer);
        }
        if (o !== null && o.glFrameBuffer !== undefined) {
          var a = i.checkFramebufferStatus(i.FRAMEBUFFER);
          if (i.FRAMEBUFFER_COMPLETE !== a) {
            t.removeRenderTarget(o);
            return void (t.currentCacheState.curRenderTarget = null);
          }
        }
        if (n.indexes && n.indexes.count > 0) {
          i.drawElements(i.TRIANGLES, n.indexes.count, i.UNSIGNED_SHORT, 0);
        } else {
          i.drawArrays(i.TRIANGLES, 0, n.attributes.position.count);
        }
      };
      this.onObjectRemoved = function (e) {
        e.target.traverse(function (e) {
          e.removeEventListener("removed", t.onObjectRemoved);
          t.removeObject(e);
        });
      };
      this.onGeometryRemove = function (e) {
        var n = e.target;
        n.removeEventListener("removed", t.onGeometryRemove);
        t.removeGeometry(n);
      };
      this.onMaterialRomove = function (e) {
        var n = e.target;
        n.removeEventListener("removed", t.onMaterialRomove);
        t.removeMaterial(n);
      };
      this.onRenderTargetRemove = function (e) {
        var n = e.target;
        n.removeEventListener("removed", t.onRenderTargetRemove);
        t.removeRenderTarget(n);
      };
      this.removeObject = function (t) {
        if (t.geometry) {
          delete t.geometry.__webglInit;
        }
        delete t.__webglInit;
      };
      this.removeGeometry = function (e) {
        delete e.__webglInit;
        t.deleteBuffers(e);
        t.currentCacheState.geometryProgramId = null;
      };
      this.deleteBuffers = function (e) {
        ["glVerticesBuffer", "glUvtsBuffer", "glIndicesBuffer", "glBorderVerticesBuffer"].forEach(function (n) {
          t._gl.deleteBuffer(e[n]);
          if (e[n] !== undefined && e[n] > 0) {
            delete e[n];
          }
        });
      };
      this.removeMaterial = function (e) {
        var n = e.program.program;
        if (n) {
          e.program = null;
          for (var r = t.programs, i = r.length - 1; i >= 0; i--) {
            var o = r[i];
            if (o.program === n) {
              o.usedTimes--;
              if (o.usedTimes === 0 && t.autoDisposeProgram !== false) {
                r.splice(i, 1);
                t._gl.deleteProgram(n);
              }
              break;
            }
          }
        }
      };
      this.removeRenderTarget = function (e) {
        t._gl.deleteRenderbuffer(e.glDepthBuffer);
        e.glDepthBuffer = null;
        t._gl.deleteTexture(e.glTexture);
        e.glTexture = null;
        t._gl.deleteFramebuffer(e.glFrameBuffer);
        e.glFrameBuffer = null;
      };
      this.parameters = Object.assign({}, ki, e);
      if (e && !e.canvas) {
        this.parameters.canvas = document.createElement("canvas");
      }
      this.initGL();
      this.programs = [];
      this.viewportInfo = {
        x: 0,
        y: 0,
        width: this.parameters.canvas.width,
        height: this.parameters.canvas.height
      };
      if (this.parameters.width && this.parameters.height) {
        this.setSize(this.parameters.width, this.parameters.height);
      }
      this.domElement = this.parameters.canvas;
      this.state = new Di(this._gl);
      this.state.setDefaultGLState.apply(this.state, Object.values(this.viewportInfo));
      this.currentCacheState = {
        programId: null,
        geometryProgramId: null,
        materialId: null,
        camera: null,
        curRenderTarget: null
      };
      this.capability = new Oi(this._gl);
      var n = this.capability.maxTextures;
      var r = this.capability.maxTextureSize;
      this.textureOperation = new ci(this._gl, n, r);
    }
    var e = t.prototype;
    e.clearBuffer = function () {
      var t = this._gl;
      t.clear(t.COLOR_BUFFER_BIT | t.DEPTH_BUFFER_BIT);
    };
    e.initGL = function () {
      var t = this;
      var e = this.parameters;
      var n = e.canvas;
      var r = e.context;
      var i = e.alpha;
      var o = e.depth;
      var a = e.stencil;
      var s = e.antialias;
      var u = e.premultipliedAlpha;
      var h = e.preserveDrawingBuffer;
      try {
        var c = {
          alpha: i,
          depth: o,
          stencil: a,
          antialias: s,
          premultipliedAlpha: u,
          preserveDrawingBuffer: h
        };
        var l = r || n.getContext("webgl", c) || n.getContext("experimental-webgl", c) || n.getContext("moz-webgl", c) || n.getContext("webkit-3d", c);
        if (!l) {
          throw n.getContext !== null ? "Error creating WebGL context with your provided attributes." : "Error creating WebGL context.";
        }
        this._gl = l;
        n.addEventListener("webglcontextlost", function (e) {
          e.preventDefault();
          if (t.state !== undefined) {
            t.resetGLState();
            t.state.setDefaultGLState.apply(t.state, Object.values(t.viewportInfo));
          }
        }, false);
      } catch (t) {
        console.error("[WebGLRenderer] Create webgl error: ", t);
      }
    };
    e.resetGLState = function () {
      this.currentCacheState = {
        programId: null,
        geometryProgramId: null,
        materialId: null,
        camera: null,
        curRenderTarget: null
      };
      this.state.reset();
    };
    e.setRenderTarget = function (t) {
      var e = this._gl;
      if (t !== undefined && t.glFrameBuffer === null) {
        t.addEventListener("removed", this.onRenderTargetRemove);
        t.glFrameBuffer = e.createFramebuffer();
        e.bindFramebuffer(e.FRAMEBUFFER, t.glFrameBuffer);
        this.textureOperation.setTextureForRenderTarget(t);
        t.glDepthBuffer = e.createRenderbuffer();
        e.bindRenderbuffer(e.RENDERBUFFER, t.glDepthBuffer);
        e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_COMPONENT16, t.width, t.height);
        e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t.glTexture, 0);
        e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, t.glDepthBuffer);
        e.bindTexture(e.TEXTURE_2D, null);
        e.bindRenderbuffer(e.RENDERBUFFER, null);
        e.bindFramebuffer(e.FRAMEBUFFER, null);
      }
    };
    e.render = function (t, e, n) {
      if (e.isCamera) {
        var r = this._gl;
        t.updateWorldMatrix();
        e.updateWorldMatrix();
        e.updateProjectionMatrix();
        this.currentCacheState.camera = null;
        if (n !== undefined) {
          this.setRenderTarget(n);
          this.currentCacheState.curRenderTarget = n;
          r.bindFramebuffer(r.FRAMEBUFFER, n.glFrameBuffer);
          r.viewport(0, 0, n.width, n.height);
        } else {
          var i = this.viewportInfo;
          var o = i.width;
          var a = i.height;
          this.currentCacheState.curRenderTarget = null;
          r.bindFramebuffer(r.FRAMEBUFFER, null);
          r.viewport(0, 0, o, a);
        }
        this.initScene(t);
        this.renderScene(t, e);
      } else {
        console.error("[WebGLRenderer]  Camera is not leagal.");
      }
    };
    e.updateBufferGeometry = function (t) {
      var e = this._gl;
      var n = t.getIndexes();
      var r = t.getAttribute();
      for (var i in r) {
        if (Object.prototype.hasOwnProperty.call(r, i)) {
          var o = i + "Buffer";
          var a = r[i];
          var s = a.array;
          var u = a.usage;
          t[o] = e.createBuffer();
          e.bindBuffer(e.ARRAY_BUFFER, t[o]);
          e.bufferData(e.ARRAY_BUFFER, s, u);
        }
      }
      if (n) {
        t.indexesBuffer = e.createBuffer();
        e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t.indexesBuffer);
        e.bufferData(e.ELEMENT_ARRAY_BUFFER, n.array, n.usage);
      }
    };
    e.updateVerticesAttribute2 = function (t, e) {
      var n = !(arguments.length > 2 && arguments[2] !== undefined) || arguments[2];
      var r = this._gl;
      var i = false;
      var o = "".concat(e.id, "_").concat(t.id);
      if (o !== this.currentCacheState.geometryProgramId) {
        this.currentCacheState.geometryProgramId = o;
        this.state.initAttributes();
        i = true;
        var a = e.getAttribute();
        for (var s in a) {
          if (Object.prototype.hasOwnProperty.call(a, s)) {
            var u = s + "Buffer";
            var h = a[s];
            var c = h.itemSize;
            var l = h.type;
            var f = h.normalized;
            if (t.attributes[s] >= 0) {
              if (n !== true) {
                r.bindBuffer(r.ARRAY_BUFFER, e[u]);
                r.vertexAttribPointer(t.attributes[s], c, l, f, 0, 0);
              }
              this.state.enableAttribute(t.attributes[s]);
            }
          }
        }
      }
      this.state.disableUnusedAttributes();
      return i;
    };
    e.updateVerticesAttribute = function (t, e) {
      var n = !(arguments.length > 2 && arguments[2] !== undefined) || arguments[2];
      var r = this._gl;
      var i = false;
      var o = "".concat(e.id, "_").concat(t.id);
      if (o !== this.currentCacheState.geometryProgramId) {
        this.currentCacheState.geometryProgramId = o;
        this.state.initAttributes();
        i = true;
        var a = t.getAttributes();
        if (a.position >= 0) {
          if (n !== true) {
            r.bindBuffer(r.ARRAY_BUFFER, e.glVerticesBuffer);
            r.vertexAttribPointer(a.position, 3, r.FLOAT, false, 0, 0);
          }
          this.state.enableAttribute(a.position);
        }
        if (a.uv >= 0 && e.glUvtsBuffer !== undefined) {
          r.bindBuffer(r.ARRAY_BUFFER, e.glUvtsBuffer);
          r.vertexAttribPointer(a.uv, 2, r.FLOAT, false, 0, 0);
          this.state.enableAttribute(a.uv);
        }
      }
      this.state.disableUnusedAttributes();
      return i;
    };
    return t;
  }();
  var Ni = function (t) {
    function e(e, n, r, i, o, a) {
      var s;
      (s = t.call(this) || this).addIntoBuffer = function (t, e, n) {
        t[n] = e[0];
        t[n + 1] = e[1];
        t[n + 2] = e[2];
      };
      s.get3DVertex = function (t, e) {
        var n;
        switch (e) {
          case "x":
            n = Vt(0, t[0], t[1]);
            break;
          case "y":
            n = Vt(t[0], 0, t[1]);
            break;
          default:
            n = Vt(t[0], t[1], 0);
        }
        return n;
      };
      s.zeroAxis = o !== undefined ? o : "z";
      switch (s.zeroAxis) {
        case "x":
          s.normal = Vt(-1, 0, 0);
          break;
        case "y":
        default:
          s.normal = Vt(0, -1, 0);
          break;
        case "z":
          s.normal = Vt(0, 0, -1);
      }
      a = a !== undefined ? a : {};
      s.showBorder = !(a.showBorder === false);
      s.borderWidth = a.borderWidth !== undefined ? a.borderWidth : 1;
      s.borderColor = a.borderColor !== undefined ? a.borderColor : [0, 0, 0, 1];
      var u;
      var h;
      var c;
      var l = 0.5 * e;
      var f = 0.5 * n;
      var d = r || 1;
      var p = i || 1;
      var v = e / d;
      var m = n / p;
      var g = (d + 1) * (p + 1);
      s.verticesBufferData = new Float32Array(3 * g);
      s.uvtsBufferData = new Float32Array(2 * g);
      s.indicesBufferData = new (g > 65535 ? Uint32Array : Uint16Array)(d * p * 6);
      for (var y = 0, _ = 0, x = 0; x <= p; x++) {
        u = x * m - f;
        for (var b = 0; b <= d; b++) {
          c = _t(b * v - l, u);
          h = s.get3DVertex(c, s.zeroAxis);
          s.vertices.push(h);
          s.addIntoBuffer(s.verticesBufferData, h, y);
          s.uvtsBufferData[_] = b / d;
          s.uvtsBufferData[_ + 1] = 1 - x / p;
          y += 3;
          _ += 2;
        }
      }
      for (var M, w, E, T, A = 0, C = 0; C < p; C++) {
        for (var R = 0; R < d; R++) {
          M = R + (d + 1) * C;
          w = R + (d + 1) * (C + 1);
          E = R + 1 + (d + 1) * (C + 1);
          T = R + 1 + (d + 1) * C;
          s.addIntoBuffer(s.indicesBufferData, [M, w, E], A);
          s.addIntoBuffer(s.indicesBufferData, [M, E, T], A + 3);
          A += 6;
        }
      }
      s.borderIndicesBufferData = new Uint16Array(4);
      s.borderIndicesBufferData[0] = 0;
      s.borderIndicesBufferData[1] = d;
      s.borderIndicesBufferData[2] = (d + 1) * p;
      s.borderIndicesBufferData[3] = (d + 1) * (p + 1) - 1;
      var S = 0;
      s.borderVerticesBufferData = new Float32Array(6 * (d + p));
      for (var P = 0; P < g; P += d + 1) {
        s.addIntoBuffer(s.borderVerticesBufferData, s.vertices[P], S);
        S += 3;
      }
      for (var D = (d + 1) * p + 1; D < g; D++) {
        s.addIntoBuffer(s.borderVerticesBufferData, s.vertices[D], S);
        S += 3;
      }
      for (var O = (d + 1) * p - 1; O > 0; O -= d + 1) {
        s.addIntoBuffer(s.borderVerticesBufferData, s.vertices[O], S);
        S += 3;
      }
      for (var I = d - 1; I > 0; I--) {
        s.addIntoBuffer(s.borderVerticesBufferData, s.vertices[I], S);
        S += 3;
      }
      return s;
    }
    c(e, t);
    return e;
  }(Jr);
  var Fi = "z";
  var ji = function (t) {
    function e(n, r, i, o) {
      var a;
      var s = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
      a = t.call(this) || this;
      var u = e.buildPlane(n, r, i, o, s);
      var h = u.uvs;
      var c = u.indices;
      var l = u.normals;
      var f = u.vertices;
      a.name = "PlaneBufferGeometry";
      a.setAttribute("position", new Gr(f, 3));
      a.setAttribute("normals", new Gr(l, 3));
      a.setAttribute("uv", new Gr(h, 2));
      a.setIndexes(c);
      return a;
    }
    c(e, t);
    e.buildPlane = function (t, n, r, i) {
      for (var o = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {}, a = o.normalAxis, s = a === undefined ? Fi : a, u = o.useBack, h = u !== undefined && u, c = o.normalDest, l = c === undefined ? 0 : c, f = 0.5 * t, d = 0.5 * n, p = r || 1, v = i || 1, m = t / p, g = n / v, y = e.getNormal(s, h), _ = [], x = [], b = [], M = [], w = 0; w <= v; w++) {
        for (var E = w * g - d, T = 0; T <= p; T++) {
          var A = T * m - f;
          var C = e.get3DVertex([A, E], s, l);
          b.push.apply(b, mi(C));
          _.push(T / p, 1 - w / v);
          M.push.apply(M, mi(y));
        }
      }
      for (var R = 0; R < v; R++) {
        for (var S = 0; S < p; S++) {
          var P = S + (p + 1) * R;
          var D = S + (p + 1) * (R + 1);
          var O = S + 1 + (p + 1) * (R + 1);
          var I = S + 1 + (p + 1) * R;
          x.push(P, D, O);
          x.push(P, O, I);
        }
      }
      return {
        uvs: _,
        indices: x,
        vertices: b,
        normals: M
      };
    };
    e.getNormal = function (t) {
      var e;
      var n = arguments.length > 1 && arguments[1] !== undefined && arguments[1];
      var r = n ? -1 : 1;
      switch (t) {
        case "x":
          e = [r, 0, 0];
          break;
        case Fi:
          e = [0, 0, r];
          break;
        default:
          e = [0, r, 0];
      }
      return e;
    };
    return e;
  }(Zr);
  ji.get3DVertex = function (t, e) {
    var n;
    var r = xi(t, 2);
    var i = r[0];
    var o = r[1];
    var a = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    switch (e) {
      case "x":
        n = [a, i, o];
        break;
      case "y":
        n = [i, a, o];
        break;
      default:
        n = [i, o, a];
    }
    return n;
  };
  var zi = function (t) {
    function e(e, n, r, i, o, a) {
      var s;
      (s = t.call(this) || this).name = "BoxGeometry";
      var u = s.initBox(e, n, r, i, o, a);
      var h = u.uvs;
      var c = u.normals;
      var l = u.vertices;
      var f = u.indices;
      s.setAttribute("position", new Gr(l, 3));
      s.setAttribute("normals", new Gr(c, 3));
      s.setAttribute("uv", new Gr(h, 2));
      s.setIndexes(f);
      return s;
    }
    c(e, t);
    e.prototype.initBox = function (t, e, n, r, i, o) {
      var a = [];
      var s = ji.buildPlane;
      var u = s(n, e, o, i, {
        normalAxis: "x",
        normalDest: t / 2
      });
      var h = s(n, e, o, i, {
        normalAxis: "x",
        useBack: true,
        normalDest: -t / 2
      });
      var c = s(t, n, r, o, {
        normalAxis: "y",
        normalDest: e / 2
      });
      var l = s(t, n, r, o, {
        normalAxis: "y",
        useBack: true,
        normalDest: -e / 2
      });
      var f = s(t, e, r, i, {
        normalAxis: "z",
        normalDest: n / 2
      });
      var d = s(t, e, r, i, {
        normalAxis: "z",
        useBack: true,
        normalDest: -n / 2
      });
      a.push(u, h, c, l, f, d);
      for (var p = 0, v = [], m = [], g = [], y = [], _ = function (t) {
          var e = a[t];
          var n = e.uvs;
          var r = e.vertices;
          var i = e.normals;
          var o = e.indices;
          var s = p;
          v = v.concat(n);
          m = m.concat(r);
          g = g.concat(i);
          y = y.concat(o.map(function (t) {
            return s + t;
          }));
          p += r.length / 3;
        }, x = 0; x < 6; x++) {
        _(x);
      }
      return {
        uvs: v,
        vertices: m,
        normals: g,
        indices: y
      };
    };
    return e;
  }(Zr);
  var Vi = function (t) {
    function e(e, n) {
      var r;
      (r = t.call(this) || this).width = undefined;
      r.height = undefined;
      r.glFrameBuffer = null;
      r.glDepthBuffer = null;
      r.flipY = false;
      r.premultiplyAlpha = false;
      r.glTexture = null;
      r.width = e;
      r.height = n;
      return r;
    }
    c(e, t);
    return e;
  }(Or);
  function Gi(t, e) {
    var n = typeof Symbol != "undefined" && t[Symbol.iterator] || t["@@iterator"];
    if (!n) {
      if (Array.isArray(t) || (n = function (t, e) {
        if (!t) {
          return;
        }
        if (typeof t == "string") {
          return Wi(t, e);
        }
        var n = Object.prototype.toString.call(t).slice(8, -1);
        if (n === "Object" && t.constructor) {
          n = t.constructor.name;
        }
        if (n === "Map" || n === "Set") {
          return Array.from(t);
        }
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
          return Wi(t, e);
        }
      }(t)) || e && t && typeof t.length == "number") {
        if (n) {
          t = n;
        }
        var r = 0;
        var i = function () {};
        return {
          s: i,
          n: function () {
            return r >= t.length ? {
              done: true
            } : {
              done: false,
              value: t[r++]
            };
          },
          e: function (t) {
            throw t;
          },
          f: i
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var o;
    var a = true;
    var s = false;
    return {
      s: function () {
        n = n.call(t);
      },
      n: function () {
        var t = n.next();
        a = t.done;
        return t;
      },
      e: function (t) {
        s = true;
        o = t;
      },
      f: function () {
        try {
          if (!(a || n.return == null)) {
            n.return();
          }
        } finally {
          if (s) {
            throw o;
          }
        }
      }
    };
  }
  function Wi(t, e) {
    if (e == null || e > t.length) {
      e = t.length;
    }
    for (var n = 0, r = new Array(e); n < e; n++) {
      r[n] = t[n];
    }
    return r;
  }
  var Hi = function () {
    function t() {
      this.faceCount = 0;
      this.verticesCoords = [];
      this.textureCoords = [];
      this.uvs = [];
      this.vertices = [];
      this.normals = [];
      this.indexes = [];
    }
    var e = t.prototype;
    e.load = function (t) {
      var e = this;
      return new Promise(function (n) {
        (function (t) {
          var e = new XMLHttpRequest();
          e.open("GET", t, true);
          e.send(null);
          return new Promise(function (t) {
            e.addEventListener("load", function () {
              t(e.responseText);
            }, false);
          }, function (t) {
            e.addEventListener("error", function (e) {
              console.error("request error");
              t(e);
            }, false);
          });
        })(t).then(function (t) {
          e.parse(t);
          var r = e.genObject3D();
          n(r);
        });
      });
    };
    e.genObject3D = function () {
      var t = new Zr();
      t.setAttribute("position", new Gr(this.vertices, 3));
      if (this.uvs.length) {
        t.setAttribute("uv", new Gr(this.uvs, 2));
      }
      t.setIndexes(this.indexes);
      var e = new Pi();
      return new Kr(t, e);
    };
    e.parse = function (t) {
      var e;
      var n = Gi(t.split("\n"));
      try {
        for (n.s(); !(e = n.n()).done;) {
          var r = e.value;
          var i = r.indexOf("#");
          if (i !== -1) {
            r = r.substring(0, i);
          }
          var o = (r = r.trim()).split(/\s+/);
          switch (o[0]) {
            case "v":
              this.verticesCoords.push(parseFloat(o[1]), parseFloat(o[2]), parseFloat(o[3]));
              break;
            case "vn":
              this.normals.push(parseFloat(o[1]), parseFloat(o[2]), parseFloat(o[3]));
              break;
            case "vt":
              this.textureCoords.push(parseFloat(o[1]), parseFloat(o[2]));
              break;
            case "p":
            case "l":
            case "usemtl":
              break;
            case "f":
              o.shift();
              this.parseFaceLine(o);
          }
        }
      } catch (t) {
        n.e(t);
      } finally {
        n.f();
      }
    };
    e.parseFaceLine = function (t) {
      for (var e = [], n = t.length, r = 0; r < n; r++) {
        var i = t[r];
        if (i.length > 0) {
          var o = i.split("/");
          e.push(o);
        }
      }
      for (var a = e[0], s = 1, u = e.length - 1; s < u; s++) {
        var h = e[s];
        var c = e[s + 1];
        this.addFace(a, h, c);
      }
    };
    e.addFace = function (t, e, n) {
      var r = this.verticesCoords;
      var i = r.length / 3;
      var o = this.parseVertexIndex(t[0], i);
      var a = this.parseVertexIndex(e[0], i);
      var s = this.parseVertexIndex(n[0], i);
      this.vertices.push(r[o], r[o + 1], r[o + 2], r[a], r[a + 1], r[a + 2], r[s], r[s + 1], r[s + 2]);
      var u = 3 * this.faceCount;
      this.indexes.push(u, u + 1, u + 2);
      this.faceCount++;
      if (t[1] !== "") {
        var h = this.textureCoords;
        var c = h.length;
        var l = this.parseUVIndex(t[1], c);
        var f = this.parseUVIndex(e[1], c);
        var d = this.parseUVIndex(n[1], c);
        this.uvs.push(h[l], h[l + 1], h[f], h[f + 1], h[d], h[d + 1]);
      }
      t[2];
    };
    e.parseVertexIndex = function (t, e) {
      var n = parseInt(t, 10);
      return 3 * (n >= 0 ? n - 1 : n + e / 3);
    };
    e.parseUVIndex = function (t, e) {
      var n = parseInt(t, 10);
      return 2 * (n >= 0 ? n - 1 : n + e / 2);
    };
    return t;
  }();
  function Zi(t) {
    return new Promise(function (e, n) {
      var r = new Image();
      r.src = t;
      r.crossOrigin = "Anonymous";
      r.onload = function () {
        e(r);
      };
      r.onerror = function (t) {
        n(t);
      };
    });
  }
  function qi(t) {
    if (t.length !== 6) {
      throw new Error("[loadCubeTexture] param urls need len six. [px, nx, py, ny, pz, nz]");
    }
    return new Promise(function (e, n) {
      for (var r = 0, i = new hi(), o = i.image, a = function (a) {
          Zi(t[a]).then(function (t) {
            r++;
            o[a] = t;
            if (r === 6) {
              i.needsUpdate = true;
              e(i);
            }
          }).catch(function (t) {
            console.error(t);
            n(t);
          });
        }, s = 0; s < 6; s++) {
        a(s);
      }
    });
  }
  var Yi = function (t) {
    function e() {
      var e;
      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.1;
      var r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3000;
      (e = t.call(this) || this).isCamera = true;
      e.viewMatrix = Pe();
      e.projectionMatrix = Pe();
      e.projectionMatrixNeedUpdate = false;
      e._far = undefined;
      e._near = undefined;
      e._far = r;
      e._near = n;
      return e;
    }
    c(e, t);
    e.prototype.updateWorldMatrix = function () {
      var e = arguments.length > 0 && arguments[0] !== undefined && arguments[0];
      t.prototype.updateWorldMatrix.call(this, e);
      Be(this.viewMatrix, this.worldMatrix);
    };
    o(e, [{
      key: "near",
      get: function () {
        return this._near;
      },
      set: function (t) {
        this._near = t;
        this.projectionMatrixNeedUpdate = true;
      }
    }, {
      key: "far",
      get: function () {
        return this._far;
      },
      set: function (t) {
        this._far = t;
        this.projectionMatrixNeedUpdate = true;
      }
    }]);
    return e;
  }(Ur);
  var Xi = function (t) {
    function e(e, n, r, i, o, a) {
      var s;
      (s = t.call(this, o, a) || this)._left = undefined;
      s._right = undefined;
      s._top = undefined;
      s._bottom = undefined;
      s._top = r;
      s._left = e;
      s._right = n;
      s._bottom = i;
      s.updateProjectionMatrix(true);
      return s;
    }
    c(e, t);
    var n = e.prototype;
    n.updateProjectionMatrix = function () {
      var t = arguments.length > 0 && arguments[0] !== undefined && arguments[0];
      if (t === true || this.projectionMatrixNeedUpdate === true) {
        var e = (this.right - this.left) / 2;
        var n = (this.top - this.bottom) / 2;
        var r = (this.right + this.left) / 2;
        var i = (this.top + this.bottom) / 2;
        var o = r - e;
        var a = r + e;
        var s = i + n;
        var u = i - n;
        Ie(this.projectionMatrix);
        $e(this.projectionMatrix, o, a, s, u, this.near, this.far);
        this.projectionMatrixNeedUpdate = false;
      }
    };
    n.clone = function (n) {
      if (n === undefined) {
        n = new e(0, 0, 0, 0, 0, 0);
      }
      t.prototype.clone.call(this, n);
      n.left = this.left;
      n.right = this.right;
      n.top = this.top;
      n.bottom = this.bottom;
      n.near = this.near;
      n.far = this.far;
      n.updateProjectionMatrix();
      n.updateWorldMatrix();
      return n;
    };
    o(e, [{
      key: "top",
      get: function () {
        return this._top;
      },
      set: function (t) {
        if (t !== this._top) {
          this._top = t;
          this.projectionMatrixNeedUpdate = true;
        }
      }
    }, {
      key: "left",
      get: function () {
        return this._left;
      },
      set: function (t) {
        if (t !== this._left) {
          this._left = t;
          this.projectionMatrixNeedUpdate = true;
        }
      }
    }, {
      key: "right",
      get: function () {
        return this._right;
      },
      set: function (t) {
        if (t !== this._right) {
          this._right = t;
          this.projectionMatrixNeedUpdate = true;
        }
      }
    }, {
      key: "bottom",
      get: function () {
        return this._bottom;
      },
      set: function (t) {
        if (t !== this._bottom) {
          this._bottom = t;
          this.projectionMatrixNeedUpdate = true;
        }
      }
    }]);
    return e;
  }(Yi);
  var Ki = function (t) {
    function e(e, n, r, i) {
      var o;
      (o = t.call(this, r, i) || this).type = "PerspectiveCamera";
      o._fov = undefined;
      o._aspect = undefined;
      o._fov = e;
      o._aspect = n;
      o.updateProjectionMatrix(true);
      return o;
    }
    c(e, t);
    var n = e.prototype;
    n.updateProjectionMatrix = function () {
      var t = arguments.length > 0 && arguments[0] !== undefined && arguments[0];
      if (!(t !== true && this.projectionMatrixNeedUpdate !== true)) {
        Ie(this.projectionMatrix);
        Qe(this.projectionMatrix, this.fov * Math.PI / 180, this.aspect, this.near, this.far);
        this.projectionMatrixNeedUpdate = false;
      }
    };
    n.clone = function (n) {
      if (n === undefined) {
        n = new e(0, 0, 0, 0);
      }
      t.prototype.clone.call(this, n);
      n.fov = this.fov;
      n.aspect = this.aspect;
      n.near = this.near;
      n.far = this.far;
      n.updateProjectionMatrix();
      n.updateWorldMatrix();
      return n;
    };
    o(e, [{
      key: "fov",
      get: function () {
        return this._fov;
      },
      set: function (t) {
        if (t !== this._fov) {
          this._fov = t;
          this.projectionMatrixNeedUpdate = true;
        }
      }
    }, {
      key: "aspect",
      get: function () {
        return this._aspect;
      },
      set: function (t) {
        if (t !== this._aspect) {
          this._aspect = t;
          this.projectionMatrixNeedUpdate = true;
        }
      }
    }]);
    return e;
  }(Yi);
  var Qi = Object.freeze({
    __proto__: null,
    Mesh: Kr,
    Scene: Qr,
    Geometry: Jr,
    Object3D: Ur,
    Raycaster: si,
    Texture: ui,
    CubeTexture: hi,
    TextureOperation: ci,
    Material: Ti,
    BasicMaterial: Pi,
    BufferGeometry: Zr,
    WebGLRenderer: Ui,
    PlaneGeometry: Ni,
    BoxGeometry: zi,
    WebGLRenderTarget: Vi,
    PlaneBufferGeometry: ji,
    Box3: Nr,
    OBJLoader: Hi,
    loadImage: Zi,
    loadTexture: function (t, e, n) {
      return Zi(t).then(function (t) {
        var n = new ui(t);
        if (e) {
          e(n);
        }
        return n;
      }).catch(function (t) {
        if (n) {
          n(t);
        }
      });
    },
    loadCubeTexture: qi,
    Vec2: Ut,
    Vec3: ge,
    Vec4: kn,
    Mat3: Se,
    Mat4: an,
    Quat: Ar,
    quatToEuler: Ir,
    BufferAttribute: Fr,
    Uint8BufferAttribute: jr,
    Uint16BufferAttribute: zr,
    Uint32BufferAttribute: Vr,
    Float32ArrayAttribute: Gr,
    UintBufferAttribute: Wr,
    OrthographicCamera: Xi,
    PerspectiveCamera: Ki
  });
  var Ji = function () {
    function t(t) {
      this.pano = undefined;
      this.panoData = undefined;
      this._meshs = new Kr();
      this.pano = t;
    }
    o(t, [{
      key: "camera",
      get: function () {
        return this.pano.camera;
      }
    }, {
      key: "meshs",
      get: function () {
        return this._meshs;
      },
      set: function (t) {
        this._meshs = t;
      }
    }]);
    return t;
  }();
  var $i = ["varying vec3 v_normal;", "void main(void){", "   gl_Position = mvpMatrix * vec4(position, 1.0);", "   v_normal = normalize(position.xyz);", "}"].join("\n");
  var to = ["uniform samplerCube uSampler;", "uniform float uOpacity;", "varying vec3 v_normal;", "void main(void){", "    vec4 textureColor = textureCube(uSampler, normalize(v_normal));", "    gl_FragColor = vec4(textureColor.rgb, textureColor.a * uOpacity);", "}"].join("\n");
  var eo = function (t) {
    function e(e) {
      var n;
      (n = t.call(this, e) || this).initMesh();
      return n;
    }
    c(e, t);
    var n = e.prototype;
    n.initMesh = function () {
      var t = new zi(8, 8, 8, 1, 1, 1);
      var e = new Ti();
      e.vertexShader = $i;
      e.fragmentShader = to;
      e.uniforms = {
        vColor: {
          type: "4f",
          value: [1, 0, 0, 1]
        },
        uSampler: {
          type: "t",
          value: null
        },
        uOpacity: {
          type: "1f",
          value: 1
        }
      };
      var n = new Kr(t, e);
      n.visible = false;
      n.setScale(-1, 1, 1);
      this.meshs = n;
    };
    n.setData = function (t) {
      var e = this;
      if (!t.image || t.image.length !== 6) {
        throw new Error("天空盒模型需要6张纹理，但只获取到 ".concat(t.image ? t.image.length : 0, "张"));
      }
      this.panoData = t;
      var n = this.meshs;
      qi(t.image).then(function (t) {
        n.material.uniforms.uSampler.value = t;
        n.visible = true;
        e.pano.emit({
          type: d.REFRESH,
          log: "[Refresh Log] 立方贴图加载完成， 渲染一帧"
        });
      }).catch(function (t) {
        return console.error(t);
      });
    };
    n.update = function () {};
    n.draw = function () {};
    return e;
  }(Ji);
  var no = function (t) {
    return t;
  };
  var ro = function (t) {
    return t * t;
  };
  var io = function (t) {
    return -t * (t - 2);
  };
  var oo = ro;
  var ao = io;
  var so = Object.freeze({
    __proto__: null,
    linear: no,
    reverse: function (t) {
      return 1 - t;
    },
    easeInQuad: ro,
    easeInCubic: function (t) {
      return Math.pow(t, 3);
    },
    easeOutQuad: io,
    easeOutCubic: function (t) {
      return Math.pow(t - 1, 3) + 1;
    },
    easeInOutQuad: function (t) {
      return t < 0.5 ? t * t * 2 : -2 * (t - 2) * t - 1;
    },
    easeInOutCubic: function (t) {
      return t < 0.5 ? 4 * Math.pow(t, 3) : 4 * Math.pow(t - 1, 3) + 1;
    },
    easeInOutSine: function (t) {
      return (1 - Math.cos(Math.PI * t)) / 2;
    },
    easeIn: oo,
    easeOut: ao
  });
  var uo = function () {};
  var ho = function () {
    function t(t, e, n) {
      var r = this;
      var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : no;
      this.from = undefined;
      this.to = undefined;
      this.duration = undefined;
      this.easingFn = undefined;
      this._isPlaying = false;
      this._autoTimer = null;
      this._startTime = null;
      this._onUpdateCallback = uo;
      this._onEndCallback = uo;
      this.start = function () {
        if (!r._isPlaying) {
          r._isPlaying = true;
          r._startTime = r.getNow();
        }
        return r;
      };
      this.stop = function () {
        r._isPlaying = false;
        return r;
      };
      this.startAndAutoUpdate = function () {
        if (r._isPlaying) {
          return r;
        }
        r.start();
        r._autoTimer = null;
        (function t() {
          r.update();
          r._autoTimer = requestAnimationFrame(t);
        })();
        return r;
      };
      this.onEnd = function (t) {
        if (typeof t == "function") {
          r._onEndCallback = t;
        } else {
          console.warn("[Warning] onUpdate required a funtion");
        }
        return r;
      };
      this.onUpdate = function (t) {
        if (typeof t == "function") {
          r._onUpdateCallback = t;
        } else {
          console.warn("[Warning] onUpdate required a funtion");
        }
        return r;
      };
      this.update = function () {
        if (!r._isPlaying) {
          return false;
        }
        var t = r.from;
        var e = r.to;
        var n = r.getNow();
        var i = r.easingFn;
        var o = r._startTime;
        if (o > n) {
          return false;
        }
        var a = (n - o) / r.duration;
        var s = t + (e - t) * i(a = r.duration === 0 || a > 1 ? 1 : a);
        r._onUpdateCallback(s);
        if (a === 1) {
          r.handleEnd();
        }
        return true;
      };
      this.from = t;
      this.to = e;
      this.duration = n;
      this.easingFn = i;
    }
    var e = t.prototype;
    e.getNow = function () {
      return Date.now();
    };
    e.handleEnd = function () {
      this._isPlaying = false;
      this._autoTimer = null;
      this._onEndCallback();
    };
    return t;
  }();
  var co = function (t, e, n) {
    var r = 0.5 * e;
    var i = 0.5 * n;
    return _t((t[0] - r) / r, (i - t[1]) / i);
  };
  var lo = function (t, e, n) {
    var r = 0.5 * e;
    var i = 0.5 * n;
    return _t((t[0] + 1) * r, (1 - t[1]) * i);
  };
  var fo = function (t, e, n, r) {
    var i = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 100;
    var o = sn();
    var a = co(t, n, r);
    var s = hn(a[0], a[1], i, 1);
    var u = Pe();
    var h = e.worldMatrix;
    Be(u, e.projectionMatrix);
    En(o, s, u);
    En(o, o, h);
    return o;
  };
  var po = function (t, e, n, r) {
    var i = arguments.length > 4 && arguments[4] !== undefined && arguments[4];
    var o = hn(e[0], e[1], e[2], 1);
    En(o, o, t.viewMatrix);
    if (o[2] > 0 && i !== true) {
      return null;
    }
    En(o, o, t.projectionMatrix);
    o[0] = o[0] / o[3];
    o[1] = o[1] / o[3];
    o[2] = o[2] / o[3];
    o[3] = 1;
    var a = _t(o[0], o[1]);
    return lo(a, n, r);
  };
  var vo = function (t, e, n, r) {
    var i = po(e, t, n, r) || [-1, -1];
    var o = xi(i, 2);
    var a = o[0];
    var s = o[1];
    var u = false;
    if (a >= 0 && a <= n && s >= 0 && s <= r) {
      u = true;
    }
    return u;
  };
  var mo = Object.freeze({
    __proto__: null,
    viewportToNormalizeProjection: co,
    normalizeProjectionToViewport: lo,
    viewportToWorld: fo,
    worldToViewport: po,
    isCoordsInView: vo
  });
  var go = function () {
    function t() {
      var e = this;
      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 500;
      this.getVertexs = function () {
        return e.vertexs;
      };
      this.getFacesVertex = function () {
        return e.facesVertex;
      };
      this.generateTextureCoord = function (n, r, i) {
        var o = e.facesVertex[Math.round(e.facesVertex.length / 2)];
        if (o) {
          for (var a = [], s = Math.pow(2, 5 - i), u = r % s, h = n % s, c = t.H_SEGS / e.cols, l = 1 / c, f = 1 / ((t.V_SEGS - 1) / e.rows), d = 0; d < o.length / 3; d++) {
            var p = d % (c + 1) * l;
            var v = Math.floor(d / (c + 1)) * f;
            p = p / s + 1 * u / s;
            v = v / s + 1 * h / s;
            if (i === 1) {
              v *= 2;
            }
            a.push(p, v);
          }
          return a;
        }
      };
      this.getFaceIndex = function (n) {
        var r = 0;
        var i = xi(n, 3);
        var o = i[0];
        var a = i[1];
        var s = i[2];
        var u = Math.round(180 * Math.atan(Math.abs(s) / Math.abs(o)) / Math.PI);
        if (o > 0) {
          if (s < 0) {
            u = 360 - u;
          }
        } else {
          u = s > 0 ? 180 - u : 180 + u;
        }
        u %= 360;
        r = a > e._x3 ? 7 : a > e._x2 ? 6 : a > e._x1 ? 5 : a > 0 ? 4 : a > -e._x1 ? 3 : a > -e._x2 ? 2 : a > -e._x3 ? 1 : 0;
        var h = Math.floor(u / 22.5);
        var c = t.H_SEGS;
        return [h, r, h + r * (c / (c / e.cols))];
      };
      this.viewportToSphereCoord = function (t, n, r, i) {
        var o = e.radius;
        var a = fo(t, i, n, r);
        var s = xi(a, 3);
        var u = s[0];
        var h = s[1];
        var c = s[2];
        var l = o / Math.sqrt(u * u + h * h + c * c);
        return [u * l, h * l, c * l];
      };
      this.getFaceVertex = function (n, r) {
        var i = t.H_SEGS / e.cols;
        var o = r + n * (t.H_SEGS / i);
        return e.facesVertex[o];
      };
      this.radius = n;
      this.rows = t.DEFAULT_COLS / 2;
      this.cols = t.DEFAULT_COLS;
      this.vertexs = null;
      this.facesVertex = [];
      this.facesVertexIndice = [];
      this.init();
    }
    var e = t.prototype;
    e.init = function () {
      var t = this.getSphereVertexInfo();
      this.facesVertexIndice = this.getSphereFacesIndices();
      this.vertexs = t.vertexs;
      this.facesVertex = t.facesVertex;
      this.calcConst();
    };
    e.calcConst = function () {
      var t = 360 / this.cols;
      this._x1 = Math.cos(g(3 * t)) * this.radius;
      this._x2 = Math.cos(g(2 * t)) * this.radius;
      this._x3 = Math.cos(g(1 * t)) * this.radius;
    };
    e.getSphereVertexInfo = function () {
      for (var e, n = [], r = [], i = this.radius, o = t.H_SEGS, a = t.V_SEGS, s = 360 / o, u = 180 / (a - 1), h = o / this.cols, c = o / h, l = 0, f = 0, d = [], p = 0; p < a; p++) {
        var v = Math.sin(g(p * u - 90)) * i;
        var m = Math.cos(g(p * u - 90)) * i;
        v = Math.round(100 * v) / 100;
        m = Math.round(100 * m) / 100;
        l = Math.floor(p / h);
        for (var y = 0; y < o; y++) {
          var _ = Math.cos(g(y * s)) * m;
          var x = Math.sin(g(y * s)) * m;
          _ = Math.round(100 * _) / 100;
          x = Math.round(100 * x) / 100;
          n.push(_, v, x);
          e = (f = Math.floor(y / h)) + l * c;
          if (l < this.rows) {
            if (!r[e]) {
              r[e] = [];
            }
            r[e].push(_, v, x);
          }
          if (l > 0 && p % h == 0) {
            var b = f + (l - 1) * c;
            r[b].push(_, v, x);
            if (y > 0 && y % h == 0 && r[b - 1]) {
              r[b - 1].push(_, v, x);
            }
            if (y === o - 1) {
              r[b].push(d[0], d[1], d[2]);
            }
          }
          if (f === 0 && y === 0) {
            d = [_, v, x];
          }
          if (y > 0 && y % h == 0 && r[e - 1]) {
            r[e - 1].push(_, v, x);
          }
          if (l < this.rows && y === o - 1) {
            r[e].push(d[0], d[1], d[2]);
          }
        }
      }
      return {
        vertexs: n,
        facesVertex: r
      };
    };
    e.getSphereFacesIndices = function () {
      for (var e = [], n = t.H_SEGS / this.cols, r = n + 1, i = 0; i < n; i++) {
        for (var o = 0; o < n; o++) {
          var a = i * r;
          var s = a + o + 1;
          var u = a + o + 1 + r;
          e.push(a + o, s, u);
          s = a + o + 1 + r;
          e.push(a + o, s, a + r + o);
        }
      }
      return e;
    };
    e.getSphereFacesIndicesByimageZoom = function (e) {
      for (var n = this, r = [], i = t.H_SEGS, o = Math.pow(2, 5 - e), a = i / this.cols + 1, s = a * a, u = function (t) {
          for (var e = function (e) {
              n.facesVertexIndice.forEach(function (n) {
                r.push(n + s * e + s * t * 2);
              });
            }, i = 0; i < o; i++) {
            e(i);
          }
        }, h = 0; h < o; h++) {
        u(h);
      }
      return r;
    };
    return t;
  }();
  go.DEFAULT_COLS = Math.pow(2, 4);
  go.H_SEGS = 64;
  go.V_SEGS = 33;
  var yo = function () {
    function t() {
      this._counter = 0;
      this._imageCollection = {};
    }
    var e = t.prototype;
    e.getImageInstance = function () {
      var t;
      for (var e in this._imageCollection) {
        if (this._imageCollection[e] && this._imageCollection[e]._free === true) {
          this._imageCollection[e]._free = false;
          return this._imageCollection[e];
        }
      }
      t = new Image();
      var n = this.getGUID();
      this._imageCollection[n] = t;
      return t;
    };
    e.freeImage = function (t) {
      if (t) {
        t._free = true;
        t.src = "";
        t.onload = t.onerror = null;
      }
    };
    e.getGUID = function () {
      this._counter++;
      return "img_".concat(this._counter);
    };
    return t;
  }();
  var _o = function () {
    function t(e, n) {
      var r = this;
      var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
      this.imageInstancePool = undefined;
      this.tileImagesCache = undefined;
      this.textureInfo = undefined;
      this.pano = undefined;
      this.udtVersion = undefined;
      this.cdnList = undefined;
      this.calcTileKey = function (t, e, n, r) {
        return "".concat(t, "_").concat(e, "_").concat(n, "_").concat(r);
      };
      this.loadImage = function (t, e, n, i) {
        var o = r.calcTileKey(t, e, n, i);
        var a = r.getTilesUrl(t, {
          x: e,
          y: n
        }, i);
        var s = r.tileImagesCache.getData(o);
        return new Promise(function (t, e) {
          if (s) {
            t(s._loaded ? s : null);
          } else {
            (s = r.imageInstancePool.getImageInstance()).crossOrigin = "anonymous";
            s._loaded = false;
            s.onload = function () {
              s._loaded = true;
              t(s);
            };
            s.onerror = function (t) {
              console.error("Tile ".concat(o, " load error => "), t);
              e(t);
            };
            s.src = a;
            r.tileImagesCache.setData(o, s);
          }
        });
      };
      this.loadTexture = function (t, e, n, i) {
        var o = r.calcTileKey(t, e, n, i);
        var a = r.textureInfo.getData(o);
        return new Promise(function (s, u) {
          if (a && a.loaded) {
            s(a);
          } else {
            r.loadImage(t, e, n, i).then(function (t) {
              if (!t) {
                return null;
              }
              var e = new ui(t);
              if (i !== 1) {
                r.textureInfo.setData(o, e);
              }
              s(e);
            }).catch(function (t) {
              console.error("[TextureManager] loadTexture fail => ".concat(t));
              u(null);
            });
          }
        });
      };
      this.loadTopoTexture = function (t) {
        var e = 0;
        var n = new Image();
        return new Promise(function (r) {
          n.onload = function () {
            var t = new ui(n);
            t.flipY = false;
            r(t);
          };
          n.onerror = function () {
            if (e < 2) {
              e++;
              n.src = "".concat(t, "&random=").concat(new Date().getTime());
            } else {
              r(null);
            }
          };
          n.crossOrigin = "anonymous";
          n.src = t;
        });
      };
      this.clear = function () {
        r.textureInfo.clear();
      };
      this.pano = e;
      this.udtVersion = i;
      this.cdnList = n || e.opts.tileBaseUrls;
      this.imageInstancePool = new yo();
      this.tileImagesCache = new A(t.MAX_TILE_CACHED, {
        clearCallback: function (t) {
          r.imageInstancePool.freeImage(t);
        }
      });
      this.textureInfo = new A(t.MAX_TILE_CACHED, {
        clearCallback: function (t) {
          t.destory();
        }
      });
    }
    var e = t.prototype;
    e.getRandomCDN = function () {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var e = t.length;
      return t[Math.floor(Math.random() * e)];
    };
    e.getTilesUrl = function (e, n, r) {
      return this.getRandomCDN(this.cdnList) + (t.TILE_URL_TEMPLATE + "&".concat($("/", {
        isCounter: true
      }))).replace("{udt}", this.udtVersion).replace("{sid}", e).replace("{x}", "".concat(n.x)).replace("{y}", "".concat(n.y)).replace("{zoom}", "".concat(r));
    };
    return t;
  }();
  _o.MAX_TILE_CACHED = 160;
  _o.TILE_URL_TEMPLATE = "?qt=pdata&sid={sid}&pos={y}_{x}&z={zoom}&udt={udt}&from=H5";
  var xo = ["attribute vec2 uvBack;", "varying mediump vec2 vTextureCoordBack;", "varying mediump vec2 vTextureCoord;", "void main(void) {", "    gl_Position = mvpMatrix * vec4(position, 1.0);", "    vTextureCoordBack = uvBack;", "    vTextureCoord = uv;", "}"].join("\n");
  var bo = ["precision mediump float;", "varying vec2 vTextureCoordBack;", "varying vec2 vTextureCoord;", "uniform sampler2D uSamplerBack;", "uniform sampler2D uSampler;", "uniform bool uDrawThumb;", "uniform bool uDrawBack;", "uniform float uAlpha;", "void main(void) {", "    if (uDrawThumb) {", "        gl_FragColor = texture2D(uSamplerBack, vTextureCoordBack);", "        return;", "    }", "    if (uAlpha == 1.0) {", "        gl_FragColor = texture2D(uSampler, vTextureCoord);", "        return;", "    }", "    if (uDrawBack) {", "        gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha + texture2D(uSamplerBack, vTextureCoordBack) * (1.0 - uAlpha);", "    } else {", "        vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));", "        gl_FragColor =  vec4(textureColor.rgb, textureColor.a * uAlpha);", "    }", "}"].join("\n");
  var Mo = ["varying highp vec2 vTextureCoord;", "void main(void) {", "    gl_Position = mvpMatrix * vec4(position, 1.0);", "    vTextureCoord = uv;", "}"].join("\n");
  var wo = ["precision mediump float;", "uniform sampler2D uSampler;", "varying highp vec2 vTextureCoord;", "void main(void) {", "    gl_FragColor = texture2D(uSampler, vTextureCoord);", "}"].join("\n");
  var Eo = ["varying highp vec2 vTextureCoord;", "void main(void) {", "    gl_Position = mvpMatrix * vec4(position, 1.0);", "    vTextureCoord = uv;", "}"].join("\n");
  var To = ["uniform sampler2D uSampler;", "uniform float uOpacity;", "varying vec2 vTextureCoord;", "void main(void){", "    vec4 textureColor = texture2D(uSampler, vTextureCoord);", "    gl_FragColor = vec4(textureColor.rgb, textureColor.a * uOpacity);", "}"].join("\n");
  var Ao = ["varying highp vec3 vTextureCoord;", "void main(void){", "   gl_Position = mvpMatrix  * vec4(position, 1.0);", "   vTextureCoord = vec3(uv, 1.0) * length(position);", "}"].join("\n");
  var Co = ["uniform sampler2D uSampler;", "uniform float uOpacity;", "varying vec3 vTextureCoord;", "uniform bool showDebugLine;", "uniform vec4 vColor;", "void main(void){", "   if (!showDebugLine) {", "       vec4 textureColor = texture2DProj(uSampler, vTextureCoord);", "       gl_FragColor = vec4(textureColor.rgb, textureColor.a * uOpacity);", "   } else {", "       gl_FragColor = vec4(vColor.rgb, vColor.a);", "   }", "}"].join("\n");
  var Ro = function () {
    function t(e, n, r, i) {
      this.nodes = undefined;
      this.level = undefined;
      this.key = undefined;
      this.nodes = [];
      this.level = e;
      this.key = "".concat(r, "_").concat(i);
      if (e < n) {
        this.nodes[0] = new t(e + 1, n, 2 * r, 2 * i);
        this.nodes[1] = new t(e + 1, n, 2 * r, 2 * i + 1);
        this.nodes[2] = new t(e + 1, n, 2 * r + 1, 2 * i);
        this.nodes[3] = new t(e + 1, n, 2 * r + 1, 2 * i + 1);
      }
    }
    var e = t.prototype;
    e.hasNodes = function () {
      return this.nodes.length > 0;
    };
    e.getNodeKeysByLevel = function (t) {
      if (t < this.level) {
        console.warn("指定节点".concat(t, " 不在当前节点").concat(this.level, "范围内！"));
        return [];
      }
      if (this.level === t) {
        return [this.key];
      }
      for (var e = [], n = 0; n < this.nodes.length; n++) {
        if (Object.prototype.hasOwnProperty.call(this.nodes, n)) {
          var r = this.nodes[n];
          if (this.level === t - 1) {
            e.push(r.key);
          } else if (r.hasNodes()) {
            var i = r.getNodeKeysByLevel(t);
            e.push.apply(e, mi(i));
          }
        }
      }
      return e;
    };
    return t;
  }();
  var So = function (t) {
    function e(e) {
      var n;
      (n = t.call(this, e) || this).name = "SphereRender";
      n.sphere = undefined;
      n.textureManager = undefined;
      n.imgColsRows = undefined;
      n.curThumbTexture = undefined;
      n.meshCache = {};
      n.tileInfoCache = {};
      n.imgRange = undefined;
      n.faceRange = undefined;
      n.hitTile = undefined;
      n.setData = function (t) {
        n.panoData = t;
        n.curThumbTexture = null;
        n.loadThumbTextures(t.panoId);
      };
      n.update = function () {
        n.updateRangeInfo();
        n.checkAndLoadTiles();
      };
      n.checkAndLoadTiles = function () {
        if (n.curThumbTexture && n.panoData) {
          var t = n.panoData.panoId;
          var e = n.camera;
          var r = n.imgColsRows[n._imgZoom];
          var i = r.cols;
          var o = i - 1;
          var a = r.rows - 1;
          var s = n.pano.getContainerSize();
          var u = s.width;
          var h = s.height;
          var c = false;
          var l = [];
          var f = xi(n.imgRange, 4);
          var d = f[0];
          var p = f[1];
          var v = f[2];
          var m = f[3];
          if (vo(Vt(0, 100, 0), e, u, h)) {
            for (var g = 0; g <= v; g++) {
              for (var y = 0; y <= o; y++) {
                n.checkAndLoadTile(t, y, g, n._imgZoom);
                l.push([g, y]);
              }
            }
            if (v < m) {
              v += 1;
              c = true;
            }
          } else if (vo(Vt(0, -100, 0), e, u, h)) {
            for (var _ = m; _ <= a; _++) {
              for (var x = 0; x <= o; x++) {
                n.checkAndLoadTile(t, x, _, n._imgZoom);
                l.push([_, x]);
              }
            }
            if (v < m) {
              m -= 1;
              c = true;
            }
          } else {
            c = true;
          }
          if (c === true) {
            if (p > o) {
              p = o;
            }
            for (var b = d; b <= p; b++) {
              for (var M = v; M <= m; M++) {
                var w = b < 0 ? b + i : b;
                n.checkAndLoadTile(t, w, M, n._imgZoom);
                l.push([M, w]);
              }
            }
          }
          n.hitTile = l;
          l.forEach(function (t) {
            var e = xi(t, 2);
            var r = e[0];
            var i = e[1];
            var o = "".concat(r, "_").concat(i, "_").concat(n._imgZoom);
            if (n.tileInfoCache[o] === undefined) {
              var a = new Ro(n._imgZoom, 5, r, i).getNodeKeysByLevel(5);
              n.tileInfoCache[o] = a;
            }
          });
        }
      };
      n.draw = function () {
        var t = n.meshs;
        if (!n.faceRange || !n.curThumbTexture) {
          return false;
        }
        t.children = [];
        for (var e = function (e, r) {
            var i = n.curThumbTexture;
            var o = n.textureManager.calcTileKey(n.panoData.panoId, e, r, n._imgZoom);
            var a = n.textureManager.textureInfo.getData(o);
            var s = false;
            var u = null;
            if (a) {
              if (!(u = a).finished && u.aniInfo && u.aniInfo) {
                u.aniInfo.update();
              }
            } else if (i) {
              s = true;
              u = i;
            }
            if (u) {
              var h = "".concat(r, "_").concat(e, "_").concat(n._imgZoom);
              var c = n.meshCache[h];
              if (!c) {
                if (!(c = n.createTileMesh(r, e))) {
                  return;
                }
                n.meshCache[h] = c;
              }
              if (!c.material) {
                return;
              }
              var l = c.material.uniforms;
              l.uSamplerBack.value = i;
              if (s) {
                l.uDrawThumb.value = true;
              } else {
                l.uDrawThumb.value = false;
                l.uSampler.value = u;
                l.uAlpha.value = u.alpha;
              }
              t.add(c);
            }
          }, r = 0; r < n.hitTile.length; r++) {
          var i = xi(n.hitTile[r], 2);
          var o = i[0];
          e(i[1], o);
        }
        return true;
      };
      n.pano = e;
      n.sphere = new go(e.opts.radius);
      n.textureManager = new _o(e);
      n.imgColsRows = function () {
        for (var t = [], e = 0; e <= 5; e++) {
          t[e] = e < 2 ? {
            cols: 1,
            rows: 1
          } : {
            cols: Math.pow(2, e - 1),
            rows: Math.pow(2, e - 1) / 2
          };
        }
        return t;
      }();
      n.curThumbTexture = null;
      n.meshs = new Kr();
      return n;
    }
    c(e, t);
    var n = e.prototype;
    n.checkAndLoadTile = function (t, e, n, r) {
      var i = this;
      var o = this.textureManager;
      var a = o.calcTileKey(t, e, n, r);
      if (o.textureInfo.getData(a) !== undefined !== true) {
        this.textureManager.loadTexture(t, e, n, r).then(function (t) {
          if (t && !t.done) {
            t.aniInfo = i.createTextureAnimation(t);
            t.done = true;
            i.pano.dispatchEvent({
              type: d.REFRESH,
              log: "[Refresh Log] 瓦片加载完成， 渲染一帧"
            });
          }
        });
      }
    };
    n.loadThumbTextures = function (t) {
      var e = this;
      this.textureManager.loadTexture(t, 0, 0, 1).then(function (t) {
        e.curThumbTexture = t;
        e.pano.dispatchEvent({
          type: d.THUMB_LOADED
        });
        e.pano.dispatchEvent({
          debug: true,
          type: d.REFRESH,
          log: "[Refresh Log] 缩略图加载完毕，渲染一帧"
        });
      });
    };
    n.createTextureAnimation = function (t) {
      var e = this;
      t.alpha = 0;
      return new ho(0, 1, 300).onUpdate(function (n) {
        t.alpha = n;
        e.pano.dispatchEvent({
          debug: true,
          type: d.REFRESH,
          log: "[Refresh Log] 纹理清晰度渐变动画，渲染一帧"
        });
      }).onEnd(function () {
        t.finished = true;
      }).start();
    };
    n.createTileMesh = function (t, e) {
      var n = new Ti();
      var r = new Zr();
      n.depthTest = false;
      n.vertexShader = xo;
      n.fragmentShader = bo;
      n.uniforms = {
        uSampler: {
          type: "t",
          value: null
        },
        uSamplerBack: {
          type: "t",
          value: null
        },
        uDrawThumb: {
          type: "1i",
          value: 1
        },
        uDrawBack: {
          type: "1i",
          value: 1
        },
        uAlpha: {
          type: "1f",
          value: 1
        }
      };
      if (!this.setGeometryAttrib(r, t, e)) {
        return null;
      }
      var i = new Kr(r, n);
      i.name = "tile-mesh";
      return i;
    };
    n.setGeometryAttrib = function (t, e, n) {
      var r = "".concat(e, "_").concat(n, "_").concat(this._imgZoom);
      var i = this.tileInfoCache[r];
      if (!i) {
        return false;
      }
      for (var o = [], a = [], s = [], u = 0; u < i.length; u++) {
        var h = i[u].split("_");
        var c = this.sphere.rows;
        var l = Number(h[1]);
        var f = c - 1 - Number(h[0]);
        o.push.apply(o, mi(this.sphere.getFaceVertex(f, l)));
        a.push.apply(a, mi(this.sphere.generateTextureCoord(f, l, this._imgZoom)));
        s.push.apply(s, mi(this.sphere.generateTextureCoord(f, l, 1)));
      }
      var d = this.sphere.getSphereFacesIndicesByimageZoom(this._imgZoom);
      t.setAttribute("uv", new Gr(a, 2));
      t.setAttribute("uvBack", new Gr(s, 2));
      t.setAttribute("position", new Gr(o, 3));
      t.setIndexes(d);
      return true;
    };
    n.getTileBoundary = function () {
      var t = this.pano.getContainerSize();
      var e = t.width;
      var n = t.height;
      var r = _t(0, 0);
      var i = _t(e, 0);
      var o = _t(0, n);
      var a = _t(e, n);
      var s = _t(0.5 * e, 0);
      var u = _t(0.5 * e, n);
      var h = _t(0, 0.5 * n);
      var c = _t(e, 0.5 * n);
      var l = this.getSpherePosition(r);
      var f = this.getSpherePosition(i);
      var d = this.getSpherePosition(o);
      var p = this.getSpherePosition(a);
      var v = this.getSpherePosition(s);
      var m = this.getSpherePosition(u);
      var g = this.getSpherePosition(h);
      var y = this.getSpherePosition(c);
      var _ = Math.max(l[1], v[1], f[1]);
      var x = Math.min(d[1], m[1], p[1]);
      var b = [l[0], g[0], d[0], v[0]];
      var w = [f[0], y[0], p[0], m[0]];
      var E = Math.min.apply(Math, b);
      var T = Math.max.apply(Math, w);
      var A = M(b);
      var C = M(w);
      var R = this.sphere.cols;
      var S = R / 2;
      if (A.max - A.min > S) {
        E = Math.min.apply(Math, mi(b.filter(function (t) {
          return t > S;
        })));
      }
      if (C.max - C.min > S) {
        T = Math.max.apply(Math, mi(w.filter(function (t) {
          return t < S;
        })));
      }
      if (E > T) {
        E -= R;
      }
      var P = this.getImgIndexByFaceColRow(E, _);
      var D = xi(P, 2);
      var O = D[0];
      var I = D[1];
      var L = this.getImgIndexByFaceColRow(T, x);
      var B = xi(L, 2);
      return [[E, T, _, x], [O, B[0], I, B[1]]];
    };
    n.updateRangeInfo = function () {
      var t = this.getTileBoundary();
      var e = xi(t, 2);
      var n = e[0];
      var r = e[1];
      this.imgRange = r;
      this.faceRange = n;
    };
    n.getImgIndexByFaceColRow = function (t, e, n) {
      n = n || this._imgZoom;
      var r = Math.pow(2, 5 - n);
      var i = Math.floor(t / r);
      var o = Math.floor(e / r);
      return [i, o = this.imgColsRows[n].rows - o - 1, i + o * go.DEFAULT_COLS / r];
    };
    n.normalizeNum = function (t, e) {
      for (var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0, r = t; r < n;) {
        r += e;
      }
      return r %= e;
    };
    n.getSpherePosition = function (t) {
      var e = this.camera;
      var n = this.pano.getContainerSize();
      var r = n.width;
      var i = n.height;
      var o = this.sphere.viewportToSphereCoord(t, r, i, e);
      var a = this.sphere.getFaceIndex(o);
      var s = xi(a, 2);
      return _t(s[0], s[1]);
    };
    n.generateBackThumb = function (t) {
      if (t) {
        var e = this.pano;
        var n = e.getContainerSize();
        var r = n.width;
        var i = n.height;
        var o = "//apisv0.bdimg.com/?udt=20140616&qt=pdata&pos=0_0&z=2&sid=".concat(t, "&from=H5&").concat($("/", {
          isCounter: true
        }));
        var a = e.getPanes().tileLayer;
        a.style.backgroundImage = "url(\"" + o + "\")";
        a.style.backgroundPosition = "50% 50%";
        a.style.backgroundSize = "150% 150%";
        a.style.width = "".concat(r, "px");
        a.style.height = "".concat(i, "px");
      }
    };
    o(e, [{
      key: "_imgZoom",
      get: function () {
        return this.pano.imageZoom;
      }
    }]);
    return e;
  }(Ji);
  var Po = [10, -20, 30, 10, -20, 10, -10, -20, 10, -10, -20, 30].map(function (t) {
    return t === -20 ? -20 : 1.8 * t;
  });
  var Do = [10, -22, 30, 10, -22, 10, -10, -22, 10, -10, -22, 30].map(function (t) {
    return t === -22 ? -22 : 1.8 * t;
  });
  var Oo = [1.8, -20, 24.9, 1.8, -20, 16.3, -1.8, -20, 16.3, -1.8, -20, 24.9].map(function (t) {
    return t === -20 ? -20 : 1.8 * t;
  });
  var Io = [0, 0, 0, 0.5, 0.25, 0.5, 0.25, 0];
  var Lo = function () {
    function t(t, e, n) {
      var r = this;
      this.mesh = undefined;
      this.material = undefined;
      this.linkData = undefined;
      this._pano = undefined;
      this.northDir = undefined;
      this.yAxisDis = undefined;
      this.isPosInArrow = function (t, e, n, i, o) {
        var a = _t(t, e);
        var s = fo(a, n, i, o, -1);
        var u = 200 * s[0];
        var h = 200 * s[1];
        var c = 200 * s[2];
        var l = r.yAxisDis / h;
        if (l < 0) {
          return false;
        }
        var f = [u * l, h * l, c * l];
        return r.isHitLink(f);
      };
      this._pano = t;
      this.linkData = e;
      this.northDir = n;
      this.yAxisDis = 0;
      this.linkData.refinedDir = _((e.topoDir || 0) + this.northDir);
      this.material = this.createArrowMaterial();
      this.mesh = this.initMesh();
      this.changePose();
    }
    var e = t.prototype;
    e.initMesh = function () {
      var t = this.createGeometry();
      var e = new Kr(t, this.material);
      e.visible = false;
      e.name = "link-mesh";
      return e;
    };
    e.createArrowMaterial = function () {
      var t = new Ti();
      t.depthTest = false;
      t.vertexShader = Mo;
      t.fragmentShader = wo;
      t.uniforms = {
        uSampler: {
          type: "t",
          value: null
        }
      };
      return t;
    };
    e.setTopoTexture = function (t) {
      if (t.isTexture) {
        this.material.uniforms.uSampler.value = t;
      }
    };
    e.setVisible = function (t) {
      this.mesh.setVisible(t, true);
    };
    e.createGeometry = function () {
      var t = new Zr();
      var e = this.getTextCoord(this.linkData.topoDir);
      var n = [].concat(Do, Po, Oo);
      var r = [].concat([0.5, 0, 0.5, 0.5, 1, 0.5, 1, 0], [0, 0, 0, 0.5, 0.5, 0.5, 0.5, 0], e);
      var i = [].concat([0, 1, 2, 0, 2, 3], [4, 5, 6, 4, 6, 7], [8, 9, 11, 10, 11, 9]);
      t.setAttribute("position", new Gr(n, 3));
      t.setAttribute("uv", new Gr(r, 2));
      t.setIndexes(i);
      return t;
    };
    e.changePose = function (t) {
      t = t || this.mesh;
      var e = 50;
      var n = -30;
      var r = this._pano.getPov().pitch;
      var i = this.linkData.refinedDir;
      e += 20 * this._pano.getZoom();
      if (r < 0) {
        e *= (90 - (r = Math.abs(r))) / 90;
        n -= 20 * r / 90;
      }
      var o = Math.cos(g(i)) * e;
      var a = Math.sin(g(i)) * e;
      this.yAxisDis = n + -20;
      t.setPosition(o, n, a);
      t.rotateY(-_(i - 90));
      t.rotateX(-5);
      t.updateWorldMatrix(true);
    };
    e.getTextCoord = function (t) {
      t = (t + 360) % 360;
      var e = Math.ceil(Math.floor(t / 22.5) / 2);
      if (e === 8) {
        e = 0;
      }
      for (var n = Io.slice(0), r = Math.floor(e / 2), i = e % 2, o = 0; o < n.length; o++) {
        if (o % 2 == 0) {
          n[o] += 0.25 * r;
          n[o] = 0.5 * n[o];
        } else {
          n[o] += 0.5 * i;
          n[o] = 0.5 * n[o] + 0.5;
        }
      }
      return n;
    };
    e.isHitLink = function (t) {
      var e = t[0];
      var n = t[2];
      var r = this.mesh.worldMatrix;
      var i = Vt(Po[0], Po[1], Po[2]);
      var o = Vt(Po[6], Po[7], Po[8]);
      var a = Vt((i[0] + o[0]) / 2, (i[1] + o[1]) / 2, (i[2] + o[2]) / 2);
      ee(a, a, r);
      return Math.abs(e - a[0]) < 18 && Math.abs(n - a[2]) < 18;
    };
    return t;
  }();
  var Bo = function (t) {
    function e(e) {
      var n;
      (n = t.call(this, e) || this).name = "PanoLinkRender";
      n.linkVisible = true;
      n.textureManager = undefined;
      n.linkInfos = [];
      n.setData = function (t) {
        if (t && (o = t.getTopos, a = Object.prototype.toString.call(o) === "[object Function]", s = Object.prototype.toString.call(o) === "[object AsyncFunction]", a || s)) {
          n.reset();
          var e = t.getTopos();
          var r = t.northDir;
          var i = t.panoType === p.TYPE_STREET;
          if (e.length && i) {
            n.linkInfos = e.map(function (t) {
              return new Lo(n.pano, t, r);
            });
            n.meshs = n.linkInfos.map(function (t) {
              return t.mesh;
            });
            n.loadTextures();
            n.setVisible(true);
          }
        }
        var o;
        var a;
        var s;
      };
      n.clickChecker = function (t, e) {
        if (n.linkVisible) {
          var r = n.getIdByTouchPos(t, e);
          if (r) {
            n.setVisible(false);
            n.pano.dispatchEvent({
              type: d.LINK_CLICK,
              id: r
            });
            n.pano.setId(r, {
              animation: true
            });
          }
          return !r;
        }
      };
      n.pano = e;
      n.meshs = [];
      n.textureManager = new _o(e);
      return n;
    }
    c(e, t);
    var n = e.prototype;
    n.reset = function () {
      this.meshs = [];
      this.linkInfos = [];
    };
    n.update = function () {
      this.linkInfos.forEach(function (t) {
        t.changePose();
      });
    };
    n.setVisible = function (t) {
      var e = this.linkInfos;
      if (!(e.length < 1)) {
        var n = this.pano.opts.linksControl;
        var r = false;
        if (n === true) {
          r = t;
        }
        this.linkVisible = r;
        e.forEach(function (t) {
          return t.setVisible(r);
        });
      }
    };
    n.draw = function () {};
    n.loadTextures = function () {
      var t = this;
      var e = this.pano.opts.imgPath ? "".concat(this.pano.opts.imgPath, "topo_arrow.png") : p.TOPO_ARROW_TEXTURE;
      this.textureManager.loadTopoTexture(e).then(function (e) {
        if (e) {
          t.linkInfos.forEach(function (t) {
            t.setTopoTexture(e);
          });
        }
      });
    };
    n.getIdByTouchPos = function (t, e) {
      var n = this;
      var r = null;
      if (!this.linkInfos.length) {
        return r;
      }
      var i = this.pano.getContainerSize();
      var o = i.width;
      var a = i.height;
      var s = this.linkInfos.filter(function (r) {
        return r.isPosInArrow(t, e, n.camera, o, a);
      });
      if (s.length) {
        r = s[0].linkData.panoId;
      }
      return r;
    };
    return e;
  }(Ji);
  var ko = function () {
    function t(t, e, n) {
      var r = this;
      this.start = function () {
        r.fadeAni.start();
        r._pano.dispatchEvent({
          debug: true,
          log: "淡出动画，渲染一帧",
          type: d.REFRESH
        });
      };
      this.update = function () {
        r.fadeAni.update();
      };
      this._pano = t;
      this.gl = this._pano.gl;
      this.snapshot = e;
      this.scene = this.initScene();
      this.camera = this.initCamera();
      this.fadeAni = new ho(1, 0, 600).onUpdate(function (t) {
        r.material.uniforms.uOpacity.value = t;
        r._pano.dispatchEvent({
          type: d.REFRESH
        });
      }).onEnd(function () {
        if (n) {
          n();
        }
        r._pano.dispatchEvent({
          type: d.REFRESH,
          debug: true,
          log: "淡出动画结束，渲染一帧"
        });
      });
    }
    var e = t.prototype;
    e.initScene = function () {
      var t = new Qr();
      var e = this._pano.getContainerSize();
      var n = e.width;
      var r = e.height;
      var i = new ji(n, r);
      var o = this.initMaterial();
      var a = new Kr(i, o);
      t.add(a);
      return t;
    };
    e.initMaterial = function () {
      var t = new Ti();
      t.depthTest = false;
      t.vertexShader = Eo;
      t.fragmentShader = To;
      t.uniforms = {
        uSampler: {
          type: "t",
          value: this.snapshot
        },
        uOpacity: {
          type: "1f",
          value: 1
        }
      };
      this.material = t;
      return t;
    };
    e.initCamera = function () {
      var t = this._pano.getContainerSize();
      var e = t.width / 2;
      var n = t.height / 2;
      return new Xi(-e, e, n, -n, 0, 11000);
    };
    return t;
  }();
  var Uo = function () {
    function t(t, e, n) {
      var r = this;
      this.start = function () {
        r.waveAni.start();
        r._pano.dispatchEvent({
          debug: true,
          log: "淡出动画，渲染一帧",
          type: d.REFRESH
        });
      };
      this.update = function () {
        r.waveAni.update();
      };
      this._pano = t;
      this.gl = this._pano.gl;
      this.snapshot = e;
      this.scene = this.initScene();
      this.camera = this.initCamera();
      this.waveAni = new ho(0, 1, 800).onUpdate(function (t) {
        r.material.uniforms.progress.value = t;
        r.material.uniforms.uOpacity.value = 1 - t;
        r._pano.dispatchEvent({
          type: d.REFRESH
        });
      }).onEnd(function () {
        if (n) {
          n();
        }
        r._pano.dispatchEvent({
          type: d.REFRESH,
          debug: true,
          log: "淡出动画结束，渲染一帧"
        });
      });
    }
    var e = t.prototype;
    e.initCamera = function () {
      var t = this._pano.getContainerSize();
      var e = t.width / 2;
      var n = t.height / 2;
      return new Xi(-e, e, n, -n, 0, 11000);
    };
    e.initScene = function () {
      var t = new Qr();
      var e = this._pano.getContainerSize();
      var n = e.width;
      var r = e.height;
      var i = new ji(n, r);
      var o = this.initMaterial();
      var a = new Kr(i, o);
      t.add(a);
      return t;
    };
    e.initMaterial = function () {
      var t = new Ti();
      var e = this._pano.getContainerSize();
      var n = e.width;
      var r = e.height;
      t.depthTest = false;
      t.vertexShader = Eo;
      t.fragmentShader = "\n    uniform float aspect;\n    uniform float radius;\n    uniform float amp;\n    uniform float band;\n    uniform float waves;\n    uniform float speed;\n    uniform float progress;\n    uniform vec2 uCenter;\n    uniform sampler2D uSampler;\n    uniform float uOpacity;\n\n    varying vec2 vTextureCoord;\n\n    void main() {\n        vec2 tc = vTextureCoord;\n        vec2 uv = vec2(0.0, 0.0);\n        vec2 p;\n        float len;\n        vec2 uv_offset;\n        float wave_width = band * radius;\n\n        p = (tc - uCenter);\n        p.x = p.x * aspect;\n        len = length(p);\n\n        float current_radius = radius * progress;\n        float damp_factor = 1.0;\n        if (progress > .5) {\n            damp_factor = (1.0 - progress) * 2.0;\n        }\n\n        float cut_factor = clamp(wave_width * damp_factor - abs(current_radius - len), 0.0, 1.0);\n        float waves_factor = waves * len / radius;\n        uv_offset = (p / len) * cos((waves_factor - progress * speed) * 3.14) * amp * cut_factor;\n\n        uv += uv_offset;\n\n        vec4 t_image = texture2D(uSampler, fract(tc + uv));\n\n        // gl_FragColor = t_image;\n        gl_FragColor = vec4(t_image.rgb, t_image.a * uOpacity);\n    }\n";
      t.uniforms = {
        uSampler: {
          type: "t",
          value: this.snapshot
        },
        uCenter: {
          type: "2f",
          value: [0.5, 0.5]
        },
        uOpacity: {
          type: "1f",
          value: 1
        },
        progress: {
          type: "1f",
          value: 0
        },
        speed: {
          type: "1f",
          value: 4
        },
        waves: {
          type: "1f",
          value: 14
        },
        band: {
          type: "1f",
          value: 0.3
        },
        amp: {
          type: "1f",
          value: 0.3
        },
        aspect: {
          type: "1f",
          value: n / r
        },
        radius: {
          type: "1f",
          value: 1
        }
      };
      this.material = t;
      return t;
    };
    return t;
  }();
  var No = function () {
    function t(t, e, n, r) {
      var i = this;
      this.startAni = function () {
        i.animation.start();
      };
      this.update = function () {
        i.animation.update();
      };
      this.pano = t;
      this.distance = n;
      this.refinedDir = e;
      this.camera = this.pano.camera;
      this.cameraBase = this.pano.camera.clone();
      this.handleEnd = r;
      this.initAni();
    }
    t.prototype.initAni = function () {
      var t = this;
      var e = this.distance;
      var n = this.refinedDir;
      var r = Math.cos(g(n));
      var i = Math.sin(g(n));
      this.animation = new ho(0, 1, 400, so.easeOutQuad).onUpdate(function (n) {
        var o = e * n;
        var a = r * o;
        var s = i * o;
        t.camera.setPosition(a, 0, s);
        t.pano.dispatchEvent({
          debug: true,
          type: d.REFRESH,
          log: "[Refresh Log] 前进动画， 渲染一帧"
        });
      }).onEnd(function () {
        if (t.handleEnd) {
          t.handleEnd();
        }
      });
    };
    return t;
  }();
  var Fo = function (t, e, n, r) {
    this.x = t || 0;
    this.y = e || 0;
    this.width = n || 0;
    this.height = r || 0;
  };
  var jo = function (t, e) {
    var n = this;
    this.angleDegreeDelta = function (t, e) {
      var n = Math.abs(t - e);
      return n > 180 ? 360 - n : n;
    };
    this.getRoad = function (t, e, n, r, i) {
      for (var o, a = [], s = [[-t / 2, -e, -10], [-t / 2, -e, -20], [t / 2, -e, -10], [t / 2, -e, -20]], u = s.length, h = 0; h < u; h++) {
        ee(o = s[h], o, n);
        a[h] = {
          x: o[0] * r * 0.5,
          y: -o[1] * i * 0.5
        };
      }
      return a;
    };
    this.getIntersection = function (t, e, n, r) {
      if (t.x === e.x || n.x === r.x) {
        return null;
      }
      var i = (e.y - t.y) / (e.x - t.x);
      var o = (r.y - n.y) / (r.x - n.x);
      if (i === o) {
        return null;
      }
      var a = (o * n.x - i * t.x + t.y - n.y) / (o - i);
      return {
        x: a,
        y: i * (a - t.x) + t.y
      };
    };
    this.calculateVanishPoint = function (t, e, r, i) {
      var o = n.getIntersection(t[0], t[1], t[2], t[3]);
      return o === null ? null : (o.x += r * e * 0.5, o.y += i * e * 0.5, o);
    };
    this.getOuterRect = function (t, e, n) {
      return new Fo(t * (n - 1) * 0.5, e * (n - 1) * 0.5, t, e);
    };
    this.transformPoint = function (t, e, n) {
      return t && t.x !== undefined && t.y !== undefined ? {
        x: t.x + e,
        y: t.y + n
      } : t;
    };
    this.getInnerRect = function (t, e, r, i, o) {
      var a = n.transformPoint(t, 0.5 * -r * o, 0.5 * -i * o);
      var s = n.transformPoint(a, 0, 20);
      var u = n.transformPoint(a, 10, 20);
      var h = n.getIntersection(e[0], e[1], s, u);
      var c = n.getIntersection(e[2], e[3], s, u);
      var l = n.transformPoint(h, 0, -70);
      var f = new Fo(l.x + r * o * 0.5, l.y + i * o * 0.5, c.x - h.x, 70);
      f = n.fixInnerRectPosition(f, t);
      return f = n.fixInnerRectSize(f, t, r);
    };
    this.fixInnerRectPosition = function (t, e) {
      var n = t;
      var r = (e.x - t.x) / t.width;
      var i = 0;
      if (r > 0.7) {
        i = r - 0.7;
      }
      if (r < 0.3) {
        i = 0.3 - r;
      }
      n.x = n.x + n.width * i;
      return n;
    };
    this.fixInnerRectSize = function (t, e, n) {
      var r;
      var i;
      var o;
      var a;
      var s = t;
      if (s.width / n > 0.12) {
        a = (o = 0.12 * n) * (s.width / s.height);
        r = s.x + (s.width - o) * (e.x - s.x) / s.width;
        i = s.y + (s.height - a) * (e.y - s.y) / s.height;
        s = new Fo(r, i, o, a);
      }
      var u = s.width / s.height;
      a = s.height;
      if (u > 1.2) {
        a = s.height * u / 1.2;
      }
      if (u < 0.9) {
        a = s.height * u / 0.9;
      }
      i = s.y + s.height - a;
      s.height = a;
      s.y = i;
      return s;
    };
    this.panoData = t.panoData;
    this.camera = t.camera;
    this.projectionMatrix = this.camera.projectionMatrix;
    this.fov = g(this.camera.fov);
    this.traverseDir = e;
    this.cameraHeading = t.getPov().heading || 0;
    this.isMovingForward = this.angleDegreeDelta(this.cameraHeading, this.traverseDir) <= 90;
    this.roadWith = Math.min(1.5 * this.panoData.getRoadWidth(), 10);
    this.deviceHeight = this.panoData.deviceHeight || 2.2;
    this.panoWidth = t._container.clientWidth;
    this.panoHeight = t._container.clientHeight;
    var r = this.angleDegreeDelta(this.cameraHeading, this.traverseDir) > 45;
    this.snapshotRatio = r ? 1 : 1.8;
    this.projectionRoadInfos = this.getRoad(this.roadWith, this.deviceHeight, this.projectionMatrix, this.panoWidth, this.panoHeight);
    this.vanishPoint = this.calculateVanishPoint(this.projectionRoadInfos, this.snapshotRatio, this.panoWidth, this.panoHeight);
    this.innerRect = this.getInnerRect(this.vanishPoint, this.projectionRoadInfos, this.panoWidth, this.panoHeight, this.snapshotRatio);
    this.outerRect = this.getOuterRect(this.panoWidth, this.panoHeight, this.snapshotRatio);
    this.focusLength = 0.5 * this.panoHeight / Math.tan(0.75 * this.fov);
    this.vanishPointDeltaX = this.vanishPoint.x - this.outerRect.x - 0.5 * this.outerRect.width;
    this.vanishPointDeltaY = this.vanishPoint.y - this.outerRect.y - 0.5 * this.outerRect.height;
  };
  var zo = {
    FAR: [10, 10, 0],
    LEFT: [0, 10, 30],
    RIGHT: [0, 10, 30],
    TOP: [10, 0, 30],
    BOTTOM: [10, 0, 30]
  };
  var Vo = {
    FAR: ["innerTopLeftVertex", "innerBottomRightVertex"],
    LEFT: ["outerTopLeftVertex", "innerBottomLeftVertex"],
    RIGHT: ["innerTopRightVertex", "outerBottomRightVertex"],
    TOP: ["outerTopLeftVertex", "innerTopRightVertex"],
    BOTTOM: ["innerBottomLeftVertex", "outerBottomRightVertex"]
  };
  var Go = Object.keys(zo);
  var Wo = function (t) {
    function e(e, n) {
      var r;
      (r = t.call(this) || this).createSkeleton = function (t) {
        var e = t.vanishPoint;
        var n = t.innerRect;
        var r = t.outerRect;
        var i = t.focusLength;
        var o = r.y + r.height - n.y - n.height;
        var a = e.y - n.y;
        var s = e.x - n.x;
        var u = n.x + n.width - e.x;
        var h = r.y + r.height - e.y;
        var c = o * i / (h - o);
        var l = u * (i + c) / i;
        var f = -(s * (i + c) / i);
        var d = h + a * (i + c) / i - h;
        var p = -h;
        var v = c / 5;
        return {
          innerTopLeftVertex: {
            x: f,
            y: d,
            z: -c
          },
          innerBottomLeftVertex: {
            x: f,
            y: p,
            z: -c
          },
          innerTopRightVertex: {
            x: l,
            y: d,
            z: -c
          },
          innerBottomRightVertex: {
            x: l,
            y: p,
            z: -c
          },
          outerTopLeftVertex: {
            x: f,
            y: d,
            z: v
          },
          outerTopRightVertex: {
            x: l,
            y: d,
            z: v
          },
          outerBottomLeftVertex: {
            x: f,
            y: p,
            z: v
          },
          outerBottomRightVertex: {
            x: l,
            y: p,
            z: v
          }
        };
      };
      r.modelSkeleton = function (t, e) {
        var n = [];
        var i = [];
        Go.forEach(function (o) {
          var a = xi(Vo[o], 2);
          var s = a[0];
          var u = a[1];
          var h = n.length / 3;
          n = n.concat(r.calculatePlaneVertex(t[s], t[u], o, e));
          i = i.concat(r.calculateIndices(o, h));
        });
        return [n, i];
      };
      r.calculatePlaneVertex = function (t, e, n, i) {
        for (var o, a = [], s = xi(zo[n], 3), u = s[0], h = s[1], c = s[2], l = r.linerInterpolate(t.x, e.x, u), f = r.linerInterpolate(t.y, e.y, h), d = r.linerInterpolate(t.z, e.z, c), p = 0; p <= u; p++) {
          for (var v = 0; v <= h; v++) {
            for (var m = 0; m <= c; m++) {
              En(o = hn(l[p], f[v], d[m], 1), o, i);
              o[0] = o[0] / o[3];
              o[1] = o[1] / o[3];
              o[2] = o[2] / o[3];
              a.push(o[0], o[1], o[2]);
            }
          }
        }
        return a;
      };
      r.calculateIndices = function (t, e) {
        var n = [];
        var r = zo[t];
        r = r.filter(function (t) {
          return t > 0;
        });
        for (var i = xi(r, 2), o = i[0], a = i[1], s = 0, u = 0, h = 0, c = 0, l = 0; l < o; l++) {
          for (var f = 0; f < a; f++) {
            u = (s = e + (a + 1) * l + f) + 1;
            c = (h = s + a + 1) + 1;
            n.push(s, h, c);
            n.push(s, c, u);
          }
        }
        return n;
      };
      r.linerInterpolate = function (t, e, n) {
        var r = [];
        if (n <= 0) {
          r.push(t);
        } else {
          for (var i = (e - t) / n, o = 0; o <= n; o++) {
            r[o] = t + i * o;
          }
        }
        return r;
      };
      r.calculateUVCoordinate = function (t, e, n) {
        for (var i, o = t.camera, a = t.panoWidth, s = t.panoHeight, u = t.vanishPointDeltaX, h = t.vanishPointDeltaY, c = [], l = e.width, f = e.height, d = 0, p = 0, v = n.length / 3, m = 0; m < v; m++) {
          En(i = hn(n[3 * m], n[3 * m + 1], n[3 * m + 2], 1), i, o.viewMatrix);
          En(i, i, o.projectionMatrix);
          i[0] = i[0] / i[3];
          i[1] = i[1] / i[3];
          i[2] = i[2] / i[3];
          i[3] = 1;
          d = (i[0] * a * 0.5 + u + 0.5 * l) / l;
          p = (i[1] * s * 0.5 + h + 0.5 * f) / f;
          c.push(r.getValidateUV(d), r.getValidateUV(p));
        }
        return new Float32Array(c);
      };
      r.getValidateUV = function (t) {
        return Math.max(-0.1, Math.min(1.1, t));
      };
      r.rotationMatrix = Pe();
      r.camera = e.camera;
      if (e.isMovingForward) {
        Ve(r.rotationMatrix, r.rotationMatrix, g(_(-e.traverseDir + e.panoData.heading)));
      } else {
        var i = _(180 - e.traverseDir + e.panoData.heading);
        Ve(r.rotationMatrix, r.rotationMatrix, g(i));
      }
      r.cuboidVertexes = r.createSkeleton(e);
      var o = r.modelSkeleton(r.cuboidVertexes, r.rotationMatrix);
      var a = xi(o, 2);
      var s = a[0];
      var u = a[1];
      r.verticesBufferData = new Float32Array(s);
      r.indicesBufferData = new Uint16Array(u);
      r.uvtsBufferData = r.calculateUVCoordinate(e, n, s, r.rotationMatrix);
      r.setAttribute("position", new Gr(r.verticesBufferData, 3));
      r.setAttribute("uv", new Gr(r.uvtsBufferData, 2));
      r.setIndexes(r.indicesBufferData);
      return r;
    }
    c(e, t);
    return e;
  }(Zr);
  var Ho = [0, 1, 0, 0.5];
  var Zo = function () {
    function t(t, e, n, r, i) {
      var o = this;
      this.start = function () {
        o.animation.start();
        o._pano.dispatchEvent({
          debug: true,
          log: "淡出动画，渲染一帧",
          type: d.REFRESH
        });
      };
      this.update = function () {
        o.animation.update();
      };
      this._pano = t;
      this.distance = e;
      this.handleEnd = i;
      this.traverseDir = r;
      this.snapshot = n;
      this.camera = t.camera;
      this.scene = this.initScene();
      this.rotationMatrix = this.traverseGeometry.rotationMatrix;
      this.initAni();
    }
    var e = t.prototype;
    e.initAni = function () {
      var t = this;
      var e = Vt(0, 0, this.distance);
      ee(e, e, this.rotationMatrix);
      this.animation = new ho(0, 1, 700, so.linear).onUpdate(function (n) {
        var r = Ft();
        Yt(r, e, n);
        t.scene.traverse(function (t) {
          t.position = r;
          t.updateWorldMatrix(true);
        });
        t._pano.dispatchEvent({
          debug: true,
          type: d.REFRESH,
          log: "[Refresh Log] 前进动画， 渲染一帧"
        });
      }).onEnd(function () {
        if (t.handleEnd) {
          t.handleEnd();
        }
        t._pano.dispatchEvent({
          debug: true,
          type: d.REFRESH,
          log: "[Refresh Log] 前进动画， 渲染一帧"
        });
      });
    };
    e.initScene = function () {
      var t = new Qr();
      var e = this._pano.getContainerSize();
      var n = e.width;
      var r = e.height;
      var i = new jo(this._pano, this.traverseDir);
      var o = new Fo(0, 0, n, r);
      var a = new Wo(i, o);
      var s = this.initMaterial();
      var u = new Kr(a, s);
      this.traverseGeometry = a;
      t.add(u);
      return t;
    };
    e.initMaterial = function () {
      var t = new Ti();
      t.depthTest = false;
      t.vertexShader = Ao;
      t.fragmentShader = Co;
      t.uniforms = {
        uSampler: {
          type: "t",
          value: this.snapshot
        },
        uOpacity: {
          type: "1f",
          value: 1
        },
        vColor: {
          type: "4f",
          value: Ho
        },
        showDebugLine: {
          type: "1i",
          value: true
        }
      };
      this.material = t;
      return t;
    };
    return t;
  }();
  var qo = function () {
    function t() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.x = t;
      this.y = e;
    }
    t.prototype.equals = function (t) {
      return t && t.x === this.x && t.y === this.y;
    };
    return t;
  }();
  var Yo = function () {
    function t(t, e) {
      var n = this;
      this.setData = function (t, e) {
        n.panoData = t;
        n.nextPanoData = e;
      };
      this.sceneChangeHandler = function () {
        if (n.panoData && n.nextPanoData) {
          return new Promise(function (t) {
            var e = n.isStreet(n.panoData.panoType);
            var r = n.isStreet(n.nextPanoData.panoType);
            var i = n.snapshotFn();
            var o = n.pano.animationType;
            if (o && ["waterwave", "fade"].indexOf(o) > -1) {
              switch (o) {
                case "waterwave":
                  n.prepareWaterWave(i);
                  t();
                  break;
                case "fade":
                  n.prepareFade(i);
                  t();
              }
            } else if (r && e) {
              n.setDir();
              n.prepareTraverse(i).then(function (e) {
                n.prepareFade(e);
                t();
              });
            } else {
              n.prepareFade(i);
              t();
            }
          });
        }
      };
      this.setSnapshot = function (t) {
        n.snapshot = t;
      };
      this.pano = t;
      this.snapshotFn = e;
      this.panoData = null;
      this.nextPanoData = null;
      this.changeAni = null;
      this.animateDir = 0;
    }
    var e = t.prototype;
    e.draw = function () {
      if (this.changeAni) {
        var t = this.changeAni;
        var e = t.scene;
        var n = t.camera;
        this.changeAni.update();
        this.pano.renderer.render(e, n);
      }
    };
    e.setDir = function () {
      if (this.panoData && this.nextPanoData) {
        var t = this.nextPanoData.panoId;
        var e = this.panoData.getTopos().filter(function (e) {
          return e && e.panoId === t;
        });
        if (e.length) {
          var n = e[0].topoDir;
          this.animateDir = n;
        } else {
          this.animateDir = this.pano.getPov().heading || 0;
        }
      }
    };
    e.prepareJump = function () {
      var t = this;
      var e = this.calcJumpDistance();
      return new Promise(function (n) {
        t.changeAni = new No(t.pano, t.animateDir, e, function () {
          t.changeAni = null;
          n();
        });
        t.changeAni.startAni();
        t.pano.dispatchEvent({
          debug: true,
          log: "穿梭动画，渲染一帧",
          type: d.REFRESH
        });
      });
    };
    e.prepareTraverse = function (t) {
      var e = this;
      var n = this.calcJumpDistance();
      return new Promise(function (r) {
        e.changeAni = new Zo(e.pano, n, t, e.animateDir, function () {
          var t = e.snapshotFn(e.changeAni.scene, e.changeAni.camera);
          r(t);
          e.changeAni = null;
        });
        e.changeAni.start();
        e.pano.dispatchEvent({
          debug: true,
          log: "穿梭动画，渲染一帧",
          type: d.REFRESH
        });
      });
    };
    e.prepareFade = function (t) {
      var e = this;
      this.changeAni = new ko(this.pano, t, function () {
        e.changeAni = null;
        e.pano.emit(d.SCENE_CHANGE_END);
      });
    };
    e.prepareWaterWave = function (t) {
      var e = this;
      this.changeAni = new Uo(this.pano, t, function () {
        e.changeAni = null;
        e.pano.emit(d.SCENE_CHANGE_END);
      });
    };
    e.calcJumpDistance = function () {
      var t;
      var e;
      var n = 300;
      t = new qo(this.panoData.panoX, this.panoData.panoY);
      e = new qo(this.nextPanoData.panoX, this.nextPanoData.panoY);
      var r = t && e ? Math.round(Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2))) : 0;
      if (typeof r == "number") {
        n *= Math.pow(r, 1 / 4);
      }
      return n;
    };
    e.isStreet = function (t) {
      return t === p.TYPE_STREET;
    };
    return t;
  }();
  var Xo = function () {
    function t(t, e) {
      var n = e.fov;
      var r = n === undefined ? 145 : n;
      var i = e.cameraY;
      var o = i === undefined ? 3000 : i;
      var a = e.handleEnd;
      this._pano = undefined;
      this.originFov = undefined;
      this.originRotateX = undefined;
      this.originRotateY = undefined;
      this.targetFov = undefined;
      this.targetCameraY = undefined;
      this.handleEnd = undefined;
      this.animate = undefined;
      this._pano = t;
      this.originFov = this.camera.fov;
      this.originRotateX = this.camera.rotation.x;
      this.originRotateY = this.camera.rotation.y;
      this.targetFov = r;
      this.targetCameraY = o;
      this.handleEnd = a;
      this.init();
    }
    var e = t.prototype;
    e.start = function () {
      this._pano.dispatchEvent({
        type: d.REFRESH,
        debug: true,
        log: "开场动画动画起始，渲染一帧"
      });
      this.animate.start();
    };
    e.update = function () {
      this.animate.update();
    };
    e.init = function () {
      var t = this;
      var e = this.camera;
      this.handleCameraChange(0);
      this.animate = new ho(0, 1, p.FISHEYE_DURATION, so.easeInOutQuad).onUpdate(function (e) {
        t.handleCameraChange(e);
        t._pano.dispatchEvent({
          type: d.REFRESH,
          debug: true,
          log: "开场动画动画，渲染一帧"
        });
      }).onEnd(function () {
        e.fov = t.originFov;
        e.rotateX(t.originRotateX);
        e.rotateY(t.originRotateY);
        e.setPosition(0, 0, 0);
        e.updateWorldMatrix();
        e.updateProjectionMatrix();
        t._pano.dispatchEvent({
          type: d.REFRESH,
          debug: true,
          log: "开场动画动画结束，渲染一帧"
        });
        t.handleEnd();
      });
    };
    e.handleCameraChange = function (t) {
      var e = this.camera;
      var n = this.targetCameraY;
      var r = this.targetFov - (this.targetFov - this.originFov) * t;
      var i = (this.originRotateX - -90) * t - 90;
      var o = this.originRotateY * t;
      e.fov = r;
      e.rotateX(i);
      e.rotateY(o);
      e.setPosition(0, n - n * t, 0);
      e.updateWorldMatrix();
      e.updateProjectionMatrix();
    };
    o(t, [{
      key: "camera",
      get: function () {
        return this._pano.camera;
      }
    }]);
    return t;
  }();
  function Ko(t, e) {
    var n = typeof Symbol != "undefined" && t[Symbol.iterator] || t["@@iterator"];
    if (!n) {
      if (Array.isArray(t) || (n = function (t, e) {
        if (!t) {
          return;
        }
        if (typeof t == "string") {
          return Qo(t, e);
        }
        var n = Object.prototype.toString.call(t).slice(8, -1);
        if (n === "Object" && t.constructor) {
          n = t.constructor.name;
        }
        if (n === "Map" || n === "Set") {
          return Array.from(t);
        }
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
          return Qo(t, e);
        }
      }(t)) || e && t && typeof t.length == "number") {
        if (n) {
          t = n;
        }
        var r = 0;
        var i = function () {};
        return {
          s: i,
          n: function () {
            return r >= t.length ? {
              done: true
            } : {
              done: false,
              value: t[r++]
            };
          },
          e: function (t) {
            throw t;
          },
          f: i
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var o;
    var a = true;
    var s = false;
    return {
      s: function () {
        n = n.call(t);
      },
      n: function () {
        var t = n.next();
        a = t.done;
        return t;
      },
      e: function (t) {
        s = true;
        o = t;
      },
      f: function () {
        try {
          if (!(a || n.return == null)) {
            n.return();
          }
        } finally {
          if (s) {
            throw o;
          }
        }
      }
    };
  }
  function Qo(t, e) {
    if (e == null || e > t.length) {
      e = t.length;
    }
    for (var n = 0, r = new Array(e); n < e; n++) {
      r[n] = t[n];
    }
    return r;
  }
  var Jo = function () {
    function t(t) {
      var e = this;
      this.name = "PanoOverlayManager";
      this.overlays = [];
      this.pano = undefined;
      this.isReady = false;
      this.clickChecker = function (t, n) {
        var r;
        var i = true;
        var o = Ko(e.overlays);
        try {
          for (o.s(); !(r = o.n()).done;) {
            var a = r.value;
            var s = a.dom.getBoundingClientRect();
            var u = s.left;
            var h = s.right;
            var c = s.top;
            var l = s.bottom;
            if (t >= u && t <= h && n >= c && n <= l) {
              i = false;
              a.handleClick();
              break;
            }
          }
        } catch (t) {
          o.e(t);
        } finally {
          o.f();
        }
        return i;
      };
      this.pano = t;
    }
    var e = t.prototype;
    e.handleAdd = function (t) {
      if (t && t.id) {
        if (!this.overlays.some(function (e) {
          return e.id === t.id;
        })) {
          this.overlays.push(t);
          if (this.isReady) {
            t.init(this.pano);
          }
        }
      }
    };
    e.handleRemove = function (t) {
      for (var e = 0; e < this.overlays.length; e++) {
        if (this.overlays[e].id === t.id) {
          this.overlays[e].remove();
          return void this.overlays.splice(e, 1);
        }
      }
    };
    e.init = function () {
      this.isReady = true;
      var t;
      var e = Ko(this.overlays);
      try {
        for (e.s(); !(t = e.n()).done;) {
          t.value.init(this.pano);
        }
      } catch (t) {
        e.e(t);
      } finally {
        e.f();
      }
    };
    e.draw = function () {
      if (this.isReady) {
        var t;
        var e = Ko(this.overlays);
        try {
          for (e.s(); !(t = e.n()).done;) {
            t.value.draw();
          }
        } catch (t) {
          e.e(t);
        } finally {
          e.f();
        }
      }
    };
    e.destroy = function () {
      var t;
      var e = Ko(this.overlays);
      try {
        for (e.s(); !(t = e.n()).done;) {
          t.value.remove();
        }
      } catch (t) {
        e.e(t);
      } finally {
        e.f();
      }
      this.overlays = [];
    };
    return t;
  }();
  function $o(t, e) {
    var n = typeof Symbol != "undefined" && t[Symbol.iterator] || t["@@iterator"];
    if (!n) {
      if (Array.isArray(t) || (n = function (t, e) {
        if (!t) {
          return;
        }
        if (typeof t == "string") {
          return ta(t, e);
        }
        var n = Object.prototype.toString.call(t).slice(8, -1);
        if (n === "Object" && t.constructor) {
          n = t.constructor.name;
        }
        if (n === "Map" || n === "Set") {
          return Array.from(t);
        }
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
          return ta(t, e);
        }
      }(t)) || e && t && typeof t.length == "number") {
        if (n) {
          t = n;
        }
        var r = 0;
        var i = function () {};
        return {
          s: i,
          n: function () {
            return r >= t.length ? {
              done: true
            } : {
              done: false,
              value: t[r++]
            };
          },
          e: function (t) {
            throw t;
          },
          f: i
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var o;
    var a = true;
    var s = false;
    return {
      s: function () {
        n = n.call(t);
      },
      n: function () {
        var t = n.next();
        a = t.done;
        return t;
      },
      e: function (t) {
        s = true;
        o = t;
      },
      f: function () {
        try {
          if (!(a || n.return == null)) {
            n.return();
          }
        } finally {
          if (s) {
            throw o;
          }
        }
      }
    };
  }
  function ta(t, e) {
    if (e == null || e > t.length) {
      e = t.length;
    }
    for (var n = 0, r = new Array(e); n < e; n++) {
      r[n] = t[n];
    }
    return r;
  }
  var ea = function () {
    function t(t) {
      var e = this;
      this.renderer = undefined;
      this.gl = undefined;
      this.camera = undefined;
      this.cameraNoFix = null;
      this.panoData = null;
      this.scene = undefined;
      this.sceneChange = undefined;
      this.openingAni = undefined;
      this.sphereRender = undefined;
      this.linkGLRender = undefined;
      this.overlayManager = undefined;
      this.skyboxRender = undefined;
      this.pano = undefined;
      this.renderThreadId = null;
      this.requestId = null;
      this.isRAFRuning = false;
      this.setData = function () {
        var t = nt(ot.mark(function t(n) {
          var r;
          var o;
          return ot.wrap(function (t) {
            for (;;) {
              switch (t.prev = t.next) {
                case 0:
                  if (n) {
                    t.next = 2;
                    break;
                  }
                  return t.abrupt("return");
                case 2:
                  if (!e.panoData || !e.pano.useAnimation) {
                    t.next = 8;
                    break;
                  }
                  e.sceneChange.setData(e.panoData, n);
                  t.next = 6;
                  return e.sceneChange.sceneChangeHandler();
                case 6:
                  if (e.pano.backupUseAnimation !== undefined) {
                    e.pano.useAnimation = e.pano.backupUseAnimation;
                  }
                  e.pano.animationType = "";
                case 8:
                  e.reset();
                  e.panoData = n;
                  e.pano.panoData = n;
                  if (!(i(n.defaultHeading) === undefined && i(n.defaultPitch) === undefined)) {
                    e.pano.handlePovChange({
                      heading: n.defaultHeading,
                      pitch: n.defaultPitch
                    });
                  }
                  r = n.image && n.image.length === 6;
                  (o = r ? e.skyboxRender : e.sphereRender).setData(n);
                  e.linkGLRender.setData(n);
                  e.overlayManager.init();
                  e.scene.add(o.meshs);
                  e.updateProjectionMatrix(e.camera);
                  e.updateCameraHeadingAndPitch(e.camera);
                case 20:
                case "end":
                  return t.stop();
              }
            }
          }, t);
        }));
        return function (e) {
          return t.apply(this, arguments);
        };
      }();
      this.getSnapshot = function (t, n) {
        t = t || e.scene;
        n = n || e.camera;
        var r = e.pano.getContainerSize();
        var i = r.width;
        var o = r.height;
        var a = new Vi(i, o);
        a.premultiplyAlpha = true;
        e.renderer.render(t, n, a);
        return a;
      };
      this.update = function () {
        if (e.panoData) {
          e.sphereRender.update();
          e.linkGLRender.update();
          e.startRenderThread();
        }
      };
      this.onThumbLoaded = function () {
        if (e.sceneChange.changeAni) {
          e.sceneChange.changeAni.start();
        }
        var t = e.linkGLRender.meshs;
        if (t) {
          e.scene.add(t);
        }
        e.startFishEyeAni();
      };
      this.startRenderThread = function () {
        var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
        if (e.renderThreadId) {
          clearTimeout(e.renderThreadId);
          e.renderThreadId = null;
        }
        e.renderThreadId = window.setTimeout(function () {
          e.isRAFRuning = false;
          e.renderThreadId = null;
        }, t);
        if (!e.isRAFRuning) {
          e.isRAFRuning = true;
          e.renderFrame();
        }
      };
      this.resize = function () {
        var t = e.pano.getContainer();
        e.renderer.setSize(t.clientWidth, t.clientHeight);
      };
      var n = window.devicePixelRatio || 1;
      var r = t.getContainer();
      this.pano = t;
      this.renderer = new Ui({
        premultipliedAlpha: false,
        preserveDrawingBuffer: t.opts.enableCapture || false,
        antialias: !(n > 1),
        pixelRatio: n,
        width: r.clientWidth,
        height: r.clientHeight
      });
      this.renderer.setSize(r.clientWidth, r.clientHeight);
      t.getPanes().tileLayer.appendChild(this.renderer.domElement);
      this.gl = this.renderer.getContext();
      this.camera = new Ki(75, r.clientWidth / r.clientHeight, 0.01, 67000);
      this.scene = new Qr();
      t.gl = this.gl;
      t.canvas = this.renderer.domElement;
      t.scene = this.scene;
      t.camera = this.camera;
      t.cameraNoFix = this.cameraNoFix;
      t.renderer = this.renderer;
      t.renders = [];
      this.sceneChange = new Yo(t, this.getSnapshot);
      this.initModule();
    }
    var e = t.prototype;
    e.initModule = function () {
      var t = this.pano;
      this.sphereRender = new So(t);
      this.linkGLRender = new Bo(t);
      this.overlayManager = new Jo(t);
      this.skyboxRender = new eo(t);
      this.pano.renders.push(this.sphereRender, this.linkGLRender, this.overlayManager, this.skyboxRender);
    };
    e.reset = function () {
      this.scene.remove(this.sphereRender.meshs);
      this.scene.remove(this.linkGLRender.meshs);
    };
    e.getModule = function (t) {
      var e;
      var n = null;
      var r = $o(this.pano.renders);
      try {
        for (r.s(); !(e = r.n()).done;) {
          var i = e.value;
          if (i.name === t) {
            n = i;
            break;
          }
        }
      } catch (t) {
        r.e(t);
      } finally {
        r.f();
      }
      return n;
    };
    e.renderFrame = function () {
      if (this.isRAFRuning !== false) {
        if (this.openingAni) {
          this.openingAni.update();
        }
        this.sphereRender.draw();
        this.renderer.render(this.scene, this.camera);
        this.overlayManager.draw();
        this.sceneChange.draw();
        this.requestId = requestAnimationFrame(this.renderFrame.bind(this));
      } else if (this.requestId) {
        cancelAnimationFrame(this.requestId);
        this.requestId = null;
      }
    };
    e.startFishEyeAni = function () {
      var t = this;
      if (this.pano.fisheye) {
        this.openingAni = new Xo(this.pano, {
          handleEnd: function () {
            t.openingAni = null;
            t.pano.fisheye = false;
          }
        });
        setTimeout(function () {
          t.openingAni.start();
          t.startRenderThread();
        }, p.FISHEYE_DELAY);
      }
    };
    e.updateProjectionMatrix = function (t, e) {
      var n = this.pano.getFov(e);
      var r = this.pano.getContainerSize();
      var i = r.width / r.height;
      t.fov = n;
      t.aspect = i;
      t.updateProjectionMatrix();
    };
    e.updateCameraHeadingAndPitch = function (t) {
      var e = this.pano.getPov();
      var n = e.heading;
      var r = e.pitch;
      var i = this.panoData;
      var o = i.fixHeading;
      var a = o === undefined ? 0 : o;
      var s = i.fixPitch;
      var u = s === undefined ? 0 : s;
      var h = i.fixRoll;
      var c = h === undefined ? 0 : h;
      t.rotateX(r - u);
      t.rotateY(-n + a);
      t.rotateZ(c);
      t.updateWorldMatrix();
    };
    e.safeCall = function (t, e, n) {
      var r = this.getModule(t);
      if (r && r[e]) {
        return r[e].apply(r, n || []);
      }
      throw new Error("[safeCall] get module error => ".concat(t));
    };
    o(t, [{
      key: "isCanUpdate",
      get: function () {
        var t = this.sceneChange.changeAni;
        var e = this.openingAni;
        return this.panoData && !(t || e);
      }
    }]);
    return t;
  }();
  var na = function () {
    function t(t) {
      var e = this;
      this.updateAnglePerPixel = function () {
        e._anglePerPixel = e._pano.calcAnglePerPixel();
      };
      this.destroy = function () {
        e.bindEvent(false);
      };
      this._pano = t;
      this._displayZoom = t.getZoom();
      this._anglePerPixel = t.calcAnglePerPixel();
      this._container = t.getContainer();
      this.lock = false;
      this.clickTimer = null;
      this.dragAni = null;
      this.state = {
        initPos: null,
        initHeading: 0,
        initPitch: 0,
        lastDiffPos: null,
        moveDiffPos: null,
        isTouchDown: false,
        isTouchMove: false,
        startTime: 0,
        lastMoveTime: 0
      };
    }
    var e = t.prototype;
    e.init = function () {
      if (!this._initialized) {
        this._initialized = true;
        this.isMobile = navigator.userAgent.toLowerCase().match(/ipod|ipad|iphone|android/);
        if (this.isMobile) {
          this.EVENTS = {
            START: "touchstart",
            MOVING: "touchmove",
            END: "touchend",
            OUT: "touchcancel",
            WHEEL: "gesturechange",
            DOMMouseScroll: "DOMMouseScroll"
          };
          var t = this._container.getBoundingClientRect ? this._container.getBoundingClientRect() : {};
          var e = t.left;
          var n = e === undefined ? 0 : e;
          var r = t.top;
          var i = r === undefined ? 0 : r;
          this.getPagePosition = function (t) {
            var e = t.touches.length > 0 ? t.touches[0] : t.changedTouches[0];
            return {
              x: e.pageX - n,
              y: e.pageY - i
            };
          };
        } else {
          this.EVENTS = {
            START: "mousedown",
            MOVING: "mousemove",
            END: "mouseup",
            OUT: "mouseout",
            WHEEL: "mousewheel"
          };
          this.getPagePosition = function (t) {
            return {
              x: t.offsetX,
              y: t.offsetY
            };
          };
        }
        this.bindEvent();
      }
    };
    e.bindEvent = function () {
      var t = !(arguments.length > 0 && arguments[0] !== undefined) || arguments[0];
      var e = document.body;
      var n = this.EVENTS;
      var r = n.START;
      var i = n.MOVING;
      var o = n.END;
      var a = this._pano._svContainer;
      var s = t ? "addEventListener" : "removeEventListener";
      a[s](r, this.handleDown.bind(this));
      a[s](i, this.handleMove.bind(this));
      e[s](o, this.handleUp.bind(this));
    };
    e.handleDown = function (t) {
      if (this.dragAni) {
        this.dragAni.stop();
      }
      var e = this.state;
      var n = this.getPagePosition(t);
      var r = this._pano.getPov();
      e.initPos = n;
      e.isTouchDown = true;
      e.initHeading = r.heading;
      e.initPitch = r.pitch;
      e.startTime = x();
      this._pano.dispatchEvent(d.TOUCH_START, t);
    };
    e.handleMove = function (t) {
      if (this.state.isTouchDown) {
        this.state.isTouchMove = true;
        var e = this.calcDiffPos(this.state.initPos, this.getPagePosition(t));
        this.setPov(e);
        this.state.moveDiffPos = e;
        this.state.lastDiffPos = e;
        this.state.lastMoveTime = x();
        t.preventDefault();
        t.stopPropagation();
      }
    };
    e.handleUp = function (t) {
      var e = this;
      if (this.state.isTouchDown) {
        var n = true;
        var r = this.getPagePosition(t);
        t.pos = r;
        this.state.isTouchDown = false;
        this._pano.dispatchEvent(d.TOUCH_END, t);
        if (this._pano.renders.length) {
          for (var i = 0; i < this._pano.renders.length; i++) {
            var o = this._pano.renders[i];
            if (o.clickChecker && !(n = o.clickChecker(r.x, r.y))) {
              t.stopPropagation();
              break;
            }
          }
        }
        if (n !== false) {
          if (this.state.isTouchMove) {
            this.state.isTouchMove = false;
            this.processMotion(t);
          } else {
            t.stopPropagation();
            if (this.clickTimer) {
              clearTimeout(this.clickTimer);
              this.clickTimer = null;
              this._pano.dispatchEvent(d.DOUBLE_CLICK, t);
            } else {
              this.clickTimer = setTimeout(function () {
                e.clickTimer = null;
                e._pano.dispatchEvent(d.CLICK, t);
              }, 300);
            }
          }
        }
      }
    };
    e.setPov = function (t) {
      var e = t.x;
      var n = t.y;
      var r = -e * this._anglePerPixel;
      var i = n * this._anglePerPixel;
      var o = this.state.initHeading + r;
      var a = this.state.initPitch + i;
      this._pano.setPov({
        heading: o,
        pitch: a
      });
    };
    e.processMotion = function (t) {
      var e = this;
      var n = this.state;
      var r = x();
      var i = r - n.lastMoveTime;
      var o = n.moveDiffPos;
      var a = o.x;
      var s = o.y;
      if (i < 300 && (Math.abs(a) > 10 || Math.abs(s) > 10)) {
        var u = this.calcDiffPos(this.state.initPos, this.getPagePosition(t));
        var h = 2 * Math.sqrt(Math.pow(u.x, 2) + Math.pow(u.y, 2)) / (0.008 * (r - n.startTime));
        var c = [u.x > 0 ? 1 : -1, u.y > 0 ? 1 : -1];
        var l = Math.abs(u.x);
        var f = Math.abs(u.y);
        var p = Math.atan2(f, l);
        var v = Math.cos(p) * h;
        var m = Math.sin(p) * h;
        if (c[0] === -1) {
          v = -v;
        }
        if (c[1] === -1) {
          m = -m;
        }
        if (this.dragAni) {
          this.dragAni.stop();
        }
        var g = this._pano.getPov();
        var y = g.heading;
        var _ = g.pitch;
        n.initHeading = y;
        n.initPitch = _;
        this.dragAni = new ho(0, 1, 400, function (t) {
          return 0.3125 * t - 0.15625 * t * t;
        }).onUpdate(function (t) {
          var n = (t *= 6.4) * v;
          var r = t * m;
          e.setPov({
            x: n,
            y: r
          });
        }).onEnd(function () {
          e.dragAni = null;
          e._pano.dispatchEvent({
            type: d.POV_CHANGED_END
          });
        }).startAndAutoUpdate();
      } else {
        this._pano.dispatchEvent({
          type: d.POV_CHANGED_END
        });
      }
    };
    e.calcDiffPos = function (t, e) {
      return t && e ? {
        x: e.x - t.x,
        y: e.y - t.y
      } : {
        x: 0,
        y: 0
      };
    };
    return t;
  }();
  function ra(t, e) {
    var n = typeof Symbol != "undefined" && t[Symbol.iterator] || t["@@iterator"];
    if (!n) {
      if (Array.isArray(t) || (n = function (t, e) {
        if (!t) {
          return;
        }
        if (typeof t == "string") {
          return ia(t, e);
        }
        var n = Object.prototype.toString.call(t).slice(8, -1);
        if (n === "Object" && t.constructor) {
          n = t.constructor.name;
        }
        if (n === "Map" || n === "Set") {
          return Array.from(t);
        }
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
          return ia(t, e);
        }
      }(t)) || e && t && typeof t.length == "number") {
        if (n) {
          t = n;
        }
        var r = 0;
        var i = function () {};
        return {
          s: i,
          n: function () {
            return r >= t.length ? {
              done: true
            } : {
              done: false,
              value: t[r++]
            };
          },
          e: function (t) {
            throw t;
          },
          f: i
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var o;
    var a = true;
    var s = false;
    return {
      s: function () {
        n = n.call(t);
      },
      n: function () {
        var t = n.next();
        a = t.done;
        return t;
      },
      e: function (t) {
        s = true;
        o = t;
      },
      f: function () {
        try {
          if (!(a || n.return == null)) {
            n.return();
          }
        } finally {
          if (s) {
            throw o;
          }
        }
      }
    };
  }
  function ia(t, e) {
    if (e == null || e > t.length) {
      e = t.length;
    }
    for (var n = 0, r = new Array(e); n < e; n++) {
      r[n] = t[n];
    }
    return r;
  }
  var oa = function () {
    function t(t) {
      this.pano = t;
      this.preZoom = t.getZoom();
      this.zoomChangeAni = null;
      this.debug = false;
      this.panoServiceLock = false;
      this.bindEvent();
      this.initModule();
      this.initResize();
      this.handleContextStatus();
    }
    var e = t.prototype;
    e.initModule = function () {
      var t = this.pano;
      this.panoService = new tt(t);
      this.panoGLRender = new ea(t);
      this.op = new na(t);
    };
    e.initResize = function () {
      var t = this;
      var e = this.pano.getContainerSize();
      var n = this.pano.getContainer();
      var r = function (n, r) {
        if (n && r) {
          var i = new l(n, r);
          if (!i.equals(e)) {
            t.pano.dispatchEvent({
              type: d.SIZE_CHANGED
            });
            e = i;
          }
        }
      };
      if (window.ResizeObserver !== undefined) {
        var i = new window.ResizeObserver(function (t) {
          var e;
          var n = ra(t);
          try {
            for (n.s(); !(e = n.n()).done;) {
              var i = e.value.target;
              r(i.clientWidth, i.clientHeight);
            }
          } catch (t) {
            n.e(t);
          } finally {
            n.f();
          }
        });
        i.observe(n);
        this.resizeOb = i;
      } else {
        this.checkSizeTimer = setInterval(function () {
          r(n.clientWidth, n.clientHeight);
        }, 80);
      }
    };
    e.bindEvent = function () {
      var t = this;
      var e = this.pano;
      e.on(d.PANO_ERROR, function () {
        t.panoServiceLock = false;
      });
      e.on(d.DATA_LOADED, function (n) {
        if (t.pano.opts.visible) {
          t.pano.show();
        } else {
          t.pano.hide();
        }
        t.panoServiceLock = false;
        if (n.options && n.options.animation) {
          e.backupUseAnimation = e.useAnimation;
          e.useAnimation = n.options.animation;
          if (n.options.animationType !== "") {
            e.animationType = n.options.animationType;
          }
        }
        t.panoGLRender.setData(n.data);
        t.op.init();
      });
      e.on(d.SET_POV, function (n) {
        var r = n.pov;
        var i = n.options;
        var o = (i === undefined ? {
          animation: true
        } : i).animation;
        if (t.panoGLRender.isCanUpdate) {
          var a = function (n) {
            if (e.handlePovChange(n)) {
              t.panoGLRender.updateCameraHeadingAndPitch(e.camera);
              t.panoGLRender.update();
              e.dispatchEvent(d.POV_CHANGED, n);
            }
          };
          if (o) {
            var s = e.getPov();
            var u = s.heading;
            var h = s.pitch;
            var c = r.heading - u;
            var l = r.pitch - h;
            if (c > 180) {
              u += 360;
              c = r.heading - u;
            } else if (c < -180) {
              u -= 360;
              c = r.heading - u;
            }
            new ho(0, 1, 400, so["ease-out"]).onUpdate(function (t) {
              a({
                heading: u + t * c,
                pitch: h + t * l
              });
            }).onEnd(function () {}).startAndAutoUpdate();
          } else {
            a(r);
          }
        } else {
          e.handlePovChange(r);
        }
      });
      e.on(d.ZOOM_CHANGED, function () {
        var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (t.panoGLRender.isCanUpdate) {
          var r = t.preZoom;
          var i = e.getZoom();
          if (r !== i) {
            var o = n.noAnimation || false;
            if (t.zoomChangeAni) {
              t.zoomChangeAni.stop();
              t.zoomChangeAni = null;
            }
            if (o) {
              t.op.updateAnglePerPixel();
              t.panoGLRender.updateProjectionMatrix(e.camera);
              t.panoGLRender.update();
              return void (t.preZoom = i);
            }
            var a = 400;
            t.zoomChangeAni = new ho(r, i, a, so.easeOutCubic).onUpdate(function (n) {
              t.panoGLRender.updateProjectionMatrix(e.camera, n);
              t.panoGLRender.update(n);
            }).onEnd(function () {
              t.zoomChangeAni = null;
              t.preZoom = i;
            }).startAndAutoUpdate();
          }
        }
      });
      e.on(d.DOUBLE_CLICK, function () {
        if (t.panoGLRender.isCanUpdate) {
          if (v.isMobile) {
            if (e.getZoom() === 3) {
              e.setZoom(2);
            } else {
              e.setZoom(3);
            }
          }
        }
      });
      e.on(d.REFRESH, function (e) {
        var n = e.duration || 200;
        t.panoGLRender.startRenderThread(n);
        if (t.debug && e.log && e.debug) {
          console.warn(e.log);
        }
      });
      e.on(d.SET_ID, function (e) {
        if (!t.panoServiceLock && e.id) {
          t.panoServiceLock = true;
          window.getPanoById = t.panoService.getPanoById;
          var n = (100000 * Math.random()).toFixed(0);
          BMapGL._rd = BMapGL._rd || {};
          BMapGL._rd["_cbk" + n] = function (t) {
            if (t && t.error !== undefined && t.error === 0) {
              window.getPanoById(e.id);
            } else {
              Q("PANORAMA");
            }
            delete BMapGL._rd["_cbk" + n];
          };
          K("PANORAMA", "BMapGL._rd._cbk" + n);
        }
      });
      e.on(d.SET_POSITION, function (e) {
        if (!t.panoServiceLock && e.point) {
          t.panoServiceLock = true;
          window.getPanoByLocation = t.panoService.getPanoByLocation;
          var n = (100000 * Math.random()).toFixed(0);
          BMapGL._rd = BMapGL._rd || {};
          BMapGL._rd["_cbk" + n] = function (t) {
            if (t && t.error !== undefined && t.error === 0) {
              window.getPanoByLocation(e.point);
            } else {
              Q("PANORAMA");
            }
            delete BMapGL._rd["_cbk" + n];
          };
          K("PANORAMA", "BMapGL._rd._cbk" + n);
        }
      });
      e.on(d.SIZE_CHANGED, function () {
        t.op.updateAnglePerPixel();
        t.panoGLRender.resize();
        t.panoGLRender.updateProjectionMatrix(e.camera);
        t.panoGLRender.update();
      });
      e.on(d.THUMB_LOADED, function () {
        t.panoGLRender.onThumbLoaded();
        t.panoGLRender.update();
      });
      e.on(d.OVERLAY_ADD, function (e) {
        t.panoGLRender.overlayManager.handleAdd(e);
      });
      e.on(d.OVERLAY_REMOVE, function (e) {
        t.panoGLRender.overlayManager.handleRemove(e);
      });
      e.on(d.OVERLAYS_CLEAR, function () {
        t.panoGLRender.overlayManager.destroy();
      });
      e.on(d.LINK_VISIBLE_CHANGE, function (e) {
        if (typeof e.value == "boolean") {
          t.panoGLRender.safeCall("PanoLinkRender", "setVisible", [e.value]);
          t.pano.dispatchEvent(d.REFRESH);
        }
      });
      e.on(d.DESTROY, function () {
        t.op.destroy();
        if (t.resizeOb) {
          t.resizeOb.disconnect();
        }
        if (t.checkSizeTimer) {
          clearInterval(t.checkSizeTimer);
        }
        t.panoGLRender.renderer.forceContextLoss();
        e.canvas.removeEventListener("webglcontextlost", t.onWebGLContextLost, false);
      });
      var n = v.isFirefox ? "DOMMouseScroll" : "mousewheel";
      var r = new Date();
      e._svContainer.addEventListener(n, function (t) {
        if (e.opts.enableScrollWheelZoom && e.opts.visible) {
          var n = new Date();
          if (n - r < 400) {
            return;
          }
          r = n;
          var i = -t.detail / 3 || t.wheelDelta / 120;
          var o = e.getZoom() + i;
          e.setZoom(o);
          t.preventDefault();
        }
      });
    };
    e.getImgZoom = function () {
      return this.pano.calcDisplayZoom().imgZoom;
    };
    e.handleContextStatus = function () {
      this.pano.canvas.addEventListener("webglcontextlost", this.onWebGLContextLost, false);
    };
    e.onWebGLContextLost = function (t) {
      t.preventDefault();
      setTimeout(function () {
        window.location.reload();
      }, 200);
    };
    return t;
  }();
  function aa(t, e, n) {
    t.addEventListener(e, n, false);
  }
  var sa = function (t) {
    function e(e, n) {
      var r;
      (r = t.call(this) || this).panoData = null;
      r.opts = undefined;
      r.useAnimation = false;
      r.backupUseAnimation = r.useAnimation;
      r.animationType = "";
      r.fisheye = false;
      r.canvas = undefined;
      r.camera = undefined;
      r.renderer = undefined;
      r.gl = undefined;
      r.scene = undefined;
      r.cameraNoFix = undefined;
      r.renders = undefined;
      r.closeBtn = null;
      r.navigator = null;
      r._container = undefined;
      r._pov = {
        heading: 0,
        pitch: 0
      };
      r._id = null;
      r._position = null;
      r._zoom = 2;
      r._displayZoomResultsCache = {};
      r._svContainer = undefined;
      r._eventManager = undefined;
      r._panes = undefined;
      r.addCloseButton = function (t) {
        var e = r.closeBtn = document.createElement("div");
        e.className = "pano_close";
        e.style.cssText = ["position:absolute", "right:10px", "top:10px", "padding: 5px 8px;", "cursor:pointer", "border-radius: 4px", "font-size: 14px", "background-color: rgba(0,0,0,.55)", "z-index: 99", "color: #fff"].join(";");
        e.innerText = "关闭";
        e.title = "退出全景";
        e.onclick = function () {
          r.hide();
          if (t) {
            t();
          }
        };
        r._svContainer.appendChild(e);
      };
      r.getContainer = function () {
        return r._container;
      };
      r.getContainerSize = function () {
        var t = r._container;
        return new l(t.clientWidth, t.clientHeight);
      };
      r.getPanes = function () {
        return r._panes;
      };
      r.show = function () {
        r.opts.visible = true;
        w.show(r._svContainer);
      };
      r.hide = function () {
        r.opts.visible = false;
        w.hide(r._svContainer);
      };
      r.getZoom = function () {
        return r._zoom;
      };
      r.setZoom = function (t) {
        var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        if (t !== r._zoom) {
          if (t > p.MAX_ZOOM) {
            t = p.MAX_ZOOM;
          }
          if (t < p.MIN_ZOOM) {
            t = p.MIN_ZOOM;
          }
          if (t !== r._zoom) {
            r._zoom = t;
            r.dispatchEvent(d.ZOOM_CHANGED, {
              noAnimation: e.noAnimation || false
            });
          }
        }
      };
      r.getPov = function () {
        return r._pov;
      };
      r.setPov = function (t, e) {
        r.dispatchEvent(d.SET_POV, {
          pov: t,
          options: e || {
            animation: false
          }
        });
      };
      r.handlePovChange = function (t) {
        if (i(t) === "object") {
          var e = false;
          var n = t.heading;
          var o = t.pitch;
          if (!(typeof n != "number" || isNaN(n))) {
            e = true;
            n = _(n);
            r._pov.heading = n;
          }
          if (typeof o == "number" && !isNaN(n)) {
            e = true;
            var a = r.opts.minPitch;
            var s = r.opts.maxPitch;
            if (o > s) {
              o = s;
            }
            if (o < a) {
              o = a;
            }
            r._pov.pitch = o;
          }
          return e;
        }
      };
      r.calcDisplayZoom = function (t, e) {
        t = t || r.getContainerSize();
        e = e || r.getZoom();
        var n = t;
        var i = n.width;
        var o = n.height;
        var a = r.opts.maxImageZoom;
        var s = r.opts.minImageZoom;
        var u = "".concat(i, "_").concat(o, "_").concat(e);
        if (r._displayZoomResultsCache[u]) {
          return r._displayZoomResultsCache[u];
        }
        for (var h = r.calcAnglePerPixel(), c = Math.floor(e) + 2, l = 360 / (2 * Math.pow(2, c - 2) * h); l > 512;) {
          c++;
          l = 360 / (2 * Math.pow(2, c - 2) * h);
        }
        if (c > a) {
          var f = c - a;
          l *= Math.pow(2, f);
          c = a;
        }
        if (c < s) {
          c = s;
        }
        var d = {
          imgZoom: c,
          displayTileSize: l = Math.round(l)
        };
        r._displayZoomResultsCache[u] = d;
        return d;
      };
      r.calcAnglePerPixel = function () {
        return r.getFov() / r.getContainerSize().height;
      };
      r.getFov = function (t) {
        t = t || r.getZoom();
        return (v.isMobile ? r.calcMobileFovy : r.calcPCFovy).call(a(r), t);
      };
      r.getVisible = function () {
        return r.opts.visible;
      };
      r.setId = function (t) {
        var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        r.useAnimation = e.animation || false;
        r.fisheye = e.fisheye || false;
        r.animationType = e.animationType || "";
        r.dispatchEvent(d.SET_ID, {
          id: t
        });
      };
      r.setPosition = function (t) {
        var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        r.useAnimation = e.animation || false;
        r.fisheye = e.fisheye || false;
        r.animationType = e.animationType || "";
        r.dispatchEvent(d.SET_POSITION, {
          point: t
        });
      };
      var o = {
        minImageZoom: p.TILE_MIN_ZOOM,
        maxImageZoom: p.TILE_MAX_ZOOM,
        minPitch: p.MIN_PITCH,
        maxPitch: p.MAX_PITCH,
        radius: p.RADIUS,
        tileBaseUrls: p.TILE_BASE_URLS,
        linksControl: true,
        navigationControl: true,
        enableScrollWheelZoom: true,
        enableCapture: false,
        visible: true
      };
      r.opts = Object.assign({}, o, n);
      var s = typeof e == "string" ? document.querySelector(e) : e;
      if (!s) {
        throw new Error("全景引擎宿主容器不存在");
      }
      r._container = s;
      r._init();
      return r;
    }
    c(e, t);
    var n = e.prototype;
    n.getPosition = function () {
      return this.position;
    };
    n.setOptions = function (t) {
      var e;
      for (e in t) {
        if (Object.prototype.hasOwnProperty.call(t, e)) {
          var n = true;
          if (i(t[e]) !== "object") {
            n = t[e] !== this.opts[e];
          }
          this.opts[e] = t[e];
          if (!n) {
            continue;
          }
          switch (e) {
            case "linksControl":
              this.dispatchEvent(d.LINK_VISIBLE_CHANGE, {
                value: t[e]
              });
              break;
            case "navigationControl":
              var r = !!t[e];
              var o = this.navigator;
              if (r) {
                o.show();
              } else {
                o.hide();
              }
          }
        }
      }
    };
    n.capture = function () {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (this.canvas) {
        var e = this.canvas;
        var n = t.quality || 0.8;
        var r = t.type || "image/jpeg";
        var i = e.toDataURL(r, n);
        return i;
      }
    };
    n.addOverlay = function (t) {
      this.dispatchEvent(d.OVERLAY_ADD, t);
    };
    n.removeOverlay = function (t) {
      this.dispatchEvent(d.OVERLAY_REMOVE, t);
    };
    n.clearOverlays = function () {
      this.dispatchEvent(d.OVERLAYS_CLEAR);
    };
    n.destroy = function () {
      this.dispatchEvent(d.DESTROY);
    };
    n._init = function () {
      this._createDoms();
      this.navigator = function (t) {
        function e(t) {
          this._initialize(t);
        }
        m(e.prototype, {
          _initialize: function (t) {
            this._pano = t;
            this.imgPath = t.opts.imgPath || "//api0.map.bdimg.com/images/";
            this._zoomInEnabled = true;
            this._zoomOutEnabled = true;
            this._render();
            this._bind();
          },
          _render: function () {
            this._container = w.create("div");
            var t = this._container.style;
            t.position = "absolute";
            t.left = "10px";
            t.top = "10px";
            t.zIndex = 99;
            var e = this._container;
            e.innerHTML = this._generateHtml();
            if (v.isPc) {
              this._panBtnContainer = e.children[2];
              this._panBtns = [this._panBtnContainer.children[0], this._panBtnContainer.children[1], this._panBtnContainer.children[2], this._panBtnContainer.children[3]];
              this._svgDirGroup = e.children[1].childNodes[0];
              this._zoomContainer = e.children[3];
            } else if (v.isMobile) {
              this._zoomContainer = e.children[0];
            }
            this._btnZoomIn = this._zoomContainer.children[0];
            this._btnZoomOut = this._zoomContainer.children[1];
            if (v.isMobile) {
              this._zoomContainer.style.left = this._zoomContainer.style.top = "0";
              this._zoomContainer.style.width = "36px";
              this._zoomContainer.style.height = "78px";
              this._btnZoomIn.style.width = this._btnZoomOut.style.width = "33px";
              this._btnZoomIn.style.height = this._btnZoomOut.style.height = "36px";
              this._btnZoomOut.style.top = "37.5px";
            }
            if (this._pano.getZoom() >= p.MAX_ZOOM) {
              this._setZoomBtnEnabled("zoomIn", false);
            }
            if (this._pano.getZoom() <= p.MIN_ZOOM) {
              this._setZoomBtnEnabled("zoomOut", false);
            }
            this._pano._svContainer.appendChild(e);
          },
          _generateHtml: function () {
            var t = [];
            if (v.isPc) {
              t.push(this._generatePanHtml());
              t.push(this._generateDirHtml());
              t.push(this._generatePanBtnHtml());
            }
            t.push(this._generateZoomContainerHtml());
            return t.join("");
          },
          _generateDirHtml: function () {
            return "<svg version=\"1.1\" overflow=\"hidden\" width=\"82px\" height=\"82px\" viewBox=\"0 0 82 82\"style=\"position: absolute; top: 0px; left: 0px;\"><g transform=\"rotate(0, 41, 41)\"><rect x=\"33\"y=\"1\" width=\"14\" height=\"12\" rx=\"4\" ry=\"4\" stroke=\"#868685\" stroke-width=\"1\" fill=\"#f8f8f8\"></rect><polyline points=\"37.5,9.5 37.5,3.5 42.5,9.5 42.5,3.5\" stroke-linejoin=\"bevel\" stroke-width=\"1.5\" fill=\"#f2f4f6\" stroke=\"#868685\"></polyline></g></svg>";
          },
          _generatePanHtml: function () {
            return "<div style=\"position:absolute;top:4px;left:4px;width:74px;height:74px;background:url(" + this.imgPath + "st-navictrl.png) no-repeat;-webkit-user-select:none;overflow:hidden\"><div></div></div>";
          },
          _generatePanBtnHtml: function () {
            return "<div style=\"position:absolute;top:0px;left:0;width:82px;height:82px;user-select:none;\"><div style=\"position:absolute;left:32px;top:13px;cursor:pointer;width:17px;height:17px;\" title=\"向上平移\"></div><div style=\"position:absolute;left:14px;top:32px;cursor:pointer;width:17px;height:17px;\" title=\"向左平移\"></div><div style=\"position:absolute;left:51px;top:32px;cursor:pointer;width:17px;height:17px;\" title=\"向右平移\"></div><div style=\"position:absolute;left:33px;top:51px;cursor:pointer;width:17px;height:17px;\" title=\"向下平移\"></div></div>";
          },
          _generateZoomContainerHtml: function () {
            var t = "background-image:url('" + this.imgPath + "st-navictrl.png');background-repeat:no-repeat;background-position:-74px 0;";
            if (v.isMobile) {
              t = "background-image:url('" + this.imgPath + "st-navictrl-hd.png');background-repeat:no-repeat;background-position:0 0;background-size:180px 78px;";
            }
            return "<div style=\"position:absolute;top:84px;left:30px;width:24px;height:52px;" + t + "-webkit-user-select:none;overflow:hidden\"><div style=\"position:absolute;cursor:pointer;width:22px;height:24px;top:0;left:0;-webkit-user-select:none;-webkit-tap-highlight-color:rgba(0,0,0,0)\" title=\"放大一级\"></div><div style=\"position:absolute;cursor:pointer;width:22px;height:24px;top:25px;left:0;-webkit-user-select:none;-webkit-tap-highlight-color:rgba(0,0,0,0)\" title=\"缩小一级\"></div><div></div></div>";
          },
          _bind: function () {
            var t = this._pano;
            var e = this;
            if (v.isPc) {
              aa(this._panBtns[0], "click", function () {
                var e = t.getPov();
                t.setPov({
                  heading: e.heading,
                  pitch: e.pitch + 30
                }, {
                  animation: true
                });
              });
              aa(this._panBtns[1], "click", function () {
                var e = t.getPov();
                t.setPov({
                  heading: e.heading - 45,
                  pitch: e.pitch
                }, {
                  animation: true
                });
              });
              aa(this._panBtns[2], "click", function () {
                var e = t.getPov();
                t.setPov({
                  heading: e.heading + 45,
                  pitch: e.pitch
                }, {
                  animation: true
                });
              });
              aa(this._panBtns[3], "click", function () {
                var e = t.getPov();
                t.setPov({
                  heading: e.heading,
                  pitch: e.pitch - 30
                }, {
                  animation: true
                });
              });
              for (var n = 0; n < this._panBtns.length; n++) {
                aa(this._panBtns[n], "mousedown", function (t) {
                  t.stopPropagation();
                });
              }
              e._mousedown = false;
              aa(this._panBtnContainer, "mousedown", function (n) {
                e._mousedown = true;
                e._panBtnContainer.style.cursor = "grabbing";
                e._startHeading = e._calcAngle(n);
                e._curHeading = t.getPov().heading;
                n.preventDefault();
              });
              aa(document, "mousemove", function (n) {
                if (e._mousedown) {
                  t.setPov({
                    heading: e._curHeading + 360 - (e._calcAngle(n) - e._startHeading),
                    pitch: t.getPov().pitch
                  });
                }
              });
              aa(document, "mouseup", function () {
                if (e._mousedown) {
                  e._mousedown = false;
                  e._panBtnContainer.style.cursor = "grab";
                  e._startHeading = null;
                }
              });
              t.addEventListener("position_changed", function () {
                var t = 360 - this.getPov().heading;
                e._svgDirGroup.setAttribute("transform", "rotate(" + t + ", 41, 41)");
              });
              t.addEventListener("pov_changed", function () {
                var t = 360 - this.getPov().heading;
                e._svgDirGroup.setAttribute("transform", "rotate(" + t + ", 41, 41)");
              });
            }
            aa(this._btnZoomIn, "click", function () {
              t.setZoom(t.getZoom() + 1);
            });
            aa(this._btnZoomOut, "click", function () {
              t.setZoom(t.getZoom() - 1);
            });
            if (v.isPc) {
              aa(this._btnZoomIn, "mousedown", function () {
                e._redrawZoomBtn(e._zoomInEnabled, -98);
              });
              aa(this._btnZoomOut, "mousedown", function () {
                e._redrawZoomBtn(e._zoomOutEnabled, -122);
              });
              aa(this._btnZoomIn, "mouseup", function () {
                e._redrawZoomBtn(e._zoomInEnabled, -74);
              });
              aa(this._btnZoomOut, "mouseup", function () {
                e._redrawZoomBtn(e._zoomOutEnabled, -74);
              });
            } else if (v.isMobile) {
              aa(this._btnZoomIn, "touchstart", function () {
                e._redrawZoomBtn(e._zoomInEnabled, -98);
              });
              aa(this._btnZoomOut, "touchstart", function () {
                e._redrawZoomBtn(e._zoomOutEnabled, -122);
              });
              aa(this._btnZoomIn, "touchend", function () {
                e._redrawZoomBtn(e._zoomInEnabled, -74);
              });
              aa(this._btnZoomOut, "touchend", function () {
                e._redrawZoomBtn(e._zoomOutEnabled, -74);
              });
            }
            t.addEventListener("zoom_changed", function (n) {
              if (t.getZoom() >= p.MAX_ZOOM) {
                e._setZoomBtnEnabled("zoomIn", false);
              } else if (t.getZoom() <= p.MIN_ZOOM) {
                e._setZoomBtnEnabled("zoomOut", false);
              } else {
                e._setZoomBtnEnabled("zoomIn", true);
                e._setZoomBtnEnabled("zoomOut", true);
              }
            });
          },
          _redrawZoomBtn: function (t, e) {
            if (t) {
              if (v.isMobile) {
                e = (e + 74) / 24 * 36;
              }
              this._zoomContainer.style.backgroundPosition = e + "px 0";
            }
          },
          show: function () {
            this._container.style.display = "";
          },
          hide: function () {
            this._container.style.display = "none";
          },
          _calcAngle: function (t) {
            var e = (t = window.event || t).pageX || t.clientX;
            var n = t.pageY || t.clientY;
            var r = this._pano.getContainer().getBoundingClientRect();
            e = e - r.left - 50;
            n = -(n - r.top - 50);
            var i = Math.atan2(n, e) / Math.PI * 180;
            return i < 90 ? 90 - i : 450 - i;
          },
          _setZoomBtnEnabled: function (t, e) {
            if (t === "zoomIn") {
              if (e) {
                this._zoomInEnabled = true;
                this._btnZoomIn.style.cursor = "pointer";
                var n = -74;
                if (v.isMobile) {
                  n = 0;
                }
                this._zoomContainer.style.backgroundPosition = n + "px 0";
              } else {
                this._zoomInEnabled = false;
                this._btnZoomIn.style.cursor = "";
                var r = -170;
                if (v.isMobile) {
                  r = -144;
                }
                this._zoomContainer.style.backgroundPosition = r + "px 0";
              }
            }
            if (t === "zoomOut") {
              if (e) {
                this._zoomOutEnabled = true;
                this._btnZoomOut.style.cursor = "pointer";
                var i = -74;
                if (v.isMobile) {
                  i = 0;
                }
                this._zoomContainer.style.backgroundPosition = i + "px 0";
              } else {
                this._zoomOutEnabled = false;
                this._btnZoomOut.style.cursor = "";
                var o = -146;
                if (v.isMobile) {
                  o = -108;
                }
                this._zoomContainer.style.backgroundPosition = o + "px 0";
              }
            }
          }
        });
        return new e(t);
      }(this);
      this._eventManager = new oa(this);
    };
    n._createDoms = function () {
      var t = this._container;
      var e = w.create("div");
      var n = e.style;
      n.overflow = "hidden";
      n.position = "absolute";
      n.zIndex = "20";
      n.top = n.left = "0px";
      n.height = n.width = "100%";
      n.backgroundColor = "#e5e3df";
      n.display = "none";
      n.cursor = "grab";
      e.addEventListener("mousedown", function () {
        return n.cursor = "grabbing";
      });
      e.addEventListener("mouseup", function () {
        return n.cursor = "grab";
      });
      this._svContainer = e;
      this._panes = {
        tileLayer: this._createContainer("1"),
        maskLayer: this._createContainer("2"),
        linksLayer: this._createContainer("3"),
        overlayLayer: this._createContainer("4"),
        effectLayer: this._createContainer("5")
      };
      e.appendChild(this._panes.tileLayer);
      e.appendChild(this._panes.linksLayer);
      e.appendChild(this._panes.overlayLayer);
      e.appendChild(this._panes.effectLayer);
      if (!b()) {
        e.appendChild(this._panes.maskLayer);
        this._panes.maskLayer.style.width = "".concat(t.clientWidth, "px");
        this._panes.maskLayer.style.height = "".concat(t.clientHeight, "px");
        this._panes.maskLayer.style.overflow = "hidden";
      }
      t.appendChild(e);
      if (w.getCurrentStyle(t).position !== "absolute") {
        t.style.position = "relative";
      }
    };
    n._createContainer = function (t) {
      var e = w.create("div");
      var n = e.style;
      n.position = "absolute";
      n.top = n.left = "0";
      n.zIndex = t || "0";
      return e;
    };
    n.calcMobileFovy = function (t) {
      var e = this.getContainerSize();
      var n = e.width;
      var r = e.height;
      var i = 240 / Math.pow(2, t);
      var o = n / 2 / Math.tan(g(i / 2));
      var a = Math.atan2(r / 2, o);
      return 2 * y(a);
    };
    n.calcPCFovy = function (t) {
      return 90 - 15 * (t - 1);
    };
    o(e, [{
      key: "imageZoom",
      get: function () {
        return this.calcDisplayZoom().imgZoom;
      }
    }, {
      key: "panoId",
      get: function () {
        return this.panoData ? this.panoData.panoId : "";
      }
    }, {
      key: "panoNorthDir",
      get: function () {
        return this.panoData ? this.panoData.northDir : 0;
      }
    }, {
      key: "position",
      get: function () {
        return this.panoData && typeof this.panoData.panoX == "number" && typeof this.panoData.panoY == "number" ? new f(this.panoData.panoX, this.panoData.panoY) : null;
      }
    }]);
    return e;
  }(Or);
  var ua = {
    dom: null,
    anchor: null,
    width: null,
    height: null,
    altitude: 2,
    sphereZ: null,
    useUV: false
  };
  var ha = function (t) {
    function e(e) {
      var n;
      var r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      (n = t.call(this) || this).visible = true;
      n.worldCoord = undefined;
      n.pov = undefined;
      n.id = n.genId();
      n._pano = undefined;
      n.lastPanoPosition = null;
      n.initialized = false;
      n.position = undefined;
      n.options = undefined;
      n.position = e;
      n.options = Object.assign({}, ua, r);
      n.pov = null;
      return n;
    }
    c(e, t);
    var n = e.prototype;
    n.getPov = function () {
      return this.pov;
    };
    n.genId = function () {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 4;
      return Number("".concat(Math.random().toString().substr(3, t)).concat(Date.now())).toString(36);
    };
    n.init = function (t) {
      if (t && !this.initialized) {
        this._pano = t;
        this.lastPanoPosition = this._pano.position;
        this.worldCoord = this.options.useUV ? this.calcCoordsByUV() : this.calcCoordsByMC();
        if (this.worldCoord) {
          this.initialized = true;
          this.add();
          this.draw();
        }
      }
    };
    n.calcCoordsByMC = function () {
      var t = this._pano.position;
      if (t && this.position) {
        var e;
        var n = this.position;
        var r = n.lng - t.lng;
        var i = n.lat - t.lat;
        var o = Math.atan2(r, i);
        if (o < 0) {
          o += 2 * Math.PI;
        }
        o = Math.round(y(o));
        var a = 500;
        var s = this.options;
        var u = s.sphereZ;
        var h = s.altitude;
        if (u === null) {
          e = 25 * h;
        } else {
          e = u || 0;
          a = Math.sqrt(Math.pow(r, 2) + Math.pow(i, 2) + Math.pow(e, 2));
        }
        var c = y(Math.asin(e / a));
        c = c > 90 ? 90 : c < -90 ? -90 : c;
        var l = _(o + this._pano.panoNorthDir);
        var f = this.radius;
        var d = Math.cos(g(c)) * f;
        d = Math.round(100 * d) / 100;
        var p = Math.cos(g(l)) * d;
        var v = Math.sin(g(c)) * f;
        var m = Math.sin(g(l)) * d;
        this.pov = {
          heading: o,
          pitch: c
        };
        return Vt(p, v, m);
      }
    };
    n.calcCoordsByUV = function () {
      if (this.position) {
        var t = this.radius;
        var e = this.position;
        var n = xi(e, 2);
        var r = n[0];
        var i = n[1];
        var o = 2 * r * Math.PI;
        var a = (i - 0.5) * Math.PI;
        var s = Math.cos(a) * Math.cos(o) * t;
        var u = Math.sin(a) * t;
        var h = Math.cos(a) * Math.sin(o) * t;
        this.pov = {
          heading: _(y(o) - this._pano.panoNorthDir),
          pitch: y(a)
        };
        return Vt(s, u, h);
      }
    };
    n.add = function () {
      var t = this.options;
      var e = t.width;
      var n = t.height;
      if (this.dom) {
        var r = this._pano;
        var i = this.dom;
        i.style.position = "absolute";
        r.getPanes().overlayLayer.appendChild(i);
        if (typeof e != "number") {
          this.options.width = i.clientWidth;
        }
        if (typeof n != "number") {
          this.options.height = i.clientHeight;
        }
        r.dispatchEvent({
          type: "onoverlaydomadded",
          overlay: this
        });
      }
    };
    n.remove = function () {
      var t = this.dom;
      if (t && t.parentNode) {
        t.parentNode.removeChild(t);
      }
    };
    n.povToPointGL = function () {
      if (!this.worldCoord) {
        return null;
      }
      var t = this._pano;
      var e = t.camera;
      var n = t.getContainerSize();
      var r = n.width;
      var i = n.height;
      return po(e, this.worldCoord, r, i);
    };
    n.draw = function () {
      if (this.initialized && this.visible && this._pano && this._pano.panoData && this.dom) {
        var t = this.lastPanoPosition;
        var e = this._pano.position;
        if (!(t.lng === e.lng && t.lat === e.lat)) {
          this.lastPanoPosition = e;
          this.worldCoord = this.options.useUV ? this.calcCoordsByUV() : this.calcCoordsByMC();
        }
        var n = this.dom;
        var r = this.povToPointGL();
        n.style.visibility = "hidden";
        if (r) {
          var i = this.calcAnchor();
          var o = "".concat(r[0] - i.width, "px");
          var a = "".concat(r[1] - i.height, "px");
          if (isNaN(r[0]) || isNaN(r[1])) {
            return;
          }
          n.style.visibility = "visible";
          n.style.webkitTransform = "translate(".concat(o, ", ").concat(a, ")");
          n.style.transform = "translate(".concat(o, ", ").concat(a, ")");
        }
      }
    };
    n.handleClick = function () {
      this.dispatchEvent("click");
    };
    n.calcAnchor = function () {
      var t = this.options;
      var e = t.anchor;
      var n = t.width;
      var r = n === undefined ? 0 : n;
      var i = t.height;
      return e || new l(r / 2, (i === undefined ? 0 : i) / 2);
    };
    n.show = function () {
      this.visible = true;
      if (this.dom) {
        this.dom.style.display = "";
      }
    };
    n.hide = function () {
      this.visible = false;
      if (this.dom) {
        this.dom.style.display = "none";
      }
    };
    o(e, [{
      key: "radius",
      get: function () {
        return this._pano ? this._pano.opts.radius : 0;
      }
    }, {
      key: "dom",
      get: function () {
        return this.options.dom;
      }
    }]);
    return e;
  }(Or);
  var ca = function (t) {
    function e(e, n) {
      var r = n.position;
      var i = n.altitude;
      var o = i === undefined ? 2 : i;
      var a = n.costomStyle;
      var s = function (t) {
        var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var n = document.createElement("div");
        var r = {
          backgroundColor: "rgba(29, 29, 29, 0.8)",
          fontSize: "14px",
          padding: "7px 14px",
          height: "19px",
          color: "#fff",
          whiteSpace: "nowrap",
          borderRadius: "4px"
        };
        m(n.style, r, e);
        n.innerText = t;
        return n;
      }(e, a === undefined ? {} : a);
      return t.call(this, r, {
        dom: s,
        altitude: o
      }) || this;
    }
    c(e, t);
    return e;
  }(ha);
  t.Converters = mo;
  t.Engines = Qi;
  t.EventType = d;
  t.PanoLabel = ca;
  t.PanoOverlay = ha;
  t.PanoramaService = function () {
    var t = this;
    this.getPanoById = function (e, n) {
      var r;
      r = "".concat(tt.SERVICE_URL, "?qt=sdata&sid=").concat(e, "&").concat($("/"));
      t.request(r).then(function (t) {
        if (n) {
          n(t);
        }
      }).catch(function (t) {
        if (n) {
          n(null);
        }
      });
    };
    this.getPanoByLocation = function (e, n, r) {
      var i;
      i = "".concat(tt.SERVICE_URL, "?qt=qsdata&x=").concat(e.lng, "&y=").concat(e.lat).concat(n ? "&r=" + n : "", "&action=1&").concat($("/"));
      t.request(i).then(function (t) {
        if (r) {
          r(t);
        }
      }).catch(function (t) {
        if (r) {
          r(null);
        }
      });
    };
    this.request = function (t) {
      return T(t, {}, {
        jsonp: "fn"
      });
    };
  };
  t.Point = f;
  t.getPanoControl = function (t, e) {
    var n;
    var r;
    var i;
    var o = (e = e || {}).imgPath || "//api.map.baidu.com/images/";
    function a(e) {
      e.call(this);
      this.defaultAnchor = t.ControlAnchor.TOP_RIGHT;
      this.defaultOffset = new t.Size(10, 10);
      this._isOn = false;
    }
    n = a;
    r = t.Control;
    (i = Object.create(r.prototype)).constructor = n;
    n.prototype = i;
    m(a.prototype, {
      initialize: function (t) {
        this._map = t;
        this._render();
        this._bind();
        return this._container;
      },
      _render: function () {
        var t = this;
        var n = w.create("div");
        n.innerHTML = "<span style=\"position:relative;top:33px;\">全景</span>";
        n.title = "进入全景";
        m(n.style, {
          width: "49px",
          height: "51px",
          color: "#565656",
          background: "url(\"".concat(o, "st-control.png\")"),
          position: "absolute",
          cursor: "pointer",
          fontFamily: "arial,sans-serif",
          fontSize: "13px",
          textAlign: "center",
          boxShadow: "0px 0px 3px rgba(0, 0, 0, 0.3)",
          MozBoxShadow: "0px 0px 3px rgba(0, 0, 0, 0.3)",
          WebkitBoxShadow: "0px 0px 3px rgba(0, 0, 0, 0.3)"
        });
        this._container = n;
        var r = this._map.getContainer();
        r.appendChild(n);
        var i = {
          visible: false
        };
        if (e.imgPath) {
          i.imgPath = [e.imgPath];
        }
        if (e.tileBaseUrl) {
          i.tileBaseUrls = [e.tileBaseUrl];
        }
        this._pano = new sa(r, i);
        this._pano.addCloseButton(function () {
          if (t.isMapEnableWheelZoom) {
            t._map.enableScrollWheelZoom();
          }
        });
        var a = this._scout = w.create("div");
        m(a.style, {
          position: "absolute",
          width: "24px",
          height: "41px",
          cursor: "pointer",
          backgroundImage: "url(\"".concat(o, "st-scout.png\")"),
          backgroundRepeat: "no-repeat",
          backgroundPosition: "-24px 0",
          overflow: "hidden",
          display: "none",
          zIndex: 11
        });
        r.appendChild(a);
        var s = this._infoWindow = w.create("div");
        m(s.style, {
          position: "absolute",
          width: "112px",
          height: "119px",
          backgroundImage: "url(\"".concat(o, "st-infowindow.gif\")"),
          backgroundRepeat: "no-repeat",
          backgroundPosition: "0 0",
          display: "none",
          cursor: "pointer",
          zIndex: 12
        });
        var u = this._thumb = w.create("img");
        s.appendChild(u);
        u.src = o + "st-noresult.png";
        m(u.style, {
          width: "100px",
          height: "75px",
          left: "6px",
          top: "6px",
          position: "absolute"
        });
        var h = this._stDescription = w.create("div");
        m(h.style, {
          position: "absolute",
          top: "85px",
          fontFamily: "arial,sans-serif",
          fontSize: "13px",
          paddingLeft: "6px"
        });
        s.appendChild(h);
        r.appendChild(s);
      },
      _updateView: function () {
        var t = this._container.style;
        if (this._isOn || this._isOver) {
          t.backgroundPosition = "-49px 0";
          t.color = "#fff";
        } else {
          t.backgroundPosition = "0 0";
          t.color = "#565656";
        }
      },
      _bind: function () {
        var n = this;
        this._pano.on("dataload", function (t) {
          var r = t.data;
          if (r) {
            n._currentSvId = r.panoId;
            if (e.tileBaseUrl) {
              n._thumb.src = "".concat(e.tileBaseUrl, "?&sid=").concat(r.panoId, "&pos=0_0&z=0");
            } else {
              n._thumb.src = "//apisv0.bdimg.com/?qt=pdata&sid=".concat(r.panoId, "&pos=0_0&z=0&from=H5&").concat($("/"));
            }
            n._stDescription.innerHTML = r.roadName;
          } else {
            n._currentSvId = null;
            n._thumb.src = o + "st-noresult.png";
            n._stDescription.innerHTML = "";
          }
        });
        var r = this;
        if (v.isPc) {
          this._container.addEventListener("mouseover", function () {
            r._isOver = true;
            r._updateView();
          });
          this._container.addEventListener("mouseout", function () {
            r._isOver = false;
            r._updateView();
          });
        }
        this._container.addEventListener("click", function () {
          if (r._isOn) {
            r._close();
          } else {
            r._open();
          }
        });
        this._map.getContainer().addEventListener("mousemove", function (e) {
          if (r._isOn) {
            var n = (e = window.event || e).pageX || e.clientX;
            var i = e.pageY || e.clientY;
            var a = function (t) {
              for (var e = {
                left: 0,
                top: 0
              }; t && t.offsetParent;) {
                e.left += t.offsetLeft;
                e.top += t.offsetTop;
                t = t.offsetParent;
              }
              return e;
            }(r._map.container);
            var s = new qo(n - a.left, i - a.top);
            var u = r._map.pixelToPoint(s);
            if (r._scout.style.display !== "" && v.isPc) {
              r._scout.style.display = "";
              r._infoWindow.style.display = "";
            }
            r._scout.style.left = s.x - 12 + "px";
            r._scout.style.top = s.y - 41 - 2 + "px";
            r._prePixel = r._curPixel;
            r._curPixel = s;
            if (r._prePixel) {
              var h = s.x - r._prePixel.x;
              if (h > 0) {
                r._scout.style.backgroundPosition = "-48px 0";
              } else if (h < 0) {
                r._scout.style.backgroundPosition = "0 0";
              }
            }
            if (r._curPixel.y < 170) {
              r._infoStatus = 2;
            } else {
              r._infoStatus = 1;
            }
            if (r._curPixel.x < 66) {
              r._infoStatus = 3;
            }
            if (r._curPixel.x > r._map.getSize().width - 56 - 10) {
              r._infoStatus = 4;
            }
            var c = r._infoStatus === 1 || r._infoStatus === 2 ? 112 : 126;
            var l = r._infoStatus === 1 || r._infoStatus === 2 ? 119 : 105;
            if (!(r._infoStatus !== 1 && r._infoStatus !== 2)) {
              r._infoWindow.style.left = r._curPixel.x - Math.round(c / 2) + "px";
              if (r._infoStatus === 1) {
                r._infoWindow.style.top = r._curPixel.y - l - 42 + "px";
                r._infoWindow.style.backgroundPosition = "0 0";
                r._thumb.style.top = "6px";
                r._thumb.style.bottom = "";
                r._stDescription.style.top = "85px";
                r._stDescription.style.bottom = "";
              } else {
                r._infoWindow.style.top = r._curPixel.y + 2 + "px";
                r._infoWindow.style.backgroundPosition = "-112px 0";
                r._thumb.style.top = "";
                r._thumb.style.bottom = "6px";
                r._stDescription.style.top = "";
                r._stDescription.style.bottom = "85px";
              }
              r._infoWindow.style.width = "112px";
              r._infoWindow.style.height = "119px";
              r._thumb.style.left = "6px";
              r._stDescription.style.left = "0";
            }
            if (!(r._infoStatus !== 3 && r._infoStatus !== 4)) {
              r._infoWindow.style.top = r._curPixel.y - Math.round(l / 2) - 20 + "px";
              if (r._infoStatus === 3) {
                r._infoWindow.style.left = r._curPixel.x + 12 + "px";
                r._infoWindow.style.backgroundPosition = "0 -119px";
                r._thumb.style.left = "20px";
                r._stDescription.style.left = "14px";
              } else {
                r._infoWindow.style.left = r._curPixel.x - 12 - c + "px";
                r._infoWindow.style.backgroundPosition = "-126px -119px";
                r._thumb.style.left = "6px";
                r._stDescription.style.left = "0";
              }
              r._infoWindow.style.width = "126px";
              r._infoWindow.style.height = "105px";
            }
            r._infoWindow.style.backgroundImage = "url(\"".concat(o, "st-infowindow.gif\")");
            if (r._timerId) {
              clearTimeout(r._timerId);
              r._timerId = null;
            }
            r._timerId = setTimeout(function () {
              r._currentPoint = u;
              r._scout.style.backgroundPosition = "-24px 0";
              var e = r._map.lnglatToMercator(u.lng, u.lat);
              r._pano.setPosition(new t.Point(e[0], e[1]));
            }, 200);
          }
        });
        this._map.addEventListener("click", function (t) {
          if (r._isOn && v.isMobile) {
            r._pano.setPosition(t.point);
            r._pano.show();
            r._close();
          }
          if (r._isOn && r._currentSvId) {
            r._pano.setId(r._currentSvId);
            r._pano.show();
            if (r._map.config.enableWheelZoom) {
              r._map.disableScrollWheelZoom();
              r.isMapEnableWheelZoom = true;
            }
            r._close();
          }
        });
      },
      _open: function () {
        if (!this._isOn) {
          this._isOn = true;
          this._map.addTileLayer(this._panoCoverageLayer);
          if (v.isPc) {
            this._preDefaultCursor = this._map.getDefaultCursor();
            this._preDraggingCursor = this._map.getDraggingCursor();
            this._map.setDefaultCursor("pointer");
            this._map.setDraggingCursor("pointer");
          }
        }
        this._updateView();
      },
      _close: function () {
        if (this._isOn) {
          this._map.removeTileLayer(this._panoCoverageLayer);
          if (v.isPc) {
            this._scout.style.display = "none";
            this._infoWindow.style.display = "none";
            this._map.setDefaultCursor(this._preDefaultCursor);
            this._map.setDraggingCursor(this._preDraggingCursor);
          }
          this._isOn = false;
        }
        this._updateView();
      }
    });
    return new a(t.Control);
  };
  t.getStreetViewCoverageLayer = function (t) {
    var e = new t.TileLayer({
      transparentPng: true,
      dataType: 1,
      cacheSize: 32
    });
    e.zIndex = 110;
    e.getTilesUrl = window.PANORAMA_URL ? function (t, e) {
      var n = window.PANORAMA_URL + "/tile";
      var r = t.x;
      var i = t.y;
      if (window.BMAPGL_84) {
        i = Math.pow(2, e) - i - 1;
      }
      return "".concat(n, "?customid=panorama&x=").concat(r, "&y=").concat(i, "&z=").concat(e, "&type=WGS84");
    } : function (t, e) {
      var n = ["//apisv0.bdimg.com/", "//apisv1.bdimg.com/"];
      var r = (Math.abs(t.x) + Math.abs(t.y)) % n.length;
      return "".concat(n[r], "?udt=").concat("20150114", "&qt=tile&styles=").concat("pl", "&x=").concat(t.x, "&y=").concat(t.y, "&z=").concat(e).replace(/-(\d+)/gi, "M$1") + "&" + $("/", {
        isCounter: false
      });
    };
    return e;
  };
  t.init = function (t, e) {
    return new sa(t, e);
  };
  Object.defineProperty(t, "__esModule", {
    value: true
  });
})(Pano = {});
window.BMapGL = window.BMapGL || {};
(function (bx, fs) {
  var eX = eX || {
    version: "20150702",
    emptyFn: function () {}
  };
  (function () {
    eX._log = [];
    var i = 0;
    var T = {};
    eX.BaseClass = function (kc) {
      T[this.hashCode = kc || eX.BaseClass.guid()] = this;
    };
    eX.BaseClass.guid = function () {
      return "mz_" + (i++).toString(36);
    };
    eX.BaseClass.create = function () {
      var kc = new eX.BaseClass();
      kc.decontrol();
      return kc;
    };
    var e = eX.instance = eX.I = function (kc) {
      return T[kc];
    };
    eX.BaseClass.prototype.dispose = function () {
      if (this.hashCode) {
        delete T[this.hashCode];
      }
      for (var kc in this) {
        if (typeof this[kc] != "function") {
          delete this[kc];
        }
      }
    };
    eX.BaseClass.prototype.getHashCode = function () {
      if (!this.hashCode) {
        T[this.hashCode = eX.BaseClass.guid()] = this;
      }
      return this.hashCode;
    };
    eX.BaseClass.prototype.decontrol = function () {
      delete T[this.hashCode];
    };
    eX.BaseClass.prototype.toString = function () {
      return "[object " + (this._className || "Object") + "]";
    };
    eX.BaseClass.prototype._wlog = function (kd, ke) {
      var kc = eX._log;
      if (kc.length > 100) {
        kc.reverse().length = 50;
        kc.reverse();
      }
      kc[kc.length] = "[" + kd + "][" + (this._className || "Object") + " " + this.hashCode + "] " + ke;
    };
  })();
  Function.prototype.inherits = function (kc, T) {
    var e;
    var kd;
    var kf = this.prototype;
    var ke = function () {};
    ke.prototype = kc.prototype;
    kd = this.prototype = new ke();
    if (typeof T == "string") {
      kd._className = T;
    }
    for (e in kf) {
      kd[e] = kf[e];
    }
    this.prototype.constructor = kf.constructor;
    kf = ke = null;
    return kd;
  };
  eX.BaseEvent = function (e, i) {
    this.type = e;
    this.returnValue = true;
    this.target = i || null;
    this.currentTarget = this.srcElement = null;
    this.cancelBubble = false;
    this.domEvent = null;
  };
  eX.BaseClass.prototype.on = eX.BaseClass.prototype.addEventListener = function (T, i) {
    if (typeof i !== "function") {
      return this._wlog("error", "addEventListener:" + i + " is not a function");
    }
    if (!this._listeners) {
      this._listeners = {};
    }
    var e = this._listeners;
    if (T.indexOf("on") !== 0) {
      T = "on" + T;
    }
    if (typeof e[T] !== "object") {
      e[T] = {};
    }
    var kc = i.hashCode || eX.BaseClass.guid();
    i.hashCode = kc;
    if (e[T][kc]) {
      this._wlog("warning", "repeat key:" + kc);
    }
    e[T][kc] = i;
  };
  eX.BaseClass.prototype.off = eX.BaseClass.prototype.removeEventListener = function (T, i) {
    if (typeof i == "function") {
      i = i.hashCode;
    } else if (typeof i !== "string" && typeof i !== "undefined") {
      return;
    }
    if (!this._listeners) {
      this._listeners = {};
    }
    if (T.indexOf("on") != 0) {
      T = "on" + T;
    }
    var e = this._listeners;
    if (!e[T]) {
      return;
    }
    if (i === undefined) {
      e[T] = {};
      return;
    }
    if (e[T][i]) {
      delete e[T][i];
    }
  };
  eX.BaseClass.prototype.fire = eX.BaseClass.prototype.dispatchEvent = function (kc) {
    if (!this._listeners) {
      this._listeners = {};
    }
    var T;
    var e = this._listeners;
    var kd = kc.type;
    kc.target = kc.srcElement = kc.target || kc.srcElement || this;
    kc.currentTarget = this;
    if (typeof this[kd] == "function") {
      this[kd](kc);
    }
    if (typeof e[kd] == "object") {
      for (T in e[kd]) {
        if (typeof e[kd][T] == "function") {
          e[kd][T].call(this, kc);
        }
      }
    }
    return kc.returnValue;
  };
  eX.BaseEvent.prototype.inherit = function (T) {
    var i = this;
    this.domEvent = T = window.event || T;
    i.clientX = T.clientX || T.pageX;
    i.clientY = T.clientY || T.pageY;
    i.offsetX = T.offsetX || T.layerX;
    i.offsetY = T.offsetY || T.layerY;
    i.screenX = T.screenX;
    i.screenY = T.screenY;
    i.ctrlKey = T.ctrlKey || T.metaKey;
    i.shiftKey = T.shiftKey;
    i.altKey = T.altKey;
    return i;
  };
  eX.Browser = function () {
    var T = navigator.userAgent;
    var kd = 0;
    var e = 0;
    var ke = 0;
    var i = 0;
    var ki = 0;
    var kg = 0;
    var kh = 0;
    var kf = 0;
    var kc = 0;
    var kj = 0;
    if (typeof window.opera === "object" && /Opera(\s|\/)(\d+(\.\d+)?)/.test(T)) {
      ke = parseFloat(RegExp.$2);
    } else if (/OPR(\/(\d+)(\..?)?)/.test(T)) {
      ke = parseInt(RegExp.$2, 10);
    } else if (/Edge\/((\d+)\.\d+)/.test(T)) {
      kd = parseInt(RegExp.$2, 10);
    } else if (/MSIE (\d+(\.\d+)?)/.test(T)) {
      e = parseFloat(RegExp.$1);
    } else if (T.indexOf("Trident") > -1 && /rv:(\d+(\.\d+)?)/.test(T)) {
      e = parseInt(RegExp.$1, 10);
    } else if (/Firefox(\s|\/)(\d+(\.\d+)?)/.test(T)) {
      ki = parseFloat(RegExp.$2);
    } else if (navigator.vendor === "Netscape" && /Netscape(\s|\/)(\d+(\.\d+)?)/.test(T)) {
      kh = parseFloat(RegExp.$2);
    } else if (T.indexOf("Safari") > -1 && /Version\/(\d+(\.\d+)?)/.test(T)) {
      i = parseFloat(RegExp.$1);
    }
    if (T.indexOf("Trident") > -1 && /Trident\/(\d+(\.\d+)?)/.test(T)) {
      kf = parseInt(RegExp.$1, 10);
    } else if (!e && !kd && T.indexOf("Gecko") > -1 && T.indexOf("KHTML") === -1 && /rv\:(\d+(\.\d+)?)/.test(T)) {
      kc = parseFloat(RegExp.$1);
    } else if (!kd && /chrome\/(\d+(\.\d+)?)/i.test(T)) {
      kg = parseFloat(RegExp.$1);
    } else if (!kd && /AppleWebKit\/(\d+(\.\d+)?)/.test(T)) {
      kj = parseInt(RegExp.$1, 10);
    }
    var kk = {
      edge: kd,
      ie: e,
      firefox: ki,
      netscape: kh,
      opera: ke,
      safari: i,
      chrome: kg,
      gecko: kc,
      trident: kf,
      webkit: kj
    };
    return kk;
  }();
  window.FeBrowser = eX.Browser;
  eX.Dom = {};
  eX.Dom.createDom = function (i, e) {
    if (eX.isIE && e && e.name) {
      i = "<" + i + " name=\"" + eX.String.escapeHTML(e.name) + "\">";
    }
    var T = document.createElement(i);
    if (e) {
      eX.Dom.setProperties(T, e);
    }
    return T;
  };
  eX.Dom.getOffset = function (kc) {
    var kf = eX.Dom.getOwnerDocument(kc);
    var ke = eX.isGecko > 0 && kf.getBoxObjectFor && eX.Dom.getStyle(kc, "position") == "absolute" && (kc.style.top === "" || kc.style.left === "");
    var kg = {
      left: 0,
      top: 0
    };
    var i = eX.isIE && !eX.isStrict ? kf.body : kf.documentElement;
    if (kc == i) {
      return kg;
    }
    var T = null;
    var kd;
    if (kc.getBoundingClientRect) {
      kd = kc.getBoundingClientRect();
      kg.left = kd.left + Math.max(kf.documentElement.scrollLeft, kf.body.scrollLeft);
      kg.top = kd.top + Math.max(kf.documentElement.scrollTop, kf.body.scrollTop);
      kg.left -= kf.documentElement.clientLeft;
      kg.top -= kf.documentElement.clientTop;
      if (eX.isIE && !eX.isStrict) {
        kg.left -= 2;
        kg.top -= 2;
      }
    } else if (kf.getBoxObjectFor && !ke) {
      kd = kf.getBoxObjectFor(kc);
      var e = kf.getBoxObjectFor(i);
      kg.left = kd.screenX - e.screenX;
      kg.top = kd.screenY - e.screenY;
    } else {
      T = kc;
      do {
        kg.left += T.offsetLeft;
        kg.top += T.offsetTop;
        if (eX.isWebkit > 0 && eX.Dom.getStyle(T, "position") == "fixed") {
          kg.left += kf.body.scrollLeft;
          kg.top += kf.body.scrollTop;
          break;
        }
        T = T.offsetParent;
      } while (T && T != kc);
      if (eX.isOpera > 0 || eX.isWebkit > 0 && eX.Dom.getStyle(kc, "position") == "absolute") {
        kg.top -= kf.body.offsetTop;
      }
      T = kc.offsetParent;
      while (T && T != kf.body) {
        kg.left -= T.scrollLeft;
        if (!eX.isOpera || T.tagName != "TR") {
          kg.top -= T.scrollTop;
        }
        T = T.offsetParent;
      }
    }
    return kg;
  };
  eX.Dom.getOwnerDocument = function (e) {
    return e.nodeType == 9 ? e : e.ownerDocument || e.document;
  };
  eX.Dom.setProperties = function (i, e) {
    eX.each(e, function (kc, T) {
      eX.Dom._setProperty(i, T, kc);
    });
  };
  eX.Dom._setProperty = function (i, e, T) {
    if (e == "style") {
      i.style.cssText = T;
    } else if (e == "class") {
      i.className = T;
    } else if (e == "for") {
      i.htmlFor = T;
    } else if (e in eX.Dom._DIRECT_ATTRIBUTE_MAP) {
      i.setAttribute(eX.Dom._DIRECT_ATTRIBUTE_MAP[e], T);
    } else {
      i[e] = T;
    }
  };
  eX.Dom._DIRECT_ATTRIBUTE_MAP = {
    cellpadding: "cellPadding",
    cellspacing: "cellSpacing",
    colspan: "colSpan",
    rowspan: "rowSpan",
    valign: "vAlign",
    height: "height",
    width: "width",
    usemap: "useMap",
    frameborder: "frameBorder"
  };
  eX.G = function () {
    for (var T = [], kc = arguments.length - 1; kc > -1; kc--) {
      var kd = arguments[kc];
      T[kc] = null;
      if (typeof kd == "object" && kd && kd.dom) {
        T[kc] = kd.dom;
      } else if (typeof kd == "object" && kd && kd.tagName || kd == window || kd == document) {
        T[kc] = kd;
      } else if (typeof kd == "string" && (kd = document.getElementById(kd))) {
        T[kc] = kd;
      }
    }
    return T.length < 2 ? T[0] : T;
  };
  eX.ac = function (e, i) {
    if (!(e = this.G(e))) {
      return;
    }
    i = this.trim(i);
    if (!new RegExp("(^| )" + i.replace(/(\W)/g, "\\$1") + "( |$)").test(e.className)) {
      e.className = e.className.split(/\s+/).concat(i).join(" ");
    }
  };
  eX.addClassName = eX.ac;
  eX.each = function (ke, e) {
    if (typeof e != "function") {
      return ke;
    }
    if (ke) {
      if (ke.length === undefined) {
        for (var T in ke) {
          e.call(ke[T], ke[T], T);
        }
      } else {
        for (var kc = 0, kd = ke.length; kc < kd; kc++) {
          e.call(ke[kc], ke[kc], kc);
        }
      }
    }
    return ke;
  };
  eX.extend = function (ke, kc) {
    if (ke && kc && typeof kc == "object") {
      for (var kd in kc) {
        ke[kd] = kc[kd];
      }
      var T = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
      for (var e = 0, i; e < T.length; e++) {
        i = T[e];
        if (Object.prototype.hasOwnProperty.call(kc, i)) {
          ke[i] = kc[i];
        }
      }
    }
    return ke;
  };
  eX.hide = function () {
    eX.each(arguments, function (e) {
      if (e = eX.G(e)) {
        e.style.display = "none";
      }
    });
  };
  eX.inherit = function (kg, kc, T) {
    var kf = kg.prototype;
    var ke = function () {};
    ke.prototype = kc.prototype;
    var kd = kg.prototype = new ke();
    if (typeof T == "string") {
      kd._className = T;
    }
    for (var e in kf) {
      kd[e] = kf[e];
    }
    kg.prototype.constructor = kf.constructor;
    kf = null;
    return kd;
  };
  eX.isIE = 0;
  (function () {
    if (navigator.userAgent.indexOf("MSIE") > 0 && !window.opera) {
      /MSIE (\d+(\.\d+)?)/.test(navigator.userAgent);
      eX.isIE = parseFloat(RegExp.$1);
    }
  })();
  eX.rc = function (e, i) {
    if (!(e = this.G(e))) {
      return;
    }
    i = this.trim(i);
    var T = e.className.replace(new RegExp("(^| +)" + i.replace(/(\W)/g, "\\$1") + "( +|$)", "g"), "$2");
    if (e.className != T) {
      e.className = T;
    }
  };
  eX.removeClassName = eX.rc;
  eX.show = function () {
    this.each(arguments, function (e) {
      if (e = eX.G(e)) {
        e.style.display = "";
      }
    });
  };
  eX.trim = function (e) {
    return e.replace(/(^[\s\t\xa0\u3000]+)|([\u3000\xa0\s\t]+$)/g, "");
  };
  eX.getElementsByClassName = function (e, i) {
    if (e.getElementsByClassName) {
      return e.getElementsByClassName(i);
    } else {
      return function T(kj, kh) {
        if (kh == null) {
          kh = document;
        }
        var kg = [];
        var kf = kh.getElementsByTagName("*");
        var kc = kf.length;
        var ki = new RegExp("(^|\\s)" + kj + "(\\s|$)");
        var ke;
        var kd;
        for (ke = 0, kd = 0; ke < kc; ke++) {
          if (ki.test(kf[ke].className)) {
            kg[kd] = kf[ke];
            kd++;
          }
        }
        return kg;
      }(i, e);
    }
  };
  eX.toggleClass = function (e, i) {
    if (eX.hasClass(e, i)) {
      eX.removeClassName(e, i);
    } else {
      eX.addClassName(e, i);
    }
  };
  eX.hasClass = function (kc, T) {
    if (!kc || !kc.className || typeof kc.className != "string") {
      return false;
    }
    var i = -1;
    try {
      i = kc.className == T || kc.className.search(new RegExp("(\\s|^)" + T + "(\\s|$)"));
    } catch (kd) {
      return false;
    }
    return i > -1;
  };
  eX.insertHTML = function (kc, e, T) {
    kc = eX.G(kc);
    if (kc === null) {
      return kc;
    }
    var i;
    var kd;
    if (kc.insertAdjacentHTML) {
      kc.insertAdjacentHTML(e, T);
    } else {
      i = kc.ownerDocument.createRange();
      e = e.toUpperCase();
      if (e == "AFTERBEGIN" || e == "BEFOREEND") {
        i.selectNodeContents(kc);
        i.collapse(e == "AFTERBEGIN");
      } else {
        kd = e == "BEFOREBEGIN";
        i[kd ? "setStartBefore" : "setEndAfter"](kc);
        i.collapse(kd);
      }
      i.insertNode(i.createContextualFragment(T));
    }
    return kc;
  };
  if (typeof HTMLElement != "undefined" && HTMLElement.prototype.__lookupGetter__ && !HTMLElement.prototype.__lookupGetter__("children") && !window.opera) {
    try {
      HTMLElement.prototype.__defineGetter__("children", function () {
        for (var T = [], kc = 0, ke, kd = 0, e = this.childNodes.length; kd < e; kd++) {
          ke = this.childNodes[kd];
          if (ke.nodeType == 1) {
            T[kc++] = ke;
            if (ke.name) {
              if (!T[ke.name]) {
                T[ke.name] = [];
              }
              T[ke.name][T[ke.name].length] = ke;
            }
            if (ke.id) {
              T[ke.id] = ke;
            }
          }
        }
        return T;
      });
    } catch (jq) {}
  }
  if (typeof HTMLElement != "undefined" && !window.opera && HTMLElement.prototype && !HTMLElement.prototype.insertAdjacentHTML) {
    HTMLElement.prototype.insertAdjacentHTML = function (i, T) {
      var kc = this.ownerDocument.createRange();
      kc.setStartBefore(this);
      kc = kc.createContextualFragment(T);
      switch (i) {
        case "beforeBegin":
          this.parentNode.insertBefore(kc, this);
          break;
        case "afterBegin":
          this.insertBefore(kc, this.firstChild);
          break;
        case "beforeEnd":
          this.appendChild(kc);
          break;
        case "afterEnd":
          if (!this.nextSibling) {
            this.parentNode.appendChild(kc);
          } else {
            this.parentNode.insertBefore(kc, this.nextSibling);
          }
          break;
      }
    };
  }
  if (typeof HTMLElement != "undefined" && !window.opera) {
    HTMLElement.prototype.contains = function (e) {
      if (!e) {
        return false;
      }
      if (e == this) {
        return true;
      }
      while (e = e.parentNode) {
        if (e == this) {
          return true;
        }
      }
      return false;
    };
  }
  if (!eX.Browser.ie && typeof Event != "undefined" && !window.opera) {
    Event.prototype.__defineSetter__("returnValue", function (e) {
      if (!e) {
        this.preventDefault();
      }
      return e;
    });
    Event.prototype.__defineSetter__("cancelBubble", function (e) {
      if (e) {
        this.stopPropagation();
      }
      return e;
    });
  }
  eX.each = function (kd, kc) {
    if (bR(kc)) {
      for (var T = 0, e = kd.length; T < e; T++) {
        if (kc.call(kd, kd[T], T) === false) {
          break;
        }
      }
    }
    return kd;
  };
  eX.Platform = {
    x11: 0,
    macintosh: 0,
    windows: 0,
    android: 0,
    iphone: 0,
    ipad: 0
  };
  for (var jo in eX.Platform) {
    if (eX.Platform.hasOwnProperty(jo)) {
      eX.Platform[jo] = new RegExp(jo, "i").test(window.navigator.userAgent) ? 1 : 0;
    }
  }
  if (typeof eX.Dom === "undefined") {
    eX.Dom = {};
  }
  eX.Dom.getComputedStyle = function (i, e) {
    var kc = i.nodeType == 9 ? i : i.ownerDocument || i.document;
    var T;
    if (kc.defaultView && kc.defaultView.getComputedStyle) {
      T = kc.defaultView.getComputedStyle(i, null);
      if (T) {
        return T[e] || T.getPropertyValue(e);
      }
    } else if (i.currentStyle) {
      return i.currentStyle[e] || "";
    }
    return "";
  };
  var fJ = eX.BaseEvent;
  var c8 = eX.BaseClass;
  c8.prototype.toString = function () {
    return this._className || "";
  };
  eX.on = function (T, i, e) {
    if (!(T = eX.G(T))) {
      return T;
    }
    i = i.replace(/^on/, "");
    if (T.addEventListener) {
      T.addEventListener(i, e, false);
    } else if (T.attachEvent) {
      T.attachEvent("on" + i, e);
    }
    return T;
  };
  eX.un = function (T, i, e) {
    if (!(T = eX.G(T))) {
      return T;
    }
    i = i.replace(/^on/, "");
    if (T.removeEventListener) {
      T.removeEventListener(i, e, false);
    } else if (T.detachEvent) {
      T.detachEvent("on" + i, e);
    }
    return T;
  };
  eX.hc = function (kc, T) {
    if (!kc || !kc.className || typeof kc.className != "string") {
      return false;
    }
    var i = -1;
    try {
      i = kc.className == T || kc.className.search(new RegExp("(\\s|^)" + T + "(\\s|$)"));
    } catch (kd) {
      return false;
    }
    return i > -1;
  };
  eX.isEmptyObject = function (T) {
    if (Object.prototype.toString.call(T) === "[object Object]") {
      for (var e in T) {
        return false;
      }
      return true;
    } else {
      return false;
    }
  };
  var bQ = window.location.protocol === "http:" ? "http:" : "https:";
  var eu = {
    fontFamily: "Arial,Helvetica,\"PingFang SC\",\"Hiragino Sans GB\",STHeiti,sans-serif",
    mapStyleNameIdPair: {
      default: 0,
      "grayed-out": 1
    },
    mapHost: bQ + "//map.baidu.com",
    apiHost: bQ + "//api.map.baidu.com",
    apiIMG: bQ + "//api.map.baidu.com/images",
    staticHost: bQ + "//webmap0.bdimg.com",
    imgPath: bQ + "//webmap0.bdimg.com/image/api/",
    tileDomain: [bQ + "//maponline0.bdimg.com", bQ + "//maponline1.bdimg.com", bQ + "//maponline2.bdimg.com", bQ + "//maponline3.bdimg.com"],
    panoTilePath: "//apisv1.bdimg.com/",
    optDomain: "http://10.120.25.45:8017",
    rasterTilePath: "/tile/",
    vectorTilePath: "/pvd/",
    originTilePath: [bQ + "//pcor.baidu.com"],
    stylePath: "//maponline0.bdimg.com/sty/",
    bosPath: bQ + "//mapopen-pub-jsapigl.bj.bcebos.com/assets/images/",
    getIconSetPath: function (e) {
      var i = "map_icons2x/";
      if (typeof e === "string" && this.mapStyleNameIdPair[e] > 0) {
        i = "map_icons2x_" + (this.mapStyleNameIdPair[e] - 1) + "/";
      }
      return bQ + this.stylePath + i;
    },
    getMapStyleFiles: function (T) {
      var kd = true;
      if (typeof T === "string" && T !== "default") {
        kd = false;
      }
      var ke = kd ? "" : "_" + (this.mapStyleNameIdPair[T] - 1);
      var i = by();
      var kc = "udt=" + i.udt + "&v=" + i.ver;
      var e = bQ + this.stylePath;
      return [e + "icons_2x" + ke + ".js?" + kc, e + "fs" + ke + ".js?" + kc, e + "indoor_fs.js?" + kc];
    },
    tvc: {
      ditu: {
        normal: {
          version: "088",
          updateDate: "20210726"
        },
        satellite: {
          version: "009",
          updateDate: "20210726"
        },
        normalTraffic: {
          version: "081",
          updateDate: "20210726"
        },
        satelliteTraffic: {
          version: "083",
          updateDate: "20210726"
        },
        mapJS: {
          version: "104",
          updateDate: "20210726"
        },
        satelliteStreet: {
          version: "083",
          updateDate: "20210726"
        },
        panoClick: {
          version: "1033",
          updateDate: "20180108"
        },
        panoUdt: {
          version: "20180108",
          updateDate: "20180108"
        },
        panoSwfAPI: {
          version: "20150123",
          updateDate: "20150123"
        },
        panoSwfPlace: {
          version: "20141112",
          updateDate: "20141112"
        },
        earthVector: {
          version: "001",
          updateDate: "20210726"
        }
      }
    },
    msv: {
      mapstyle: {
        updateDate: "20221108",
        version: "001"
      }
    }
  };
  eu.imgResources = {
    blankGIF: eu.staticHost + "/res/litemapapi/v1d1/images/blank.gif?20170501",
    markerPng: eu.staticHost + "/res/litemapapi/v1d1/images/marker.png?20170501",
    locPng: eu.staticHost + "/res/litemapapi/v1d1/images/loc.png?20180918",
    locNewPng: eu.staticHost + "/res/litemapapi/v1d1/images/loc_new.png?20190314",
    zoomPng: eu.staticHost + "/res/litemapapi/v1d1/images/zoombtn.png?20180918",
    mapLogoPng: eu.staticHost + "/res/litemapapi/v1d1/images/logo-2x.png?20190226"
  };
  var B = eu;
  var jf = "ruler.cur";
  if (eX.Browser.ie || eX.Browser.edge) {
    eX.extend(B, {
      distCursor: "url(" + B.imgPath + jf + "),crosshair",
      defaultCursor: "url(" + B.imgPath + "openhand.cur),default",
      draggingCursor: "url(" + B.imgPath + "closedhand.cur),move"
    });
  } else if (eX.Browser.firefox) {
    eX.extend(B, {
      distCursor: "url(" + B.imgPath + jf + "),crosshair",
      defaultCursor: "-moz-grab",
      draggingCursor: "-moz-grabbing"
    });
  } else if (eX.Browser.chrome || eX.Browser.safari) {
    eX.extend(B, {
      distCursor: "url(" + B.imgPath + jf + ") 2 6,crosshair",
      defaultCursor: "url(" + B.imgPath + "openhand.cur) 8 8,default",
      draggingCursor: "url(" + B.imgPath + "closedhand.cur) 8 8,move"
    });
    if (eX.Platform.macintosh) {
      B.defaultCursor = "-webkit-grab";
      B.draggingCursor = "-webkit-grabbing";
    }
  } else {
    eX.extend(B, {
      distCursor: "url(" + B.imgPath + jf + "),crosshair",
      defaultCursor: "url(" + B.imgPath + "openhand.cur),default",
      draggingCursor: "url(" + B.imgPath + "closedhand.cur),move"
    });
  }
  bx = bx || {};
  bx.version = "gl";
  bx._register = [];
  bx.register = function (e) {
    this._register[this._register.length] = e;
  };
  bx.guid = 1;
  bx.getGUID = function (e) {
    return (e || "") + bx.guid++;
  };
  var eN = window.BMAP_AUTHENTIC_KEY || "";
  function R(e, i, kc) {
    var T = new Date();
    T.setTime(T.getTime() + kc * 24 * 60 * 60 * 1000);
    document.cookie = e + "=" + escape(i) + ";expires=" + T.toGMTString();
  }
  function a3(e, i) {
    if (navigator.cookieEnabled) {
      return R(e, i, 30);
    }
    if (localStorage) {
      return localStorage.setItem(e, i);
    }
    if (sessionStorage) {
      return sessionStorage.setItem(e, i);
    }
  }
  bx.getSeckeyCid = function () {
    var i = +new Date();
    var e = bQ + "//dlswbr.baidu.com/heicha/mw/abclite-2063-s.js?_t=" + i;
    gM.load(e, iM);
  };
  function iM() {
    if (window.___abvk) {
      a3("SECKEY_ABVK", window.___abvk);
    }
  }
  window.__abbaidu_2063_cb = function (i) {
    var e = JSON.parse(i);
    a3("BMAP_SECKEY", e.data);
  };
  bx.bmapVerifyCbk = function (kd) {
    if (kd && kd.error !== 0) {
      bx = null;
      BMapGL = null;
      var ke = "百度未授权使用地图API，可能是因为您提供的密钥不是有效的百度地图开放平台密钥，或此密钥未对本应用的百度地图JavaScriptAPI授权。您可以访问如下网址了解如何获取有效的密钥：https://lbs.baidu.com/apiconsole/key#。";
      switch (kd.error) {
        case 101:
          ke = "您所使用的密钥ak有问题，不支持jsapi服务，可以访问该网址了解如何获取有效密钥：http://lbsyun.baidu.com/apiconsole/key#。";
          break;
        case 102:
          ke = "MCODE参数不存在，mobile类型MCODE参数必需，详情查看：http://lbsyun.baidu.com/apiconsole/key#。";
          break;
        case 200:
          ke = "APP不存在，AK有误请检查再重试，详情查看：http://lbsyun.baidu.com/apiconsole/key#。";
          break;
        case 201:
          ke = "APP被您禁用啦，可以访问 http://lbsyun.baidu.com/apiconsole/key# 查看自己的应用具体详情，或联系我们了解详情。";
          break;
        case 202:
          ke = "APP被管理员删除啦，可以访问 http://lbsyun.baidu.com/apiconsole/key# 查看自己的应用具体详情，或联系我们了解详情。";
          break;
        case 203:
          ke = "APP类型错误，可以访问 http://lbsyun.baidu.com/apiconsole/key# 查看自己的应用具体详情，或联系我们了解详情。";
          break;
        case 210:
          ke = "APP IP校验失败，可以访问 http://lbsyun.baidu.com/apiconsole/key# 查看自己的应用具体详情，或联系我们了解详情。";
          break;
        case 220:
          ke = "APP Referer校验失败。请检查该ak设置的白名单与访问所有的域名是否一致。详情查看：http://lbsyun.baidu.com/apiconsole/key#";
          break;
        case 230:
          ke = "APP Mcode码校验失败，可以访问 http://lbsyun.baidu.com/apiconsole/key# 查看自己的应用具体详情，或联系我们了解详情。";
          break;
        case 240:
          ke = "APP服务被禁用了，可以访问 http://lbsyun.baidu.com/apiconsole/key# 查看自己的应用具体详情，或联系我们了解详情。";
          break;
        case 250:
          ke = "该用户不存在... 请登录 https://lbs.baidu.com 的控制台，注册成为开发者申请ak吧。";
          break;
        case 251:
          ke = "该用户被自己删除啦，可以访问 http://lbsyun.baidu.com/apiconsole/key# 查看自己的应用具体详情。";
          break;
        case 252:
          ke = "该用户被管理员删除啦，可以访问 http://lbsyun.baidu.com/apiconsole/key# 了解如何获取有效密钥，或请联系我们了解详情。";
          break;
        case 260:
          ke = "您所使用的密钥AK不包含该服务呢，可以访问 http://lbsyun.baidu.com/apiconsole/key# 查看服务选择情况，或请联系我们了解详情。";
          break;
        case 261:
          ke = "您所使用的密钥AK的该服务被禁用啦，可以访问 http://lbsyun.baidu.com/apiconsole/key# 查看服务选择情况，或请联系我们了解详情。";
          break;
        case 401:
          ke = "您所使用的AK并发超限了，请登录 http://lbsyun.baidu.com/cashier/quota#/home 了解详情。";
          break;
        case 302:
          ke = "您所使用的AK天配额超限了，请登录 http://lbsyun.baidu.com/cashier/quota#/home 了解详情。";
          break;
      }
      alert(ke);
      var T = document.getElementsByClassName("bmap-container");
      if (T) {
        for (var kc = 0; kc < T.length; kc++) {
          var e = T[kc];
          if (e && e.firstChild && e.firstChild.id === "platform") {
            e.innerText = "";
          }
        }
      }
    }
  };
  bx.frequencyCbk = function (e) {
    if (e) {
      window.QTFrequency = e;
    }
  };
  bx.verify = function () {
    var e = B.apiHost + "/?qt=verify&v=gl&type=webgl&ak=" + eN + "&callback=" + fs + ".bmapVerifyCbk";
    gM.load(e);
  };
  bx.frequency = function () {};
  bx.apiLoad = bx.apiLoad || function () {};
  function h6(i, e) {
    this._size = i;
    this._cache = [];
    this._totalGetTimes = 0;
    this._totalHitTimes = 0;
    this._options = {
      clearCallback: null,
      removeOldCallback: null
    };
    e = e || {};
    for (var T in e) {
      if (e.hasOwnProperty(T)) {
        this._options[T] = e[T];
      }
    }
  }
  h6.prototype.setData = function (T, kc) {
    var e = this._cache;
    var i = this._size;
    if (i === 0) {
      return;
    }
    if (e.length > i) {
      this._removeOld();
    }
    if (!e[T]) {
      e.push(kc);
    }
    e[T] = kc;
    kc._key_ = T;
  };
  h6.prototype.getHitRate = function () {
    return Math.round(this._totalHitTimes / this._totalGetTimes * 1000) / 1000;
  };
  h6.prototype.getData = function (i) {
    var e = this._cache[i];
    if (e) {
      this._totalHitTimes++;
    }
    this._totalGetTimes++;
    return e;
  };
  h6.prototype.removeData = function (kd) {
    if (this._options.clearCallback) {
      this._options.clearCallback(this._cache[kd]);
    }
    var T = this._cache;
    var ke = T[kd];
    for (var kc = 0, e = T.length; kc < e; kc++) {
      if (T[kc] === ke) {
        T.splice(kc, 1);
        break;
      }
    }
    delete T[kd];
  };
  h6.prototype._removeOld = function () {
    var e = this._cache;
    var kd = Math.round(this._size * 0.6);
    for (var kc = 0; kc < kd; kc++) {
      var T = e[kc]._key_;
      if (this._options.clearCallback) {
        this._options.clearCallback(e[T]);
      }
      delete e[T];
    }
    e.splice(0, kd);
    if (this._options.removeOldCallback) {
      this._options.removeOldCallback();
    }
  };
  h6.prototype.clear = function () {
    var T = this._cache;
    for (var kd = 0, e = T.length; kd < e; kd++) {
      var kc = T[kd]._key_;
      if (this._options.clearCallback) {
        this._options.clearCallback(T[kc]);
      }
      delete T[kc];
    }
    this._cache = T = [];
  };
  h6.prototype.forEach = function (kc) {
    var T = this._cache;
    for (var ke = 0, e = T.length; ke < e; ke++) {
      var kd = T[ke]._key_;
      kc(T[kd]);
    }
  };
  h6.prototype.getBatch = function (kd) {
    var e = [];
    for (var kc = 0, T = kd.length; kc < T; kc++) {
      if (this.getData(kd[kc])) {
        e[e.length] = this.getData(kd[kc]);
      }
    }
    return e;
  };
  h6.prototype.clearExcept = function (ke) {
    var T = this._cache;
    for (var e = T.length, kd = e - 1; kd >= 0; kd--) {
      var kc = this._cache[kd]._key_;
      if (!ke[kc]) {
        T.splice(kd, 1);
        if (this._options.clearCallback) {
          this._options.clearCallback(T[kc]);
        }
        delete T[kc];
      }
    }
  };
  h6.prototype.getDataCount = function () {
    return this._cache.length;
  };
  function iR() {}
  eX.extend(iR.prototype, {
    centerAndZoomIn: function (kh, T, ki) {
      var kf = this;
      if (!kh && !T) {
        return;
      }
      kh = kh || this.centerPoint;
      T = T || this.zoomLevel;
      T = this._getProperZoom(T).zoom;
      if (this.mapType === BMAP_EARTH_MAP) {
        if (!this._earth) {
          this.mapType = BMAPGL_NORMAL_MAP;
          this.temp.originMapType = BMAP_EARTH_MAP;
          function kg() {
            kf._earth = new bx.Earth(kf, {
              showRealSunlight: kf.config.showRealSunlight,
              showMilkyway: kf.config.showMilkyway,
              earthBackground: kf.config.earthBackground
            });
            kf._proxyEarthEvents();
            kf._changeEarthMapType(BMAP_EARTH_MAP);
            eX.extend(kf, bx.EarthView.prototype);
            if (!kf._navigationCtrl && kf.config.showControls) {
              kf._navigationCtrl = new bx.NavigationControl3D(kf);
            }
            delete kf.temp.originMapType;
          }
          g2.load("earth", function () {
            if (bx["FeatureStyle" + kf.config.style]) {
              kg();
            } else {
              kf.loadMapStyleFiles(function () {
                kg();
              });
            }
          });
        }
      }
      this.lastLevel = this.zoomLevel || T;
      this.zoomLevel = T;
      var kd = new fJ("onload");
      kd.point = kh;
      kd.zoom = T;
      this.centerPoint = this.restrictCenter(new cx(kh.lng, kh.lat));
      if (this.centerPoint.zoom) {
        this.zoomLevel = this.centerPoint.zoom;
      }
      this.defaultZoomLevel = this.defaultZoomLevel || this.zoomLevel;
      this.defaultCenter = this.defaultCenter || this.centerPoint;
      if (!this.loaded && !(this.temp.originMapType === BMAP_EARTH_MAP)) {
        var i = this.config.defaultMaxBounds;
        var ke = new m(i, "baidu", this.mapType);
        var kc = new hv({
          mapType: this.mapType,
          copyright: ke,
          customLayer: false,
          baseLayer: true,
          tileTypeName: "web"
        });
        kc._isInnerLayer = true;
        this.addTileLayer(kc);
        if (this.mapType === BMAP_SATELLITE_MAP && this._isHybridShow === true) {
          this._addHybirdMap();
        }
      }
      this.dispatchEvent(kd);
      this.loaded = true;
      ki = ki || {};
      if (ki.callback) {
        ki.callback();
      }
    },
    _setPlatformPosition: function (ki, kh, kl) {
      kl = kl || {};
      if (ki === 0 && kh === 0 && !kl.point) {
        return;
      }
      if (isNaN(kl.initMapOffsetX)) {
        kl.initMapOffsetX = this.offsetX;
      }
      if (isNaN(kl.initMapOffsetY)) {
        kl.initMapOffsetY = this.offsetY;
      }
      var kj = ki + kl.initMapOffsetX;
      var kg = kh + kl.initMapOffsetY;
      if (kl.point) {
        var i = this.restrictCenter(kl.point);
        if (!i.equals(this.centerPoint)) {
          this.centerPoint = i.clone();
          this.fire(new fJ("oncenter_changed"));
        }
      } else {
        var kc = this.offsetX - kj;
        var e = this.offsetY - kg;
        var T = this.getZoomUnits();
        var kf = this.centerPoint.lng;
        var ke = this.centerPoint.lat;
        var kd = new cx(kf, ke);
        this.centerPoint = this.restrictCenter(new cx(kd.lng + kc * T, kd.lat - e * T), T);
        this.fire(new fJ("oncenter_changed"));
        if (this.zoomLevel < 10) {
          kj = this.offsetX - (this.centerPoint.lng - kd.lng) / T;
          kg = this.offsetY + (this.centerPoint.lat - kd.lat) / T;
        }
      }
      this.offsetX = kj;
      this.offsetY = kg;
      var kk = this.platform.style;
      kk.left = kj + "px";
      kk.top = kg + "px";
      this.maskLayer.style.left = -kj + "px";
      this.maskLayer.style.top = -kg + "px";
      if (kl.dispatchEvent !== false) {
        this.dispatchEvent(new fJ("onmoving"));
      }
    },
    zoomTo: function (e, kf, kj) {
      kj = kj || {};
      kj.zoomCenter = kf;
      if (kj.noAnimation !== true) {
        this.deepZoomTo(e, kj);
        return;
      }
      if (typeof e !== "number") {
        return;
      }
      var kd = ej[this.mapType];
      if (!kd) {
        return;
      }
      var T = e;
      e = this._getProperZoom(e).zoom;
      if (e === this.zoomLevel) {
        var kg = new fJ("onzoomexceeded");
        kg.targetZoom = T;
        this.dispatchEvent(kg);
        if (kj.callback) {
          kj.callback();
        }
        return;
      }
      this.lastLevel = this.zoomLevel;
      if (kf) {
        this.temp._cPoint = kf;
        this.temp._cPixel = this.pointToPixelIn(kf);
      } else if (this.getInfoWindow()) {
        var ki = this.getInfoWindow().getPoint();
        this.temp._cPixel = this.pointToPixelIn(ki);
        this.temp._cPoint = ki;
      }
      if (this.config.zoomCenter) {
        kf = this.config.zoomCenter;
        this.temp._cPoint = kf;
        this.temp._cPixel = this.pointToPixelIn(kf);
      }
      if (kf || this.temp.infoWin && this.temp.infoWin.isOpen()) {
        var i = this.temp._cPoint;
        var kh = this.temp._cPixel;
        var kc = this.getZoomUnits(e);
        var ke = new cx(i.lng + kc * (this.width / 2 - kh.x), i.lat - kc * (this.height / 2 - kh.y));
        this.centerPoint = this.restrictCenter(ke, kc, e);
        if (this.centerPoint.zoom) {
          e = this.centerPoint.zoom;
        }
      }
      if (kj.fireEvent !== false) {
        this.dispatchEvent(new fJ("onzoomstart"));
      }
      if (e !== this.zoomLevel) {
        this.zoomLevel = e;
        this.dispatchEvent(new fJ("onzooming"));
        this.dispatchEvent(new fJ("onzoomstartcode"));
      }
      if (kj.fireEvent !== false) {
        this.dispatchEvent(new fJ("onzoomend"));
      }
      if (kj.callback) {
        kj.callback();
      }
    },
    deepZoomMedia: function (e) {
      var i = this;
      if (!i.temp.isStdCtrlBusy) {
        i.temp.isStdCtrlBusy = true;
        i.deepZoomTo(i.zoomLevel + e);
        setTimeout(function () {
          i.temp.isStdCtrlBusy = false;
        }, 400);
      }
    },
    deepZoomTo: function (kg, kc) {
      kc = kc || {};
      var ke = kg - this.zoomLevel;
      var kd = this._getProperZoom(kg);
      if (kd.exceeded) {
        var e = new fJ("onzoomexceeded");
        e.targetZoom = kg;
        this.dispatchEvent(e);
        return;
      }
      var i;
      if (kc.zoomCenter) {
        i = this.pointToPixelIn(kc.zoomCenter);
      } else if (this.getInfoWindow()) {
        i = this.pointToPixelIn(this.getInfoWindow().getPoint(), {
          zoom: this.lastLevel
        });
      } else {
        var i = new fi(this.width / 2, this.height / 2);
      }
      this.lastLevel = this.zoomLevel;
      var kf = this.deepZoom || new aE(this);
      var T = ke > 0 ? 1 : -1;
      kf.zoomMap(i, ke, T, null, kc);
    },
    flyToIn: function (kh, e) {
      if (e === this.zoomLevel) {
        this.panToIn(kh);
        return;
      }
      var ke = this._getProperZoom(e);
      if (ke.exceeded) {
        var ki = new fJ("onzoomexceeded");
        ki.targetZoom = e;
        this.dispatchEvent(ki);
        return;
      }
      var kg = e - this.zoomLevel;
      var T = new fi(this.width / 2, this.height / 2);
      var i = this.pointToPixelIn(kh);
      var kf = new i0(i.x - T.x, i.y - T.y);
      this.lastLevel = this.zoomLevel;
      if (Math.abs(kg) >= 4 || Math.abs(kf.width) > this.width || Math.abs(kf.height) > this.height) {
        this.centerAndZoomIn(kh, e);
        return;
      }
      var kd = this.deepZoom || new aE(this);
      var kc = kg > 0 ? 1 : -1;
      kd.zoomMap(i, kg, kc, kf);
    },
    panToIn: function (i, T) {
      T = T || {};
      if (!i || i.equals(this.centerPoint)) {
        if (T.callback) {
          T.callback();
        }
        return;
      }
      var kc = this.pointToPixelIn(i);
      var e = Math.round(this.width / 2);
      var kd = Math.round(this.height / 2);
      if (Math.abs(e - kc.x) > this.width || Math.abs(kd - kc.y) > this.height || T.noAnimation === true) {
        this._panToIn(e - kc.x, kd - kc.y, i);
        if (T.callback) {
          T.callback();
        }
      } else {
        this._panBy(e - kc.x, kd - kc.y, T);
      }
    },
    _panToIn: function (i, e, kc) {
      var T = this.temp;
      if (T.operating === true) {
        return;
      }
      if (T.dragAni) {
        T.dragAni.stop();
        T.dragAni = null;
        this.dispatchEvent(new fJ("onmoveend"));
      }
      this.dispatchEvent(new fJ("onmovestart"));
      this._setPlatformPosition(i, e, {
        point: kc
      });
      this.dispatchEvent(new fJ("onmoveend"));
    },
    panBy: function (i, e, T) {
      T = T || {};
      i = Math.round(i) || 0;
      e = Math.round(e) || 0;
      if (Math.abs(i) <= this.width && Math.abs(e) <= this.height && T.noAnimation !== true) {
        this._panBy(i, e, T);
      } else {
        this._panToIn(i, e);
        if (T.callback) {
          T.callback();
        }
      }
    },
    _panBy: function (i, e, kd) {
      if (this.temp.operating === true) {
        return;
      }
      kd = kd || {};
      this.dispatchEvent(new fJ("onmovestart"));
      var kc = this;
      var T = kc.temp;
      T.pl = kc.offsetX;
      T.pt = kc.offsetY;
      if (T.tlPan) {
        T.tlPan.cancel();
      }
      if (T.dragAni) {
        T.dragAni.stop();
        T.dragAni = null;
        this.dispatchEvent(new fJ("onmoveend"));
      }
      T.tlPan = new fy({
        fps: kd.fps || kc.config.fps,
        duration: kd.duration || kc.config.actionDuration,
        transition: kd.transition || gA.easeInOutQuad,
        render: function (ke) {
          this.terminative = kc.temp.operating;
          if (kc.temp.operating) {
            return;
          }
          kc._setPlatformPosition(Math.ceil(i * ke), Math.ceil(e * ke), {
            initMapOffsetX: T.pl,
            initMapOffsetY: T.pt
          });
        },
        finish: function (ke) {
          kc.dispatchEvent(new fJ("onmoveend"));
          kc.temp.tlPan = false;
          if (kc.temp.stopArrow === true) {
            kc.temp.stopArrow = false;
            if (kc.temp.arrow !== 0) {
              kc._arrow();
            }
          }
          if (kd.callback) {
            kd.callback();
          }
        }
      });
    },
    getCenterIn: function () {
      return this.centerPoint;
    },
    getZoom: function () {
      return this.zoomLevel;
    },
    setTilt: function () {},
    getTilt: function () {
      return this._tilt;
    },
    setHeading: function () {},
    getHeading: function () {
      return this._heading;
    },
    restrictCenter: function (kk, i, e) {
      this.isRestrict = false;
      i = i || this.getZoomUnits();
      e = e || this.zoomLevel;
      var ki = this.pixelToPointIn(new fi(this.width, 0), {
        center: kk,
        zoom: e
      });
      var kg = this.pixelToPointIn(new fi(0, this.height), {
        center: kk,
        zoom: e
      });
      var kl = kk.lng;
      var kq = kk.lat;
      if (this.config.restrictBounds !== null && !this.config.restrictBounds.isEmpty()) {
        var kp = this.config.restrictBounds;
        var kc = kp.getSouthWest();
        var kn = kp.getNorthEast();
        var kj = i9.convertLL2MC(kc);
        var ke = i9.convertLL2MC(kn);
        kk.lng = this.calcNewLngByBounds(kl, kg, ki, kj.lng, ke.lng, i);
        kk.lat = this.calcNewLatByBounds(kq, kg, ki, kj.lat, ke.lat, i);
        return kk;
      }
      var kh = this.pixelToPointIn(new fi(0, 0), {
        center: kk,
        zoom: e
      });
      var kd = this.pixelToPointIn(new fi(0, this.height), {
        center: kk,
        zoom: e
      });
      if (this.zoomLevel < 5) {
        if (kh.lat > hK.MAX_LAT && kd.lat < hK.MIN_LAT) {
          this.isRestrict = true;
          var T = hK.MAX_LAT - kk.lat;
          var kf = kk.lat - hK.MIN_LAT;
          var ko;
          if (T < kf) {
            ko = T / (this.height / 2);
          } else {
            ko = kf / (this.height / 2);
          }
          var km = 18 - p(ko);
          this.zoomLevel = Math.ceil(km);
          kk.zoom = Math.ceil(km);
          return kk;
        }
      }
      if (kh.lat > hK.MAX_LAT) {
        this.isRestrict = true;
        kk.lat = hK.MAX_LAT - this.height / 2 * i;
      } else if (kd.lat < hK.MIN_LAT) {
        this.isRestrict = true;
        kk.lat = hK.MIN_LAT + this.height / 2 * i;
      }
      return kk;
    }
  });
  function hK(e, T) {
    if (typeof e === "string") {
      e = document.getElementById(e);
    }
    c8.call(this);
    this.container = e;
    this.width = e.clientWidth;
    this.height = e.clientHeight;
    this.offsetX = 0;
    this.offsetY = 0;
    this._setStyle(e);
    e.unselectable = "on";
    e.innerHTML = "";
    eX.ac(e, "bmap-container");
    e.appendChild(this.render());
    this._initDate = new Date();
    this.platform = e.children[0];
    this.maskLayer = this.platform.children[0];
    this._panes = {};
    this.centerPoint = new cx(0, 0);
    this.zoomLevel = 0;
    this._heading = 0;
    this._tilt = 0;
    this._bounds = new hY();
    this.lastLevel = 0;
    this._lock = false;
    this._enableTiltZoom = 7;
    this._enableHeadingZoom = 7;
    this.defaultZoomLevel = null;
    this.defaultCenter = null;
    this.zoomEventStatus = "idle";
    this.currentOperation = ed.idle;
    this._setConfig(T);
    this._initMapRenderType();
    this._animationInfo = {};
    this._animationInfoUnstopable = {};
    this.suspendLoad = false;
    this._customTileLabels = [];
    if (this._renderType === "webgl") {
      this._workerMgr = new jw(this);
      this._featureMgr = new cd();
      eX.extend(this, C.prototype);
      this.jobScheduler = new bj(this);
      this.benchmark = new cY();
      this._setupWebGLMap();
      this.deviceInfo = {
        hardwareInfo: {
          renderer: "",
          vendor: ""
        }
      };
      if (c6.ifSupportWebGL._renderer) {
        this.deviceInfo.hardwareInfo.renderer = c6.ifSupportWebGL._renderer;
        this.deviceInfo.hardwareInfo.vendor = c6.ifSupportWebGL._vendor;
      }
    } else {
      eX.extend(this, iR.prototype);
    }
    if (!ej[this.config.mapType]) {
      this.config.mapType = BMAPGL_NORMAL_MAP;
    }
    if (this.config.mapType === BMAP_EARTH_MAP && !this.config.enableEarth) {
      if (this.forceEnableEarth() === false) {
        this.config.mapType = BMAPGL_NORMAL_MAP;
      }
    }
    this.mapType = this.config.mapType;
    this.preMapType = null;
    if (this.config.enableEarth) {
      var ke = this.maskLayer.style;
      ke.opacity = 0;
      ke.background = "#000";
      if (this.config.mapType === BMAP_EARTH_MAP) {
        ke.opacity = 1;
      }
      setTimeout(function () {
        ke.WebkitTransition = ke.transition = "opacity .4s";
      }, 100);
    }
    this._isHybridShow = this.config.showStreetLayer;
    this.temp = {
      operating: false,
      arrow: 0,
      lastDomMoveTime: 0,
      lastLoadTileTime: 0,
      lastMovingTime: 0,
      canKeyboard: false,
      I: function (i) {
        return eX.I(i);
      },
      curSpots: [],
      curSpotsArray: [],
      curAreaSpot: null,
      spotsGuid: 1,
      registerIndex: -1,
      hoverOnSpot: null,
      isStdCtrlBusy: false
    };
    window.InstanceCore = this.temp.I;
    this.platform.style.cursor = this.config.defaultCursor;
    this._bind();
    if (!bx.BMAP_INSTANCES) {
      bx.BMAP_INSTANCES = 1;
    } else {
      bx.BMAP_INSTANCES += 1;
    }
    for (var kc = 0; kc < bx._register.length; kc++) {
      bx._register[kc](this);
    }
    this.temp.registerIndex = kc;
    var kd = this;
    if (this._renderType === "webgl") {
      g2.load("oppcgl", function () {
        kd._asyncRegister();
      });
    } else {
      g2.load("oppc", function () {
        kd._asyncRegister();
      });
    }
    if (this.config.mapType === "B_EARTH_MAP") {
      if (!bx.Earth) {
        g2.load("earth", function () {});
      } else {
        kd._syncAndChangeMapType("B_EARTH_MAP");
      }
    }
  }
  hK.MAX_TILT = 87;
  hK.MAX_DRAG_TILT = 73;
  hK.MAX_DRAG_TILT_L2 = 50;
  hK.MIN_TILT = 0;
  hK.MAX_LAT = 19431424;
  hK.MIN_LAT = -16023552;
  hK.WORLD_SIZE_MC_HALF = 20037726.372307256;
  hK.WORLD_SIZE_MC = hK.WORLD_SIZE_MC_HALF * 2;
  hK.RIGHT_EDGE_POINT = new cx(hK.WORLD_SIZE_MC_HALF, 0);
  hK.LEFT_EDGE_POINT = new cx(-hK.WORLD_SIZE_MC_HALF, 0);
  hK.HIGH_RES_MIN_RATIO = 1.2;
  hK.inherits(c8, "Map");
  var fq = {
    NORMAL: "B_NORMAL_MAP",
    EARTH: "B_EARTH_MAP",
    SATELLITE: "B_STREET_MAP"
  };
  bx.MapTypeId = fq;
  eX.extend(hK.prototype, {
    render: function () {
      var e = bX("div", {
        id: "platform"
      });
      var kc = e.style;
      kc.overflow = "visible";
      kc.position = "absolute";
      kc.zIndex = 5;
      kc.top = kc.left = "0px";
      var i = bX("div", {
        id: "mask",
        class: "BMap_mask"
      });
      var T = i.style;
      T.position = "absolute";
      T.top = T.left = "0px";
      T.zIndex = "9";
      T.overflow = "hidden";
      T.WebkitUserSelect = "none";
      T.width = this.width + "px";
      T.height = this.height + "px";
      e.appendChild(i);
      return e;
    },
    _initMapRenderType: function () {
      var e = this.config.forceRenderType;
      if (e === "dom") {
        this._renderType = "dom";
        return;
      } else if (e === "canvas") {
        if (c6.isModernBrowser && !c6.ifCanvas2dInBlackList()) {
          this._renderType = "canvas";
          return;
        } else {
          this._renderType = "dom";
          return;
        }
      } else if (e === "webgl") {
        if (c6.ifSupportWebGL()) {
          this._renderType = "webgl";
          return;
        }
      }
      if (c6.ifSupportWebGL() && c6.ifEnableWebGLMap()) {
        this._renderType = "webgl";
        return;
      }
      if (c6.isModernBrowser && c6.ifEnableCanvas2dMap()) {
        this._renderType = "canvas";
        return;
      }
      this._renderType = "dom";
    },
    _setConfig: function (i) {
      i = i || {};
      this.config = {
        bottomOffset: 0,
        clickInterval: 200,
        enableDragging: true,
        enableRotate: true,
        enableTilt: true,
        enableKeyboard: false,
        enableDblclickZoom: true,
        enableContinuousZoom: true,
        enableWheelZoom: false,
        enableRotateGestures: true,
        enableTiltGestures: true,
        enablePinchZoom: true,
        fixCenterWhenPinch: false,
        enableAutoResize: true,
        zoomCenter: null,
        fps: eX.Browser.ie ? 30 : 60,
        zoomerDuration: 240,
        actionDuration: 450,
        defaultCursor: B.defaultCursor,
        draggingCursor: B.draggingCursor,
        overlayMoveCursor: "pointer",
        coordType: BMAP_COORD_MERCATOR,
        mapType: BMAPGL_NORMAL_MAP,
        drawer: BMAP_SYS_DRAWER,
        enableInertialDragging: true,
        drawMargin: 500,
        drawMarginGL: 500,
        enableFulltimeSpotClick: false,
        enableResizeOnCenter: false,
        isModernBrowser: c6.isModernBrowser,
        forceRenderType: "",
        textRenderType: null,
        ratio: gd() >= hK.HIGH_RES_MIN_RATIO ? 2 : 1,
        enableEarth: c6.ifEnableEarth(),
        defaultMaxBounds: new hY(new cx(-21364736, -10616832), new cx(23855104, 15859712)),
        showControls: false,
        showRealSunlight: true,
        showMilkyway: true,
        earthBackground: null,
        showStreetLayer: true,
        showVectorStreetLayer: false,
        showVectorLine: false,
        minZoom: null,
        maxZoom: null,
        style: "default",
        backgroundColor: null,
        enableIconClick: false,
        autoSafeArea: false,
        ak: null,
        webgl2: false,
        restrictCenter: true,
        restrictBounds: null,
        smaa: true,
        preserveDrawingBuffer: false,
        privateOn: false,
        privateRegions: null,
        popRightClick: false
      };
      for (var T in i) {
        if (i.hasOwnProperty(T)) {
          this.config[T] = i[T];
          if (T === "fixCenterWhenResize") {
            this.config.enableResizeOnCenter = i[T];
          }
        }
      }
      if (i.style) {
        if (i.style.styleId && i.style.styleId.length < 32) {
          this.config.style = i.style.styleId;
        } else {
          this.config.style = i.style;
        }
      }
      this._setTextRenderType();
      this._displayOptions = {
        poi: true,
        poiText: true,
        poiIcon: true,
        overlay: true,
        layer: true,
        building: true,
        indoor: true,
        street: true,
        skyColors: ["rgba(226, 237, 248, 0)", "rgba(186, 211, 252, 1)"],
        isFlat: false,
        labelMargin: 0
      };
      if (i.displayOptions) {
        for (var e in i.displayOptions) {
          if (i.displayOptions.hasOwnProperty(e)) {
            this._displayOptions[e] = i.displayOptions[e];
          }
        }
      }
      if (this.config.restrictCenter === false) {
        this._enableTiltZoom = 0;
        this._enableHeadingZoom = 0;
      }
    },
    getMinZoom: function () {
      var T;
      if (ej[this.mapType][this._renderType]) {
        T = ej[this.mapType][this._renderType].minZoom;
      } else {
        T = ej[this.mapType].minZoom;
      }
      if (this.config.minZoom !== null && this.config.minZoom >= T) {
        T = this.config.minZoom;
      }
      if (this.mapType === "B_EARTH_MAP") {
        return T;
      }
      var i = this.getSize();
      var e = this.worldSize(T);
      while (e < i.width) {
        T++;
        e = this.worldSize(T);
      }
      return T;
    },
    getMaxZoom: function () {
      var e;
      if (ej[this.mapType][this._renderType]) {
        e = ej[this.mapType][this._renderType].maxZoom;
      } else {
        e = ej[this.mapType].maxZoom;
      }
      if (this.config.maxZoom !== null && this.config.maxZoom <= e) {
        e = this.config.maxZoom;
      } else if (this._renderType === "webgl") {
        e = 21;
      }
      return e;
    },
    _drawFrame: function () {
      this._webglMapScene._painter.draw();
    },
    _setupWebGLMap: function () {
      var e = this;
      g2.load("mapgl", function () {
        e._asyncRegister();
      });
    },
    _setStyle: function (i) {
      var e = i.style;
      e.overflow = "hidden";
      if (ch(i).position !== "absolute") {
        e.position = "relative";
      }
      e.backgroundImage = "url(" + B.imgPath + "bg.png)";
      e.textAlign = "left";
      e.touchAction = e.MSTouchAction = "none";
    },
    _bind: function () {
      var e = this;
      if (e._renderType !== "webgl") {
        e._watchSize = function () {
          var T = e.getContainerSize();
          if (e.width !== T.width || e.height !== T.height) {
            var kf = (T.width - e.width) / 2;
            var kh = (T.height - e.height) / 2;
            var kc = e.getZoomUnits();
            var ke = e.centerPoint;
            if (ke && !e.config.enableResizeOnCenter) {
              e.centerPoint = new cx(ke.lng + kf * kc, ke.lat - kh * kc);
            }
            e.maskLayer.style.width = (e.width = T.width) + "px";
            e.maskLayer.style.height = (e.height = T.height) + "px";
            var kd = new fJ("onresize");
            kd.size = T;
            e.dispatchEvent(kd);
            e.fire(new fJ("onsize_changed"));
            var i = parseInt(e.platform.style.left, 10) || 0;
            var kg = parseInt(e.platform.style.top, 10) || 0;
            if (e.currentOperation !== "undefined" && e.currentOperation !== ed.idle && (e.offsetX !== i || e.offsetY !== kg)) {
              e._setPlatformPosition(i, kg);
            }
          }
        };
      } else {
        e._watchSize = function () {
          var i = e.getContainerSize();
          if (e.width !== i.width || e.height !== i.height) {
            var kc = e.getSize();
            e.maskLayer.style.width = (e.width = i.width) + "px";
            e.maskLayer.style.height = (e.height = i.height) + "px";
            if (gd() !== e.config.ratio) {
              e.config.ratio = gd();
            }
            var kd = new fJ("onresize");
            kd.size = i;
            e.dispatchEvent(kd);
            var T = new fJ("onsize_changed");
            T.size = i;
            T.oldSize = kc;
            e.fire(T);
          }
        };
      }
      if (e.config.enableAutoResize) {
        e.temp.autoResizeTimer = setInterval(e._watchSize, 16);
      }
      this.on("size_changed", function () {
        var i = e.getMinZoom();
        if (e.zoomLevel < i) {
          e.setZoomIn(i, {
            noAnimation: true
          });
        }
      });
      this.on("zoom_changed", function () {
        this.dispatchEvent(new fJ("onzooming"));
      });
    },
    addControl: function (e) {
      if (e && bR(e._i)) {
        e._i(this);
        this.dispatchEvent(new fJ("onaddcontrol", e));
      }
    },
    removeControl: function (e) {
      if (e && bR(e.remove)) {
        e.remove();
        this.dispatchEvent(new fJ("onremovecontrol", e));
      }
    },
    addContextMenu: function (i, e) {
      if (i) {
        i.initialize(this, e);
        this.dispatchEvent(new fJ("onaddcontextmenu", i));
      }
    },
    removeContextMenu: function (e) {
      if (e) {
        this.dispatchEvent(new fJ("onremovecontextmenu", e));
        e.remove();
      }
    },
    addDistrictLayer: function (e) {
      if (e) {
        e.initialize(this);
      }
    },
    removeDistrictLayer: function (e) {
      if (e) {
        e.removeDistrict(this, e);
      }
    },
    addCustomHtmlLayer: function (e) {
      if (e) {
        e.initialize(this);
      }
    },
    removeCustomHtmlLayer: function (e) {
      if (e) {
        e.removeLayer(e);
      }
    },
    addOverlay: function (i) {
      if (i && bR(i._i)) {
        var T = new fJ("onbeforeaddoverlay", i);
        T.overlay = i;
        this.dispatchEvent(T);
        i._i(this);
        T = new fJ("onaddoverlay", i);
        T.overlay = i;
        this.dispatchEvent(T);
      }
    },
    removeOverlay: function (i) {
      if (i && bR(i.remove)) {
        if (i instanceof cj) {
          if (this.stencil) {
            this.stencil = null;
          }
        }
        var T = new fJ("onremoveoverlay", i);
        T.overlay = i;
        i.remove();
        this.dispatchEvent(T);
      }
    },
    clearOverlays: function () {
      this.dispatchEvent(new fJ("onclearoverlays"));
    },
    addTileLayer: function (kd) {
      if (!kd) {
        return;
      }
      if (kd instanceof dr || kd instanceof d8) {
        if (kd.layer) {
          kd = kd.layer;
        } else {
          return;
        }
      }
      for (var kc = 0, e = this.tileMgr.tileLayers.length; kc < e; kc++) {
        var T = this.tileMgr.tileLayers[kc];
        if (T === kd || T.getMapType() === kd.getMapType()) {
          return;
        }
      }
      kd.initialize(this);
      this.dispatchEvent(new fJ("onaddtilelayer", kd));
    },
    removeTileLayer: function (e) {
      if (e) {
        if (e instanceof dr || e instanceof d8) {
          if (e.layer) {
            e = e.layer;
          } else {
            return;
          }
        }
        e.remove();
        this.dispatchEvent(new fJ("onremovetilelayer", e));
      }
    },
    addNormalLayer: function (e) {
      if (!e || !(e instanceof cm)) {
        return;
      }
      this.dispatchEvent(new fJ("onaddnormallayer", e));
    },
    removeNormalLayer: function (e) {
      if (e && e instanceof cm) {
        this.dispatchEvent(new fJ("onremovenormallayer", e));
      }
    },
    addGeoJSONLayer: function (e) {
      if (e && e instanceof aN) {
        e.init(this);
      }
    },
    removeGeoJSONLayer: function (e) {
      if (e && e instanceof aN) {
        e.remove();
      }
    },
    getTileLayer: function (e) {
      if (this.tileMgr) {
        return this.tileMgr.getTileLayer(e);
      }
      return null;
    },
    setMapType: function (e) {
      var i = this;
      if (this.mapType === e || this._mapTypeChanging) {
        return;
      }
      if (e === BMAP_EARTH_MAP && !this.config.enableEarth) {
        return;
      }
      if (this._earth && this._earth.getLock()) {
        return;
      }
      this._mapTypeChanging = true;
      this.preMapType = this.mapType;
      this._boundsInPreMapType = this.getBoundsIn();
      if (this.preMapType === BMAP_SATELLITE_MAP) {
        this._preStreetLayerShow = this._isHybridShow;
      }
      if (e === BMAP_EARTH_MAP) {
        if (!bx.Earth) {
          g2.load("earth", function () {
            i._syncAndChangeMapType(e);
          });
          return;
        }
        i._syncAndChangeMapType(e);
      } else if (this.preMapType !== BMAP_EARTH_MAP) {
        this._changeFlatMapType(e);
        this._mapTypeChanging = false;
      } else {
        this._setMapTypeStatus(e, function (T, kc) {
          var kd = i._earth.getEarthCanvas();
          i._changeFlatMapType(e, this.preMapType);
          if (i._mapTypeChangAni) {
            i._mapTypeChangAni.stop();
          }
          i._mapTypeChangAni = dm.start({
            el: kd,
            style: "opacity",
            startValue: 1,
            endValue: 0,
            duration: 200,
            callback: function () {
              i._mapTypeChangAni = null;
              i._mapTypeChanging = false;
            }
          });
          T = i9.convertLL2MC(T);
          if (i._renderType === "webgl") {
            eX.extend(i, C.prototype);
            i.setCenterIn(T, {
              noAnimation: true
            });
            i.setZoomIn(kc, {
              noAnimation: true
            });
          } else {
            eX.extend(i, iR.prototype);
            i.centerAndZoomIn(T, kc);
          }
        });
      }
    },
    _changeFlatMapType: function (kf) {
      if (!kf || !ej[kf]) {
        return;
      }
      var kn = this.preMapType;
      this.mapType = kf;
      var kc = this.getTileLayer(kn);
      if (kc) {
        this.removeTileLayer(kc);
      } else if (this.tileMgr.tileLayers.length) {
        var km = this.getTileLayer("B_NORMAL_MAP");
        if (km) {
          this.removeTileLayer(km);
        } else {
          km = this.getTileLayer("B_SATELLITE_MAP");
          if (km) {
            this.removeTileLayer(km);
          }
        }
      }
      this._preStreetLayerShow = this.config.showStreetLayer;
      if (kn === BMAP_SATELLITE_MAP && this.config.showVectorStreetLayer) {
        this._removeHybirdVectorMap();
      } else if (kn === BMAP_SATELLITE_MAP && this._preStreetLayerShow) {
        this._removeHybirdMap();
      }
      if (this.mapType !== BMAP_EARTH_MAP || this._renderType !== "webgl" || this.baseLayerAdded !== true) {
        if (kf !== BMAP_NONE_MAP) {
          var T = new hY(new cx(-21364736, -10616832), new cx(23855104, 15859712));
          var kk = new m(T, "baidu", kf);
          var kd = new hv({
            mapType: this.mapType,
            copyright: kk,
            dataType: this.mapType === BMAP_SATELLITE_MAP ? gF : hI,
            customLayer: this.mapType === BMAP_SATELLITE_MAP,
            baseLayer: true,
            transparentPng: false,
            tileTypeName: this.mapType === BMAP_SATELLITE_MAP ? "web" : "na"
          });
          kd._isInnerLayer = true;
          kd.setZIndex(0);
          this.addTileLayer(kd);
          if (this._renderType === "webgl" && !this.baseLayerAdded) {
            this.baseLayerAdded = true;
          }
        }
      }
      if (kf === BMAP_SATELLITE_MAP) {
        this._featureMgr.clearLabelOverlayData();
        this._featureMgr.setLabelData([]);
        if (this.config.showVectorStreetLayer) {
          this._addHybirdVectorMap();
        } else if (this._preStreetLayerShow === true || typeof this._preStreetLayerShow === "undefined") {
          this._addHybirdMap();
        }
      }
      var kh = this.tileMgr.tileLayers;
      for (var kg = 0, ke = kh.length; kg < ke; kg++) {
        var ki = kh[kg];
        var kl = ki.tilesDiv;
        if (!kl) {
          continue;
        }
        if (!ki._isInnerLayer && kl.style.visibility === "hidden") {
          kl.style.visibility = "";
        }
      }
      var kj = new fJ("onmaptypechange");
      kj.zoomLevel = this.zoomLevel;
      kj.mapType = kf;
      kj.exMapType = kn;
      this.dispatchEvent(kj);
    },
    showStreetLayer: function (e) {
      if (e) {
        this.hideVectorStreetLayer();
      }
      if (e) {
        this._addHybirdMap();
      } else {
        this._removeHybirdMap();
      }
    },
    showVectorStreetLayer: function () {
      this.hideStreetLayer();
      this.hideVectorStreetLayer();
      this.config.showVectorStreetLayer = true;
      if (this.mapType === BMAP_SATELLITE_MAP || this.mapType === BMAP_NONE_MAP) {
        this._addHybirdVectorMap();
      }
    },
    hideStreetLayer: function (e) {
      this._hideStreetLayerOptions = e;
      this._removeHybirdMap(e);
    },
    hideVectorStreetLayer: function () {
      this.config.showVectorStreetLayer = false;
      if (this.mapType === BMAP_SATELLITE_MAP || this.mapType === BMAP_NONE_MAP) {
        this._removeHybirdVectorMap();
      }
    },
    _addHybirdVectorMap: function () {
      var e = new hv({
        mapType: "B_NORMAL_MAP",
        dataType: hI,
        customLayer: false,
        baseLayer: false,
        transparentPng: true,
        tileTypeName: "na"
      });
      e._isInnerLayer = true;
      e.setZIndex(1);
      this.addTileLayer(e);
    },
    _removeHybirdVectorMap: function () {
      var kd = this.tileMgr.tileLayers;
      for (var kc = 0, e = kd.length; kc < e; kc++) {
        var T = kd[kc];
        if (T._isInnerLayer && T.mapType === "B_NORMAL_MAP") {
          this.removeTileLayer(T);
        }
      }
    },
    _addHybirdMap: function () {
      this._isHybridShow = true;
      if (this.mapType === "B_EARTH_MAP") {
        if (this._earth) {
          this._earth.showStreetLayer();
        }
        return;
      }
      if (this._hybridTileLayer) {
        this.addTileLayer(this._hybridTileLayer);
        var kf = new fJ("onstreetlayer_show");
        this.dispatchEvent(kf);
        return;
      }
      var kd = new hY(new cx(-21364736, -10616832), new cx(23855104, 15859712));
      var T = new m(kd, "", BMAP_HYBRID_MAP);
      var i = new hv({
        copyright: T,
        transparentPng: true,
        tileTypeName: "web"
      });
      i._isInnerLayer = true;
      var kc = this.isCanvasMap();
      i.getTilesUrl = function (kg, kl) {
        var kj = ej.B_STREET_MAP;
        var kk = jO("ditu", "satelliteStreet");
        var kh = kk.ver;
        var e = kk.udt;
        var ki = kj.tileUrls[Math.abs(kg.x + kg.y) % kj.tileUrls.length] + "?qt=vtile&x=" + (kg.x + "").replace(/-/gi, "M") + "&y=" + (kg.y + "").replace(/-/gi, "M") + "&z=" + kl + "&styles=sl&v=" + kh + "&udt=" + e + "&scaler=" + gd() + "&showtext=" + (kc ? 0 : 1);
        return ki;
      };
      this._isHybridShow = true;
      this.addTileLayer(i);
      this._hybridTileLayer = i;
      var ke = new fJ("onstreetlayer_show");
      this.dispatchEvent(ke);
    },
    _removeHybirdMap: function (i) {
      this._isHybridShow = false;
      if (this.mapType === "B_EARTH_MAP") {
        if (this._earth) {
          this._earth.hideStreetLayer(i);
        }
        return;
      }
      if (this._hybridTileLayer) {
        this.removeTileLayer(this._hybridTileLayer);
        var T = new fJ("onstreetlayer_hide");
        this.dispatchEvent(T);
      }
    },
    isStreetLayerShow: function () {
      return this._isHybridShow;
    },
    getTileId: function (e, ke) {
      var kc = ej[this.mapType];
      if (typeof kc !== "object") {
        return null;
      }
      var T = kc.baseUnits * Math.pow(2, kc.zoomLevelBase - ke);
      var kd = parseInt(e.lng / T, 10);
      var i = parseInt(e.lat / T, 10);
      return {
        row: kd,
        column: i,
        level: ke
      };
    },
    reset: function () {
      this.centerAndZoomIn(this.defaultCenter, this.defaultZoomLevel, true);
    },
    setOptions: function (i) {
      i = i || {};
      var kd = this;
      for (var kc in i) {
        if (i.hasOwnProperty(kc)) {
          var T = true;
          if (typeof i[kc] !== "object") {
            T = i[kc] !== this.config[kc];
          }
          this.config[kc] = i[kc];
          if (kc === "fixCenterWhenResize") {
            this.config.enableResizeOnCenter = i[kc];
          }
          if (!T) {
            continue;
          }
          switch (kc) {
            case "style":
            case "styleUrl":
              var e = {
                os: i.style.os,
                sv: i.style.sv
              };
              if (kc === "style" && i.styleUrl) {
                break;
              }
              this.fire(new fJ("onstyle_willchange"));
              this.loadMapStyleFiles(function () {
                var ke = new fJ("onlayer_update");
                ke.name = "na";
                kd.fire(ke);
              }, e);
              break;
            case "enableAutoResize":
              if (i[kc] === true) {
                this.enableAutoResize();
              } else {
                this.disableAutoResize();
              }
              break;
            case "displayOptions":
              this.setDisplayOptions(i[kc]);
              break;
          }
        }
      }
    },
    setPrivateStatus: function (i) {
      if (typeof i === "boolean") {
        if (this.config.privateOn !== i) {
          this.config.privateOn = i;
          var e = new fJ("onlayer_update");
          e.name = "na";
          this.fire(e);
        }
      }
    },
    getPrivateStatus: function () {
      return this.config.privateOn;
    },
    setPrivateRegions: function (kd) {
      if (kd && kd instanceof Array) {
        var kc = true;
        for (var T = 0; T < kd.length; T++) {
          if (kd[T] instanceof cM) {
            continue;
          } else {
            kc = false;
            break;
          }
        }
        if (kc) {
          this.config.privateRegions = kd;
          var e = new fJ("onlayer_update");
          e.name = "na";
          this.fire(e);
        }
      }
    },
    getPrivateRegions: function () {
      if (!this.config.privateRegions) {
        return null;
      } else {
        return this.config.privateRegions;
      }
    },
    enableDragging: function () {
      this.config.enableDragging = true;
    },
    disableDragging: function () {
      this.config.enableDragging = false;
    },
    enableInertialDragging: function () {
      this.config.enableInertialDragging = true;
    },
    disableInertialDragging: function () {
      this.config.enableInertialDragging = false;
    },
    enableScrollWheelZoom: function () {
      this.config.enableWheelZoom = true;
    },
    disableScrollWheelZoom: function () {
      this.config.enableWheelZoom = false;
    },
    enableContinuousZoom: function () {
      this.config.enableContinuousZoom = true;
    },
    disableContinuousZoom: function () {
      this.config.enableContinuousZoom = false;
    },
    enableResizeOnCenter: function () {
      this.config.enableResizeOnCenter = true;
    },
    disableResizeOnCenter: function () {
      this.config.enableResizeOnCenter = false;
    },
    enableDoubleClickZoom: function () {
      this.config.enableDblclickZoom = true;
    },
    disableDoubleClickZoom: function () {
      this.config.enableDblclickZoom = false;
    },
    enableKeyboard: function () {
      this.config.enableKeyboard = true;
    },
    disableKeyboard: function () {
      this.config.enableKeyboard = false;
    },
    getSize: function () {
      return new i0(this.width, this.height);
    },
    enablePinchToZoom: function () {
      this.config.enablePinchZoom = true;
    },
    disablePinchToZoom: function () {
      this.config.enablePinchZoom = false;
    },
    enableRotateGestures: function () {
      this.config.enableRotateGestures = true;
    },
    disableRotateGestures: function () {
      this.config.enableRotateGestures = false;
    },
    enableTilt: function () {
      this.config.enableTilt = true;
    },
    disableTilt: function () {
      this.config.enableTilt = false;
    },
    enableRotate: function () {
      this.config.enableRotate = true;
    },
    disableRotate: function () {
      this.config.enableRotate = false;
    },
    enableAutoResize: function () {
      this.config.enableAutoResize = true;
      this._watchSize();
      if (!this.temp.autoResizeTimer) {
        this.temp.autoResizeTimer = setInterval(this._watchSize, 16);
      }
    },
    disableAutoResize: function () {
      this.config.enableAutoResize = false;
      if (this.temp.autoResizeTimer) {
        clearInterval(this.temp.autoResizeTimer);
        this.temp.autoResizeTimer = null;
      }
    },
    checkResize: function () {
      this._watchSize();
    },
    resize: function () {
      this._watchSize();
    },
    getContainerSize: function () {
      return new i0(this.container.clientWidth, this.container.clientHeight);
    },
    _getProperZoom: function (T) {
      if (!T) {
        T = this.zoomLevel;
      }
      var i = this.getMinZoom();
      var e = this.getMaxZoom();
      var kc = false;
      if (T < i) {
        kc = true;
        T = i;
      }
      if (T > e) {
        kc = true;
        T = e;
      }
      if (this._renderType !== "webgl") {
        T = Math.round(T);
      }
      return {
        zoom: T,
        exceeded: kc
      };
    },
    getContainer: function () {
      return this.container;
    },
    getZoomUnits: function (T) {
      if (this.mapType === BMAP_EARTH_MAP) {
        return Math.pow(2, 18 - this._earth.getImageZoom());
      }
      var e = ej[this.mapType];
      if (typeof e !== "object") {
        return null;
      }
      var i = T || this.zoomLevel;
      return Math.pow(2, e.zoomLevelBase - i);
    },
    pointToPixelIn: function (kn, kp) {
      if (!kn) {
        return;
      }
      kp = kp || {};
      if (this.mapType === BMAP_EARTH_MAP) {
        var ke;
        if (!kn._llPt) {
          ke = i9.convertMC2LL(kn);
          kn._llPt = ke;
        }
        ke = kn._llPt;
        var kj = null;
        var kd = null;
        if (typeof kp.zoom === "number") {
          var km = this._earth;
          var ko = km._getEarthZoomByImgZoom(kp.zoom);
          if (ko <= 3) {
            kj = km._generateTmpPMatrix(ko);
          }
          kd = km._generateTmpMVMatrix(km.getCenter(), ko);
        }
        var kf = this._earth.fromLatLngToPixel(ke, {
          useRound: false,
          isCalcOnBack: true,
          matrixInfo: {
            modelViewMatrix: kd,
            projectionMatrix: kj
          }
        });
        return kf;
      }
      if (this._heading % 360 === 0 && this._tilt === 0 || !this._webglMapCamera) {
        var kl = this.getZoomUnits(kp.zoom);
        var kh = kp.center || this.centerPoint;
        var kc = this.width / 2;
        var kg = this.height / 2;
        var kk;
        if (kn.lng * kh.lng < 0) {
          var i = Math.abs(kn.lng - kh.lng);
          var e = (e0._mc180X * 2 - i) / kl;
          if (kh.lng < 0) {
            kk = kc - e;
          } else {
            kk = kc + e;
          }
        } else {
          kk = (kn.lng - kh.lng) / kl + kc;
        }
        var ki = (kh.lat - kn.lat) / kl + kg;
        if (kp.useRound !== false) {
          kk = Math.round(kk);
          ki = Math.round(ki);
        }
        return new fi(kk, ki);
      }
      var T = this._webglMapCamera.fromMCToScreenPixel(kn.lng, kn.lat, kp);
      if (kp.useRound === false) {
        return T;
      }
      T.x = Math.round(T.x);
      T.y = Math.round(T.y);
      return T;
    },
    pixelToPointIn: function (e, kj) {
      if (!e) {
        return;
      }
      kj = kj || {};
      if (this.mapType === BMAP_EARTH_MAP) {
        if (typeof kj.zoom === "number") {
          var kh = this._earth;
          var ke = null;
          var T = null;
          var ki = kh._getEarthZoomByImgZoom(kj.zoom);
          if (ki <= 3) {
            ke = kh._generateTmpPMatrix(ki);
          }
          T = kh._generateTmpMVMatrix(kh.getCenter(), ki);
        }
        var i = this._earth.fromPixelToLatLng(e, {
          matrixInfo: {
            modelViewMatrix: T,
            projectionMatrix: ke
          }
        });
        if (i === null) {
          return null;
        }
        return i9.convertLL2MC(i);
      }
      if ((this._heading % 360 !== 0 || this._tilt > 0) && this._webglMapCamera) {
        return this._webglMapCamera.fromScreenPixelToMC(e.x, e.y, kj);
      }
      var kf = kj.center || this.centerPoint;
      var kg = this.getZoomUnits(kj.zoom);
      var kd = kf.lng + kg * (e.x - this.width / 2);
      var kc = kf.lat - kg * (e.y - this.height / 2);
      return new cx(kd, kc);
    },
    pointToOverlayPixelIn: function (e, kc) {
      kc = kc || {};
      var T = this.pointToPixelIn(e, {
        zoom: kc.zoom,
        center: kc.center,
        forLabel: true,
        frustumTest: true,
        useRound: kc.useRound
      });
      if (!T) {
        return;
      }
      if (kc.fixPosition && this.mapType !== "B_EARTH_MAP") {
        var kd = this.getSize();
        var i = this.worldSize(kc.zoom);
        if (T.x > kd.width) {
          while (T.x > kd.width) {
            T.x -= i;
          }
        } else if (T.x < 0) {
          while (T.x < 0) {
            T.x += i;
          }
        }
      }
      if (this._renderType === "webgl") {
        return T;
      }
      T.x -= this.offsetX;
      T.y -= this.offsetY;
      return T;
    },
    overlayPixelToPointIn: function (i, e) {
      if (!i) {
        return;
      }
      var T = i.clone();
      if (this._renderType !== "webgl") {
        T.x += this.offsetX;
        T.y += this.offsetY;
      }
      return this.pixelToPointIn(T, e);
    },
    getProjection: function () {
      return new i9();
    },
    lnglatToMercator: function (e, kc) {
      var i = new cx(e, kc);
      var T = i9.convertLL2MC(i);
      return [T.lng, T.lat];
    },
    mercatorToLnglat: function (i, e) {
      if (isNaN(i) || isNaN(e)) {
        return [];
      }
      i = parseFloat(i);
      e = parseFloat(e);
      var kc = new cx(i, e);
      var T = i9.convertMC2LL(kc);
      return [T.lng, T.lat];
    },
    getBoundsIn: function () {
      if (!this._bounds) {
        return;
      }
      var kp = arguments[0];
      if (this.mapType === BMAP_EARTH_MAP && this._earth) {
        var kj = this._earth.getCustomBounds();
        if (!kj) {
          return this.config.defaultMaxBounds;
        }
        var ki = kj.getSouthWest();
        var e = kj.getNorthEast();
        if (ki.lng > e.lng) {
          e.lng = 180;
        }
        var kG = i9.convertLL2MC(ki);
        var kw = i9.convertLL2MC(e);
        var km = this.config.defaultMaxBounds;
        var kv = Math.max(kG.lng, km.sw.lng);
        var ku = Math.max(kG.lat, km.sw.lat);
        var ko = Math.min(kw.lng, km.ne.lng);
        var kn = Math.min(kw.lat, km.ne.lat);
        var kr = new hY(new cx(kv, ku), new cx(ko, kn));
        kr.pointBottomLeft = new cx(kv, ku);
        kr.pointBottomRight = new cx(ko, ku);
        kr.pointTopLeft = new cx(kv, kn);
        kr.pointTopRight = new cx(ko, kn);
        kr.setMinMax();
        kr.makeNormalizedPoint(this._earth.getHeading());
        return kr;
      }
      kp = kp || {};
      var kd = kp.margins || [0, 0, 0, 0];
      var kB = this.pixelToPointIn({
        x: kd[3],
        y: this.height - kd[2]
      }, kp);
      var kF = this.pixelToPointIn({
        x: this.width - kd[1],
        y: kd[0]
      }, kp);
      var kt = typeof kp.heading === "number" ? kp.heading : this._heading % 360;
      var T = typeof kp.tilt === "number" ? kp.tilt : this._tilt;
      var kl = this._webglMapCamera;
      if (kt === 0 && T === 0 || !kl) {
        this._bounds.setSouthWest(kB);
        this._bounds.setNorthEast(kF);
        this._bounds.pointBottomLeft = kB;
        this._bounds.pointBottomRight = new cx(kF.lng, kB.lat);
        this._bounds.pointTopRight = kF;
        this._bounds.pointTopLeft = new cx(kB.lng, kF.lat);
        this._bounds.setMinMax();
        this._bounds.makeNormalizedPoint(kt);
        return this._bounds;
      }
      var ks = this.pixelToPointIn({
        x: kd[3],
        y: kd[0]
      }, kp);
      var kc = kl.getPosition();
      var kH = Math.sqrt(Math.pow(ks.lng - kc[0], 2) + Math.pow(ks.lat - kc[1], 2));
      var kC = this.getZoomUnits();
      var kJ = kH / kC;
      var kz = kl._frustumSideLen;
      var kh = kl._fovy;
      if (kJ > kz || 90 - T < kh / 2) {
        var kI = [ks.lng - kc[0], ks.lat - kc[1]];
        if (90 - T < kh / 2) {
          kI[0] = -kI[0];
          kI[1] = -kI[1];
        }
        var kA = kz * kC;
        var kg = [kI[0] / kH * kA + kc[0], kI[1] / kH * kA + kc[1]];
        var kx = [kF.lng - kc[0], kF.lat - kc[1]];
        if (90 - T < kh / 2) {
          kx[0] = -kx[0];
          kx[1] = -kx[1];
        }
        var ke = [kx[0] / kH * kA + kc[0], kx[1] / kH * kA + kc[1]];
        ks.lng = kg[0];
        ks.lat = kg[1];
        kF.lng = ke[0];
        kF.lat = ke[1];
      }
      var kq = this.pixelToPointIn({
        x: this.width - kd[1],
        y: this.height - kd[2]
      }, kp);
      var ky = [kB, kF, ks, kq];
      var kE = ky[0].lng;
      var kK = ky[0].lat;
      var kf = ky[0].lng;
      var kk = ky[0].lat;
      for (var kD = 1; kD < 4; kD++) {
        if (ky[kD].lng < kE) {
          kE = ky[kD].lng;
        }
        if (ky[kD].lng > kf) {
          kf = ky[kD].lng;
        }
        if (ky[kD].lat < kK) {
          kK = ky[kD].lat;
        }
        if (ky[kD].lat > kk) {
          kk = ky[kD].lat;
        }
      }
      this._bounds.setSouthWest(new cx(kE, kK));
      this._bounds.setNorthEast(new cx(kf, kk));
      this._bounds.pointTopLeft = ks;
      this._bounds.pointTopRight = kF;
      this._bounds.pointBottomRight = kq;
      this._bounds.pointBottomLeft = kB;
      this._bounds.makeNormalizedPoint(kt);
      this._bounds.setMinMax();
      return this._bounds;
    },
    isLoaded: function () {
      return !!this.loaded;
    },
    _getBestLevel: function (i, kl) {
      var ke = 0;
      if (this._renderType === "webgl" && !bW()) {
        ke = 100;
      }
      var kf = kl.margins || [10, 10, 10, 10];
      var kc = kl.zoomFactor || 0;
      var kg = kf[1] + kf[3];
      var kd = kf[0] + kf[2];
      var e = this.getMinZoom();
      var kk = this.getMaxZoom();
      var kj = i.toSpan();
      var ki = kj.width / (this.width - kg - ke);
      var kh = kj.height / (this.height - kd - ke);
      var T = 18 - p(Math.max(ki, kh));
      if (T < e) {
        T = e;
      }
      if (T > kk) {
        T = kk;
      }
      T += kc;
      if (this._renderType !== "webgl") {
        T = Math.floor(T);
      }
      return T;
    },
    getViewportIn: function (kl, kd) {
      if (this.mapType === BMAP_EARTH_MAP) {
        kl = kl || [];
        var kf = [];
        for (var km = 0; km < kl.length; km++) {
          if (!kl[km]) {
            continue;
          }
          kf.push(i9.convertMC2LL(kl[km]));
        }
        var kn = this._earth.getViewportIn(kf, kd);
        var kc = kn.center;
        var kj = kn.zoom;
        var kr = i9.convertLL2MC(kc);
        return {
          center: kr,
          zoom: kj
        };
      }
      var kh = {
        center: this.getCenterIn(),
        zoom: this.getZoom()
      };
      if (!kl || kl.length === 0) {
        return kh;
      }
      kd = kd || {};
      var kg;
      if (kl instanceof hY) {
        kg = kl;
      } else {
        var ke = kl;
        kg = new hY();
        for (var kk = ke.length - 1; kk >= 0; kk--) {
          kg.extend(ke[kk]);
        }
        if (kg.isEmpty()) {
          return kh;
        }
      }
      var kq = kg.getCenter();
      var e = this._getBestLevel(kg, kd);
      if (kd.margins) {
        var T = kd.margins;
        var kp = (T[1] - T[3]) / 2;
        var ki = (T[0] - T[2]) / 2;
        var ko = this.getZoomUnits(e);
        kq.lng = kq.lng + ko * kp;
        kq.lat = kq.lat + ko * ki;
      }
      return {
        center: kq,
        zoom: e
      };
    },
    setViewportIn: function (kc, kd) {
      if (this.mapType === BMAP_EARTH_MAP) {
        var kh;
        if (kc && kc.center) {
          var T = i9.convertMC2LL(kc.center);
          var kf = this._earth._getEarthZoomByImgZoom(kc.zoom, T);
          kh = {
            center: T,
            zoom: kf
          };
        } else {
          kh = [];
          for (var ke = 0; ke < kc.length; ke++) {
            var kg = i9.convertMC2LL(kc[ke]);
            kh[ke] = new cr(kg.lat, kg.lng);
          }
        }
        this._earth.setViewportIn(kh, kd);
        return;
      }
      var e;
      if (kc && kc.center) {
        e = kc;
      } else {
        e = this.getViewportIn(kc, kd);
      }
      kd = kd || {};
      if (this._renderType === "webgl") {
        this.centerAndZoomIn(e.center, e.zoom, kd);
        return;
      }
      if (e.zoom === this.zoomLevel && kd.enableAnimation !== false) {
        this.panToIn(e.center, {
          duration: 200,
          callback: kd.callback
        });
      } else {
        this.centerAndZoomIn(e.center, e.zoom, kd);
      }
    },
    addSpots: function (T, i) {
      if (!T || T.length === 0) {
        return;
      }
      i = i || {};
      var ke = i.zIndex || 0;
      var kd = typeof i.enableMultiResponse === "undefined" ? true : !!i.enableMultiResponse;
      this.spotsPool = this.spotsPool || {};
      var e = "sp" + this.temp.spotsGuid++;
      this.spotsPool[e] = {
        spots: T.slice(0),
        zIndex: ke,
        enableMultiResponse: kd
      };
      var kc = this;
      g2.load("hotspot", function () {
        kc._asyncRegister();
      });
      return e;
    },
    getSpots: function (e) {
      return this.spotsPool[e] && this.spotsPool[e].spots || [];
    },
    removeSpots: function (e) {
      if (!e || !this.spotsPool[e]) {
        return;
      }
      delete this.spotsPool[e];
    },
    clearSpots: function () {
      delete this.spotsPool;
    },
    getIconByClickPosition: function (i) {
      if (!this.config.enableIconClick || !this._spotsMgr) {
        return null;
      }
      var e = this._spotsMgr.getSpotsByScreenPosition(i);
      if (e[0] && e[0].userdata) {
        var T = e[0].userdata;
        return {
          name: T.name,
          uid: T.uid,
          position: T.iconPoint || e[0].pt
        };
      }
      return null;
    },
    setBounds: function (e) {
      ej[this.mapType].bounds = e.clone();
    },
    getCoordType: function () {
      return this.config.coordType;
    },
    getPanes: function () {
      return this._panes;
    },
    getInfoWindow: function () {
      if (this.temp.infoWin && this.temp.infoWin.isOpen()) {
        return this.temp.infoWin;
      }
      return null;
    },
    getDistanceIn: function (kd, e) {
      if (!kd || !e) {
        return;
      }
      if (kd.equals(e)) {
        return 0;
      }
      if (this.mapType === BMAP_EARTH_MAP) {
        var kc = i9.convertMC2LL(kd);
        var T = i9.convertMC2LL(e);
        return this._earth.getDistance(kc, T);
      }
      var i = i9.getDistanceByMC(kd, e);
      return i;
    },
    getOverlays: function () {
      var ke = [];
      var kf = this._overlays;
      var kd = this._customOverlays;
      if (kf) {
        for (var kc in kf) {
          if (kf[kc] instanceof eA) {
            ke.push(kf[kc]);
          }
        }
      }
      if (kd) {
        for (var T = 0, e = kd.length; T < e; T++) {
          ke.push(kd[T]);
        }
      }
      return ke;
    },
    getMapType: function () {
      return this.mapType;
    },
    getMapCoordType: function () {
      return this.coordType;
    },
    _asyncRegister: function () {
      for (var e = this.temp.registerIndex; e < bx._register.length; e++) {
        if (bx._register[e] instanceof Function) {
          bx._register[e](this);
        }
      }
      this.temp.registerIndex = e;
    },
    setDefaultCursor: function (e) {
      this.config.defaultCursor = e;
      if (this.platform) {
        this.platform.style.cursor = this.config.defaultCursor;
      }
    },
    getDefaultCursor: function () {
      return this.config.defaultCursor;
    },
    setOverlayMoveCursor: function (e) {
      this.config.overlayMoveCursor = e;
    },
    getOverlayMoveCursor: function () {
      return this.config.overlayMoveCursor;
    },
    setDraggingCursor: function (e) {
      this.config.draggingCursor = e;
    },
    getDraggingCursor: function () {
      return this.config.draggingCursor;
    },
    _syncAndChangeMapType: function (e) {
      var i = this;
      if (i._renderType === "webgl" && i.getTilt() > hK.MAX_DRAG_TILT_L2) {
        i.setTilt(hK.MAX_DRAG_TILT_L2, {
          callback: function () {
            i._changeEarthMapType(e);
          }
        });
      } else {
        i._changeEarthMapType(e);
      }
    },
    _changeEarthMapType: function (T) {
      var kc = this;
      var kf = kc.tileMgr.tileLayers;
      if (this._mapTypeChangAni) {
        this._mapTypeChangAni.stop();
      }
      var ke;
      if (this._earth) {
        ke = this._earth.getEarthCanvas();
      }
      if (!this._earth) {
        this.maskLayer.style.opacity = 1;
        this.maskLayer.style.zIndex = 999;
        this.maskLayer.style.background = "#000";
      }
      this._mapTypeChangAni = new fy({
        duration: 400,
        render: function (e) {
          if (!kc._earth) {
            return;
          }
          ke.style.opacity = e;
        },
        finish: function () {
          for (var e = kf.length - 1, kg = e; kg >= 0; kg--) {
            var ki = kf[kg].tilesDiv;
            if (ki) {
              ki.style.visibility = "hidden";
            }
            if (kf[kg]._isInnerLayer && kc._renderType !== "webgl") {
              kc.removeTileLayer(kf[kg]);
            }
          }
          kc._mapTypeChangAni = null;
          kc._mapTypeChanging = false;
          function kh() {
            var km = kc.getZoom() - 2;
            var kn = kc.getCenterIn();
            var kk = i9.convertMC2LL(kn);
            kc._earth = new bx.Earth(kc, {
              center: kk,
              zoom: km,
              showRealSunlight: kc.config.showRealSunlight,
              showMilkyway: kc.config.showMilkyway,
              earthBackground: kc.config.earthBackground
            });
            kc._proxyEarthEvents();
            var kj = kc.mapType;
            kc.mapType = T;
            var kl = new fJ("onmaptypechange");
            kl.zoomLevel = this.zoomLevel;
            kl.mapType = T;
            kl.exMapType = kj;
            kc.dispatchEvent(kl);
            kc._setMapTypeStatus(T);
            eX.extend(kc, bx.EarthView.prototype);
            if (!kc._navigationCtrl && kc.config.showControls) {
              kc._navigationCtrl = new eZ(kc);
            }
          }
          if (!kc._earth) {
            if (bx["FeatureStyle" + kc.config.style]) {
              kh();
            } else {
              kc.loadMapStyleFiles(function () {
                kh();
              });
            }
          }
          if (parseInt(kc.maskLayer.style.opacity, 10) === 1) {
            setTimeout(function () {
              kc.maskLayer.style.zIndex = 9;
              kc.maskLayer.style.opacity = 0;
            }, 1000);
          }
        }
      });
      if (!this._earth) {
        return;
      }
      var i = this.mapType;
      this.mapType = T;
      var kd = new fJ("onmaptypechange");
      kd.zoomLevel = this.zoomLevel;
      kd.mapType = T;
      kd.exMapType = i;
      this.dispatchEvent(kd);
      kc._setMapTypeStatus(T);
      eX.extend(kc, bx.EarthView.prototype);
    },
    getMapStyleId: function () {
      if (typeof this.config.style === "string") {
        return this.config.style;
      }
      return this.config.mapStyleId || "custom";
    },
    _setMapTypeStatus: function (T) {
      var kg = arguments[1];
      if (T === BMAP_EARTH_MAP) {
        var ke = this._earth.getEarthCanvas();
        if (ke) {
          ke.style.display = "";
        }
        var kh = {
          noAnimation: true
        };
        this._earth.setCenter(i9.convertMC2LL(this.centerPoint), kh);
        this._earth.setImageZoom(this.zoomLevel, kh);
        this._earth.setTilt(this.getTilt(), kh);
        this._earth.setHeading(this.getHeading(), kh);
      } else if (this.preMapType === BMAP_EARTH_MAP && this._earth) {
        var kf = this._earth;
        var kc = kf.getMapZoom();
        var kd = kf._imageRawZoom || kc;
        var i = kd - kc;
        var e = kf.getCenter();
        if (this._renderType === "webgl") {
          this._tilt = kf.getTilt();
          if (this.zoomLevel > 7) {
            this._heading = kf.getHeading();
            if (kg) {
              kg(e, kc);
            }
            return;
          }
          if (kf.getHeading() !== 0) {
            kf.setTilt(this.getTilt());
            kf.setHeading(this.getHeading(), {
              callback: function () {
                if (kg) {
                  kg(e, kc);
                }
              }
            });
          } else if (kg) {
            kg(e, kc);
          }
          return;
        }
        if (i < 0.1 && kf.getTilt() === 0 && kf.getHeading() === 0) {
          if (kg) {
            kg(e, kc);
          }
          return;
        }
        kf.setTilt(0);
        kf.setHeading(0);
        kf.setZoom(kf.getZoom() - i, {
          callback: function () {
            if (kg) {
              kg(e, kc);
            }
          }
        });
      }
    },
    _proxyEarthEvents: function () {
      var kd = this;
      var ke = this._earth;
      ke.on("tilesload", function (i) {
        kd.fire(i);
      });
      ke.on("centerandzoom", function (i) {
        kd.dispatchEvent(new fJ("onmoveend"));
        kd.dispatchEvent(new fJ("onzoomend"));
      });
      function kc(i) {
        kd.fire(i);
      }
      var e = ["zoomstart", "zoomend", "tilesload", "sunlighttime_change", "sunlighttime_clear", "centerandzoom", "animation_start", "animation_stop", "movestart", "moveend", "moving", "dragstart", "dragend", "dragging"];
      for (var T = 0; T < e.length; T++) {
        ke.on(e[T], kc);
      }
    },
    forceEnableEarth: function () {
      this.config.forceEnableEarth = true;
      this.config.enableEarth = c6.ifEnableEarth(true);
      this.dispatchEvent(new fJ("forceenableearth"));
      return this.config.enableEarth;
    },
    setLock: function (e) {
      if (this.mapType === BMAP_EARTH_MAP) {
        this._earth.setLock(e);
      }
      this._lock = e;
    },
    getLock: function () {
      if (this.mapType === BMAP_EARTH_MAP) {
        return this._earth.getLock();
      }
      return this._lock;
    },
    getEarth: function () {
      return this._earth;
    },
    isSupportEarth: function () {
      return this.config.enableEarth;
    },
    isCanvasMap: function () {
      return !!(this._renderType === "canvas" && this.getMapType() !== "B_EARTH_MAP");
    },
    getCanvasMapCoordByUid: function (kd) {
      if (this._renderType === "webgl") {
        var ke = this.tileMgr.tileLayers;
        for (var kc = 0; kc < ke.length; kc++) {
          if (ke[kc].labelProcessor) {
            return ke[kc].labelProcessor.getLabelByUid(kd, "");
          }
        }
        return null;
      }
      var e = this.canvas2dMapMgr._labelClick;
      var T = e.findLabelByUid(kd);
      return T ? new cx(T.iconPos.geoX, T.iconPos.geoY) : null;
    },
    loadBizData: function (i) {
      var e = new fJ("onloadbizdata");
      e.data = i;
      this.dispatchEvent(e);
    },
    unloadBizData: function () {
      var e = new fJ("onunloadbizdata");
      this.dispatchEvent(e);
    },
    zoomIn: function (e) {
      this.setZoomIn(this.zoomLevel + 1, {
        zoomCenter: e
      });
    },
    zoomOut: function (e) {
      this.setZoomIn(this.zoomLevel - 1, {
        zoomCenter: e
      });
    },
    setMaxZoom: function (e) {
      if (this._renderType === "webgl") {
        this.config.maxZoom = e <= 25 ? e : 25;
      } else {
        this.config.maxZoom = e <= 19 ? e : 19;
      }
    },
    setMinZoom: function (e) {
      this.config.minZoom = e >= 3 ? e : 3;
    },
    setCenterIn: function (e, i) {
      i = i ? i : {};
      i.tilt = i.tilt ? i.tilt : this.getTilt();
      i.heading = i.heading ? i.heading : this.getHeading();
      this.panToIn(e, i);
    },
    getRenderType: function () {
      return this._renderType;
    },
    getSolarInfo: function (kc) {
      kc = kc || this._initDate;
      var T = fv(kc);
      var e = i9.convertLL2MC(new cx(T[0], T[1]));
      var kk = e.latLng;
      var kf = bx.Projection.convertMC2LL(this.centerPoint);
      var kh = kc.getUTCHours();
      var kj = kh + 24 * kf.lng / 360;
      var ki = kj - 12;
      var kg = ki * 60 * 0.25;
      var ke = Math.asin(Math.sin(iB(kf.lat)) * Math.sin(iB(kk.lat)) + Math.cos(iB(kf.lat)) * Math.cos(iB(kk.lat)) * Math.cos(iB(kg)));
      var kd = Math.asin(Math.sin(iB(kg)) * Math.cos(iB(kk.lat)) / Math.cos(ke));
      var i = "north";
      if (kf.lat < kk.lat) {
        i = "south";
      }
      return {
        zenith: e,
        solarAltitude: ke,
        solarAzimuth: kd,
        centerPosition: i,
        position: e
      };
    },
    setDisplayOptions: function (T) {
      if (!T) {
        return;
      }
      for (var e in this._displayOptions) {
        if (this._displayOptions.hasOwnProperty(e)) {
          if (typeof T[e] === "boolean" || e === "skyColors" && typeof T.skyColors === "object" || e === "labelMargin" && typeof T.labelMargin === "number") {
            this._displayOptions[e] = T[e];
          }
        }
      }
      var i = this.getMapType();
      if (i === fq.NORMAL) {
        this.fire(new fJ("ondisplayoptions_changed"));
      } else if (i === fq.EARTH && this._earth) {
        this._earth.fire(new fJ("ondisplayoptions_changed"));
      }
    },
    getHorizonPosY: function (e) {
      if (!e || !this._webglMapCamera) {
        return null;
      }
      var i = this._webglMapCamera.fromMCToScreenPixel(e.lng, e.lat, {
        heading: 0
      });
      return i.y;
    },
    getIndoorInfo: function () {
      if (!this._indoorMgr) {
        return;
      }
      return this._indoorMgr.getData();
    },
    showIndoor: function (e, T) {
      var i = new fJ("onindoor_status_changed");
      i.uid = e;
      i.floor = T;
      this.fire(i);
    },
    addAreaSpot: function (e, T) {
      if (!e || e.length === 0) {
        return;
      }
      T = T || {};
      this.areaSpots = this.areaSpots || {};
      var i = T.id || "sp" + this.temp.spotsGuid++;
      this.areaSpots[i] = {
        spot: e,
        userData: T.userData
      };
      var kc = this;
      g2.load("hotspot", function () {
        kc._asyncRegister();
      });
      return i;
    },
    getAreaSpot: function (e) {
      if (this.areaSpots && this.areaSpots[e]) {
        return this.areaSpots[e];
      }
      return null;
    },
    removeAreaSpot: function (e) {
      if (!e || !this.areaSpots[e]) {
        return;
      }
      delete this.areaSpots[e];
    },
    clearAreaSpots: function () {
      this.areaSpots = {};
    },
    resetSpotStatus: function () {
      this.fire(new fJ("onspot_status_reset"));
    },
    hightlightSpotByUid: function (e, T) {
      var i = new fJ("onspot_highlight");
      i.uid = e;
      i.tilePosStr = T;
      this.fire(i);
    },
    setZoomIn: function (i, e) {
      e = e || {};
      this.zoomTo(i, e.zoomCenter || null, e);
    },
    restrictBounds: function (e) {
      if (e instanceof hY) {
        this.config.restrictBounds = e;
        this.restrictCenter(this.getCenterIn());
        this.fire(new fJ("oncenter_changed"));
      }
    },
    getCurrentMaxTilt: function () {
      var e = this.zoomLevel;
      if (this.mapType === "B_EARTH_MAP") {
        return hK.MAX_DRAG_TILT_L2;
      }
      if (this.config.restrictCenter === false) {
        return hK.MAX_DRAG_TILT;
      }
      if (e >= 19) {
        return hK.MAX_DRAG_TILT;
      } else if (e <= 18) {
        if (e < this._enableTiltZoom) {
          if (e >= this._enableTiltZoom - 2) {
            return (1 - (this._enableTiltZoom - e) / 2) * hK.MAX_DRAG_TILT_L2;
          }
          return 0;
        }
        return hK.MAX_DRAG_TILT_L2;
      } else {
        return (hK.MAX_DRAG_TILT - hK.MAX_DRAG_TILT_L2) * (e - 18) + hK.MAX_DRAG_TILT_L2;
      }
    },
    worldSize: function (i) {
      var e = i || this.zoomLevel;
      return hK.WORLD_SIZE_MC / this.getZoomUnits(e);
    },
    setTrafficOn: function (e) {
      if (e && Number(e) > 1) {
        jE.setZIndex(Number(e));
      }
      this.addTileLayer(jE);
    },
    setTrafficOff: function () {
      this.removeTileLayer(jE);
    },
    showOverlayContainer: function () {
      this.setDisplayOptions({
        overlay: true
      });
    },
    hideOverlayContainer: function () {
      this.setDisplayOptions({
        overlay: false
      });
    },
    addLabelsToMapTile: function (kf, ke) {
      for (var kc = 0; kc < kf.length; kc++) {
        if (typeof kf[kc].type === "undefined") {
          kf[kc].type = "fixed";
        }
        if (typeof kf[kc].rank !== "number") {
          kf[kc].rank = 50000;
        }
        kf[kc].pt = kf[kc].position;
        kf[kc].custom = true;
        kf[kc].processedInZoom = 0;
        var T = false;
        for (var e = 0; e < this._customTileLabels.length; e++) {
          if (this._customTileLabels[e].uid === kf[kc].uid) {
            T = true;
            break;
          }
        }
        if (!T) {
          this._customTileLabels.push(kf[kc]);
        }
      }
      var kd = new fJ("onadd_tile_labels");
      if (ke && ke instanceof d8) {
        kd.data = kf;
        kd.index = ke.layer.drawIndex;
        kd.model = "mvt";
      }
      this.dispatchEvent(kd);
    },
    removeLabelsFromMapTile: function (kd, kc, T) {
      var kf = new fJ("onremove_tile_labels");
      if (kc && T) {
        kf.data = kd;
        kf.index = kc;
        kf.model = T;
      } else {
        for (var ke = 0; ke < kd.length; ke++) {
          for (var e = 0; e < this._customTileLabels.length; e++) {
            if (this._customTileLabels[e].uid === kd[ke]) {
              this._customTileLabels.splice(e, 1);
            }
          }
        }
      }
      this.dispatchEvent(kf);
    },
    clearLabels: function (T, i) {
      var e = new fJ("onclear_labels");
      if (T && i) {
        e.data = [];
        e.index = T;
        e.model = i;
      } else {
        this._customTileLabels.length = 0;
      }
      this.dispatchEvent(e);
    },
    loadMapStyleFiles: function (ke, e) {
      this.customLoaded = false;
      var T = this.config.style;
      var kd = this.config.styleUrl;
      var kc = this;
      this._setTextRenderType();
      if (typeof T === "string" && !kd) {
        if (bx["FeatureStyle" + T]) {
          this.customLoaded = true;
          kc.fire(new fJ("onstyle_loaded"));
          ke();
          return;
        }
        bx["FeatureStyle" + T] = window.FeatureStyle;
        bx["iconSetInfo" + T] = window.iconSetInfo_high;
        bx.indoorStyle = window.indoorStyle;
        gM.load(B.getMapStyleFiles(T), function () {
          if (kc.config.style === T) {
            bx["FeatureStyle" + T] = window.FeatureStyle;
            bx["iconSetInfo" + T] = window.iconSetInfo_high;
            bx.indoorStyle = window.indoorStyle;
            kc.customLoaded = true;
            kc.fire(new fJ("onstyle_loaded"));
            ke();
          }
        });
      } else {
        var i = T;
        u.init(kc);
        u.getStyleJson(i, function (kg) {
          var kl = eN;
          var kn = bx.getGUID("custom");
          kc.config.mapStyleId = kn;
          var kj = {};
          eX.extend(kj, kg);
          var kh = Math.floor(kc.getZoom());
          var kk;
          window["styleCbk_" + kn] = function (ko, kp) {
            if (kp !== kk || !bx["customStyleInfo_" + kn]) {
              return;
            }
            if (typeof ko === "string") {
              ko = JSON.parse(ko);
            }
            u.onStyleDataBack(ko, kh, kn, kj, kl, bx["customStyleInfo_" + kn]);
            kc.customLoaded = true;
            kc.fire(new fJ("onstyle_loaded"));
            ke();
          };
          bx["customStyleInfo_" + kn] = {
            zoomRegion: {},
            zoomStyleBody: [],
            zoomFrontStyle: {}
          };
          var km = u.getStyleUrl(kg, kl, "styleCbk_" + kn, kh, e, bx["customStyleInfo_" + kn]);
          var kf = km.split("?")[0];
          kk = km.split("?")[1];
          if (kd) {
            kf = kd;
            kk = kf.split("?")[1];
          }
          if (!bx.iconSetInfoCustom) {
            var ki = B.getMapStyleFiles("default");
            ki.splice(1, 1);
            gM.load(ki, function () {
              bx.iconSetInfoCustom = window.iconSetInfo_high;
              bx.indoorStyle = window.indoorStyle;
              if (kf.indexOf("jsonp") > "-1") {
                gM.load(kf);
              } else {
                bx["customStyleInfo_" + kn].xhr = h5.post(kf, kk, window["styleCbk_" + kn]);
              }
            });
          } else if (kf.indexOf("jsonp") > "-1") {
            gM.load(kf);
          } else {
            bx["customStyleInfo_" + kn].xhr = h5.post(kf, kk, window["styleCbk_" + kn]);
          }
        });
      }
    },
    getFeatureStyleTags: function () {
      var e = [];
      var kd = Object.keys(bx);
      for (var kc = 0; kc < kd.length; kc++) {
        var T = kd[kc];
        if (T.indexOf("FeatureStyle") > -1 && bx[T]) {
          e.push(T);
        }
      }
      return e;
    },
    setCopyrightOffset: function (kc, i) {
      var T = new fJ("oncopyrightoffsetchange", {
        logo: kc,
        cpy: i
      });
      this.dispatchEvent(T);
    },
    _setTextRenderType: function (e) {
      if (e) {
        this.config.textRenderType = e;
        return;
      }
      if (this.config.textRenderType !== null) {
        return;
      }
      if (bW()) {
        this.config.textRenderType = "canvas";
      } else if (typeof this.config.style === "string") {
        this.config.textRenderType = "image";
      } else {
        this.config.textRenderType = "canvas";
      }
    },
    destroy: function () {
      this._destroyed = true;
      this.disableAutoResize();
      this.fire(new fJ("ondestroy"));
      var e = this.config.mapStyleId || 0;
      delete bx["customStyleInfo_" + e];
      if (bx.BMAP_INSTANCES) {
        bx.BMAP_INSTANCES -= 1;
      }
      if (!bx.BMAP_INSTANCES) {
        this.destroyStyle();
      }
      this.config = {};
      this.clearSpots();
      if (this._webGLStateId) {
        dS.WebGLState.remove(this._webGLStateId);
      }
      this.container.onselectstart = null;
      this.container.style.backgroundImage = "";
      this.maskLayer = null;
      this.platform = null;
      var i = this;
      setTimeout(function () {
        i._listeners = null;
        i._bounds = null;
        i.tileLabels = [];
        i._overlayMgrGL = null;
        i._overlayMgr = null;
        i._mapIcon = null;
        if (i._mouse) {
          i._mouse._drag = null;
          i._mouse = null;
        }
        i.deepZoom = null;
        i.tileMgr = null;
        i.indexToRgb = null;
        i.toFormatCoords = null;
        i._webglMapCamera = null;
        i._normalLayerMgr = null;
        i._webglPainter = null;
        i._webglMapScene = null;
        i._indoorMgr = null;
        if (i._renderType === "webgl") {
          i._spotsMgr = null;
          i._workerMgr = null;
          i.jobScheduler = null;
          i.benchmark = null;
          i._featureMgr = null;
          i._labelProcessor = null;
          i._customLabelMgr = null;
        }
        if (i.cpyCtrl) {
          i.cpyCtrl._map = null;
          i.cpyCtrl = null;
        }
        i.logoCtrl = null;
        i._spotDataOnCanvas = null;
        i._navigationCtrl = null;
        i.container.innerHTML = "";
        window.FeatureStyle = null;
        window.iconSetInfo_high = null;
        window.indoorStyle = null;
        window._indoorMgr = null;
      }, 600);
    },
    destroyStyle: function () {
      var e = [];
      var kd = Object.keys(bx);
      for (var kc = 0; kc < kd.length; kc++) {
        var T = kd[kc];
        if (T.indexOf("FeatureStyle") > -1 || T.indexOf("iconSetInfo") > -1 || T.indexOf("indoorStyle") > -1) {
          e.push(T);
        }
      }
      for (var kc = 0; kc < e.length; kc++) {
        delete bx[e[kc]];
      }
    },
    centerAndZoom: function (e, kf, T) {
      if (Object.prototype.toString.call(kf) !== "[object Undefined]") {
        kf = parseInt(kf, 10);
      }
      if (typeof e === "string") {
        var kc = this;
        var ke = new bf();
        ke.getPoint(e, function (kg) {
          e = kg;
          var kh = i9.convertLL2MC(e);
          kc.centerAndZoomIn(kh, kf, T);
        }, e);
      } else {
        if (this.config.coordType === BMAP_COORD_GCJ02) {
          var kd = iu(e, 3);
          var i = i9.convertLL2MC(kd);
        } else {
          var i = i9.convertLL2MC(e);
        }
        this.centerAndZoomIn(i, kf, T);
      }
    },
    pointToPixel: function (e, T) {
      var i = i9.convertLL2MC(e);
      var kc = {};
      eX.extend(kc, T);
      if (kc && kc.center) {
        kc.center = i9.convertLL2MC(kc.center);
      }
      return this.pointToPixelIn(i, kc);
    },
    pixelToPoint: function (T, i) {
      var kc = {};
      eX.extend(kc, i);
      if (kc && kc.center) {
        kc.center = i9.convertLL2MC(kc.center);
      }
      var e = this.pixelToPointIn(T, kc);
      return i9.convertMC2LL(e);
    },
    pointToOverlayPixel: function (e, T) {
      var i = i9.convertLL2MC(e);
      var kc = {};
      eX.extend(kc, T);
      if (kc && kc.center) {
        kc.center = i9.convertLL2MC(kc.center);
      }
      return this.pointToOverlayPixelIn(i, kc);
    },
    overlayPixelToPoint: function (T, i) {
      var kc = {};
      eX.extend(kc, i);
      if (kc && kc.center) {
        kc.center = i9.convertLL2MC(kc.center);
      }
      var e = this.overlayPixelToPointIn(T, kc);
      return i9.convertMC2LL(e);
    },
    setViewport: function (T, kc) {
      var e;
      if (T && T.center) {
        e = {};
        eX.extend(e, T);
        e.center = i9.convertLL2MC(e.center);
      } else {
        e = [];
        for (var kd = 0; kd < T.length; kd++) {
          e[kd] = i9.convertLL2MC(T[kd]);
        }
      }
      this.setViewportIn(e, kc);
    },
    getViewport: function (ke, kc) {
      var T;
      if (ke && ke.length) {
        T = [];
        for (var kd = 0; kd < ke.length; kd++) {
          T[kd] = i9.convertLL2MC(ke[kd]);
        }
      } else if (ke instanceof hY) {
        T = new hY(i9.convertLL2MC(ke.getSouthWest()), i9.convertLL2MC(ke.getNorthEast()));
        T.setMinMax();
      }
      var e = this.getViewportIn(T, kc);
      e.center = i9.convertMC2LL(e.center);
      return e;
    },
    getDistance: function (kd, T) {
      var i = i9.convertLL2MC(kd);
      var kc = i9.convertLL2MC(T);
      var e = this.getDistanceIn(i, kc);
      return e;
    },
    setCenter: function (e, T) {
      if (typeof e === "string") {
        var kc = this;
        var ke = new bf();
        ke.getPoint(e, function (kf) {
          e = kf;
          var kg = i9.convertLL2MC(e);
          kc.setCenterIn(kg, T);
        }, e);
      } else {
        if (this.config.coordType === BMAP_COORD_GCJ02) {
          var kd = iu(e, 3);
          var i = i9.convertLL2MC(kd);
        } else {
          var i = i9.convertLL2MC(e);
        }
        this.setCenterIn(i, T);
      }
    },
    setZoom: function (T, e) {
      var i = {};
      eX.extend(i, e);
      if (i && i.zoomCenter) {
        i.zoomCenter = i9.convertLL2MC(i.zoomCenter);
      }
      this.setZoomIn(T, i);
    },
    flyTo: function (e, kd, T) {
      if (this.config.coordType === BMAP_COORD_GCJ02) {
        var kc = iu(e, 3);
        var i = i9.convertLL2MC(kc);
      } else {
        var i = i9.convertLL2MC(e);
      }
      this.flyToIn(i, kd, T);
    },
    panTo: function (e, T) {
      var i = i9.convertLL2MC(e);
      this.panToIn(i, T);
    },
    getCenter: function () {
      var e = this.getCenterIn();
      if (this.config.coordType === BMAP_COORD_GCJ02) {
        var i = i9.convertMC2LL(e);
        return eG(i);
      }
      return i9.convertMC2LL(e);
    },
    getBounds: function () {
      var e = this.getBoundsIn();
      var i = new hY(i9.convertMC2LL(e.getSouthWest()), i9.convertMC2LL(e.getNorthEast()));
      return i;
    },
    setMapStyleV2: function (e) {
      if (typeof e === "string") {
        this._setTextRenderType("image");
      } else {
        this._setTextRenderType("canvas");
      }
      this.setOptions({
        style: e
      });
    },
    startViewAnimation: function (T) {
      var e = T._options.delay;
      var i = this;
      setTimeout(function () {
        T._start(i);
      }, e);
    },
    pauseViewAnimation: function (e) {
      e._pause(this);
    },
    continueViewAnimation: function (e) {
      e._continue(this);
    },
    cancelViewAnimation: function (e) {
      e._cancel(this);
    },
    getMapScreenshot: function () {
      return this._webglMapScene._painter._canvas.toDataURL();
    }
  });
  window.BMAP_NORMAL_MAP = "B_NORMAL_MAP";
  window.BMAPGL_NORMAL_MAP = "B_NORMAL_MAP";
  window.BMAP_SATELLITE_MAP = "B_SATELLITE_MAP";
  window.BMAP_HYBRID_MAP = "B_STREET_MAP";
  window.BMAP_EARTH_MAP = "B_EARTH_MAP";
  window.BMAP_NONE_MAP = "B_NONE_MAP";
  window.BMAP_COORD_MERCATOR = 1;
  window.BMAP_COORD_GCJ02 = 2;
  window.BMAP_SYS_DRAWER = 0;
  window.BMAP_SVG_DRAWER = 1;
  window.BMAP_VML_DRAWER = 2;
  window.BMAP_CANVAS_DRAWER = 3;
  var u = {
    environment: "jsapi",
    map: null,
    ontilesloaded: false,
    onstyle_loaded: false,
    init: function (i) {
      var e = this;
      e.map = i;
      this.changeCopyright();
      this.setEnvironment(e.map.config.style);
      this.resetEventListener();
    },
    resetEventListener: function () {
      var e = this;
      this.ontilesloaded = false;
      this.onstyle_loaded = false;
      e.map.addEventListener("ontilesloaded", e.checkLoadedStatus);
      e.map.addEventListener("onstyle_loaded", e.checkLoadedStatus);
    },
    checkLoadedStatus: function (i) {
      u[i.type] = true;
      if (u.ontilesloaded && u.onstyle_loaded) {
        this.dispatchEvent(new fJ("onstylechangetilesloaded"));
        this.removeEventListener("ontilesloaded", u.checkLoadedStatus);
        this.removeEventListener("onstyle_loaded", u.checkLoadedStatus);
      }
    },
    changeCopyright: function () {
      var e = this;
      if (e.map.cpyCtrl) {
        e.map.cpyCtrl.hide();
        if (e.environment !== "customEditor") {
          e.map.setCopyrightOffset(new i0(1, 1));
        }
      } else {
        e.map.addEventListener("oncopyrightaddend", function () {
          e.map.cpyCtrl.hide();
          if (e.environment !== "customEditor") {
            e.map.setCopyrightOffset(new i0(1, 1));
          }
        });
      }
    },
    setEnvironment: function (e) {
      if (e.customEditor) {
        this.environment = "customEditor";
        aW.map = this.map;
      } else if (e.sharing) {
        this.environment = "sharing";
      } else if (e.preview) {
        this.environment = "preview";
      } else {
        this.environment = "jsapi";
      }
    },
    getStyleJson: function (kc, ke) {
      var kd = this;
      if (kc.styleJson) {
        if (ke) {
          ke(kc.styleJson);
        }
      } else if (kc.styleId) {
        var i = kc.styleId;
        var e = (Math.random() * 100000).toFixed(0);
        bx["_cbk_si_phpui" + e] = function (kg) {
          var kf = [];
          if (kg.result && kg.result.error === 0 && kg.content && kg.content.status === 0) {
            kf = kd.parseJson(kg.content.data.json);
            if (ke) {
              ke(kf);
            }
          } else if (ke) {
            ke("default");
          }
        };
        bx["_cbk_si_api" + e] = function (kg) {
          var kf = [];
          if (kg.status === 0) {
            if (kg.info) {
              kf = kd.parseJson(kg.info.json);
            } else {
              kf = kd.parseJson(kg.data.json);
            }
            if (ke) {
              ke(kf);
            }
          } else if (ke) {
            ke("default");
          }
        };
        var T = "";
        switch (this.environment) {
          case "jsapi":
            T = eu.apiHost + "/?qt=custom_map&v=3.0&style_id=" + i + "&type=publish&ak=" + eN;
            T += "&callback=" + fs + "._cbk_si_phpui" + e;
            break;
          case "sharing":
            T += "/apiconsole/custommap/getSharingJson";
            T += "?styleid=" + i + "&type=edit";
            T += "&ck=" + fs + "._cbk_si_api" + e;
            break;
          case "preview":
            T += "/apiconsole/custommap/getJson";
            T += "?styleid=" + i + "&type=edit";
            T += "&ck=" + fs + "._cbk_si_api" + e;
            break;
        }
        gM.load(T);
      } else if (ke) {
        ke("default");
      }
    },
    parseJson: function (T) {
      if (T === null || T === "") {
        return [];
      }
      var i = {
        t: "featureType",
        e: "elementType",
        v: "visibility",
        c: "color",
        o: "opacity",
        l: "lightness",
        s: "saturation",
        w: "weight",
        z: "level",
        h: "hue",
        f: "fontsize",
        zri: "curZoomRegionId",
        zr: "curZoomRegion"
      };
      var kd = {
        all: "all",
        g: "geometry",
        "g.f": "geometry.fill",
        "g.s": "geometry.stroke",
        l: "labels",
        "l.t.f": "labels.text.fill",
        "l.t.s": "labels.text.stroke",
        "l.t": "labels.text",
        "l.i": "labels.icon",
        "g.tf": "geometry.topfill",
        "g.sf": "geometry.sidefill"
      };
      var kc = T.split(",");
      var e = kc.map(function (kh) {
        var kg = kh.split("|").map(function (kn) {
          var kl = i[kn.split(":")[0]];
          var kk = kd[kn.split(":")[1]] ? kd[kn.split(":")[1]] : kn.split(":")[1];
          switch (kk) {
            case "poi":
              kk = "poilabel";
              break;
            case "districtlabel":
              kk = "districtlabel";
              break;
          }
          var km = {};
          km[kl] = kk;
          return km;
        });
        var ke = kg[0];
        var kj = 1;
        if (kg[1].elementType) {
          kj = 2;
          eX.extend(ke, kg[1]);
        }
        var ki = {};
        for (var kf = kj; kf < kg.length; kf++) {
          eX.extend(ki, kg[kf]);
        }
        return eX.extend(ke, {
          stylers: ki
        });
      });
      return e;
    },
    getStyleUrl: function (i, kf, kd, T, kc, kh) {
      this.styleJson = i;
      var e = B.apiHost + "/custom/v2/mapstyle?version=" + 4 + "&ak=" + kf + "&qt=custom_v2&is_all=true&is_new=1&";
      var kg = this.styleJson2styleStringV2(i, T, kh);
      e += "styles=" + encodeURIComponent(kg);
      if (kc && kc.os && kc.sv) {
        e += "&os=" + kc.os + "&sv=" + kc.sv;
      }
      var ke = new Date().getTime();
      e += "&timeStamp=" + ke;
      e += jm()(e);
      return e;
    },
    styleJson2styleStringV2: function (e, kk, kg) {
      var kl = {
        featureType: "t",
        elementType: "e",
        visibility: "v",
        color: "c",
        opacity: "o",
        lightness: "l",
        saturation: "s",
        weight: "w",
        level: "z",
        hue: "h",
        fontsize: "f"
      };
      var km = {
        all: "all",
        geometry: "g",
        "geometry.fill": "g.f",
        "geometry.stroke": "g.s",
        labels: "l",
        "labels.text.fill": "l.t.f",
        "labels.text.stroke": "l.t.s",
        "labels.text": "l.t",
        "labels.icon": "l.i",
        "geometry.topfill": "g.tf",
        "geometry.sidefill": "g.sf"
      };
      var kn = [];
      for (var kc = this.map.getMinZoom(); kc <= this.map.getMaxZoom(); kc++) {
        kg.zoomFrontStyle[kc] = {};
      }
      kg.zoomFrontStyle.main = {};
      var T = false;
      for (var kc = 0; !!e[kc]; kc++) {
        var kj = e[kc];
        if (this.isOnlyZoomStyler(kj)) {
          continue;
        }
        kk = this.getFrontZoom(kj, kk);
        if ((kj.featureType === "land" || kj.featureType === "all" || kj.featureType === "background") && typeof kj.elementType === "string" && (kj.elementType === "geometry" || kj.elementType === "geometry.fill" || kj.elementType === "all") && kj.stylers && !T) {
          if (kj.stylers.color) {
            kg.bmapLandColor = kj.stylers.color;
          }
          if (kj.stylers.opacity) {
            kg.bmapLandColor = kj.stylers.opacity;
          }
          if (kj.stylers.visibility && kj.stylers.visibility === "off") {
            kg.bmapLandColor = "#00000000";
          }
          if (kj.featureType === "land") {
            T = true;
          }
        }
        if (kj.featureType === "building" && typeof kj.elementType === "string" && kj.elementType === "geometry.fill") {
          kg.buildingFill = true;
        }
        if (kj.featureType === "roadarrow" && kj.elementType === "labels.icon" && kj.stylers) {
          var kh = kj.stylers.visibility;
          kg.zoomFrontStyle[kk].bmapRoadarrowVisibility = kh;
        }
        var kd = {};
        eX.extend(kd, kj);
        var kf = kd.stylers;
        delete kd.stylers;
        eX.extend(kd, kf);
        var ke = [];
        for (var ki in kl) {
          if (kd[ki]) {
            if (this.isEditorZoomKeys(ki)) {
              continue;
            }
            if (ki === "elementType") {
              ke.push(kl[ki] + ":" + km[kd[ki]]);
            } else {
              switch (kd[ki]) {
                case "poilabel":
                  kd[ki] = "poi";
                  break;
                case "districtlabel":
                  kd[ki] = "label";
                  break;
              }
              ke.push(kl[ki] + ":" + kd[ki]);
            }
          }
        }
        if (ke.length > 2) {
          kn.push(ke.join("|"));
        }
      }
      return kn.join(",");
    },
    getFrontZoom: function (i, e) {
      var T = i.stylers.level;
      if (T === undefined) {
        return "main";
      } else {
        return parseInt(T, 10);
      }
    },
    isZoomConfig: function (e) {
      var i = e.stylers.level;
      if (i === undefined) {
        return false;
      } else {
        return true;
      }
    },
    isOnlyZoomStyler: function (e) {
      var i = {};
      eX.extend(i, e.stylers);
      delete i.curZoomRegionId;
      delete i.curZoomRegion;
      delete i.level;
      if (eX.isEmptyObject(i)) {
        return true;
      } else {
        return false;
      }
    },
    isSelectZoom: function (i, e) {
      var T = i.stylers.level;
      if (T === undefined) {
        return true;
      } else if (T === e + "") {
        return true;
      } else {
        return false;
      }
    },
    isEditorZoomKeys: function (e) {
      var i = {
        curZoomRegionId: true,
        curZoomRegion: true
      };
      if (i[e]) {
        return true;
      } else {
        return false;
      }
    },
    getZoomRegion: function (e, i) {
      var kc = e.stylers.level;
      var T = {};
      eX.extend(T, i);
      if (kc === undefined) {
        return T;
      } else {
        T[parseInt(kc, 10)] = true;
        return T;
      }
    },
    onStyleDataBack: function (kd, e, i, kc, kf, T) {
      if (kd.status !== 0) {
        return;
      }
      if (kd.data.style.length === 3) {
        if (!T.baseFs) {
          T.baseFs = kd.data.style;
        }
        bx.StyleBody = kd.data.style[2];
      } else {
        bx.StyleBody = kd.data.style;
      }
      var ke = T.baseFs;
      bx["FeatureStyle" + i] = ke;
      this.updateFrontFeatureStyle(T);
    },
    updateFrontFeatureStyle: function (T) {
      if (T.zoomFrontStyle.main.bmapRoadarrowVisibility) {
        for (var e = this.map.getMinZoom(); e <= this.map.getMaxZoom(); e++) {
          if (!T.zoomFrontStyle[e].bmapRoadarrowVisibility) {
            T.zoomFrontStyle[e].bmapRoadarrowVisibility = T.zoomFrontStyle.main.bmapRoadarrowVisibility;
          }
        }
      }
    }
  };
  var aW = {
    map: null,
    labelCache: {},
    calcDrawMc: function (T, i, e) {
      var kc = [];
      switch (i) {
        case "fill":
          kc = this.calcFill(T, e);
          break;
        case "line":
          break;
        case "building3d":
          kc = this.calcBuilding3d(T, e);
          break;
      }
      return kc;
    },
    calcFill: function (kd, T) {
      var ke = [];
      for (var kc = 0; kc < kd.length; kc = kc + 5) {
        var e = this.coordToMc({
          x: kd[kc],
          y: kd[kc + 1]
        }, T.row, T.col, T.mercatorSize, T.baseTileSize);
        ke.push(e[0], e[1]);
      }
      return ke;
    },
    calcLine: function (kd, T) {
      var ke = [];
      var kf = new Int16Array(kd.buffer);
      for (var kc = 0; kc < kf.length; kc = kc + 10) {
        var e = this.coordToMc({
          x: kf[kc] / 10,
          y: kf[kc + 1] / 10
        }, T.row, T.col, T.mercatorSize, T.baseTileSize);
        ke.push(e[0], e[1]);
      }
      return ke;
    },
    calcBuilding3d: function (ke, T) {
      var kf = [];
      var kc = {};
      for (var kd = 0; kd < ke.length / 2; kd = kd + 7) {
        if (ke[kd] === ke[kd - 7] && ke[kd + 1] === ke[kd - 6]) {
          continue;
        }
        if (kc[ke[kd].toString() + ke[kd + 1].toString()]) {
          continue;
        }
        kc[ke[kd].toString() + ke[kd + 1].toString()] = true;
        var e = this.coordToMc({
          x: ke[kd],
          y: ke[kd + 1]
        }, T.row, T.col, T.mercatorSize, T.baseTileSize);
        kf.push(e[0], e[1]);
      }
      return kf;
    },
    coordToMc: function (kd, kc, e, i, T) {
      return [kd.x * (i / T) + e * i, kd.y * (i / T) + kc * i];
    },
    addDrawIntoAreaSpots: function (e, kd) {
      if (u.environment !== "customEditor") {
        return;
      }
      if (!kd.styleIds) {
        return;
      }
      for (var T = 0; T < kd.styleIds.length; T++) {
        var kg = 0;
        if (T > 0) {
          kg = kd.verticesLength[T - 1];
        }
        end = kd.verticesLength[T];
        var ke = [];
        var kc = "";
        if (kd.vertex) {
          ke = kd.vertex;
          kc = "building3d";
        } else if (kd.data[0]) {
          ke = kd.data[0];
          kc = kd.type;
        } else {
          continue;
        }
        var kf = this.calcDrawMc(ke.slice(kg, end), kc, e);
        this.map.addAreaSpot(kf, {
          userData: {
            styleId: kd.styleIds[T],
            type: "mapstyle"
          }
        });
      }
    },
    addLabelIntoAreaSpots: function (e) {
      if (u.environment !== "customEditor") {
        return;
      }
      for (var kd = 0; kd < e.length; kd++) {
        var ke = e[kd];
        for (var kc = 0; kc < ke.fixedLabel.length; kc++) {
          var T = ke.fixedLabel[kc];
          if (!T._mcBds) {
            continue;
          }
          var kf = [T._mcBds[0].lng, T._mcBds[0].lat, T._mcBds[0].lng, T._mcBds[1].lat, T._mcBds[1].lng, T._mcBds[1].lat, T._mcBds[1].lng, T._mcBds[0].lat];
          if (!this.labelCache[kf.join()]) {
            this.labelCache[kf.join()] = true;
            this.map.addAreaSpot(kf, {
              userData: {
                styleId: T.styleId,
                type: "mapstyle",
                name: T.name
              }
            });
          }
        }
      }
    }
  };
  function cl(i, e, kc, T) {
    this.cx = 3 * i;
    this.bx = 3 * (kc - i) - this.cx;
    this.ax = 1 - this.cx - this.bx;
    this.cy = 3 * e;
    this.by = 3 * (T - e) - this.cy;
    this.ay = 1 - this.cy - this.by;
    this.p1x = i;
    this.p1y = T;
    this.p2x = kc;
    this.p2y = T;
  }
  cl.prototype.sampleCurveX = function (e) {
    return ((this.ax * e + this.bx) * e + this.cx) * e;
  };
  cl.prototype.sampleCurveY = function (e) {
    return ((this.ay * e + this.by) * e + this.cy) * e;
  };
  cl.prototype.sampleCurveDerivativeX = function (e) {
    return (3 * this.ax * e + 2 * this.bx) * e + this.cx;
  };
  cl.prototype.solveCurveX = function (e, kh) {
    if (typeof kh === "undefined") {
      kh = 0.000001;
    }
    var kg;
    var kf;
    var kd;
    var T;
    var kc;
    for (kd = e, kc = 0; kc < 8; kc++) {
      T = this.sampleCurveX(kd) - e;
      if (Math.abs(T) < kh) {
        return kd;
      }
      var ke = this.sampleCurveDerivativeX(kd);
      if (Math.abs(ke) < 0.000001) {
        break;
      }
      kd = kd - T / ke;
    }
    kg = 0;
    kf = 1;
    kd = e;
    if (kd < kg) {
      return kg;
    }
    if (kd > kf) {
      return kf;
    }
    while (kg < kf) {
      T = this.sampleCurveX(kd);
      if (Math.abs(T - e) < kh) {
        return kd;
      }
      if (e > T) {
        kg = kd;
      } else {
        kf = kd;
      }
      kd = (kf - kg) * 0.5 + kg;
    }
    return kd;
  };
  cl.prototype.solve = function (e, i) {
    return this.sampleCurveY(this.solveCurveX(e, i));
  };
  var gA = {};
  function fy(T) {
    var e = {
      duration: 1000,
      fps: 30,
      delay: 0,
      transition: gA.linear,
      dropLastAnimation: false
    };
    if (T) {
      for (var kc in T) {
        e[kc] = T[kc];
      }
    }
    if (T.beginTime) {
      this._beginTime = T.beginTime;
    }
    this._callbacks = [];
    this._options = e;
    if (e.delay) {
      var kd = this;
      setTimeout(function () {
        kd._doStart();
      }, e.delay);
    } else {
      this._doStart();
    }
    this._pauseTime = 0;
  }
  fy.INFINITE = "INFINITE";
  fy.prototype._doStart = function () {
    if (this._isPausing) {
      var e = performance.now() || new Date().getTime();
      this._pauseTime += e - this._isPausing;
      this._isPausing = undefined;
    }
    if (window.requestAnimationFrame) {
      var i = this;
      i._timer = window.requestAnimationFrame(function (T) {
        i._loop(T);
      });
    } else {
      this._beginTime = new Date().getTime();
      if (this._options.duration === fy.INFINITE) {
        this._endTime = null;
      } else {
        this._endTime = this._beginTime + this._options.duration;
      }
      this._loop();
    }
  };
  fy.prototype._loop = function (kc) {
    var kf = this;
    kc = kc || new Date().getTime();
    kc = kc - this._pauseTime;
    if (!this._beginTime) {
      this._beginTime = kc;
    }
    if (!this._endTime && typeof this._options.duration === "number") {
      this._endTime = this._beginTime + this._options.duration;
    }
    if (kf._endTime !== null && kc >= kf._endTime) {
      if (kf._options.dropLastAnimation === false) {
        kf._options.render(kf._options.transition(1), 1, kc);
      }
      if (typeof kf._options.finish === "function") {
        kf._options.finish(kc, this);
      }
      for (var ke = 0, e = kf._callbacks.length; ke < e; ke++) {
        kf._callbacks[ke]();
      }
      return;
    }
    var kd;
    if (typeof kf._options.duration === "number") {
      kd = (kc - kf._beginTime) / kf._options.duration;
      kf.schedule = kf._options.transition(kd);
    } else {
      kd = kc - kf._beginTime;
      kf.schedule = 0;
    }
    kf._options.render(kf.schedule, kd, kc);
    if (!kf.terminative) {
      if (window.requestAnimationFrame) {
        kf._timer = requestAnimationFrame(function T(i) {
          kf._loop(i);
        });
      } else {
        kf._timer = setTimeout(function () {
          kf._loop();
        }, 1000 / kf._options.fps);
      }
    }
  };
  fy.prototype.stop = function (i, e) {
    this.terminative = true;
    if (this._timer) {
      if (window.cancelAnimationFrame) {
        cancelAnimationFrame(this._timer);
      } else {
        clearTimeout(this._timer);
      }
      this._timer = null;
      if (typeof this._options.onStop === "function") {
        this._options.onStop(e);
      }
    }
    if (i) {
      this._endTime = this._beginTime;
      this._loop();
    }
  };
  fy.prototype.pause = function () {
    if (!this._isPausing) {
      this.stop();
      this.terminative = undefined;
      this._isPausing = performance.now() || new Date().getTime();
    }
  };
  fy.prototype.cancel = function () {
    this.stop();
  };
  fy.prototype.append = function (e) {
    this._callbacks.push(e);
    return this;
  };
  gA = {
    _p1: 1,
    _p2: 1.525,
    linear: function (e) {
      return e;
    },
    reverse: function (e) {
      return 1 - e;
    },
    easeInQuad: function (e) {
      return e * e;
    },
    easeInCubic: function (e) {
      return Math.pow(e, 3);
    },
    easeInBiquad: function (e) {
      return Math.pow(e, 4);
    },
    easeInBack: function (e) {
      return e * e * ((gA._p1 + 1) * e - gA._p1);
    },
    easeOutQuad: function (e) {
      return -(e * (e - 2));
    },
    easeOutCubic: function (e) {
      return Math.pow(e - 1, 3) + 1;
    },
    easeOutBiquad: function (e) {
      return 1 - Math.pow(e - 1, 4);
    },
    easeOutBack: function (e) {
      return (e = e - 1) * e * ((gA._p1 + 1) * e + gA._p1) + 1;
    },
    easeInOutQuad: function (e) {
      if (e < 0.5) {
        return e * e * 2;
      } else {
        return -2 * (e - 2) * e - 1;
      }
    },
    easeInOutCubic: function (e) {
      if (e < 0.5) {
        return Math.pow(e, 3) * 4;
      } else {
        return Math.pow(e - 1, 3) * 4 + 1;
      }
    },
    easeInOutBiquad: function (e) {
      if (e < 0.5) {
        return Math.pow(e, 4) * 8;
      } else {
        return 1 - Math.pow(e - 1, 4) * 8;
      }
    },
    easeInOutSine: function (e) {
      return (1 - Math.cos(Math.PI * e)) / 2;
    }
  };
  gA.ease = function () {
    var e = new cl(0.4, 0, 0.6, 1);
    return function (i) {
      return e.solve(i);
    };
  }();
  gA["ease-in"] = gA.easeInQuad;
  gA["ease-out"] = gA.easeOutQuad;
  var dm = {
    start: function (ki) {
      var kc = ki.el;
      var e = ki.style;
      var i = ki.startValue;
      var kf = ki.endValue;
      var kd = ki.duration || 1400;
      var ke = ki.transition || gA.linear;
      var kh = ki.callback;
      var kg = kf - i;
      var T = ki.unit || "";
      return new fy({
        fps: 60,
        duration: kd,
        transition: ke,
        render: function (kj) {
          kc.style[e] = i + kg * kj + T;
        },
        finish: function () {
          if (kh) {
            kh();
          }
        }
      });
    }
  };
  function q(kd, T) {
    c8.call(this);
    this.keyframes = kd;
    var e = {
      duration: 1000,
      delay: 0,
      transition: gA.linear,
      interation: 1
    };
    if (T) {
      for (var kc in T) {
        e[kc] = T[kc];
      }
    }
    this._options = e;
  }
  q.inherits(c8, "ViewAnimation");
  q.prototype._start = function (ke) {
    var T = this;
    T.map = ke;
    var kd = new fJ("onanimationstart");
    T.dispatchEvent(kd);
    this._initStatus(T.map);
    var kc = this._options.duration;
    var i = this._options.interation;
    var kf = this._options.transition;
    var kg = 0;
    T.poiStatus = T.map._displayOptions.poi;
    if (T.poiStatus) {
      T.map.setDisplayOptions({
        poi: false
      });
    }
    T.map.viewAnimationTime = new Date().getTime();
    this.animation = new fy({
      duration: kc,
      transition: kf,
      start: function (e) {},
      render: function (kh, e) {
        if (kh === 0) {
          T._initStatus(T.map);
        } else {
          T._setViewByRate(kh);
        }
      },
      finish: function (ki, kh) {
        if (++kg < i || i === "INFINITE") {
          var kj = new fJ("onanimationiterations");
          T.dispatchEvent(kj);
          delete kh._beginTime;
          delete kh._endTime;
          kh._doStart();
        } else {
          var kj = new fJ("onanimationend");
          T.dispatchEvent(kj);
          delete T.map.viewAnimationTime;
          T.map.setDisplayOptions({
            poi: T.poiStatus
          });
        }
      }
    });
  };
  q.prototype._getTotalDuration = function (e, i) {
    if (e === fy.INFINITE) {
      return fy.INFINITE;
    } else {
      return e * i;
    }
  };
  q.prototype._initStatus = function (e) {
    if (this.keyframes[0]) {
      e.setCenter(this.keyframes[0].center, {
        noAnimation: true
      });
      e.setZoom(this.keyframes[0].zoom, {
        noAnimation: true
      });
      e.setTilt(this.keyframes[0].tilt, {
        noAnimation: true
      });
      e.setHeading(this.keyframes[0].heading, {
        noAnimation: true
      });
    }
  };
  q.prototype._setViewByRate = function (kc) {
    for (var e = 0; e < this.keyframes.length - 1; e++) {
      var kd = this.keyframes[e];
      var T = this.keyframes[e + 1];
      if (kc >= kd.percentage && kc < T.percentage) {
        this.map.setHeading(this._getHeadingDelta(kd, T, kc), {
          noAnimation: true
        });
        this.map.setTilt(this._getTiltDelta(kd, T, kc), {
          noAnimation: true
        });
        this.map.setCenter(this._getCenterDelta(kd, T, kc), {
          noAnimation: true
        });
        this.map.setZoom(this._getZoomDelta(kd, T, kc), {
          noAnimation: true
        });
      }
    }
  };
  q.prototype._getHeadingDelta = function (T, i, e) {
    var kd = (e - T.percentage) / (i.percentage - T.percentage);
    var kc = T.heading + (i.heading - T.heading) * kd;
    return kc;
  };
  q.prototype._getTiltDelta = function (T, i, e) {
    var kd = (e - T.percentage) / (i.percentage - T.percentage);
    var kc = T.tilt + (i.tilt - T.tilt) * kd;
    return kc;
  };
  q.prototype._getCenterDelta = function (T, i, e) {
    var kd = (e - T.percentage) / (i.percentage - T.percentage);
    var kc = T.center.add(i.center.sub(T.center).mult(kd));
    return kc;
  };
  q.prototype._getZoomDelta = function (kc, T, i) {
    var kd = (i - kc.percentage) / (T.percentage - kc.percentage);
    var e = kc.zoom + (T.zoom - kc.zoom) * kd;
    return e;
  };
  q.prototype._pause = function (e) {
    this.animation.pause();
  };
  q.prototype._continue = function (e) {
    this.animation._doStart();
  };
  q.prototype._cancel = function (T) {
    T.setDisplayOptions({
      poi: this.poiStatus
    });
    this.animation.cancel();
    delete T.viewAnimationTime;
    var i = new fJ("onanimationcancel");
    this.dispatchEvent(i);
  };
  var cI = undefined;
  var ft = {
    is64Bit: function () {
      if (/Windows/.test(navigator.userAgent)) {
        if (/Win64; x64/.test(navigator.userAgent)) {
          return true;
        } else if (/WOW64/.test(navigator.userAgent)) {
          return true;
        } else {
          return false;
        }
      }
      return true;
    },
    isIOS112: function a4(e) {
      return /11_2/.test(navigator.userAgent);
    },
    canUseWebAssembly: function (i) {
      if (cI !== undefined) {
        if (i) {
          i(cI);
        }
        return;
      }
      if (window.WebAssembly && this.is64Bit()) {
        if (window.disableWebAssembly === true) {
          cI = false;
          if (i) {
            i(cI);
          }
        } else if (!ct()) {
          cI = true;
          if (i) {
            i(cI);
          }
        } else if (this.isIOS112()) {
          cI = false;
          if (i) {
            i(cI);
          }
        } else {
          var e = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127, 3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 5, 131, 128, 128, 128, 0, 1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 145, 128, 128, 128, 0, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 109, 97, 105, 110, 0, 0, 10, 138, 128, 128, 128, 0, 1, 132, 128, 128, 128, 0, 0, 65, 42, 11]);
          WebAssembly.instantiate(e).then(function (T) {
            cI = true;
            if (i) {
              i(cI);
            }
          }, function (T) {
            cI = false;
            if (i) {
              i(cI);
            }
          });
        }
      } else {
        cI = false;
        if (i) {
          i(cI);
        }
      }
    }
  };
  var aI = {};
  bx.Utils = aI;
  function j3(e) {
    return e.style;
  }
  function h0(i) {
    if (eX.Browser.ie > 0) {
      i.unselectable = "on";
      i.selectstart = function () {
        return false;
      };
      i.onmousedown = function (T) {
        T.preventDefault();
        return false;
      };
    } else {
      var e = j3(i);
      e.MozUserSelect = "none";
      e.WebkitUserSelect = "none";
      i.addEventListener("mousedown", function (T) {
        T.preventDefault();
      }, false);
    }
  }
  function aS(e) {
    return e && e.parentNode && e.parentNode.nodeType !== 11;
  }
  function bJ(i, e) {
    i.insertAdjacentHTML("beforeEnd", e);
    return i.lastChild;
  }
  function fM(T, i) {
    var kc = document.createElement("div");
    kc.innerHTML = i;
    var e = kc.childNodes[0];
    return T.parentNode.insertBefore(e, T);
  }
  function ai(i) {
    i = i || window.event;
    if (i.stopPropagation) {
      i.stopPropagation();
    } else {
      i.cancelBubble = true;
    }
  }
  function c(i) {
    i = i || window.event;
    if (i.preventDefault) {
      i.preventDefault();
    } else {
      i.returnValue = false;
    }
    return false;
  }
  function ho(i) {
    ai(i);
    return c(i);
  }
  function gR() {
    var e = document.documentElement;
    var i = document.body;
    if (e && (e.scrollTop || e.scrollLeft)) {
      return [e.scrollTop, e.scrollLeft];
    } else if (i) {
      return [i.scrollTop, i.scrollLeft];
    } else {
      return [0, 0];
    }
  }
  function im(kd) {
    if (!kd) {
      return;
    }
    kd.onload = kd.onerror = null;
    var T = kd.attributes;
    var kc;
    var e;
    var ke;
    if (T) {
      e = T.length;
      for (kc = 0; kc < e; kc += 1) {
        ke = T[kc].name;
        if (typeof kd[ke] === "function") {
          kd[ke] = null;
        }
      }
    }
    T = kd.children;
    if (T) {
      e = T.length;
      for (kc = 0; kc < e; kc += 1) {
        im(kd.children[kc]);
      }
    }
  }
  function fP(i, kf, ke) {
    var kd = kf.lng - ke.lng;
    var kc = kf.lat - ke.lat;
    if (kd === 0) {
      return Math.abs(i.lng - kf.lng);
    }
    if (kc === 0) {
      return Math.abs(i.lat - kf.lat);
    }
    var T = kc / kd;
    var e = kf.lat - T * kf.lng;
    return Math.abs(T * i.lng - i.lat + e) / Math.sqrt(T * T + 1);
  }
  function ci(i, e) {
    if (!i || !e) {
      return;
    }
    return Math.round(Math.sqrt(Math.pow(i.x - e.x, 2) + Math.pow(i.y - e.y, 2)));
  }
  function es(i, e) {
    if (!i || !e) {
      return 0;
    }
    return Math.round(Math.sqrt(Math.pow(i.lng - e.lng, 2) + Math.pow(i.lat - e.lat, 2)));
  }
  function fI(kh, T, kd) {
    var ke = (kd.lng - T.lng) * (kh.lng - T.lng) + (kd.lat - T.lat) * (kh.lat - T.lat);
    if (ke <= 0) {
      return es(kh, T);
    }
    var e = (kd.lng - T.lng) * (kd.lng - T.lng) + (kd.lat - T.lat) * (kd.lat - T.lat);
    if (ke >= e) {
      return es(kh, kd);
    }
    var i = ke / e;
    var kg = T.lng + (kd.lng - T.lng) * i;
    var kf = T.lat + (kd.lat - T.lat) * i;
    const kc = {
      lng: kg,
      lat: kf
    };
    return es(kh, kc);
  }
  function fa(T, i) {
    var e = Math.round((T.x + i.x) / 2);
    var kc = Math.round((T.y + i.y) / 2);
    return new fi(e, kc);
  }
  function jk(e, T) {
    var i = [];
    T = T || function (kd) {
      return kd;
    };
    for (var kc in e) {
      i.push(kc + "=" + T(e[kc]));
    }
    return i.join("&");
  }
  function bX(T, i, ke) {
    var kf = document.createElement(T);
    if (ke) {
      kf = document.createElementNS(ke, T);
    }
    i = i || {};
    for (var kc in i) {
      var kd = {
        for: "htmlFor",
        class: "cssClass"
      }[kc] || kc;
      if (kc === "style") {
        kf.style.cssText = i[kc];
        continue;
      }
      if (kc === "class") {
        eX.ac(kf, i[kc]);
        continue;
      }
      if (kf.setAttribute) {
        kf.setAttribute(kd, i[kc]);
      } else {
        try {
          kf[kd] = i[kc];
        } catch (kf) {}
      }
    }
    return kf;
  }
  function ch(e) {
    if (e.currentStyle) {
      return e.currentStyle;
    } else if (e.ownerDocument && e.ownerDocument.defaultView) {
      return e.ownerDocument.defaultView.getComputedStyle(e, null);
    }
  }
  function bR(e) {
    return typeof e === "function";
  }
  function gc(e) {
    return e === undefined;
  }
  function jB(e, i) {
    return Object.prototype.hasOwnProperty.call(e, i);
  }
  function g(kd, ke) {
    if (gc(kd.length)) {
      for (var kc in kd) {
        if (jB(kd, kc)) {
          ke.call(null, kc, kd[kc]);
        }
      }
    } else {
      var T = kd.length;
      if (T) {
        for (var e = 0; e < T; e++) {
          ke.call(null, e, kd[e]);
        }
      }
    }
  }
  function aq(i, e) {
    if (!e) {
      return i;
    }
    g(e, function (T, kc) {
      i[T] = kc;
    });
    return i;
  }
  var g6 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  function dj(kd) {
    var T = "";
    var kk;
    var ki;
    var kg = "";
    var kj;
    var kh;
    var kf;
    var ke = "";
    var kc = 0;
    var e = /[^A-Za-z0-9+/=]/g;
    if (!kd || e.exec(kd)) {
      return kd;
    }
    kd = kd.replace(/[^A-Za-z0-9+/=]/g, "");
    do {
      kj = g6.indexOf(kd.charAt(kc++));
      kh = g6.indexOf(kd.charAt(kc++));
      kf = g6.indexOf(kd.charAt(kc++));
      ke = g6.indexOf(kd.charAt(kc++));
      kk = kj << 2 | kh >> 4;
      ki = (kh & 15) << 4 | kf >> 2;
      kg = (kf & 3) << 6 | ke;
      T = T + String.fromCharCode(kk);
      if (kf !== 64) {
        T = T + String.fromCharCode(ki);
      }
      if (ke !== 64) {
        T = T + String.fromCharCode(kg);
      }
      kk = ki = kg = "";
      kj = kh = kf = ke = "";
    } while (kc < kd.length);
    return T;
  }
  function ji(e) {
    return btoa(encodeURIComponent(e));
  }
  function fW(e) {
    return decodeURIComponent(atob(e));
  }
  (function (e) {
    if (!e.Utils) {
      e.Utils = {};
    }
    var i = e.Utils;
    i.format = function () {
      function T(kf, ke, kg) {
        var kd = kg[+ke];
        return typeof kd === "function" ? kd(ke) : kd;
      }
      function kc(kf, ke, kg) {
        var ki = ke;
        var kj = [];
        var kd = ke.split(":");
        if (kd.length === 2) {
          ki = kd[0];
          kj.push(kd[1]);
        }
        var kh = typeof kg[ki];
        if (kh === "function") {
          return kg[ki].apply(undefined, kj);
        } else if (kh === "undefined") {
          return kf;
        } else {
          return String(kg[ki]);
        }
      }
      return function (kd, ke) {
        var kg = ke.splice ? T : kc;
        var kf = kd.splice ? kd.join("") : kd;
        return kf.replace(/{([a-zA-Z0-9_$:.]+)}/g, function (ki, kh) {
          return kg(ki, kh, ke);
        });
      };
    }();
    i.ErrorMonitor = function (kc, T, kd) {};
    ft.canUseWebAssembly(function (T) {
      i.canUseWebAssembly = T;
    });
  })(bx);
  function bW() {
    return ct() || hS();
  }
  function ct() {
    var e = navigator.userAgent;
    if (e.indexOf("iPhone") > -1 || e.indexOf("iPad") > -1) {
      return true;
    }
    return false;
  }
  function hS() {
    var e = navigator.userAgent;
    if (e.indexOf("Android") > -1) {
      return true;
    }
    return false;
  }
  function iB(e) {
    return e * Math.PI / 180;
  }
  function e9(e) {
    return e / Math.PI * 180;
  }
  function bB(e, kd) {
    var kc = Math.pow(10, kd);
    if (typeof e === "number") {
      return Math.round(e * kc) / kc;
    }
    for (var T = 0; T < e.length; T++) {
      e[T] = bB(e[T], kd);
    }
    return e;
  }
  function cb(T, i, e) {
    if (T < i) {
      T = i;
    } else if (T > e) {
      T = e;
    }
    return T;
  }
  function ee(e, i) {
    while (e < 0) {
      e += i;
    }
    return e % i;
  }
  function hP(i, e) {
    return i >= 0 && e >= 0 || i < 0 && e < 0;
  }
  function L(i) {
    if (i._gl) {
      return i._gl;
    }
    var e = {
      alpha: true,
      antialias: false,
      failIfMajorPerformanceCaveat: false,
      preserveDrawingBuffer: false,
      stencil: false
    };
    var T = i.getContext("webgl", e) || i.getContext("experimental-webgl", e);
    i._gl = T;
    return T;
  }
  function iy(kc, T) {
    for (var e = 0; e < T.length; e++) {
      eX.on(kc, T[e], ai);
    }
  }
  function eR(i, T, e) {
    T[e] = i.getUniformLocation(T, e);
  }
  function bZ(kd, ke, e, T, i) {
    var kc = "";
    switch (i) {
      case "mat4":
        kd.uniformMatrix4fv(ke[e], false, T);
        return;
      case "v3":
        kc = "uniform3fv";
        break;
      case "f":
        kc = "uniform1f";
        break;
      case "i":
        kc = "uniform1i";
        break;
    }
    if (kc === "") {
      throw "error";
    }
    kd[kc](ke[e], T);
  }
  function hA(kk, e) {
    while (kk < 0) {
      kk += 360;
    }
    kk = kk % 360;
    var kc = e.width;
    var kj = e.height;
    var kf = kc;
    var T = kj;
    if (kk < 90) {
      var i = Math.sin(iB(kk)) * kc;
      var kh = Math.sin(iB(kk)) * kj;
      var ki = Math.cos(iB(kk)) * kc;
      var ke = Math.cos(iB(kk)) * kj;
      var kf = Math.ceil(ki + kh);
      var T = Math.ceil(i + ke);
    } else if (kk < 180) {
      var kk = kk - 90;
      var i = Math.sin(iB(kk)) * kc;
      var kh = Math.sin(iB(kk)) * kj;
      var ki = Math.cos(iB(kk)) * kc;
      var ke = Math.cos(iB(kk)) * kj;
      var kf = Math.ceil(i + ke);
      var T = Math.ceil(ki + kh);
    } else if (kk < 270) {
      var kk = kk - 180;
      var i = Math.sin(iB(kk)) * kc;
      var kh = Math.sin(iB(kk)) * kj;
      var ki = Math.cos(iB(kk)) * kc;
      var ke = Math.cos(iB(kk)) * kj;
      var kf = Math.ceil(ki + kh);
      var T = Math.ceil(i + ke);
    } else {
      var kk = kk - 270;
      var i = Math.sin(iB(kk)) * kc;
      var kh = Math.sin(iB(kk)) * kj;
      var ki = Math.cos(iB(kk)) * kc;
      var ke = Math.cos(iB(kk)) * kj;
      var kf = Math.ceil(i + ke);
      var T = Math.ceil(ki + kh);
    }
    var kg = kf - kc;
    var kd = T - kj;
    return [0 - kg / 2, 0 - kd / 2, kc + kg / 2, kj + kd / 2];
  }
  function ca(e) {
    if (e.toDataURL() === ca._blankData) {
      return true;
    }
    return false;
  }
  function V(kd, kc, T) {
    var i = [T.lng - kd.lng, T.lat - kd.lat];
    var e = [kc.lng - kd.lng, kc.lat - kd.lat];
    return i[0] * e[1] - i[1] * e[0];
  }
  function iX(ke, kd, T) {
    var e;
    var kf;
    var kc;
    var i;
    if (ke.lng < kd.lng) {
      e = ke.lng;
      kc = kd.lng;
    } else {
      e = kd.lng;
      kc = ke.lng;
    }
    if (ke.lat < kd.lat) {
      kf = ke.lat;
      i = kd.lat;
    } else {
      kf = kd.lat;
      i = ke.lat;
    }
    if (T.lng < e || T.lng > kc || T.lat < kf || T.lat > i) {
      return false;
    }
    return true;
  }
  function i8(kg, kf, ke, kc) {
    var kd = V(ke, kc, kg);
    var T = V(ke, kc, kf);
    var i = V(kg, kf, ke);
    var e = V(kg, kf, kc);
    if (kd * T < 0 && i * e < 0) {
      return true;
    } else if (kd === 0 && iX(ke, kc, kg)) {
      return true;
    } else if (T === 0 && iX(ke, kc, kf)) {
      return true;
    } else if (i === 0 && iX(kg, kf, ke)) {
      return true;
    } else if (e === 0 && iX(kg, kf, kc)) {
      return true;
    } else {
      return false;
    }
  }
  function hD(T, i) {
    var e = i.parentNode;
    if (e.lastChild === i) {
      e.appendChild(T);
    } else {
      e.insertBefore(T, i.nextSibling);
    }
  }
  function dR(ki, kj) {
    if (kj === 0) {
      return ki;
    }
    var kh = 0;
    var kf = 0;
    if (!ki) {
      throw "异常";
    }
    if (ki.length === 0) {
      return [];
    }
    for (var kd = 1, T = ki.length - 1; kd < T; kd++) {
      var kg = fP(ki[kd], ki[0], ki[ki.length - 1]);
      if (kg > kh) {
        kf = kd;
        kh = kg;
      }
    }
    var e = [];
    if (kh >= kj) {
      var kl = ki.slice(0, kf);
      var kk = ki.slice(kf, ki.length);
      var ke = dR(kl, kj);
      var kc = dR(kk, kj);
      for (var kd = 0, T = ke.length; kd < T; kd++) {
        e.push(ke[kd]);
      }
      for (var kd = 0, T = kc.length; kd < T; kd++) {
        e.push(kc[kd]);
      }
    } else {
      e.push(ki[0]);
      e.push(ki[ki.length - 1]);
    }
    return e;
  }
  function p(e) {
    if (Math.log2) {
      return Math.log2(e);
    }
    return Math.log(e) / Math.LN2;
  }
  function dc(T, i, e) {
    return Math.min(e, Math.max(i, T));
  }
  function ap(e, i) {
    if (!i) {
      return e;
    }
    var ke = i[0];
    var kd = i[1];
    var kc = i[2];
    var T = i[3];
    var kg = [];
    var kf = [];
    kg[0] = T * e[0] + kc * e[2];
    kg[1] = e[1];
    kg[2] = -kc * e[0] + T * e[2];
    kf[0] = kg[0];
    kf[1] = kd * kg[1] - ke * kg[2];
    kf[2] = ke * kg[1] + kd * kg[2];
    return kf;
  }
  var n = Math.PI / 180;
  var gL = 180 / Math.PI;
  function fv(T) {
    var i = (T - Date.UTC(2000, 0, 1, 12)) / 86400000 / 36525;
    var e = (d3.utcDay.floor(T) - T) / 86400000 * 360 - 180;
    return [e - fl(i) * gL, dW(i) * gL];
  }
  function fl(kc) {
    var kd = bo(kc);
    var i = d5(kc);
    var T = iw(kc);
    var ke = Math.tan(iv(kc) / 2);
    ke *= ke;
    return ke * Math.sin(2 * T) - 2 * kd * Math.sin(i) + 4 * kd * ke * Math.sin(i) * Math.cos(2 * T) - 0.5 * ke * ke * Math.sin(4 * T) - 1.25 * kd * kd * Math.sin(2 * i);
  }
  function dW(e) {
    return Math.asin(Math.sin(iv(e)) * Math.sin(bt(e)));
  }
  function bt(e) {
    return jX(e) - (0.00569 + 0.00478 * Math.sin((125.04 - 1934.136 * e) * n)) * n;
  }
  function jX(e) {
    return iw(e) + jd(e);
  }
  function d5(e) {
    return (357.52911 + e * (35999.05029 - 0.0001537 * e)) * n;
  }
  function iw(i) {
    var e = (280.46646 + i * (36000.76983 + i * 0.0003032)) % 360;
    return (e < 0 ? e + 360 : e) / 180 * Math.PI;
  }
  function jd(i) {
    var e = d5(i);
    return (Math.sin(e) * (1.914602 - i * (0.004817 + 0.000014 * i)) + Math.sin(e + e) * (0.019993 - 0.000101 * i) + Math.sin(e + e + e) * 0.000289) * n;
  }
  function iv(e) {
    return dt(e) + 0.00256 * Math.cos((125.04 - 1934.136 * e) * n) * n;
  }
  function dt(e) {
    return (23 + (26 + (21.448 - e * (46.815 + e * (0.00059 - e * 0.001813))) / 60) / 60) * n;
  }
  function bo(e) {
    return 0.016708634 - e * (0.000042037 + 1.267e-7 * e);
  }
  function gd() {
    return window.devicePixelRatio || 1;
  }
  function iI(T) {
    var i;
    var e;
    var kc;
    if (T >= 0) {
      kc = Math.floor(T / 65536) * 65536;
      i = kc;
      e = T - kc;
    } else {
      kc = Math.floor(-T / 65536) * 65536;
      i = -kc;
      e = T + kc;
    }
    return [i, e];
  }
  function cE(e) {
    if (e.lng >= 0 && e.lat >= 0) {
      return new cx(e.lng - 10000000, e.lat - 6000000);
    }
    if (e.lng >= 0 && e.lat < 0) {
      return new cx(e.lng - 10000000, e.lat + 6000000);
    }
    if (e.lng < 0 && e.lat >= 0) {
      return new cx(e.lng + 10000000, e.lat - 6000000);
    }
    if (e.lng < 0 && e.lat < 0) {
      return new cx(e.lng + 10000000, e.lat + 6000000);
    }
  }
  var ia = null;
  if (window.performance && window.performance.now) {
    ia = function () {
      return performance.now();
    };
  } else if (Date.now) {
    ia = function () {
      return Date.now();
    };
  } else {
    ia = function () {
      return new Date().getTime();
    };
  }
  function hO(kc, e, i) {
    var T = "mouseWheel";
    if (eX.Platform.macintosh) {
      if (!isNaN(kc) && (kc < 10 || kc !== 120) && e % 1 === 0 && e < 5) {
        T = "padScroll";
      }
      if (eX.Browser.firefox && e % 1 === 0 && e < 5 && i === 0) {
        T = "padScroll";
      }
    }
    if (eX.Browser.safari && kc === 12) {
      T = "mouseWheel";
    }
    return T;
  }
  function bK(kl, kg) {
    var kk = kl[0];
    var kj = kl[1];
    var kc = false;
    for (var kf = 0, ke = kg.length - 2; kf < kg.length; kf += 2) {
      var ki = kg[kf];
      var kd = kg[kf + 1];
      var kh = kg[ke];
      var T = kg[ke + 1];
      var e = kd > kj !== T > kj && kk < (kh - ki) * (kj - kd) / (T - kd) + ki;
      if (e) {
        kc = !kc;
      }
      ke = kf;
    }
    return kc;
  }
  function at(kd, kf) {
    var e = kf.length;
    var T = 0;
    var ke = false;
    for (var kc = 0; kc < e; kc++) {
      T = kc === e - 1 ? 0 : T + 1;
      if (kf[kc].lat !== kf[T].lat && (kd.lat >= kf[kc].lat && kd.lat < kf[T].lat || kd.lat >= kf[T].lat && kd.lat < kf[kc].lat) && kd.lng < (kf[T].lng - kf[kc].lng) * (kd.lat - kf[kc].lat) / (kf[T].lat - kf[kc].lat) + kf[kc].lng) {
        ke = !ke;
      }
    }
    return ke;
  }
  function dP(T, e, i, kc) {
    kc = kc || 0.4;
    if (T > i) {
      T = Math.pow(T - i + 1, kc) + i - 1;
    } else if (T < e) {
      T = e - Math.pow(e - T + 1, kc) + 1;
    }
    return T;
  }
  function eT(kg) {
    var ke = "";
    for (var T = 0; T < kg.length; T++) {
      var kh = kg.charCodeAt(T) << 1;
      var e = kh.toString(2);
      var kd = e.length;
      var kk = e;
      if (kd < 8) {
        kk = "00000000" + e;
        kk = kk.substr(e.length, 8);
      }
      ke += kk;
    }
    var ki = 5 - ke.length % 5;
    var kc = [];
    for (var T = 0; T < ki; T++) {
      kc[T] = "0";
    }
    ke = kc.join("") + ke;
    var kj = [];
    for (var T = 0; T < ke.length / 5; T++) {
      var kh = ke.substr(T * 5, 5);
      var kf = parseInt(kh, 2) + 50;
      kj.push(String.fromCharCode(kf));
    }
    return kj.join("") + ki.toString();
  }
  function jO(T, i) {
    var e = bx.TILE_VERSION || window.TILE_VERSION;
    if (!e || !e[T] || !e[T][i] || !e[T][i].version || !e[T][i].updateDate) {
      e = B.tvc;
    }
    return {
      ver: e[T][i].version,
      udt: e[T][i].updateDate
    };
  }
  function by() {
    var e = bx.MSV || window.MSV;
    if (!e || !e.mapstyle || !e.mapstyle.updateDate || !e.mapstyle.version) {
      e = B.msv;
    }
    return {
      ver: e.mapstyle.version,
      udt: e.mapstyle.updateDate
    };
  }
  function dy(e, kd) {
    var kc = e.slice(0);
    for (var T = 0; T < kc.length; T++) {
      kc[T] += kd;
    }
    return kc;
  }
  var g0 = null;
  function hg(e) {
    if (g0) {
      return;
    }
    e.fire(new fJ("onloadtile"));
    g0 = setTimeout(function () {
      g0 = null;
    }, 1000);
  }
  function aL() {
    if (D("//map.baidu.com") || D("//maps.baidu.com") || D("//ditu.baidu.com")) {
      return true;
    }
    return false;
  }
  aI.inMapHost = aL();
  if (typeof window._inMapHost === "boolean") {
    aI.inMapHost = window._inMapHost;
  }
  function D(i) {
    var T = window.location;
    var e = document.createElement("a");
    e.href = i;
    return e.hostname === T.hostname && e.port === T.port && e.protocol === T.protocol;
  }
  var dV = [72.685732, 0.193351, 136.10888, 54.392257];
  var eW = [72.6892532, 0.1939743381, 136.1168614, 54.392257];
  var t = [72.69566833, 0.1999420909, 136.1232863, 54.39791217];
  var ix = 158;
  var dl = [98.789081, 122.948721, 107.857301, 118.082148, 119.126627, 128.021934, 79.939914, 99.021873, 119.912937, 122.084572, 127.906381, 130.933385, 106.496057, 108.066113, 119.818772, 126.367919, 111.789929, 119.311401, 100.742164, 102.220151, 99.853589, 100.781289, 97.522631, 98.834615, 99.092638, 99.892947, 122.905967, 123.761867, 123.716213, 125.494726, 123.723977, 124.755034, 125.475833, 126.398284, 125.471687, 126.065118, 130.817003, 133.605851, 127.900156, 128.656536, 128.646633, 129.625389, 132.88057, 134.104549, 117.365548, 119.230813, 116.073074, 117.416898, 114.406274, 116.123791, 116.479038, 119.591534, 110.566812, 111.851324, 74.465162, 79.993155, 82.858046, 91.345214, 85.71485, 98.969834, 127.651377, 129.532029, 129.462275, 130.209769, 133.716214, 134.731053, 134.366834, 135.103133, 130.854579, 131.32966, 115.499125, 117.530421, 115.765224, 116.734157, 108.524336, 110.601747, 121.351282, 124.612037, 126.151954, 127.332751, 91.273562, 95.604179, 79.87318, 82.935667, 76.413314, 78.336484, 78.275229, 79.993668, 83.956612, 85.725267, 85.500637, 89.346601, 97.990127, 98.94176, 106.641956, 108.599215, 111.386259, 111.810312, 111.578597, 111.803167, 115.99273, 117.010413, 116.24461, 116.675246, 119.422198, 119.909078, 120.646056, 121.38098, 120.335038, 120.662183, 124.579855, 125.773243, 126.207803, 126.774849, 95.565331, 102.037736, 95.576121, 96.158028, 95.556699, 97.799055, 91.296205, 93.348146, 93.321994, 94.690522, 89.339313, 90.540241, 82.263039, 82.882528, 78.335615, 80.023512, 76.623947, 78.352608, 73.495149, 74.48155, 74.846872, 76.479412, 91.560058, 94.871116, 88.759515, 89.235995, 83.237883, 83.965264, 82.292123, 83.246813, 81.876477, 83.253307, 80.75212, 81.463265, 86.463409, 88.267232, 102.199623, 104.225963, 112.153727, 116.823265, 108.965663, 113.021145, 111.166575, 117.972799];
  var dk = [22.548416, 42.276971, 17.227969, 22.7346, 41.292761, 50.741667, 30.365133, 42.324913, 21.701924, 22.69335, 42.4176, 48.936335, 21.429059, 22.648399, 50.650499, 52.914825, 42.20449, 45.199078, 21.13391, 22.568612, 21.441033, 22.583349, 23.73862, 25.298628, 22.00409, 22.563095, 38.97849, 41.338631, 40.287973, 41.330108, 39.732801, 40.343252, 40.966852, 41.323446, 40.719312, 41.05937, 44.869472, 48.009884, 41.336325, 42.443362, 42.008104, 42.434713, 45.873151, 48.205746, 45.132322, 46.784582, 45.133383, 46.392803, 45.148771, 45.740273, 47.478161, 50.064393, 42.216229, 43.461282, 37.014302, 40.662281, 42.219985, 47.31417, 27.726965, 30.466651, 48.911271, 49.642488, 48.831706, 49.434487, 46.941762, 48.37425, 47.651781, 48.463782, 42.851964, 44.905396, 47.598273, 48.438467, 48.409141, 48.901651, 42.22756, 42.906402, 52.821047, 53.578094, 50.701837, 51.654278, 42.292419, 44.392214, 42.295918, 45.385017, 34.680866, 37.027803, 30.743515, 37.066586, 28.245649, 30.406053, 47.270872, 48.497371, 25.238932, 27.778469, 42.215754, 42.540416, 43.427677, 44.689208, 44.685587, 44.994131, 48.878657, 49.318659, 49.281099, 49.624515, 50.710468, 51.306809, 52.90717, 53.331981, 52.903016, 53.107959, 52.900867, 53.250033, 51.638073, 52.400678, 42.229657, 42.691928, 43.061242, 43.891083, 42.663095, 43.074222, 44.37174, 45.180155, 44.375135, 44.974219, 47.3035, 48.053221, 45.352401, 46.807875, 40.563053, 42.040289, 40.581871, 41.405172, 38.516328, 40.178756, 35.790476, 37.02337, 26.825605, 27.761303, 27.197399, 27.74932, 29.147561, 30.37813, 29.570893, 30.062042, 30.045026, 30.380952, 29.998038, 30.385203, 48.487385, 49.16832, 22.395733, 22.598229, 7.441114, 11.501436, 3.767491, 9.000793, 12.642067, 17.406563];
  var b7 = [98.795985, 122.960792, 107.867379, 118.093451, 119.139658, 128.035888, 79.948212, 99.029524, 119.923388, 122.094977, 127.918527, 130.94789, 106.50606, 108.076783, 119.8329, 126.382207, 111.803567, 119.324928, 100.749858, 102.227985, 99.860885, 100.788921, 97.529435, 98.841564, 99.100017, 99.90035, 122.917416, 123.774367, 123.728314, 125.507211, 123.736065, 124.767299, 125.488463, 126.410675, 125.484326, 126.07764, 130.830784, 133.620042, 127.912178, 128.668957, 128.658937, 129.638599, 132.894179, 134.119086, 117.379378, 119.244569, 116.086736, 117.431212, 114.420233, 116.137458, 116.492775, 119.605527, 110.579401, 111.86488, 74.468228, 80.001908, 82.867432, 91.353788, 85.721075, 98.976964, 127.664757, 129.546833, 129.476893, 130.22449, 133.730358, 134.745235, 134.381034, 135.1178, 130.868117, 131.34409, 115.513245, 117.544751, 115.779271, 116.748045, 108.536254, 110.614326, 121.365534, 124.626434, 126.165992, 127.347013, 91.281869, 95.611754, 79.879648, 82.945041, 76.413314, 78.345207, 78.275229, 80.002329, 83.956612, 85.734098, 85.510186, 89.356499, 97.997001, 98.948845, 106.653208, 108.610811, 111.400183, 111.824179, 111.592224, 111.817136, 116.00682, 117.024631, 116.258574, 116.689291, 119.436876, 119.922961, 120.659806, 121.395479, 120.349116, 120.676014, 124.59389, 125.787788, 126.221756, 126.788962, 95.572955, 102.046581, 95.583772, 96.165551, 95.564318, 97.806095, 91.30446, 93.356438, 93.330319, 94.698145, 89.349129, 90.548677, 82.268802, 82.892025, 78.335615, 80.032266, 76.625755, 78.361413, 73.498248, 74.490992, 74.846872, 76.488771, 91.563521, 94.878444, 88.768214, 89.244787, 83.247076, 83.974127, 82.29595, 83.256003, 81.885315, 83.26249, 80.760619, 81.472404, 86.470983, 88.276988, 102.207537, 104.234614, 112.164795, 116.833667, 108.965663, 113.032246, 111.166575, 117.983363];
  var b5 = [22.551183, 42.284787, 17.227969, 22.738314, 41.300981, 50.749638, 30.368087, 42.332701, 21.705055, 22.696452, 42.426047, 48.944674, 21.432184, 22.651387, 50.657409, 52.92296, 42.212192, 45.206905, 21.137031, 22.57186, 21.444502, 22.586566, 23.741571, 25.301472, 22.006806, 22.56637, 38.985114, 41.346531, 40.295617, 41.338581, 39.740021, 40.351012, 40.974644, 41.331562, 40.726852, 41.067192, 44.877158, 48.018285, 41.344597, 42.451798, 42.016305, 42.443235, 45.880906, 48.214001, 45.140027, 46.792775, 45.141083, 46.400433, 45.156418, 45.748281, 47.485889, 50.071879, 42.223667, 43.469487, 37.019867, 40.668675, 42.226823, 47.321605, 27.72944, 30.469853, 48.919002, 49.650614, 48.840188, 49.443166, 46.949801, 48.382798, 47.660603, 48.472692, 42.859946, 44.913298, 47.605896, 48.445914, 48.41698, 48.909667, 42.23507, 42.914193, 52.8281, 53.585952, 50.709311, 51.662219, 42.29968, 44.399225, 42.302746, 45.391958, 34.680866, 37.03377, 30.743515, 37.07228, 28.245649, 30.408935, 47.277693, 48.504255, 25.241528, 27.780726, 42.223363, 42.548418, 43.435888, 44.696952, 44.693193, 45.00187, 48.886267, 49.326755, 49.288642, 49.632304, 50.717486, 51.314369, 52.914204, 53.33964, 52.910094, 53.115926, 52.908382, 53.258095, 51.64533, 52.408305, 42.236825, 42.699126, 43.068466, 43.898632, 42.670403, 43.082219, 44.379045, 45.187742, 44.382336, 44.981379, 47.310362, 48.06019, 45.359099, 46.814439, 40.569751, 42.047741, 40.587956, 41.41263, 38.519192, 40.185033, 35.790476, 37.029005, 26.825605, 27.763896, 27.199658, 27.751649, 29.150192, 30.381073, 29.573886, 30.065162, 30.047775, 30.384089, 30.001277, 30.388525, 48.494118, 49.173841, 22.398528, 22.601198, 7.441114, 11.505968, 3.767491, 9.005209, 12.642067, 17.410886];
  var ad = 95;
  var c2 = [110.3961374, 105.0743788, 96.8991824, 95.61810411, 93.82412598, 91.3892353, 91.38931858, 89.08325955, 87.22469808, 86.26278402, 85.17353, 85.23741211, 82.86627441, 81.90481038, 79.59687147, 80.39829237, 79.93319363, 77.80279948, 75.2557704, 73.49357829, 73.1892532, 73.87758816, 74.4064738, 74.10215224, 75.46409695, 76.77739692, 78.28299615, 78.15499485, 78.37920654, 78.89145345, 79.69282199, 81.19938178, 81.80830295, 83.89093424, 85.94149523, 87.86447266, 89.03414958, 90.05918132, 91.10026937, 92.15733832, 93.74361735, 95.82597331, 97.95655545, 97.12363037, 98.2129739, 99.2068571, 101.6587874, 102.5239084, 102.2356106, 105.0249238, 106.0992342, 107.8617093, 111.6439372, 109.591869, 112.284586, 117.7961157, 118.9495128, 114.2076584, 118.693565, 123.1475225, 122.730705, 120.9361393, 123.4207441, 122.3787782, 122.1385425, 121.5904281, 121.1773763, 120.6805404, 120.2483355, 122.795807, 122.8759077, 121.3060262, 122.1392177, 123.7418799, 126.4177599, 128.5647409, 129.7194884, 131.2259136, 131.9950494, 133.6289931, 135.6168614, 131.3875545, 130.8743365, 128.6303223, 126.0997773, 124.4015375, 122.22161, 119.6586483, 119.7866827, 118.5685878, 116.5177976, 114.819101, 119.0812964, 116.453265, 111.7431171];
  var c0 = [43.2190351, 42.38053385, 43.17417589, 44.42226915, 45.09863634, 45.56708116, 47.33599718, 48.68832709, 49.62448486, 48.9482175, 48.4800472, 47.33564399, 47.43948676, 46.03452067, 45.20221788, 43.34563043, 42.32965739, 41.39690972, 40.82972331, 39.95567654, 39.25892877, 38.36098768, 38.05441569, 37.16878445, 36.38899414, 35.36126817, 34.30953451, 32.58503879, 31.56975694, 30.77800266, 30.43559814, 29.7744892, 30.0931977, 28.71103299, 27.70739665, 27.5775472, 27.01096137, 27.77857883, 27.50707954, 26.50328315, 26.70387804, 27.95548557, 27.29428901, 23.64685493, 23.62310601, 21.67493381, 20.77751465, 21.32070991, 22.1824113, 22.31232964, 22.51316054, 16.80037679, 13.19749864, 0.6939743381, 1.541660428, 10.50208252, 15.58926975, 17.89090007, 19.94928467, 22.18490153, 25.37285292, 25.61456434, 30.62532552, 31.08099284, 31.89238173, 32.50092692, 32.80325765, 34.25546956, 35.15486138, 36.90170139, 37.8348272, 37.941604, 38.6480797, 38.96797201, 40.98146918, 41.25573296, 42.07218153, 42.49132813, 44.65259766, 44.69330702, 48.62286865, 48.09383952, 49.19628499, 50.03402317, 53.27678901, 53.62976345, 53.89420546, 52.98933322, 52.01872884, 50.23210259, 50.18807048, 47.49769857, 47.34362712, 46.50502143, 45.24770128];
  var eE = [98.7895, 122.954182, 107.860913, 118.087007, 119.133165, 128.029533, 79.941749, 99.023087, 119.916883, 122.08841, 127.912143, 130.941471, 106.499502, 108.070244, 119.826245, 126.375818, 111.797006, 119.318387, 100.743285, 102.221517, 99.854448, 100.782445, 97.522928, 98.835028, 99.093518, 99.893783, 122.910927, 123.767769, 123.721954, 125.50077, 123.729657, 124.760724, 125.481902, 126.404079, 125.477737, 126.071019, 130.824331, 133.613395, 127.905767, 128.662524, 128.652527, 129.6321, 132.887552, 134.11249, 117.37297, 119.237999, 116.080154, 117.424589, 114.413586, 116.130948, 116.486264, 119.598927, 110.5728, 111.858437, 74.465162, 79.995337, 82.860821, 91.347291, 85.716024, 98.970481, 127.658331, 129.540202, 129.470528, 130.21808, 133.723748, 134.738785, 134.374555, 135.111443, 130.861475, 131.337438, 115.506627, 117.538123, 115.772783, 116.741632, 108.529656, 110.60782, 121.358945, 124.619773, 126.159424, 127.340582, 91.275275, 95.605228, 79.874427, 82.938601, 76.413314, 78.338763, 78.275229, 79.995765, 83.956612, 85.727511, 85.503554, 89.349858, 97.990418, 98.942257, 106.646704, 108.604437, 111.393667, 111.817723, 111.585811, 111.810645, 116.000232, 117.018216, 116.252108, 116.682705, 119.430384, 119.916417, 120.653168, 121.38883, 120.342727, 120.669383, 124.587426, 125.781376, 126.215282, 126.782323, 95.566367, 102.040026, 95.577158, 96.159009, 95.557772, 97.799728, 91.298032, 93.350057, 93.323794, 94.691771, 89.342471, 90.542019, 82.264229, 82.885485, 78.335615, 80.025844, 76.623947, 78.355027, 73.495149, 74.484473, 74.846872, 76.482208, 91.560117, 94.871859, 88.761692, 89.23822, 83.240549, 83.967602, 82.292367, 83.2495, 81.878825, 83.256003, 80.75421, 81.465955, 86.465421, 88.270356, 102.201019, 104.228033, 112.158282, 116.827153, 108.965663, 113.025767, 111.166575, 117.97687];
  var eD = [22.545421, 42.279053, 17.226272, 22.731982, 41.294917, 50.743316, 30.361986, 42.326603, 21.699185, 22.690751, 42.419757, 48.938435, 21.426505, 22.64567, 50.651745, 52.916705, 42.20641, 45.201064, 21.131326, 22.565685, 21.438288, 22.580379, 23.735785, 25.295582, 22.001087, 22.560315, 38.979333, 41.340757, 40.28938, 41.332289, 39.734164, 40.344718, 40.968803, 41.325813, 40.721073, 41.061503, 44.871533, 48.012179, 41.338366, 42.445601, 42.010343, 42.436934, 45.875217, 48.208327, 45.134237, 46.786509, 45.135376, 46.394665, 45.150734, 45.742257, 47.480099, 50.065931, 42.217982, 43.46329, 37.014057, 40.662848, 42.221079, 47.315558, 27.723432, 30.46385, 48.913298, 49.644555, 48.83396, 49.436824, 46.944059, 48.376613, 47.654503, 48.466331, 42.854333, 44.907682, 47.600253, 48.440245, 48.410926, 48.903468, 42.229292, 42.908294, 52.822466, 53.58012, 50.703491, 51.656037, 42.29378, 44.393379, 42.296912, 45.385809, 34.679282, 37.027699, 30.740622, 37.066377, 28.241967, 30.403134, 47.271949, 48.49848, 25.235818, 27.774976, 42.217425, 42.542102, 43.429763, 44.691016, 44.687044, 44.995758, 48.880431, 49.320551, 49.282865, 49.626267, 50.711607, 51.308382, 52.908547, 53.333963, 52.904419, 53.109706, 52.902338, 53.251938, 51.639701, 52.402205, 42.231045, 42.693581, 43.062756, 43.892771, 42.664519, 43.075927, 44.372942, 45.1815, 44.376327, 44.975476, 47.304623, 48.054453, 45.353174, 46.808493, 40.563653, 42.041556, 40.582164, 41.4064, 38.51618, 40.179105, 35.789745, 37.023144, 26.825402, 27.757641, 27.193806, 27.745766, 29.144229, 30.375186, 29.567889, 30.059102, 30.041938, 30.378006, 29.995047, 30.382338, 48.48834, 49.169021, 22.392816, 22.595333, 7.439914, 11.500161, 3.766676, 9.000793, 12.640512, 17.406563];
  var fH = 3000;
  var gQ = 0.00002;
  var gP = 0.000003;
  var iU = 0.0174532925194;
  var hG = 0.0065;
  var hF = 0.006;
  var dH = 40000;
  var fu = 0;
  var je = 1;
  var ay = 2;
  var h2 = 3;
  var fn = 4;
  var hk = 1e-10;
  var iD = 6370996.81;
  var fL = 100000000;
  function ht(T, kd, i, kc) {
    var e = arguments.length;
    this.ll = {};
    this.ru = {};
    if (e === 0) {} else if (e === 4) {
      this.normalize(T, kd, i, kc);
    }
  }
  ht.prototype.contains = function (e) {
    if (e.lng > this.ll.lng && e.lng < this.ru.lng && e.lat > this.ll.lat && e.lat < this.ru.lat) {
      return h2;
    }
    if (Math.abs(e.lng - this.ll.lng) < hk || Math.abs(e.lng - this.ru.lng) < hk || Math.abs(e.lat - this.ll.lat) < hk || Math.abs(e.y - this.ru.lat) > hk) {
      return ay;
    }
    return fu;
  };
  ht.prototype.normalize = function (i, kc, e, T) {
    if (i > e) {
      this.ll.lng = e;
      this.ru.lng = i;
    } else {
      this.ll.lng = i;
      this.ru.lng = e;
    }
    if (kc > T) {
      this.ll.lat = T;
      this.ru.lat = kc;
    } else {
      this.ll.lat = kc;
      this.ru.lat = T;
    }
  };
  function ev(i, kc, e, T) {
    this.sp = {
      lng: i,
      lat: kc
    };
    this.ep = {
      lng: e,
      lat: T
    };
    this.mbr = new ht(i, kc, e, T);
  }
  function ic(kc, e, ke, kd) {
    for (var T = 0; T < kd; T = T + 2) {
      if (kc.lng >= e[T] && kc.lng <= e[T + 1] && kc.lat >= ke[T] && kc.lat <= ke[T + 1]) {
        return true;
      }
    }
    return false;
  }
  function gj(kh) {
    var i = kh.lng;
    var kg = kh.lat;
    var kc = Math.sqrt(i * i + kg * kg);
    var ke = Math.atan2(kg, i);
    var T = kc + gu(kg);
    var kd = ke + gt(i);
    var e = T * Math.cos(kd);
    var kf = T * Math.sin(kd);
    return {
      lng: e + hG,
      lat: kf + hF
    };
  }
  function aZ(kh) {
    var i = kh.lng - hG;
    var kg = kh.lat - hF;
    var kc = Math.sqrt(i * i + kg * kg);
    var ke = Math.atan2(kg, i);
    var T = kc - gu(kg);
    var kd = ke - gt(i);
    var e = T * Math.cos(kd);
    var kf = T * Math.sin(kd);
    return {
      lng: e,
      lat: kf
    };
  }
  function gu(e) {
    return Math.sin(e * fH * iU) * gQ;
  }
  function gt(e) {
    return Math.cos(e * fH * iU) * gP;
  }
  function ar(T, i, e) {
    return (i.lng - T.lng) * (e.lat - T.lat) - (e.lng - T.lng) * (i.lat - T.lat);
  }
  function hL(i, e) {
    return Math.abs(i - e) <= hk;
  }
  function gB(kc, T) {
    var i = kc.lat * iU;
    var kh = kc.lng * iU;
    var e = T.lat * iU;
    var kg = T.lng * iU;
    var ke = Math.cos(i) * Math.cos(e);
    var kd = Math.cos(kh) * Math.cos(kg);
    var kj = Math.sin(i) * Math.sin(e);
    var ki = Math.sin(kh) * Math.sin(kg);
    var kk = ke * kd + ke * ki + kj;
    if (kk < -1) {
      kk = -1;
    } else if (kk > 1) {
      kk = 1;
    }
    var kf = Math.acos(kk) * iD;
    return kf;
  }
  function h(kg, kf) {
    var i = kg.lat * iU;
    var e = kf.lat * iU;
    var kc = kg.lng * iU;
    var T = kf.lng * iU;
    var ke = i - e;
    var kd = kc - T;
    var kh = Math.sin(ke / 2) * Math.sin(ke / 2) + Math.cos(i) * Math.cos(e) * Math.sin(kd / 2) * Math.sin(kd / 2);
    return 2 * Math.asin(Math.sqrt(kh)) * iD;
  }
  function gz(kh, T) {
    var kj = bz(kh, T);
    var ki = 180;
    var kg = 90;
    var kf = -180;
    var kd = -90;
    var ke = T.sp;
    var kc = T.ep;
    ki = ke.lng < kc.lng ? ke.lng : kc.lng;
    kg = ke.lat < kc.lat ? ke.lat : kc.lat;
    kf = ke.lng < kc.lng ? ke.lng : kc.lng;
    kd = ke.lat < kc.lat ? ke.lat : kc.lat;
    if (kj.lng <= kf && kj.lng >= ki && kj.lng <= kd && kj.lat >= kg) {
      return gB(kh, kj);
    } else {
      var i = h(kh, T.sp);
      var e = h(kh, T.ep);
      return i < e ? i : e;
    }
  }
  function a0(i, e) {}
  function bD(i, kc, e, T) {
    return Math.sqrt((i - e) * (i - e) + (kc - T) * (kc - T));
  }
  function bz(kn, kf) {
    var ke = kn.lng;
    var km = kn.lat;
    var kd = kf.sp.lng;
    var kl = kf.sp.lat;
    var T = kf.ep.lng;
    var kj = kf.ep.lat;
    var kk = kj - kl;
    var ki = kd - T;
    if (hL(kk, 0) && hL(ki, 0)) {
      return kf.sp;
    }
    var kh = T * kl - kd * kj;
    var kg = ki * ke - kk * km;
    var e = kk * kk - ki * ki;
    var kc = ki * kg - kk * kh;
    var i = kk * kg + ki * kh;
    return {
      lng: kc / e,
      lat: -i / e
    };
  }
  function bH(kc) {
    var T = 0;
    for (var e = 0; e < ad; ++e) {
      if (c0[e] <= kc.lat) {
        if (c0[(e + 1) % ad] > kc.lat) {
          if (ar({
            lng: c2[e],
            lat: c0[e]
          }, {
            lng: c2[(e + 1) % ad],
            lat: c0[(e + 1) % ad]
          }, kc) > 0) {
            ++T;
          }
        }
      } else if (c0[(e + 1) % ad] <= kc.lat) {
        if (ar({
          lng: c2[e],
          lat: c0[e]
        }, {
          lng: c2[(e + 1) % ad],
          lat: c0[(e + 1) % ad]
        }, kc) < 0) {
          --T;
        }
      }
    }
    return T === 0 ? fu : h2;
  }
  function jR(kc) {
    var kf = {};
    if (kc.lng < eW[0] - 0.4 || kc.lat < eW[1] - 0.4 || kc.lng > eW[2] + 0.4 || kc.lat > eW[3] + 0.4) {
      kf.lng = kc.lng;
      kf.lat = kc.lat;
      return kf;
    } else if (ic(kc, eE, eD, ix)) {
      kf = gj(kc);
      return kf;
    }
    var e = 0;
    var ki = dH;
    var T = 0;
    var kg = new ht();
    var kh = 1;
    if (bH(kc) === fu) {
      for (var ke = 0; ke < ad; ++ke) {
        var kd = new ev(c2[ke], c0[ke], c2[(ke + 1) % ad], c0[(ke + 1) % ad]);
        kg.ll.lng = kd.mbr.ll.lng - 0.5;
        kg.ll.lat = kd.mbr.ll.lat - 0.5;
        kg.ru.lng = kd.mbr.ru.lng + 0.5;
        kg.ru.lat = kd.mbr.ru.lat + 0.5;
        if (kg.contains(kc) === fu) {
          continue;
        }
        T = gz(kc, kd);
        if (T < ki) {
          ki = T;
        }
      }
      if (ki < dH) {
        e = (dH - ki) / dH;
        kh = 2;
      }
    } else {
      kh = 3;
      e = 1;
    }
    var kj = gj(kc);
    kf = {
      lng: kc.lng + (kj.lng - kc.lng) * e,
      lat: kc.lat + (kj.lat - kc.lat) * e
    };
    return kf;
  }
  function eY(i) {
    var T = {};
    if (i.lng < t[0] - 0.4 || i.lat < t[1] - 0.4 || i.lng > t[2] + 0.4 || i.lat > t[3] + 0.4) {
      T.lng = i.lng;
      T.lat = i.lat;
      return T;
    } else if (ic(i, b7, b5, ix)) {
      T = aZ(i);
      return T;
    }
    var e = jR(i);
    if (i.lng === e.lng && i.lat === e.lng) {
      T.lng = i.lng;
      T.lat = i.lat;
      return T;
    }
    return decryptPt1(i, jR);
  }
  function iu(i, e) {
    if (e === 3 && i instanceof cx) {
      var T = jR(i);
      return new cx(T.lng, T.lat);
    } else {
      return i;
    }
  }
  function eG(i, e) {
    if (e === 3 && i instanceof cx) {
      var T = eY(i);
      return new cx(T.lng, T.lat);
    } else if (e === 5 && i instanceof cx) {
      return new cx(i.lng, i.lat);
    } else {
      return i;
    }
  }
  function o(ke) {
    if (!ke) {
      ke = {};
    }
    var kf = JSON.stringify(ke);
    var kd = 0;
    var T;
    var kc;
    var e;
    if (kf.length === 0) {
      return kd;
    }
    for (T = 0, e = kf.length; T < e; T++) {
      kc = kf.charCodeAt(T);
      kd = (kd << 5) - kd + kc;
      kd |= 0;
    }
    return kd;
  }
  function c3() {
    var i = new Date().getTime();
    var e = "xxxyxxxy".replace(/[xy]/g, function (kc) {
      var T = (i + Math.random() * 16) % 16 | 0;
      i = Math.floor(i / 16);
      return (kc == "x" ? T : T & 3 | 8).toString(16);
    });
    return e;
  }
  var b0 = 0;
  function f2() {
    return b0++;
  }
  function jm() {
    var T = function (kw, kv) {
      var ku = {
        licae: "hax",
        dhaii: "aaae",
        dhmae: function (ky, kx) {
          return ky < kx;
        },
        dedxc: "lah",
        dhmem: "eeh",
        deaex: "all",
        mdaca: function (ky, kx) {
          return ky + kx;
        },
        mhdca: function (kx, ky) {
          return kx(ky);
        },
        ccdax: function (ky, kx) {
          return ky + kx;
        },
        ihahi: function (ky, kx) {
          return ky < kx;
        },
        aidex: function (kz, ky, kx) {
          return kz(ky, kx);
        }
      };
      var kr = "1.1.2";
      function kq(kD, kB) {
        var kx = ku.licae;
        while (kx !== ku.dhaii) {
          switch (kx) {
            case "all":
              for (var kC = 0; ku.dhmae(kC, kz); kC++) {
                var kA = kB(kD[kC]);
                ky.push(kA);
              }
              kx = "lah";
              break;
            case ku.dedxc:
              return ky;
            case "hax":
              var kz = kD.length;
              kx = ku.dhmem;
              break;
            case ku.dhmem:
              var ky = [];
              kx = ku.deaex;
              break;
          }
        }
      }
      var kt;
      var ks;
      var kp;
      var ko;
      var kn;
      var km = decodeURIComponent;
      var kl = "Char";
      var kk = "";
      var kj = [T];
      kt = "de";
      ks = "fr";
      kp = "o";
      kn = ku.ccdax(ks + kp, "m");
      ko = "Co" + kt;
      var ki = function (kx) {
        return ku.mdaca(kx, kk).constructor[kn + kl + ko](kx);
      };
      var kh = function (kx) {
        return kq(kx, function (ky) {
          return ki(ky);
        });
      };
      var kg = kh.call(ki, [39, 34, 37, 96, 60, 120, 97, 65, 98, 66, 99, 67, 100, 68, 101, 69, 102, 70, 103, 110, 109, 111, 112, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57]);
      var kf = kq([28782, 27702, 26416, 25167, 24183], function (kx) {
        return ku.mhdca(km, kx);
      });
      var ke = kh.call(kf, [22354, 22749, 24415, 23346, 22257, 22688, 24306, 25174, 23595, 25547, 22984, 25690, 22212, 27547, 21594, 27210, 23090, 29193, 22394, 29368, 29532, 29459, 29530, 24146, 24500, 26352, 27441, 28788, 29370, 27673, 26925, 25249, 24430]);
      var kd = {};
      kf = kh(kf);
      var kc = new RegExp(kf.join("|"));
      for (var kt = 0; ku.ihahi(kt, kg.length); kt++) {
        kd[ke[kt]] = kg[kt];
      }
      kv = ku.aidex(kq, kv.split(kk), function (kx) {
        return kd[kx] || kx;
      }).join(kk);
      return kq(kv.split(kc), function (kx) {
        return ku.mhdca(km, kx);
      });
    }(this, "囄墠呚呚扏su尫str氶姈hhl廲氶i犸囄呚墠O娲朰廲i呚姈廲氶姈hh呚廲幷獜h囄ih幷i囄獜囄廲灮廲廲囄廲呚灮l呚犸坺th朰hl廲灮獜廲h朰H幒扖彮P抡P椭Y氙扖揋QO幒氶l廲h幷呚姈姈氶呚hl囄墠扏廲囄姈墠獜");
    (function (ke, kd) {
      var kc = function (kf) {
        while (--kf) {
          ke.push(ke.shift());
        }
      };
      kc(++kd);
    })(T, 435);
    var i = function (ke, kd) {
      ke = ke - 0;
      var kc = T[ke];
      return kc;
    };
    function e(ki) {
      var kg = {
        ehldx: i("0x0"),
        adcxm: function (kk, kj) {
          return kk !== kj;
        },
        chhla: function (kk, kj) {
          return kk + kj;
        },
        aieca: i("0x1"),
        chhea: i("0x2"),
        mhdih: i("0x3"),
        idmda: function (kk, kj) {
          return kk(kj);
        },
        aadae: "dea",
        ideha: i("0x4")
      };
      var kd = kg[i("0x5")];
      while (kg[i("0x6")](kd, i("0x7"))) {
        switch (kd) {
          case "lah":
            var kc = ki[i("0x8")](kg[i("0x9")](ki[i("0xa")]("?"), 1));
            kd = kg[i("0xb")];
            break;
          case "dea":
            var kh = kg[i("0xc")];
            kd = kg[i("0xd")];
            break;
          case kg[i("0xb")]:
            var kf = kg[i("0xe")](md5, kg[i("0x9")](md5(kg[i("0x9")](kc, ke)), kh));
            kd = i("0x4");
            break;
          case i("0x0"):
            var ke = "F5L2O6R6AD8990O";
            kd = kg[i("0xf")];
            break;
          case kg.ideha:
            return kg[i("0x9")]("&sign=", kf.substring(kf[i("0x10")] - 12));
        }
      }
    }
    return e;
  }
  function g2() {}
  eX.extend(g2, {
    Request: {
      INITIAL: -1,
      WAITING: 0,
      LOADED: 1,
      COMPLETED: 2
    },
    Dependency: {
      poly: ["marker"],
      layer: ["poly"],
      hotspot: ["poly"],
      infowindow: ["marker", "hotspot"],
      simpleInfowindow: ["marker"],
      tools: ["marker", "poly"],
      mapgl: ["glcommon", "poly"],
      earth: ["glcommon"],
      control: ["scommon"],
      scommon: [],
      localSearch: ["scommon"],
      otherSearch: ["scommon"],
      route: ["scommon"],
      buslineSearch: ["route"],
      autocomplete: ["scommon"],
      mvtParse: ["marker", "poly", "style"]
    },
    MD5Mapping: {
      control: "1fi4dn",
      marker: "e2yhnz",
      poly: "u45asu",
      layer: "$layer$",
      infowindow: "fron0g",
      simpleInfowindow: "3jbbsv",
      hotspot: "zfm4u3",
      menu: "qjsx5u",
      tools: "ul5tr4",
      oppc: "pd12cd",
      oppcgl: "ate0ec",
      mapgl: "sb5z2l",
      markeranimation: "ikdoyh",
      earth: "ljberj",
      glcommon: "g1ho4x",
      localSearch: "e4rtef",
      scommon: "enagaz",
      otherSearch: "fzznhu",
      route: "vq5u1j",
      buslineSearch: "uffdot",
      autocomplete: "hy33sc",
      style: "fsgoei",
      mvtParse: "i0u1hv"
    },
    Config: {
      baseUrl: B.apiHost + "/getmodules?v=1.0&type=webgl",
      jsModPath: (aI.inMapHost ? "" : B.mapHost) + "/res/newui/",
      timeout: 5000
    },
    delayFlag: false,
    Module: {
      modules: {},
      modulesNeedToLoad: []
    },
    _getMd5ModsStr: function (ke) {
      var kd = [];
      for (var kg = 0, T = ke.length; kg < T; kg++) {
        var kf = ke[kg];
        var e = this.MD5Mapping[kf];
        var kc = "$" + kf + "$";
        if (e !== kc) {
          kd.push(kf + "_" + e);
        }
      }
      return kd.join(",");
    },
    load: function (i, ke, kc) {
      var e = this.getModuleInfo(i);
      if (e.status === this.Request.COMPLETED) {
        if (kc === true) {
          ke();
        }
      } else {
        if (e.status === this.Request.INITIAL) {
          this.combine(i);
          this.addToLoadQueue(i);
          var T = this;
          if (T.delayFlag === false) {
            T.delayFlag = true;
            setTimeout(function () {
              var kf = T.Config.baseUrl + "&mod=" + T._getMd5ModsStr(T.Module.modulesNeedToLoad);
              gM.load(kf);
              T.Module.modulesNeedToLoad.length = 0;
              T.delayFlag = false;
            }, 1);
          }
          e.status = this.Request.WAITING;
          function kd(kh) {
            var kg = T.getModuleInfo(i);
            if (kg.status !== T.Request.COMPLETED) {
              if (window.map) {
                var kf = new fJ("onmod_timeout");
                kf.timeout = kh / 1000;
                kf.moduleName = i;
                window.map.fire(kf);
              }
            }
          }
          setTimeout(kd, this.Config.timeout, this.Config.timeout);
          setTimeout(kd, this.Config.timeout * 2, this.Config.timeout * 2);
        }
        if (ke) {
          e.callbacks.push(ke);
        }
      }
    },
    combine: function (e) {
      if (e && this.Dependency[e]) {
        var kc = this.Dependency[e];
        for (var T = 0; T < kc.length; T++) {
          this.combine(kc[T]);
          if (!this.Module.modules[kc[T]]) {
            this.addToLoadQueue(kc[T]);
          }
        }
      }
    },
    addToLoadQueue: function (e) {
      var i = this.getModuleInfo(e);
      if (i.status === this.Request.INITIAL) {
        i.status = this.Request.WAITING;
        this.Module.modulesNeedToLoad.push(e);
      }
    },
    run: function (T, kc) {
      var kg = this.getModuleInfo(T);
      var kj = this.Dependency[T];
      if (kj) {
        for (var ke = 0; ke < kj.length; ke++) {
          var kf = this.getModuleInfo(kj[ke]);
          if (kf.status !== this.Request.COMPLETED) {
            kf.modsNeedToRun.push({
              name: T,
              code: kc
            });
            return;
          }
        }
      }
      try {
        eval(kc);
      } catch (kh) {
        return;
      }
      kg.status = this.Request.COMPLETED;
      for (var ke = 0, kd = kg.callbacks.length; ke < kd; ke++) {
        kg.callbacks[ke]();
      }
      kg.callbacks.length = 0;
      for (ke = 0; ke < kg.modsNeedToRun.length; ke++) {
        var ki = kg.modsNeedToRun[ke];
        this.run(ki.name, ki.code);
      }
      kg.modsNeedToRun.length = 0;
    },
    getModuleInfo: function (i) {
      var e;
      if (!this.Module.modules[i]) {
        this.Module.modules[i] = {
          status: this.Request.INITIAL,
          callbacks: [],
          modsNeedToRun: []
        };
      }
      e = this.Module.modules[i];
      return e;
    }
  });
  window._jsload = function (kd, ke) {
    var i = g2.getModuleInfo(kd);
    i.status = g2.Request.LOADED;
    if (ke !== "") {
      g2.run(kd, ke);
    } else {
      if (window.map) {
        var e = new fJ("ongetmodules_fail");
        e.moduleName = kd;
        window.map.fire(e);
      }
      var T = document.createElement("script");
      var kc = g2.MD5Mapping[kd];
      T.src = g2.Config.jsModPath + kd + "_" + kc + ".js";
      document.getElementsByTagName("head")[0].appendChild(T);
    }
  };
  function cY() {
    this._timeData = {};
  }
  var bv;
  if (typeof window !== "undefined") {
    bv = window;
  } else {
    bv = self;
  }
  cY.prototype.mark = function (e) {
    this._timeData[e] = this._getTime();
  };
  cY.prototype.getMark = function (e) {
    return this._timeData[e];
  };
  cY.prototype.getTime = function (i, e) {
    return parseFloat((this._timeData[e] - this._timeData[i]).toFixed(2));
  };
  cY.prototype.print = function () {};
  cY.prototype.clear = function () {
    this._timeData = {};
  };
  if (bv.performance && bv.performance.now) {
    cY.prototype._getTime = function () {
      return performance.now();
    };
  } else {
    cY.prototype._getTime = function () {
      return Date.now();
    };
  }
  !function (i, T) {
    T(i.d3 = i.d3 || {});
  }(window, function (kP) {
    function k7(le, lf, T, ld) {
      function e(i) {
        le(i = new Date(+i));
        return i;
      }
      e.floor = e;
      e.ceil = function (i) {
        le(i = new Date(i - 1));
        lf(i, 1);
        le(i);
        return i;
      };
      e.round = function (i) {
        var lg = e(i);
        var lh = e.ceil(i);
        return lh - i > i - lg ? lg : lh;
      };
      e.offset = function (i, lg) {
        lf(i = new Date(+i), lg == null ? 1 : Math.floor(lg));
        return i;
      };
      e.range = function (lh, i, lg) {
        var li = [];
        lh = e.ceil(lh);
        lg = lg == null ? 1 : Math.floor(lg);
        if (!(i > lh && lg > 0)) {
          return li;
        }
        do {
          li.push(new Date(+lh));
        } while ((lf(lh, lg), le(lh), i > lh));
        return li;
      };
      e.filter = function (i) {
        return k7(function (lg) {
          for (; le(lg), !i(lg);) {
            lg.setTime(lg - 1);
          }
        }, function (lg, lh) {
          for (; --lh >= 0;) {
            for (; lf(lg, 1), !i(lg);) {}
          }
        });
      };
      if (T) {
        e.count = function (i, lg) {
          kR.setTime(+i);
          kV.setTime(+lg);
          le(kR);
          le(kV);
          return Math.floor(T(kR, kV));
        };
        e.every = function (i) {
          i = Math.floor(i);
          return isFinite(i) && i > 0 ? i > 1 ? e.filter(ld ? function (lg) {
            return ld(lg) % i === 0;
          } : function (lg) {
            return e.count(0, lg) % i === 0;
          }) : e : null;
        };
      }
      return e;
    }
    function kW(e) {
      return k7(function (i) {
        i.setDate(i.getDate() - (i.getDay() + 7 - e) % 7);
        i.setHours(0, 0, 0, 0);
      }, function (i, T) {
        i.setDate(i.getDate() + 7 * T);
      }, function (i, T) {
        return (T - i - (T.getTimezoneOffset() - i.getTimezoneOffset()) * kQ) / k4;
      });
    }
    function kO(e) {
      return k7(function (i) {
        i.setUTCDate(i.getUTCDate() - (i.getUTCDay() + 7 - e) % 7);
        i.setUTCHours(0, 0, 0, 0);
      }, function (i, T) {
        i.setUTCDate(i.getUTCDate() + 7 * T);
      }, function (i, T) {
        return (T - i) / k4;
      });
    }
    var kR = new Date();
    var kV = new Date();
    var k2 = k7(function () {}, function (i, T) {
      i.setTime(+i + T);
    }, function (i, T) {
      return T - i;
    });
    k2.every = function (e) {
      e = Math.floor(e);
      return isFinite(e) && e > 0 ? e > 1 ? k7(function (i) {
        i.setTime(Math.floor(i / e) * e);
      }, function (i, T) {
        i.setTime(+i + T * e);
      }, function (i, T) {
        return (T - i) / e;
      }) : k2 : null;
    };
    var lb = k2.range;
    var k9 = 1000;
    var kQ = 60000;
    var k6 = 3600000;
    var kY = 86400000;
    var k4 = 604800000;
    var ki = k7(function (e) {
      e.setTime(Math.floor(e / k9) * k9);
    }, function (i, T) {
      i.setTime(+i + T * k9);
    }, function (i, T) {
      return (T - i) / k9;
    }, function (e) {
      return e.getUTCSeconds();
    });
    var k8 = ki.range;
    var kX = k7(function (e) {
      e.setTime(Math.floor(e / kQ) * kQ);
    }, function (i, T) {
      i.setTime(+i + T * kQ);
    }, function (i, T) {
      return (T - i) / kQ;
    }, function (e) {
      return e.getMinutes();
    });
    var kq = kX.range;
    var kK = k7(function (i) {
      var T = i.getTimezoneOffset() * kQ % k6;
      if (T < 0) {
        T += k6;
      }
      i.setTime(Math.floor((+i - T) / k6) * k6 + T);
    }, function (i, T) {
      i.setTime(+i + T * k6);
    }, function (i, T) {
      return (T - i) / k6;
    }, function (e) {
      return e.getHours();
    });
    var k3 = kK.range;
    var kA = k7(function (e) {
      e.setHours(0, 0, 0, 0);
    }, function (i, T) {
      i.setDate(i.getDate() + T);
    }, function (i, T) {
      return (T - i - (T.getTimezoneOffset() - i.getTimezoneOffset()) * kQ) / kY;
    }, function (e) {
      return e.getDate() - 1;
    });
    var kh = kA.range;
    var kx = kW(0);
    var kz = kW(1);
    var kd = kW(2);
    var kv = kW(3);
    var kk = kW(4);
    var kN = kW(5);
    var kU = kW(6);
    var kf = kx.range;
    var kM = kz.range;
    var ko = kd.range;
    var kJ = kv.range;
    var kZ = kk.range;
    var kL = kN.range;
    var la = kU.range;
    var k1 = k7(function (e) {
      e.setDate(1);
      e.setHours(0, 0, 0, 0);
    }, function (i, T) {
      i.setMonth(i.getMonth() + T);
    }, function (i, T) {
      return T.getMonth() - i.getMonth() + 12 * (T.getFullYear() - i.getFullYear());
    }, function (e) {
      return e.getMonth();
    });
    var lc = k1.range;
    var ku = k7(function (e) {
      e.setMonth(0, 1);
      e.setHours(0, 0, 0, 0);
    }, function (i, T) {
      i.setFullYear(i.getFullYear() + T);
    }, function (i, T) {
      return T.getFullYear() - i.getFullYear();
    }, function (e) {
      return e.getFullYear();
    });
    ku.every = function (e) {
      return isFinite(e = Math.floor(e)) && e > 0 ? k7(function (i) {
        i.setFullYear(Math.floor(i.getFullYear() / e) * e);
        i.setMonth(0, 1);
        i.setHours(0, 0, 0, 0);
      }, function (i, T) {
        i.setFullYear(i.getFullYear() + T * e);
      }) : null;
    };
    var kn = ku.range;
    var kS = k7(function (e) {
      e.setUTCSeconds(0, 0);
    }, function (i, T) {
      i.setTime(+i + T * kQ);
    }, function (i, T) {
      return (T - i) / kQ;
    }, function (e) {
      return e.getUTCMinutes();
    });
    var kC = kS.range;
    var kB = k7(function (e) {
      e.setUTCMinutes(0, 0, 0);
    }, function (i, T) {
      i.setTime(+i + T * k6);
    }, function (i, T) {
      return (T - i) / k6;
    }, function (e) {
      return e.getUTCHours();
    });
    var ky = kB.range;
    var kw = k7(function (e) {
      e.setUTCHours(0, 0, 0, 0);
    }, function (i, T) {
      i.setUTCDate(i.getUTCDate() + T);
    }, function (i, T) {
      return (T - i) / kY;
    }, function (e) {
      return e.getUTCDate() - 1;
    });
    var kt = kw.range;
    var ks = kO(0);
    var kr = kO(1);
    var kp = kO(2);
    var km = kO(3);
    var kl = kO(4);
    var kg = kO(5);
    var ke = kO(6);
    var kc = ks.range;
    var kI = kr.range;
    var k5 = kp.range;
    var kT = km.range;
    var k0 = kl.range;
    var kH = kg.range;
    var kG = ke.range;
    var kF = k7(function (e) {
      e.setUTCDate(1);
      e.setUTCHours(0, 0, 0, 0);
    }, function (i, T) {
      i.setUTCMonth(i.getUTCMonth() + T);
    }, function (i, T) {
      return T.getUTCMonth() - i.getUTCMonth() + 12 * (T.getUTCFullYear() - i.getUTCFullYear());
    }, function (e) {
      return e.getUTCMonth();
    });
    var kE = kF.range;
    var kj = k7(function (e) {
      e.setUTCMonth(0, 1);
      e.setUTCHours(0, 0, 0, 0);
    }, function (i, T) {
      i.setUTCFullYear(i.getUTCFullYear() + T);
    }, function (i, T) {
      return T.getUTCFullYear() - i.getUTCFullYear();
    }, function (e) {
      return e.getUTCFullYear();
    });
    kj.every = function (e) {
      return isFinite(e = Math.floor(e)) && e > 0 ? k7(function (i) {
        i.setUTCFullYear(Math.floor(i.getUTCFullYear() / e) * e);
        i.setUTCMonth(0, 1);
        i.setUTCHours(0, 0, 0, 0);
      }, function (i, T) {
        i.setUTCFullYear(i.getUTCFullYear() + T * e);
      }) : null;
    };
    var kD = kj.range;
    kP.timeInterval = k7;
    kP.timeMillisecond = k2;
    kP.timeMilliseconds = lb;
    kP.utcMillisecond = k2;
    kP.utcMilliseconds = lb;
    kP.timeSecond = ki;
    kP.timeSeconds = k8;
    kP.utcSecond = ki;
    kP.utcSeconds = k8;
    kP.timeMinute = kX;
    kP.timeMinutes = kq;
    kP.timeHour = kK;
    kP.timeHours = k3;
    kP.timeDay = kA;
    kP.timeDays = kh;
    kP.timeWeek = kx;
    kP.timeWeeks = kf;
    kP.timeSunday = kx;
    kP.timeSundays = kf;
    kP.timeMonday = kz;
    kP.timeMondays = kM;
    kP.timeTuesday = kd;
    kP.timeTuesdays = ko;
    kP.timeWednesday = kv;
    kP.timeWednesdays = kJ;
    kP.timeThursday = kk;
    kP.timeThursdays = kZ;
    kP.timeFriday = kN;
    kP.timeFridays = kL;
    kP.timeSaturday = kU;
    kP.timeSaturdays = la;
    kP.timeMonth = k1;
    kP.timeMonths = lc;
    kP.timeYear = ku;
    kP.timeYears = kn;
    kP.utcMinute = kS;
    kP.utcMinutes = kC;
    kP.utcHour = kB;
    kP.utcHours = ky;
    kP.utcDay = kw;
    kP.utcDays = kt;
    kP.utcWeek = ks;
    kP.utcWeeks = kc;
    kP.utcSunday = ks;
    kP.utcSundays = kc;
    kP.utcMonday = kr;
    kP.utcMondays = kI;
    kP.utcTuesday = kp;
    kP.utcTuesdays = k5;
    kP.utcWednesday = km;
    kP.utcWednesdays = kT;
    kP.utcThursday = kl;
    kP.utcThursdays = k0;
    kP.utcFriday = kg;
    kP.utcFridays = kH;
    kP.utcSaturday = ke;
    kP.utcSaturdays = kG;
    kP.utcMonth = kF;
    kP.utcMonths = kE;
    kP.utcYear = kj;
    kP.utcYears = kD;
    Object.defineProperty(kP, "__esModule", {
      value: true
    });
  });
  function e7(e) {
    this._elemType = e;
    this._objCollection = {};
  }
  e7.prototype.get = function () {
    var i = null;
    for (var e in this._objCollection) {
      if (this._objCollection[e] && this._objCollection[e]._free === true) {
        this._objCollection[e]._free = false;
        return this._objCollection[e];
      }
    }
    i = bX(this._elemType);
    e = bx.getGUID("obj_pool_");
    this._objCollection[e] = i;
    return i;
  };
  e7.prototype.free = function (e) {
    if (!e) {
      return;
    }
    e._free = true;
    if (e.tagName.toLowerCase() === "img") {
      e.src = "";
      e.crossOrigin = null;
      e.onload = e.onerror = null;
    }
  };
  e7.prototype.clear = function () {
    for (var e in this._objCollection) {
      if (this._objCollection[e] && this._objCollection[e].tagName.toLowerCase === "img") {
        this._objCollection[e].onload = this._objCollection[e].onerror = null;
      }
    }
    this._objCollection = {};
  };
  var h5 = {
    get: function (i, kd, e, T) {
      var kc = new XMLHttpRequest();
      kc.open("GET", i, true);
      kc.timeout = 10000;
      kc.ontimeout = function () {
        if (T) {
          T();
        }
      };
      kc.onreadystatechange = function (ke) {
        if (this.readyState === 4) {
          if (this.status === 200) {
            if (kd) {
              kd(kc.responseText);
            }
          } else if (e) {
            e();
          }
        }
      };
      kc.send();
    },
    post: function (i, ke, kd, e, T) {
      var kc = new XMLHttpRequest();
      kc.open("POST", i, true);
      kc.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
      kc.timeout = 10000;
      kc.ontimeout = function () {
        if (T) {
          T();
        }
      };
      kc.onreadystatechange = function (kf) {
        if (this.readyState === 4) {
          if (this.status === 200) {
            if (kd) {
              kd(kc.responseText, ke);
            }
          } else if (e) {
            e();
          }
        }
      };
      kc.send(ke);
      return kc;
    }
  };
  var gM = function (e) {
    function i(ke, T, kd) {
      if (ke.indexOf("v=") === -1) {
        ke += "&v=gl";
      }
      var kc = bX("script", {
        src: ke,
        type: "text/javascript",
        charset: "utf-8"
      });
      if (kc.addEventListener) {
        kc.addEventListener("load", function (kg) {
          var kf = kg.target;
          kf.parentNode.removeChild(kf);
          if (T) {
            T();
          }
        }, false);
        kc.addEventListener("error", function (kg) {
          if (kg) {
            var kf = kg.target;
            if (kf && kf.parentNode) {
              kf.parentNode.removeChild(kf);
            }
          }
          if (kd) {
            kd(null);
          }
        }, false);
      } else if (kc.attachEvent) {
        kc.attachEvent("onreadystatechange", function (kg) {
          var kf = window.event.srcElement;
          if (kf && (kf.readyState === "loaded" || kf.readyState === "complete")) {
            kf.parentNode.removeChild(kf);
          }
          if (T) {
            T();
          }
        });
      }
      e.getElementsByTagName("head")[0].appendChild(kc);
    }
    return {
      load: function (kf, T, kc) {
        if (typeof kf === "string") {
          i(kf, T, kc);
        } else if (kf.length > 0) {
          var ke = kf.length;
          for (var kd = 0; kd < ke; kd++) {
            i(kf[kd], function () {
              ke--;
              if (ke === 0 && T) {
                T();
              }
            });
          }
        }
      }
    };
  }(window.document);
  function hZ() {}
  hZ.instances = {};
  hZ.getInstance = function (i, T) {
    if (hZ.instances[i]) {
      return hZ.instances[i];
    }
    var e = new j7(i, T);
    hZ.instances[i] = e;
    return e;
  };
  function j7(e, i) {
    this._name = e;
    this._baseZoom = 18;
    this._opts = {
      tileSize: 256
    };
    eX.extend(this._opts, i || {});
  }
  j7.mapZoomBaseIndex = [8, 8, 8, 8, 7, 7, 6, 6, 5, 5, 4, 3, 3, 3, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0];
  j7.baseScaleZoom = [19, 17, 15, 12, 10, 9, 7, 5, 3];
  j7.baseScaleZoomMercatorSize = [512, 2048, 4096, 32768, 65536, 262144, 1048576, 4194304, 8388608];
  j7.mapZoomBaseZoomMapping = [3, 3, 3, 3, 5, 5, 7, 7, 9, 9, 10, 12, 12, 12, 15, 15, 17, 17, 19, 19, 19, 19, 19, 19, 19, 19];
  j7.mapZoomStartZoomMapping = [3, 3, 3, 3, 4, 4, 6, 6, 8, 8, 10, 11, 11, 11, 14, 14, 16, 16, 18, 18, 18, 18, 18, 18, 18, 18];
  j7.baseScaleTileSize = [1024, 1024, 512, 512, 256, 512, 512, 512, 256];
  j7.mapZoomTileSize = [256, 256, 256, 256, 256, 512, 256, 512, 256, 512, 256, 256, 512, 1024, 256, 512, 512, 1024, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536];
  j7.baseZoomInfo = {
    "3": [3],
    "5": [4, 5],
    "7": [6, 7],
    "9": [8, 9],
    "10": [10],
    "12": [11, 12, 13],
    "15": [14, 15],
    "17": [16, 17],
    "19": [18, 19, 20, 21, 22, 23, 24, 25]
  };
  j7.prototype = {
    getName: function () {
      return this._name;
    },
    getTileSize: function (e) {
      e = Math.floor(e);
      if (e < 3) {
        e = 3;
      }
      if (this._name === "na") {
        return j7.mapZoomTileSize[e];
      }
      return this._opts.tileSize;
    },
    getBaseTileSize: function (i) {
      i = Math.floor(i);
      if (this._name === "na") {
        var e = j7.mapZoomBaseZoomMapping[i];
        return j7.mapZoomTileSize[e];
      }
      return this._opts.tileSize;
    },
    getDataZoom: function (e) {
      e = Math.floor(e);
      if (this._name === "na") {
        return j7.mapZoomBaseZoomMapping[e];
      }
      return e;
    },
    getZoomUnits: function (e) {
      return Math.pow(2, this._baseZoom - e);
    },
    getMercatorSize: function (T, i) {
      if (this._name === "na") {
        T = Math.floor(T);
        var e = j7.mapZoomBaseIndex[T];
        return j7.baseScaleZoomMercatorSize[e];
      }
      return this._opts.tileSize * this.getZoomUnits(i);
    },
    getBaseZoom: function () {
      return this._baseZoom;
    },
    getParentTile: function (kc, ki, kh, T, i) {
      if (this._name === "na") {
        var kd = j7.baseZoomInfo[kh];
        T--;
        if (kd.indexOf(T) > -1) {
          return {
            col: kc,
            row: ki,
            zoom: kh,
            useZoom: T
          };
        } else {
          var kf = j7.mapZoomBaseIndex[kh];
          var ke = j7.baseScaleZoom[kf + 1];
          if (!ke) {
            return null;
          }
          var kg = this.getFactorByZooms(ke, kh);
          var e = j7.baseZoomInfo[ke];
          return {
            col: Math.floor(kc / kg),
            row: Math.floor(ki / kg),
            zoom: ke,
            useZoom: e[e.length - 1]
          };
        }
        return null;
      }
      if (kh - 1 < i) {
        return null;
      }
      return {
        col: Math.floor(kc / 2),
        row: Math.floor(ki / 2),
        zoom: kh - 1,
        useZoom: kh - 1
      };
    },
    getChildTiles: function (kd, kf, e, T, km, ks) {
      if (this._name === "na") {
        var kc = j7.baseZoomInfo[e];
        T += ks;
        if (kc.indexOf(T) > -1) {
          return [{
            col: kd,
            row: kf,
            zoom: e,
            useZoom: T
          }];
        } else {
          var kq = 0;
          var kn = e;
          while (kq < ks) {
            var kr = j7.mapZoomBaseIndex[kn];
            var kh = j7.baseScaleZoom[kr - 1];
            if (!kh) {
              return null;
            }
            var ki = j7.baseZoomInfo[kh];
            if (ki[ks - 1]) {
              var kj = [];
              var kl = this.getFactorByZooms(e, kh);
              var i = kd * kl;
              var kk = kf * kl;
              for (var kp = 0; kp < kl; kp++) {
                var ke = i + kp;
                for (var ko = 0; ko < kl; ko++) {
                  var kg = kk + ko;
                  kj.push({
                    col: ke,
                    row: kg,
                    zoom: kh,
                    useZoom: ki[ks - 1]
                  });
                }
              }
              return kj;
            }
            kq += ki.length;
            if (ks === ki.length) {
              kn = kh;
            }
          }
        }
        return null;
      }
      var kj = [];
      if (e + ks > km) {
        return null;
      }
      var kl = Math.pow(2, ks);
      var i = kd * kl;
      var kk = kf * kl;
      var kh = e + ks;
      var kj = [];
      for (var kp = 0; kp < 2; kp++) {
        var ke = i + kp;
        for (var ko = 0; ko < 2; ko++) {
          var kg = kk + ko;
          kj.push({
            col: ke,
            row: kg,
            zoom: kh,
            useZoom: kh
          });
        }
      }
      return kj;
    },
    getFactorByZooms: function (i, kc) {
      var T = j7.mapZoomBaseIndex[i];
      var kd = j7.mapZoomBaseIndex[kc];
      var e = j7.baseScaleZoomMercatorSize[T];
      var ke = j7.baseScaleZoomMercatorSize[kd];
      return e / ke;
    }
  };
  var c6 = {};
  var aa = ["swiftshader", "microsoft basic render driver"];
  var hn = ["intel", "nvidia", "amd", "apple", "geforce"];
  function gD(e) {
    e = e.toLowerCase();
    if (aa.indexOf(e) >= 0) {
      return true;
    }
    if (e.indexOf("mobile") >= 0) {
      return true;
    }
    return false;
  }
  function cz(T) {
    T = T.toLowerCase();
    for (var e = 0; e < hn.length; e++) {
      if (T.indexOf(hn[e]) >= 0) {
        return true;
      }
    }
    return false;
  }
  function j5(e) {
    if (!e) {
      return false;
    }
    if (gD(e)) {
      return false;
    }
    if (cz(e)) {
      return true;
    }
    return false;
  }
  c6.ifEnableEarth = function (i) {
    var e = c6.ifEnableEarth;
    if (!i && typeof e._enable === "boolean") {
      return e._enable;
    }
    if (c6.ifSupportWebGL()) {
      e._enable = true;
      return true;
    }
    e._enable = false;
    return false;
  };
  c6.ifEnableWebGLMap = function (i) {
    var e = c6.ifEnableWebGLMap;
    if (!i && typeof e._enable === "boolean") {
      return e._enable;
    }
    if (c6.ifSupportWebGL()) {
      if (aI.inMapHost) {
        e._enable = true;
        return true;
      } else if (window.Blob || window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder) {
        e._enable = true;
        return true;
      } else {
        e._enable = false;
        return false;
      }
    }
    e._enable = false;
    return false;
  };
  c6.params = {};
  c6.ifSupportWebGL = function () {
    var i = c6.ifSupportWebGL;
    if (typeof i._supportWebGL === "boolean") {
      return i._supportWebGL;
    }
    if (!window.WebGLRenderingContext) {
      i._supportWebGL = false;
      return false;
    }
    var T = document.createElement("canvas");
    T.width = 300;
    T.height = 150;
    var kd = null;
    var kj = {
      alpha: true,
      antialias: false,
      failIfMajorPerformanceCaveat: false,
      preserveDrawingBuffer: false,
      stencil: false
    };
    try {
      kd = T.getContext("webgl", kj) || T.getContext("experimental-webgl", kj);
    } catch (kf) {
      i._supportWebGL = false;
    }
    if (kd === null) {
      i._supportWebGL = false;
    } else {
      i._supportWebGL = true;
      var kh = kd.getExtension("WEBGL_debug_renderer_info");
      var kg = "";
      if (kh) {
        kg = kd.getParameter(kh.UNMASKED_RENDERER_WEBGL);
        if (j5(kg) === true) {
          i._supportWebGL = true;
        }
        var ki = kd.getParameter(kh.UNMASKED_VENDOR_WEBGL);
        i._renderer = kg;
        i._vendor = ki;
      }
      if (!kh && eX.Browser.firefox) {
        i._supportWebGL = true;
      }
      if (!kh && eX.Platform.macintosh) {
        i._supportWebGL = true;
      }
      if (kd.drawingBufferWidth !== T.width || kd.drawingBufferHeight !== T.height) {
        i._supportWebGL = false;
      }
      if (kd.getParameter(kd.MAX_VERTEX_TEXTURE_IMAGE_UNITS) < 4) {
        i._supportWebGL = false;
      }
      var kc = kd.getParameter(kd.MAX_TEXTURE_SIZE);
      c6.params.maxTextureSize = kc;
      if (kc < 4096) {
        i._supportWebGL = false;
      }
      var ke = kd.getParameter(kd.MAX_TEXTURE_IMAGE_UNITS);
      if (ke < 8) {
        i._supportWebGL = false;
      }
      if (!kd.getShaderPrecisionFormat || kd.getShaderPrecisionFormat(kd.FRAGMENT_SHADER, kd.HIGH_FLOAT).precision < 23) {
        i._supportWebGL = false;
      }
    }
    return i._supportWebGL;
  };
  c6.ifSupportCanvas2d = function () {
    var kd = c6.ifSupportCanvas2d;
    if (typeof kd.supportCanvas2d === "boolean") {
      return kd.supportCanvas2d;
    }
    var T = document.createElement("canvas");
    var i = null;
    try {
      i = T.getContext("2d");
    } catch (kc) {
      kd.supportCanvas2d = false;
    }
    if (i === null) {
      kd.supportCanvas2d = false;
    } else {
      kd.supportCanvas2d = true;
    }
    return kd.supportCanvas2d;
  };
  c6.ifCanvas2dInBlackList = function () {
    return true;
  };
  c6.ifEnableCanvas2dMap = function () {
    return false;
    var i = navigator.userAgent;
    var e = 0;
    var kc = 0;
    var kd = 0;
    if (/macintosh/ig.test(i)) {
      var T = 0;
      if (/(\d+\.\d)?(?:\.\d)?\s+safari\/?(\d+\.\d+)?/i.test(i) && !/chrome/i.test(i)) {
        T = parseInt(RegExp.$1 || RegExp.$2, 10);
      }
      if (T > 0) {
        return false;
      }
      return true;
    }
    if (/windows nt (\d+\.\d)/ig.test(i)) {
      kc = parseFloat(RegExp.$1);
      if (kc >= 6.1) {
        if (/chrome\/(\d+\.\d)/i.test(i)) {
          e = parseFloat(RegExp.$1);
          if (e >= 31) {
            return true;
          }
        }
        if (/MSIE (\d+(\.\d+)?)/.test(i)) {
          kd = parseFloat(RegExp.$1);
          if (kd >= 10) {
            return true;
          }
        }
        if (/Firefox/.test(i)) {
          return true;
        }
        if (/rv:11.0/ig.test(i)) {
          return true;
        }
        if (/edge/ig.test(i)) {
          return true;
        }
      }
    }
    return false;
  };
  c6.ifSupportCSS3 = function (kg, i) {
    var kf = document.createElement("div");
    var ke = "Webkit Moz O ms".split(" ");
    var e = ke.length;
    var T = "";
    var kc = kf.style;
    if (kg in kc) {
      T = kg;
    }
    kg = kg.replace(/^[a-z]/, function (kh) {
      return kh.toUpperCase();
    });
    while (e--) {
      var kd = ke[e] + kg;
      if (kd in kc) {
        T = kd;
        break;
      }
    }
    if (i) {
      return T;
    } else {
      return T.length > 0 ? true : false;
    }
  };
  c6.isModernBrowser = c6.ifSupportCanvas2d() && c6.ifSupportCSS3("transform");
  function az(i, e) {
    this._size = i;
    this._curSize = 0;
    this._cache = {};
    this._least = null;
    this._most = null;
    this._options = {
      clearCallback: null,
      removeOldCallback: null
    };
    e = e || {};
    for (var T in e) {
      this._options[T] = e[T];
    }
    this._getDataTimes = 0;
    this._hitTimes = 0;
  }
  az.prototype.setData = function (kc, ke) {
    var i = this._cache;
    var T = this._size;
    if (T === 0) {
      return;
    }
    var e = this._curSize;
    if (e === T) {
      this._removeOld();
    }
    var kd;
    if (!i[kc]) {
      kd = {
        key: kc,
        data: ke,
        older: null,
        newwer: null
      };
      i[kc] = kd;
      if (this._least === null) {
        this._least = kd;
      }
      if (this._most === null) {
        this._most = kd;
      }
      this._curSize++;
    } else {
      kd = i[kc];
      kd.data = ke;
      if (this._most === kd) {
        return;
      }
      if (kd.older) {
        kd.older.newer = kd.newer;
      }
      if (kd.newer) {
        kd.newer.older = kd.older;
      }
      if (this._least === kd) {
        this._least = kd.newer;
      }
    }
    if (this._most && this._most !== kd) {
      this._most.newer = kd;
      kd.older = this._most;
      this._most = kd;
      kd.newer = null;
    }
  };
  az.prototype.getData = function (e) {
    var i = this._cache[e];
    this._getDataTimes++;
    if (i) {
      this._hitTimes++;
      var T = i.data;
      if (this._most === i) {
        return T;
      }
      if (i.older) {
        i.older.newer = i.newer;
      }
      if (i.newer) {
        i.newer.older = i.older;
      }
      if (this._least === i) {
        this._least = i.newer;
      }
      this._most.newer = i;
      i.older = this._most;
      i.newer = null;
      this._most = i;
      return T;
    }
    return null;
  };
  az.prototype.getAllData = function () {
    return this._cache;
  };
  az.prototype.getHitRate = function () {
    return this._hitTimes / this._getDataTimes;
  };
  az.prototype.removeData = function (i) {
    var e = this._cache;
    var T = e[i];
    if (!T) {
      return;
    }
    if (this._options.clearCallback) {
      this._options.clearCallback(T.data, T.key);
    }
    if (T.older) {
      T.older.newer = T.newer;
    }
    if (T.newer) {
      T.newer.older = T.older;
    }
    if (this._least === T) {
      this._least = T.newer;
    }
    if (this._most === T) {
      this._most = T.older;
    }
    delete e[i];
    this._curSize--;
  };
  az.prototype._removeOld = function () {
    var e = this._cache;
    var kc = Math.round(this._size * 0.6);
    var T = 0;
    while (this._least && T < kc) {
      var i = this._least;
      this._least = i.newer;
      if (i.newer) {
        i.newer.older = null;
      }
      if (this._options.clearCallback) {
        this._options.clearCallback(i.data, i.key);
      }
      delete e[i.key];
      T++;
    }
    this._curSize -= T;
    if (this._options.removeOldCallback) {
      this._options.removeOldCallback();
    }
  };
  az.prototype.clear = function () {
    var e = this._cache;
    var i = this._least;
    if (this._options.clearCallback) {
      while (i) {
        this._options.clearCallback(i.data, i.key);
        i = i.newer;
      }
    }
    this._least = this._most = null;
    this._cache = {};
    this._curSize = 0;
  };
  az.prototype.forEach = function (e) {
    var i = this._least;
    while (i) {
      e(i.data);
      i = i.newer;
    }
  };
  az.prototype.clearExcept = function (i) {
    var e = this._cache;
    var T = this._least;
    while (T) {
      if (!i[T.key]) {
        if (this._options.clearCallback) {
          this._options.clearCallback(T.data, T.key);
        }
        if (T.older) {
          T.older.newer = T.newer;
        }
        if (T.newer) {
          T.newer.older = T.older;
        }
        if (this._least === T) {
          this._least = T.newer;
        }
        if (this._most === T) {
          this._most = T.older;
        }
        delete e[T.key];
        this._curSize--;
      }
      T = T.newer;
    }
  };
  !function (T, i) {
    if (typeof bx == "object" && typeof module != "undefined") {
      module.exports = i();
    } else if (typeof define == "function" && define.amd) {
      define(i);
    } else {
      (T = typeof globalThis != "undefined" ? globalThis : T || self).gcoord = i();
    }
  }(this, function () {
    var kQ = function () {
      return (kQ = Object.assign || function (kV) {
        for (var i, T = 1, kX = arguments.length; T < kX; T++) {
          for (var kW in i = arguments[T]) {
            if (Object.prototype.hasOwnProperty.call(i, kW)) {
              kV[kW] = i[kW];
            }
          }
        }
        return kV;
      }).apply(this, arguments);
    };
    var kB = Math.sin;
    var kD = Math.cos;
    var kH = Math.sqrt;
    var kG = Math.abs;
    var kU = Math.PI;
    var kM = 6378245;
    var kA = 0.006693421622965823;
    function kP(T, i) {
      return T >= 72.004 && T <= 137.8347 && i >= 0.8293 && i <= 55.8271;
    }
    function kS(kX, kW) {
      var k0;
      var i;
      var k2;
      k2 = 300 + (k0 = kX - 105) + 2 * (i = kW - 35) + 0.1 * k0 * k0 + 0.1 * k0 * i + 0.1 * kH(kG(k0));
      k2 += 2 * (20 * kB(6 * k0 * kU) + 20 * kB(2 * k0 * kU)) / 3;
      var T = (k2 += 2 * (20 * kB(k0 * kU) + 40 * kB(k0 / 3 * kU)) / 3) + 2 * (150 * kB(k0 / 12 * kU) + 300 * kB(k0 / 30 * kU)) / 3;
      var kV = function (k5, k4) {
        var k3 = 2 * k5 - 100 + 3 * k4 + 0.2 * k4 * k4 + 0.1 * k5 * k4 + 0.2 * kH(kG(k5));
        k3 += 2 * (20 * kB(6 * k5 * kU) + 20 * kB(2 * k5 * kU)) / 3;
        k3 += 2 * (20 * kB(k4 * kU) + 40 * kB(k4 / 3 * kU)) / 3;
        return k3 + 2 * (160 * kB(k4 / 12 * kU) + 320 * kB(k4 * kU / 30)) / 3;
      }(kX - 105, kW - 35);
      var kZ = kW / 180 * kU;
      var kY = kB(kZ);
      var k1 = kH(kY = 1 - kA * kY * kY);
      return [T = 180 * T / (kM / k1 * kD(kZ) * kU), kV = 180 * kV / (kM * (1 - kA) / (kY * k1) * kU)];
    }
    function kJ(kV) {
      var i = kV[0];
      var T = kV[1];
      if (!kP(i, T)) {
        return [i, T];
      }
      var kW = kS(i, T);
      return [i + kW[0], T + kW[1]];
    }
    function kC(kX) {
      var k1 = kX[0];
      var T = kX[1];
      if (!kP(k1, T)) {
        return [k1, T];
      }
      for (var kV = [k1, T], kZ = kV[0], kW = kV[1], k0 = kJ([kZ, kW]), kY = k0[0] - k1, k2 = k0[1] - T; kG(kY) > 0.000001 || kG(k2) > 0.000001;) {
        kY = (k0 = kJ([kZ -= kY, kW -= k2]))[0] - k1;
        k2 = k0[1] - T;
      }
      return [kZ, kW];
    }
    var kN = Math.sin;
    var kO = Math.cos;
    var kk = Math.atan2;
    var kR = Math.sqrt;
    var kz = 3000 * Math.PI / 180;
    function kF(kV) {
      var i = kV[0] - 0.0065;
      var T = kV[1] - 0.006;
      var kX = kR(i * i + T * T) - 0.00002 * kN(T * kz);
      var kW = kk(T, i) - 0.000003 * kO(i * kz);
      return [kX * kO(kW), kX * kN(kW)];
    }
    function ko(kV) {
      var i = kV[0];
      var T = kV[1];
      var kX = kR(i * i + T * T) + 0.00002 * kN(T * kz);
      var kW = kk(T, i) + 0.000003 * kO(i * kz);
      return [kX * kO(kW) + 0.0065, kX * kN(kW) + 0.006];
    }
    var kw = 180 / Math.PI;
    var kf = Math.PI / 180;
    var kh = 6378137;
    var kT = 20037508.342789244;
    function kt(i) {
      return [i[0] * kw / kh, (0.5 * Math.PI - 2 * Math.atan(Math.exp(-i[1] / kh))) * kw];
    }
    function kI(kV) {
      var i = Math.abs(kV[0]) <= 180 ? kV[0] : kV[0] - 360 * (kV[0] < 0 ? -1 : 1);
      var T = [kh * i * kf, kh * Math.log(Math.tan(0.25 * Math.PI + 0.5 * kV[1] * kf))];
      if (T[0] > kT) {
        T[0] = kT;
      }
      if (T[0] < -kT) {
        T[0] = -kT;
      }
      if (T[1] > kT) {
        T[1] = kT;
      }
      if (T[1] < -kT) {
        T[1] = -kT;
      }
      return T;
    }
    var ks;
    var kr;
    var kq;
    var ky;
    var kn;
    var kc;
    var kx = Math.abs;
    var kK = [12890594.86, 8362377.87, 5591021, 3481989.83, 1678043.12, 0];
    var km = [75, 60, 45, 30, 15, 0];
    var ke = [[1.410526172116255e-8, 0.00000898305509648872, -1.9939833816331, 200.9824383106796, -187.2403703815547, 91.6087516669843, -23.38765649603339, 2.57121317296198, -0.03801003308653, 17337981.2], [-7.435856389565537e-9, 0.000008983055097726239, -0.78625201886289, 96.32687599759846, -1.85204757529826, -59.36935905485877, 47.40033549296737, -16.50741931063887, 2.28786674699375, 10260144.86], [-3.030883460898826e-8, 0.00000898305509983578, 0.30071316287616, 59.74293618442277, 7.357984074871, -25.38371002664745, 13.45380521110908, -3.29883767235584, 0.32710905363475, 6856817.37], [-1.981981304930552e-8, 0.000008983055099779535, 0.03278182852591, 40.31678527705744, 0.65659298677277, -4.44255534477492, 0.85341911805263, 0.12923347998204, -0.04625736007561, 4482777.06], [3.09191371068437e-9, 0.000008983055096812155, 0.00006995724062, 23.10934304144901, -0.00023663490511, -0.6321817810242, -0.00663494467273, 0.03430082397953, -0.00466043876332, 2555164.4], [2.890871144776878e-9, 0.000008983055095805407, -3.068298e-8, 7.47137025468032, -0.00000353937994, -0.02145144861037, -0.00001234426596, 0.00010322952773, -0.00000323890364, 826088.5]];
    var kL = [[-0.0015702102444, 111320.7020616939, 1704480524535203, -10338987376042340, 26112667856603880, -35149669176653700, 26595700718403920, -10725012454188240, 1800819912950474, 82.5], [0.0008277824516172526, 111320.7020463578, 647795574.6671607, -4082003173.641316, 10774905663.51142, -15171875531.51559, 12053065338.62167, -5124939663.577472, 913311935.9512032, 67.5], [0.00337398766765, 111320.7020202162, 4481351.045890365, -23393751.19931662, 79682215.47186455, -115964993.2797253, 97236711.15602145, -43661946.33752821, 8477230.501135234, 52.5], [0.00220636496208, 111320.7020209128, 51751.86112841131, 3796837.749470245, 992013.7397791013, -1221952.21711287, 1340652.697009075, -620943.6990984312, 144416.9293806241, 37.5], [-0.0003441963504368392, 111320.7020576856, 278.2353980772752, 2485758.690035394, 6070.750963243378, 54821.18345352118, 9540.606633304236, -2710.55326746645, 1405.483844121726, 22.5], [-0.0003218135878613132, 111320.7020701615, 0.00369383431289, 823725.6402795718, 0.46104986909093, 2351.343141331292, 1.58060784298199, 8.77738589078284, 0.37238884252424, 7.45]];
    function kl(kW, T, kV) {
      var kY = kx(T) / kV[9];
      var kX = kV[0] + kV[1] * kx(kW);
      var i = kV[2] + kV[3] * kY + kV[4] * Math.pow(kY, 2) + kV[5] * Math.pow(kY, 3) + kV[6] * Math.pow(kY, 4) + kV[7] * Math.pow(kY, 5) + kV[8] * Math.pow(kY, 6);
      return [kX *= kW < 0 ? -1 : 1, i *= T < 0 ? -1 : 1];
    }
    function kE(kV) {
      for (var i = kV[0], T = kV[1], kX = [], kW = 0; kW < km.length; kW++) {
        if (kx(T) > km[kW]) {
          kX = kL[kW];
          break;
        }
      }
      return kl(i, T, kX);
    }
    function kj(kV) {
      for (var i = kV[0], T = kV[1], kX = [], kW = 0; kW < kK.length; kW++) {
        if (T >= kK[kW]) {
          kX = ke[kW];
          break;
        }
      }
      return kl(i, T, kX);
    }
    function ki(T, i) {
      if (!T) {
        throw new Error(i);
      }
    }
    function ku(i) {
      return !!i && Object.prototype.toString.call(i) === "[object Array]";
    }
    function kp(i) {
      return !isNaN(Number(i)) && i !== null && !ku(i);
    }
    function kg() {
      for (var kV = [], i = 0; i < arguments.length; i++) {
        kV[i] = arguments[i];
      }
      var T = kV.length - 1;
      return function () {
        for (var kW = [], kY = 0; kY < arguments.length; kY++) {
          kW[kY] = arguments[kY];
        }
        for (var kX = T, e = kV[T].apply(null, kW); kX--;) {
          e = kV[kX].call(null, e);
        }
        return e;
      };
    }
    function kd(lc, k1, k3) {
      if (k3 === undefined) {
        k3 = false;
      }
      if (lc !== null) {
        for (var k6, k5, lf, k8, k0, lb, le, k7, k2 = 0, k9 = 0, la = lc.type, kW = la === "FeatureCollection", ld = la === "Feature", kZ = kW ? lc.features.length : 1, k4 = 0; k4 < kZ; k4++) {
          k0 = (k7 = !!(le = kW ? lc.features[k4].geometry : ld ? lc.geometry : lc) && le.type === "GeometryCollection") ? le.geometries.length : 1;
          for (var kY = 0; kY < k0; kY++) {
            var kX = 0;
            var T = 0;
            if ((k8 = k7 ? le.geometries[kY] : le) !== null) {
              var kV = k8.type;
              k2 = !k3 || kV !== "Polygon" && kV !== "MultiPolygon" ? 0 : 1;
              switch (kV) {
                case null:
                  break;
                case "Point":
                  if (k1(lb = k8.coordinates, k9, k4, kX, T) === false) {
                    return false;
                  }
                  k9++;
                  kX++;
                  break;
                case "LineString":
                case "MultiPoint":
                  for (lb = k8.coordinates, k6 = 0; k6 < lb.length; k6++) {
                    if (k1(lb[k6], k9, k4, kX, T) === false) {
                      return false;
                    }
                    k9++;
                    if (kV === "MultiPoint") {
                      kX++;
                    }
                  }
                  if (kV === "LineString") {
                    kX++;
                  }
                  break;
                case "Polygon":
                case "MultiLineString":
                  for (lb = k8.coordinates, k6 = 0; k6 < lb.length; k6++) {
                    for (k5 = 0; k5 < lb[k6].length - k2; k5++) {
                      if (k1(lb[k6][k5], k9, k4, kX, T) === false) {
                        return false;
                      }
                      k9++;
                    }
                    if (kV === "MultiLineString") {
                      kX++;
                    }
                    if (kV === "Polygon") {
                      T++;
                    }
                  }
                  if (kV === "Polygon") {
                    kX++;
                  }
                  break;
                case "MultiPolygon":
                  for (lb = k8.coordinates, k6 = 0; k6 < lb.length; k6++) {
                    for (T = 0, k5 = 0; k5 < lb[k6].length; k5++) {
                      for (lf = 0; lf < lb[k6][k5].length - k2; lf++) {
                        if (k1(lb[k6][k5][lf], k9, k4, kX, T) === false) {
                          return false;
                        }
                        k9++;
                      }
                      T++;
                    }
                    kX++;
                  }
                  break;
                case "GeometryCollection":
                  for (k6 = 0; k6 < k8.geometries.length; k6++) {
                    if (kd(k8.geometries[k6], k1, k3) === false) {
                      return false;
                    }
                  }
                  break;
                default:
                  throw new Error("Unknown Geometry Type");
              }
            }
          }
        }
      }
    }
    !function (i) {
      i.WGS84 = "WGS84";
      i.WGS1984 = "WGS84";
      i.EPSG4326 = "WGS84";
      i.GCJ02 = "GCJ02";
      i.AMap = "GCJ02";
      i.BD09 = "BD09";
      i.BD09LL = "BD09";
      i.Baidu = "BD09";
      i.BMap = "BD09";
      i.BD09MC = "BD09MC";
      i.BD09Meter = "BD09MC";
      i.EPSG3857 = "EPSG3857";
      i.EPSG900913 = "EPSG3857";
      i.EPSG102100 = "EPSG3857";
      i.WebMercator = "EPSG3857";
      i.WM = "EPSG3857";
    }(kc || (kc = {}));
    var kv = {
      WGS84: {
        to: (ks = {}, ks[kc.GCJ02] = kJ, ks[kc.BD09] = kg(ko, kJ), ks[kc.BD09MC] = kg(kE, ko, kJ), ks[kc.EPSG3857] = kI, ks)
      },
      GCJ02: {
        to: (kr = {}, kr[kc.WGS84] = kC, kr[kc.BD09] = ko, kr[kc.BD09MC] = kg(kE, ko), kr[kc.EPSG3857] = kg(kI, kC), kr)
      },
      BD09: {
        to: (kq = {}, kq[kc.WGS84] = kg(kC, kF), kq[kc.GCJ02] = kF, kq[kc.EPSG3857] = kg(kI, kC, kF), kq[kc.BD09MC] = kE, kq)
      },
      EPSG3857: {
        to: (ky = {}, ky[kc.WGS84] = kt, ky[kc.GCJ02] = kg(kJ, kt), ky[kc.BD09] = kg(ko, kJ, kt), ky[kc.BD09MC] = kg(kE, ko, kJ, kt), ky)
      },
      BD09MC: {
        to: (kn = {}, kn[kc.WGS84] = kg(kC, kF, kj), kn[kc.GCJ02] = kg(kF, kj), kn[kc.EPSG3857] = kg(kI, kC, kF, kj), kn[kc.BD09] = kj, kn)
      }
    };
    return kQ(kQ({}, kc), {
      CRSTypes: kc,
      transform: function (kZ, kX, kY) {
        ki(!!kZ, "The args[0] input coordinate is required");
        ki(!!kX, "The args[1] original coordinate system is required");
        ki(!!kY, "The args[2] target coordinate system is required");
        if (kX === kY) {
          return kZ;
        }
        var k1 = kv[kX];
        ki(!!k1, "Invalid original coordinate system: " + kX);
        var k0 = k1.to[kY];
        ki(!!k0, "Invalid target coordinate system: " + kY);
        var T = typeof kZ;
        ki(T === "string" || T === "object", "Invalid input coordinate type: " + T);
        if (T === "string") {
          try {
            kZ = JSON.parse(kZ);
          } catch (kX) {
            throw new Error("Invalid input coordinate: " + kZ);
          }
        }
        var kW = false;
        if (ku(kZ)) {
          ki(kZ.length >= 2, "Invalid input coordinate: " + kZ);
          ki(kp(kZ[0]) && kp(kZ[1]), "Invalid input coordinate: " + kZ);
          kZ = kZ.map(Number);
          kW = true;
        }
        var kV = k0;
        return kW ? kV(kZ) : (kd(kZ, function (k2) {
          var i;
          i = kV(k2);
          k2[0] = i[0];
          k2[1] = i[1];
        }), kZ);
      }
    });
  });
  var hB = {
    ColorRefTable: {
      aliceblue: ["#f0f8ff", "rgb(240,248,255)"],
      antiquewhite: ["#faebd7", "rgb(250,235,215)"],
      aqua: ["#00ffff", "rgb(0,255,255)"],
      aquamarine: ["#7fffd4", "rgb(127,255,212)"],
      azure: ["#f0ffff", "rgb(240,255,255)"],
      beige: ["#f5f5dc", "rgb(245,245,220)"],
      bisque: ["#ffe4c4", "rgb(255,228,196)"],
      black: ["#000000", "rgb(0,0,0)"],
      blanchedalmond: ["#ffebcd", "rgb(255,235,205)"],
      blue: ["#0000ff", "rgb(0,0,255)"],
      blueviolet: ["#8a2be2", "rgb(138,43,226)"],
      brown: ["#a52a2a", "rgb(165,42,42)"],
      burlywood: ["#deb887", "rgb(222,184,135)"],
      cadetblue: ["#5f9ea0", "rgb(95,158,160)"],
      chartreuse: ["#7fff00", "rgb(127,255,0)"],
      chocolate: ["#d2691e", "rgb(210,105,30)"],
      coral: ["#ff7f50", "rgb(255,127,80)"],
      cornflowerblue: ["#6495ed", "rgb(100,149,237)"],
      cornsilk: ["#fff8dc", "rgb(255,248,220)"],
      crimson: ["#dc143c", "rgb(220,20,60)"],
      cyan: ["#00ffff", "rgb(0,255,255)"],
      darkblue: ["#00008b", "rgb(0,0,139)"],
      darkcyan: ["#008b8b", "rgb(0,139,139)"],
      darkgoldenrod: ["#b8860b", "rgb(184,134,11)"],
      darkgray: ["#a9a9a9", "rgb(169,169,169)"],
      darkgreen: ["#006400", "rgb(0,100,0)"],
      darkgrey: ["#a9a9a9", "rgb(169,169,169)"],
      darkkhaki: ["#bdb76b", "rgb(189,183,107)"],
      darkmagenta: ["#8b008b", "rgb(139,0,139)"],
      darkolivegreen: ["#556b2f", "rgb(85,107,47)"],
      darkorange: ["#ff8c00", "rgb(255,140,0)"],
      darkorchid: ["#9932cc", "rgb(153,50,204)"],
      darkred: ["#8b0000", "rgb(139,0,0)"],
      darksalmon: ["#e9967a", "rgb(233,150,122)"],
      darkseagreen: ["#8fbc8f", "rgb(143,188,143)"],
      darkslateblue: ["#483d8b", "rgb(72,61,139)"],
      darkslategray: ["#2f4f4f", "rgb(47,79,79)"],
      darkslategrey: ["#2f4f4f", "rgb(47,79,79)"],
      darkturquoise: ["#00ced1", "rgb(0,206,209)"],
      darkviolet: ["#9400d3", "rgb(148,0,211)"],
      deeppink: ["#ff1493", "rgb(255,20,147)"],
      deepskyblue: ["#00bfff", "rgb(0,191,255)"],
      dimgray: ["#696969", "rgb(105,105,105)"],
      dimgrey: ["#696969", "rgb(105,105,105)"],
      dodgerblue: ["#1e90ff", "rgb(30,144,255)"],
      firebrick: ["#b22222", "rgb(178,34,34)"],
      floralwhite: ["#fffaf0", "rgb(255,250,240)"],
      forestgreen: ["#228b22", "rgb(34,139,34)"],
      fuchsia: ["#ff00ff", "rgb(255,0,255)"],
      gainsboro: ["#dcdcdc", "rgb(220,220,220)"],
      ghostwhite: ["#f8f8ff", "rgb(248,248,255)"],
      gold: ["#ffd700", "rgb(255,215,0)"],
      goldenrod: ["#daa520", "rgb(218,165,32)"],
      gray: ["#808080", "rgb(128,128,128)"],
      green: ["#008000", "rgb(0,128,0)"],
      greenyellow: ["#adff2f", "rgb(173,255,47)"],
      grey: ["#808080", "rgb(128,128,128)"],
      honeydew: ["#f0fff0", "rgb(240,255,240)"],
      hotpink: ["#ff69b4", "rgb(255,105,180)"],
      indianred: ["#cd5c5c", "rgb(205,92,92)"],
      indigo: ["#4b0082", "rgb(75,0,130)"],
      ivory: ["#fffff0", "rgb(255,255,240)"],
      khaki: ["#f0e68c", "rgb(240,230,140)"],
      lavender: ["#e6e6fa", "rgb(230,230,250)"],
      lavenderblush: ["#fff0f5", "rgb(255,240,245)"],
      lawngreen: ["#7cfc00", "rgb(124,252,0)"],
      lemonchiffon: ["#fffacd", "rgb(255,250,205)"],
      lightblue: ["#add8e6", "rgb(173,216,230)"],
      lightcoral: ["#f08080", "rgb(240,128,128)"],
      lightcyan: ["#e0ffff", "rgb(224,255,255)"],
      lightgoldenrodyellow: ["#fafad2", "rgb(250,250,210)"],
      lightgray: ["#d3d3d3", "rgb(211,211,211)"],
      lightgreen: ["#90ee90", "rgb(144,238,144)"],
      lightgrey: ["#d3d3d3", "rgb(211,211,211)"],
      lightpink: ["#ffb6c1", "rgb(255,182,193)"],
      lightsalmon: ["#ffa07a", "rgb(255,160,122)"],
      lightseagreen: ["#20b2aa", "rgb(32,178,170)"],
      lightskyblue: ["#87cefa", "rgb(135,206,250)"],
      lightslategray: ["#778899", "rgb(119,136,153)"],
      lightslategrey: ["#778899", "rgb(119,136,153)"],
      lightsteelblue: ["#b0c4de", "rgb(176,196,222)"],
      lightyellow: ["#ffffe0", "rgb(255,255,224)"],
      lime: ["#00ff00", "rgb(0,255,0)"],
      limegreen: ["#32cd32", "rgb(50,205,50)"],
      linen: ["#faf0e6", "rgb(250,240,230)"],
      magenta: ["#ff00ff", "rgb(255,0,255)"],
      maroon: ["#800000", "rgb(128,0,0)"],
      mediumaquamarine: ["#66cdaa", "rgb(102,205,170)"],
      mediumblue: ["#0000cd", "rgb(0,0,205)"],
      mediumorchid: ["#ba55d3", "rgb(186,85,211)"],
      mediumpurple: ["#9370db", "rgb(147,112,219)"],
      mediumseagreen: ["#3cb371", "rgb(60,179,113)"],
      mediumslateblue: ["#7b68ee", "rgb(123,104,238)"],
      mediumspringgreen: ["#00fa9a", "rgb(0,250,154)"],
      mediumturquoise: ["#48d1cc", "rgb(72,209,204)"],
      mediumvioletred: ["#c71585", "rgb(199,21,133)"],
      midnightblue: ["#191970", "rgb(25,25,112)"],
      mintcream: ["#f5fffa", "rgb(245,255,250)"],
      mistyrose: ["#ffe4e1", "rgb(255,228,225)"],
      moccasin: ["#ffe4b5", "rgb(255,228,181)"],
      navajowhite: ["#ffdead", "rgb(255,222,173)"],
      navy: ["#000080", "rgb(0,0,128)"],
      oldlace: ["#fdf5e6", "rgb(253,245,230)"],
      olive: ["#808000", "rgb(128,128,0)"],
      olivedrab: ["#6b8e23", "rgb(107,142,35)"],
      orange: ["#ffa500", "rgb(255,165,0)"],
      orangered: ["#ff4500", "rgb(255,69,0)"],
      orchid: ["#da70d6", "rgb(218,112,214)"],
      palegoldenrod: ["#eee8aa", "rgb(238,232,170)"],
      palegreen: ["#98fb98", "rgb(152,251,152)"],
      paleturquoise: ["#afeeee", "rgb(175,238,238)"],
      palevioletred: ["#db7093", "rgb(219,112,147)"],
      papayawhip: ["#ffefd5", "rgb(255,239,213)"],
      peachpuff: ["#ffdab9", "rgb(255,218,185)"],
      peru: ["#cd853f", "rgb(205,133,63)"],
      pink: ["#ffc0cb", "rgb(255,192,203)"],
      plum: ["#dda0dd", "rgb(221,160,221)"],
      powderblue: ["#b0e0e6", "rgb(176,224,230)"],
      purple: ["#800080", "rgb(128,0,128)"],
      red: ["#ff0000", "rgb(255,0,0)"],
      rosybrown: ["#bc8f8f", "rgb(188,143,143)"],
      royalblue: ["#4169e1", "rgb(65,105,225)"],
      saddlebrown: ["#8b4513", "rgb(139,69,19)"],
      salmon: ["#fa8072", "rgb(250,128,114)"],
      sandybrown: ["#f4a460", "rgb(244,164,96)"],
      seagreen: ["#2e8b57", "rgb(46,139,87)"],
      seashell: ["#fff5ee", "rgb(255,245,238)"],
      sienna: ["#a0522d", "rgb(160,82,45)"],
      silver: ["#c0c0c0", "rgb(192,192,192)"],
      skyblue: ["#87ceeb", "rgb(135,206,235)"],
      slateblue: ["#6a5acd", "rgb(106,90,205)"],
      slategray: ["#708090", "rgb(112,128,144)"],
      slategrey: ["#708090", "rgb(112,128,144)"],
      snow: ["#fffafa", "rgb(255,250,250)"],
      springgreen: ["#00ff7f", "rgb(0,255,127)"],
      steelblue: ["#4682b4", "rgb(70,130,180)"],
      tan: ["#d2b48c", "rgb(210,180,140)"],
      teal: ["#008080", "rgb(0,128,128)"],
      thistle: ["#d8bfd8", "rgb(216,191,216)"],
      tomato: ["#ff6347", "rgb(255,99,71)"],
      turquoise: ["#40e0d0", "rgb(64,224,208)"],
      violet: ["#ee82ee", "rgb(238,130,238)"],
      wheat: ["#f5deb3", "rgb(245,222,179)"],
      white: ["#ffffff", "rgb(255,255,255)"],
      whitesmoke: ["#f5f5f5", "rgb(245,245,245)"],
      yellow: ["#ffff00", "rgb(255,255,0)"],
      yellowgreen: ["#9acd32", "rgb(154,205,50)"]
    },
    regGroup: {
      hex: /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/,
      rgb: /rgb\(\s*(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\s*,\s*(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\s*,\s*(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\s*\)/,
      rgba: /rgba\(\s*(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\s*,\s*(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\s*,\s*(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\s*,\s*(0|1|0\.[1-9])\s*\)/
    },
    parseHexToRgbaArray: function (ke) {
      var kf = ke.replace("#", "");
      if (kf.length === 3) {
        kf += "f";
      } else if (kf.length === 6) {
        kf += "ff";
      }
      var e = [];
      var kd = kf.length;
      var kc = kd === 8 ? 2 : 1;
      for (var T = 0; T < kd; T = T + kc) {
        if (kc === 2) {
          e.push(parseInt(kf.slice(T, T + 2), 16));
        } else {
          e.push(parseInt(kf.slice(T, T + 1) + kf.slice(T, T + 1), 16));
        }
      }
      return e;
    },
    parseRgbaStrToArray: function (i) {
      var e = [0, 0, 0, 255];
      if (i.indexOf("rgba(") === 0) {
        var kc = i.replace("rgba(", "").replace(")", "");
        var T = kc.split(",");
        e[0] = parseInt(T[0], 10);
        e[1] = parseInt(T[1], 10);
        e[2] = parseInt(T[2], 10);
        e[3] = Math.round(parseFloat(T[3]) * 255);
      } else if (i.indexOf("rgb(") === 0) {
        var kc = i.replace("rgb(", "").replace(")", "");
        var kd = kc.split(",");
        e[0] = parseInt(kd[0], 10);
        e[1] = parseInt(kd[1], 10);
        e[2] = parseInt(kd[2], 10);
        e[3] = 255;
      }
      return e;
    },
    parseHexAndOpacityToRgbaArray: function (kd, ke) {
      var T = [];
      var kh = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
      var kg = kd.toLowerCase();
      if (kh.test(kg)) {
        if (kg.length === 4) {
          var e = "#";
          for (var kf = 1; kf < 4; kf++) {
            e += kg.slice(kf, kf + 1).concat(kg.slice(kf, kf + 1));
          }
          kg = e;
        }
        for (var kc = 1; kc < 7; kc += 2) {
          T.push(parseInt(kg.slice(kc, kc + 2), 16));
        }
        T.push(ke);
      }
      return T;
    },
    parseCSSColor: function (e) {
      if (e.indexOf("#") === 0) {
        return hB.parseHexToRgbaArray(e);
      }
      return hB.parseRgbaStrToArray(e);
    },
    rgbToHSV: function (kd) {
      var e = kd[0] / 255;
      var T = kd[1] / 255;
      var ke = kd[2] / 255;
      var kh = Math.max(e, T, ke);
      var kc = Math.min(e, T, ke);
      var kg = kh - kc;
      var i;
      if (kg === 0) {
        i = 0;
      } else if (kh === e) {
        i = 60 * ((T - ke) / kg % 6);
      } else if (kh === T) {
        i = 60 * ((ke - e) / kg + 2);
      } else if (kh === ke) {
        i = 60 * ((e - T) / kg + 4);
      }
      var ki = kh === 0 ? 0 : kg / kh;
      var kf = kh;
      while (i < 0) {
        i += 360;
      }
      return [i, ki, kf];
    },
    hsvToRGB: function (kc) {
      var kg = kc[2] * kc[1];
      var T = kg * (1 - Math.abs(kc[0] / 60 % 2 - 1));
      var i = kc[2] - kg;
      var kd = kc[0];
      var kf;
      var ke;
      var e;
      if (kd >= 0 && kd < 60) {
        kf = kg;
        ke = T;
        e = 0;
      } else if (kd >= 60 && kd < 120) {
        kf = T;
        ke = kg;
        e = 0;
      } else if (kd >= 120 && kd < 180) {
        kf = 0;
        ke = kg;
        e = T;
      } else if (kd >= 180 && kd < 240) {
        kf = 0;
        ke = T;
        e = kg;
      } else if (kd >= 240 && kd < 300) {
        kf = T;
        ke = 0;
        e = kg;
      } else if (kd >= 300 && kd < 360) {
        kf = kg;
        ke = 0;
        e = T;
      }
      kf = (kf + i) * 255 > 255 ? 255 : (kf + i) * 255;
      ke = (ke + i) * 255 > 255 ? 255 : (ke + i) * 255;
      e = (e + i) * 255 > 255 ? 255 : (e + i) * 255;
      return [Math.round(kf), Math.round(ke), Math.round(e)];
    },
    formatColorCssToRgbaArray: function (ke, T, kc) {
      kc = typeof kc !== "boolean" ? true : kc;
      if (typeof ke !== "string") {
        return kc ? [0, 0, 0, 1] : [0, 0, 0, 255];
      }
      var i = (ke || "Black").trim().toLowerCase();
      var e = [];
      var kd = hB.ColorRefTable[i];
      if (kd !== undefined) {
        i = kd[0];
      }
      e = hB.parseCSSColor(i);
      if (T !== undefined && !isNaN(Number(T))) {
        T = Number(T);
        e[3] = hB.fitTo(T, 0, 1);
      } else {
        e[3] = Number((e[3] / 255).toFixed(2));
      }
      if (!kc) {
        e[3] = Math.floor(e[3] * 255);
      }
      return e;
    },
    fitTo: function (T, i, e) {
      if (T < i) {
        T = i;
      } else if (T > e) {
        T = e;
      }
      return T;
    },
    generateColorRamp: function (e, ki, kj, kc, ko) {
      kj = kj || [];
      kc = kc || "#ccc";
      ko = ko || 1;
      const T = document.createElement("canvas");
      const kp = T.getContext("2d");
      T.width = 256;
      T.height = ko;
      const ke = ki[0];
      const kl = ki[ki.length - 1];
      if (e.length === ki.length) {
        const km = kp.createLinearGradient(0, 0, 256, 1);
        for (var kh = 0; kh < e.length; ++kh) {
          var kn = (ki[kh] - ke) / (kl - ke);
          km.addColorStop(kn, e[kh]);
        }
        kp.fillStyle = km;
        kp.fillRect(0, 0, 256, ko);
      } else if (e.length - ki.length === -1) {
        var kg = 0;
        var kd = 1;
        for (var kh = 0; kh < e.length; ++kh) {
          var kk = (ki[kd] - ke) / (kl - ke);
          var kn = Math.floor(kk * 256);
          kp.fillStyle = e[kh];
          kp.fillRect(kg, 0, kn, ko);
          kg = kn;
          kd++;
        }
      } else {
        kp.fillStyle = kc || "#ccc";
        kp.fillRect(0, 0, 256, ko);
      }
      if (e.length - ki.length <= -1 && kj.length === 2) {
        kp.fillStyle = kc || "#ccc";
        var kk = (kj[0] - ke) / (kl - ke);
        var kn = Math.floor(kk * 256);
        kp.fillRect(0, 0, kn, ko);
        kk = (kj[1] - ke) / (kl - ke);
        kn = Math.floor(kk * 256);
        kp.fillRect(kn, 0, 255, ko);
      }
      var kf = new Uint8Array(new Uint8ClampedArray(kp.getImageData(0, 0, 256, ko).data));
      return {
        canvas: T,
        data: kf,
        width: 256,
        height: ko
      };
    },
    validateColor: function (e, i) {
      return hB.regGroup[i].test(e);
    },
    convert2rgba: function (e, i) {
      if (i === undefined) {
        i = 1;
      }
      if (hB.validateColor(e, "rgba")) {
        return e;
      }
      if (hB.validateColor(e, "rgb")) {
        e = e.replace(/rgb/g, "rgba");
        e = e.replace(/\)/, "," + i + ")");
        return e;
      }
      var T = hB.formatColorCssToRgbaArray(e, i, true);
      return "rgba(" + T.join(",") + ")";
    }
  };
  (function (ke) {
    function ko(kt, kw) {
      var kv = (kt & 65535) + (kw & 65535);
      var ku = (kt >> 16) + (kw >> 16) + (kv >> 16);
      return ku << 16 | kv & 65535;
    }
    function kn(kt, ku) {
      return kt << ku | kt >>> 32 - ku;
    }
    function ki(ky, kv, ku, kt, kx, kw) {
      return ko(kn(ko(ko(kv, ky), ko(kt, kw)), kx), ku);
    }
    function e(kv, ku, kz, ky, kt, kx, kw) {
      return ki(ku & kz | ~ku & ky, kv, ku, kt, kx, kw);
    }
    function kf(kv, ku, kz, ky, kt, kx, kw) {
      return ki(ku & ky | kz & ~ky, kv, ku, kt, kx, kw);
    }
    function kl(kv, ku, kz, ky, kt, kx, kw) {
      return ki(ku ^ kz ^ ky, kv, ku, kt, kx, kw);
    }
    function kr(kv, ku, kz, ky, kt, kx, kw) {
      return ki(kz ^ (ku | ~ky), kv, ku, kt, kx, kw);
    }
    function T(kD, ky) {
      kD[ky >> 5] |= 128 << ky % 32;
      kD[(ky + 64 >>> 9 << 4) + 14] = ky;
      var kv;
      var kx;
      var kw;
      var ku;
      var kt;
      var kC = 1732584193;
      var kB = -271733879;
      var kA = -1732584194;
      var kz = 271733878;
      for (kv = 0; kv < kD.length; kv += 16) {
        kx = kC;
        kw = kB;
        ku = kA;
        kt = kz;
        kC = e(kC, kB, kA, kz, kD[kv], 7, -680876936);
        kz = e(kz, kC, kB, kA, kD[kv + 1], 12, -389564586);
        kA = e(kA, kz, kC, kB, kD[kv + 2], 17, 606105819);
        kB = e(kB, kA, kz, kC, kD[kv + 3], 22, -1044525330);
        kC = e(kC, kB, kA, kz, kD[kv + 4], 7, -176418897);
        kz = e(kz, kC, kB, kA, kD[kv + 5], 12, 1200080426);
        kA = e(kA, kz, kC, kB, kD[kv + 6], 17, -1473231341);
        kB = e(kB, kA, kz, kC, kD[kv + 7], 22, -45705983);
        kC = e(kC, kB, kA, kz, kD[kv + 8], 7, 1770035416);
        kz = e(kz, kC, kB, kA, kD[kv + 9], 12, -1958414417);
        kA = e(kA, kz, kC, kB, kD[kv + 10], 17, -42063);
        kB = e(kB, kA, kz, kC, kD[kv + 11], 22, -1990404162);
        kC = e(kC, kB, kA, kz, kD[kv + 12], 7, 1804603682);
        kz = e(kz, kC, kB, kA, kD[kv + 13], 12, -40341101);
        kA = e(kA, kz, kC, kB, kD[kv + 14], 17, -1502002290);
        kB = e(kB, kA, kz, kC, kD[kv + 15], 22, 1236535329);
        kC = kf(kC, kB, kA, kz, kD[kv + 1], 5, -165796510);
        kz = kf(kz, kC, kB, kA, kD[kv + 6], 9, -1069501632);
        kA = kf(kA, kz, kC, kB, kD[kv + 11], 14, 643717713);
        kB = kf(kB, kA, kz, kC, kD[kv], 20, -373897302);
        kC = kf(kC, kB, kA, kz, kD[kv + 5], 5, -701558691);
        kz = kf(kz, kC, kB, kA, kD[kv + 10], 9, 38016083);
        kA = kf(kA, kz, kC, kB, kD[kv + 15], 14, -660478335);
        kB = kf(kB, kA, kz, kC, kD[kv + 4], 20, -405537848);
        kC = kf(kC, kB, kA, kz, kD[kv + 9], 5, 568446438);
        kz = kf(kz, kC, kB, kA, kD[kv + 14], 9, -1019803690);
        kA = kf(kA, kz, kC, kB, kD[kv + 3], 14, -187363961);
        kB = kf(kB, kA, kz, kC, kD[kv + 8], 20, 1163531501);
        kC = kf(kC, kB, kA, kz, kD[kv + 13], 5, -1444681467);
        kz = kf(kz, kC, kB, kA, kD[kv + 2], 9, -51403784);
        kA = kf(kA, kz, kC, kB, kD[kv + 7], 14, 1735328473);
        kB = kf(kB, kA, kz, kC, kD[kv + 12], 20, -1926607734);
        kC = kl(kC, kB, kA, kz, kD[kv + 5], 4, -378558);
        kz = kl(kz, kC, kB, kA, kD[kv + 8], 11, -2022574463);
        kA = kl(kA, kz, kC, kB, kD[kv + 11], 16, 1839030562);
        kB = kl(kB, kA, kz, kC, kD[kv + 14], 23, -35309556);
        kC = kl(kC, kB, kA, kz, kD[kv + 1], 4, -1530992060);
        kz = kl(kz, kC, kB, kA, kD[kv + 4], 11, 1272893353);
        kA = kl(kA, kz, kC, kB, kD[kv + 7], 16, -155497632);
        kB = kl(kB, kA, kz, kC, kD[kv + 10], 23, -1094730640);
        kC = kl(kC, kB, kA, kz, kD[kv + 13], 4, 681279174);
        kz = kl(kz, kC, kB, kA, kD[kv], 11, -358537222);
        kA = kl(kA, kz, kC, kB, kD[kv + 3], 16, -722521979);
        kB = kl(kB, kA, kz, kC, kD[kv + 6], 23, 76029189);
        kC = kl(kC, kB, kA, kz, kD[kv + 9], 4, -640364487);
        kz = kl(kz, kC, kB, kA, kD[kv + 12], 11, -421815835);
        kA = kl(kA, kz, kC, kB, kD[kv + 15], 16, 530742520);
        kB = kl(kB, kA, kz, kC, kD[kv + 2], 23, -995338651);
        kC = kr(kC, kB, kA, kz, kD[kv], 6, -198630844);
        kz = kr(kz, kC, kB, kA, kD[kv + 7], 10, 1126891415);
        kA = kr(kA, kz, kC, kB, kD[kv + 14], 15, -1416354905);
        kB = kr(kB, kA, kz, kC, kD[kv + 5], 21, -57434055);
        kC = kr(kC, kB, kA, kz, kD[kv + 12], 6, 1700485571);
        kz = kr(kz, kC, kB, kA, kD[kv + 3], 10, -1894986606);
        kA = kr(kA, kz, kC, kB, kD[kv + 10], 15, -1051523);
        kB = kr(kB, kA, kz, kC, kD[kv + 1], 21, -2054922799);
        kC = kr(kC, kB, kA, kz, kD[kv + 8], 6, 1873313359);
        kz = kr(kz, kC, kB, kA, kD[kv + 15], 10, -30611744);
        kA = kr(kA, kz, kC, kB, kD[kv + 6], 15, -1560198380);
        kB = kr(kB, kA, kz, kC, kD[kv + 13], 21, 1309151649);
        kC = kr(kC, kB, kA, kz, kD[kv + 4], 6, -145523070);
        kz = kr(kz, kC, kB, kA, kD[kv + 11], 10, -1120210379);
        kA = kr(kA, kz, kC, kB, kD[kv + 2], 15, 718787259);
        kB = kr(kB, kA, kz, kC, kD[kv + 9], 21, -343485551);
        kC = ko(kC, kx);
        kB = ko(kB, kw);
        kA = ko(kA, ku);
        kz = ko(kz, kt);
      }
      return [kC, kB, kA, kz];
    }
    function km(ku) {
      var kv;
      var kt = "";
      var kw = ku.length * 32;
      for (kv = 0; kv < kw; kv += 8) {
        kt += String.fromCharCode(ku[kv >> 5] >>> kv % 32 & 255);
      }
      return kt;
    }
    function kh(ku) {
      var kw;
      var kt = [];
      kt[(ku.length >> 2) - 1] = undefined;
      for (kw = 0; kw < kt.length; kw += 1) {
        kt[kw] = 0;
      }
      var kv = ku.length * 8;
      for (kw = 0; kw < kv; kw += 8) {
        kt[kw >> 5] |= (ku.charCodeAt(kw / 8) & 255) << kw % 32;
      }
      return kt;
    }
    function kg(kt) {
      return km(T(kh(kt), kt.length * 8));
    }
    function ks(kv, ky) {
      var ku;
      var kx = kh(kv);
      var kt = [];
      var kw = [];
      var kz;
      kt[15] = kw[15] = undefined;
      if (kx.length > 16) {
        kx = T(kx, kv.length * 8);
      }
      for (ku = 0; ku < 16; ku += 1) {
        kt[ku] = kx[ku] ^ 909522486;
        kw[ku] = kx[ku] ^ 1549556828;
      }
      kz = T(kt.concat(kh(ky)), 512 + ky.length * 8);
      return km(T(kw.concat(kz), 640));
    }
    function kq(kw) {
      var kv = "0123456789abcdef";
      var ku = "";
      var kt;
      var kx;
      for (kx = 0; kx < kw.length; kx += 1) {
        kt = kw.charCodeAt(kx);
        ku += kv.charAt(kt >>> 4 & 15) + kv.charAt(kt & 15);
      }
      return ku;
    }
    function kj(kt) {
      return unescape(encodeURIComponent(kt));
    }
    function kc(kt) {
      return kg(kj(kt));
    }
    function kk(kt) {
      return kq(kc(kt));
    }
    function i(kt, ku) {
      return ks(kj(kt), kj(ku));
    }
    function kp(kt, ku) {
      return kq(i(kt, ku));
    }
    function kd(ku, kv, kt) {
      if (!kv) {
        if (!kt) {
          return kk(ku);
        }
        return kc(ku);
      }
      if (!kt) {
        return kp(kv, ku);
      }
      return i(kv, ku);
    }
    if (typeof define === "function" && define.amd) {
      define(function () {
        return kd;
      });
    } else if (typeof module === "object" && module.exports) {
      module.exports = kd;
    } else {
      ke.md5 = kd;
    }
  })(this);
  var cK = {
    levels: {
      INFO: "info",
      WARNING: "warning",
      ERROR: "error"
    },
    category: {
      JS: "js",
      RESOURCE: "resource",
      AJAX: "ajax"
    },
    config: {
      jsError: true,
      resourceError: true,
      ajaxError: true
    },
    hosts: "api.map.baidu.com|webmap0.bdimg.com|maponline0.bdimg.com|",
    ignoreUrl: "api.map.baidu.com/images/blank.gif",
    sender: true,
    collections: [],
    sendError: function () {},
    init: function (i, e, T) {
      this.hosts += i ? i : "";
      if (aq) {
        aq(this.config, e);
      }
      this.sender = true;
      if (T) {
        this.sender = false;
      }
      this.hosts = this.urlScope(this.hosts);
      this.sendError = this.notifyError();
      var kc = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      if (this.config.jsError) {
        this.handleJavaScriptError(kc);
      }
      if (this.config.resourceError) {
        this.handleResourceError(kc);
      }
      if (this.config.ajaxError) {
        this.handleAjaxError(kc);
      }
    },
    handleJavaScriptError: function (T) {
      var e = this;
      var i = T.onerror;
      T.onerror = function (kg, kf, kc, ke, kd) {
        if (e.isFetch(e.category.JS) && e.hostExit(kf)) {
          if (kd && kd.stack) {
            e.sendError({
              title: kg,
              msg: kd.stack,
              category: e.category.JS,
              level: e.levels.ERROR
            });
          } else if (typeof kg === "string") {
            e.sendError({
              title: kg,
              msg: JSON.stringify({
                resourceUrl: kf,
                rowNum: kc,
                colNum: ke
              }),
              category: "js",
              level: e.levels.ERROR
            });
          }
        }
        if (i && bR(i)) {
          if (i) {
            i.apply(T, arguments);
          }
        }
      };
    },
    handleResourceError: function (i) {
      var e = this;
      i.addEventListener("error", function (ke) {
        if (ke) {
          var kf = ke.target || ke.srcElement;
          var kd = kf instanceof HTMLScriptElement || kf instanceof HTMLLinkElement || kf instanceof HTMLImageElement;
          if (!kd) {
            if (!i.onerror) {
              var T = ke.filename || null;
              if (!e.isFetch(e.category.JS) || !e.hostExit(T)) {
                return;
              }
              if (ke.error && ke.error.stack) {
                e.sendError({
                  title: ke.message,
                  msg: ke.error.stack,
                  category: e.category.JS,
                  level: e.levels.ERROR
                });
              } else if (typeof ke.message === "string") {
                e.sendError({
                  title: ke.message,
                  msg: JSON.stringify({
                    resourceUrl: T,
                    rowNum: ke.lineno,
                    colNum: ke.cowno
                  }),
                  category: e.category.JS,
                  level: e.levels.ERROR
                });
              }
            }
            return;
          }
          var kc = kf.src || kf.href;
          if (e.isFetch(e.category.RESOURCE) && e.hostExit(kc)) {
            e.sendError({
              title: kf.nodeName,
              msg: kc,
              category: e.category.RESOURCE,
              level: e.levels.ERROR
            });
          }
        }
      }, true);
    },
    handleAjaxError: function (ke) {
      var e = this;
      var kd = ke.location.protocol;
      if (kd === "file:") {
        return;
      }
      if (!ke.XMLHttpRequest) {
        return;
      }
      var i = ke.XMLHttpRequest;
      var T = i.prototype.send;
      var kc = function (kg) {
        if (kg && kg.currentTarget && kg.currentTarget.status !== 200) {
          var kf = kg.target.responseURL;
          if (e.isFetch(e.category.AJAX) && e.hostExit(kf)) {
            e.sendError({
              title: kf,
              msg: JSON.stringify({
                response: kg.target.response,
                responseURL: kf,
                status: kg.target.status,
                statusText: kg.target.statusText
              }),
              category: e.category.AJAX,
              level: e.levels.ERROR
            });
          }
        }
      };
      i.prototype.send = function () {
        if (this.addEventListener) {
          this.addEventListener("error", kc);
          this.addEventListener("load", kc);
          this.addEventListener("abort", kc);
        } else {
          var kf = this.onreadystatechange;
          this.onreadystatechange = function (kg) {
            if (this.readyState === 4) {
              kc(kg);
            }
            if (kf) {
              kf.apply(this, arguments);
            }
          };
        }
        return T.apply(this, arguments);
      };
    },
    notifyError: function (T) {
      var i = T || 1000;
      this._idleWorkerTicker = function (kc) {
        return function () {
          kc.runJob();
        };
      }(this);
      var e = this;
      return function (kd) {
        if (kd.url) {
          if (!e.isFetch(kd.category)) {
            return;
          }
          var kc = kd.url || "";
          if (!e.hostExit(kc)) {
            return;
          }
          delete kd.url;
        }
        if (!navigator.onLine) {
          return;
        }
        e.collections.push(kd);
        e.checkJob(i);
      };
    },
    runJob: function () {
      if (this.collections.length === 0) {
        clearInterval(this.idleWork);
        this.idleWork = null;
        return;
      }
      var kd = this.collections.slice(0, 2);
      var T = ji(JSON.stringify({
        dataset: kd
      }));
      var kc = new Date().getTime();
      var i = eu.apiIMG + "/blank.gif?product=jsapi&v=gl&l=" + T + "&ak=" + eN + "&t=" + kc;
      if (this.sender) {
        try {
          var kf = document.createElement("div");
          kf.style = "width:0;height:0;visibility: hidden;opacity: 0;z-index:-999;background-image: url(" + i + ");";
          document.querySelector("BODY").appendChild(kf);
          setTimeout(function () {
            document.querySelector("BODY").removeChild(kf);
          });
        } catch (ke) {}
      }
      this.collections.splice(0, 2);
      if (this.collections.length === 0) {
        clearInterval(this.idleWork);
        this.idleWork = null;
      }
    },
    checkJob: function (e) {
      if (!this.idleWork && this._idleWorkerTicker) {
        this.idleWork = setInterval(this._idleWorkerTicker, e);
      }
    },
    urlScope: function (kc) {
      var T = {};
      var ke = Object.keys(B);
      if (B && ke.length > 0) {
        for (var kd in B) {
          if (B[kd] && typeof B[kd] !== "function") {
            T[kd] = B[kd];
          }
        }
      }
      try {
        var kg = JSON.stringify(T);
        if (kg.length > 2) {
          return kc + "|" + kg;
        } else {
          return kc;
        }
      } catch (kf) {
        return kc;
      }
    },
    hostExit: function (i) {
      try {
        if (i && i.indexOf("//") === 0) {
          i = window.location.protocol + i;
        }
        var T = new URL(i);
        if (!T || !T.host) {
          return false;
        }
        var kd = T.host + T.pathname;
        if (this.ignoreUrl.indexOf(kd) === -1 && this.hosts.indexOf(T.host) > -1) {
          return true;
        }
        return false;
      } catch (kc) {
        return false;
      }
    },
    isFetch: function (e) {
      return this.config[e + "Error"] || false;
    }
  };
  bx.fetchDebug = cK;
  var jV = {
    request: function (kk, kg, kc, kn, ke) {
      var kh = new Date().getTime();
      var kj = (Math.random() * 100000).toFixed(0);
      bx._rd["_cbk" + kj] = function (ko) {
        if (ko.result && ko.result.error && ko.result.error === 202) {
          alert("该AK因为恶意行为已经被管理员封禁！");
          return;
        }
        if (ko.result && ko.result.error && ko.result.error === 403) {
          if (gZ !== null) {
            gZ.update("未获得百度地图商用授权，可能导致部分地图请求失败，请刷新后重试。");
          }
          return;
        }
        kc = kc || {};
        if (kk) {
          kk(ko, kc);
        }
        delete bx._rd["_cbk" + kj];
      };
      kn = kn || "";
      var km;
      var kd;
      if (kc && kc.useEncodeURI) {
        km = jk(kg, encodeURI);
        kd = jk(kg);
      } else {
        km = jk(kg, encodeURIComponent);
        kd = jk(kg);
      }
      var i = B.apiHost + "/" + kn + "?" + km + "&ie=utf-8&oue=1&fromproduct=jsapi";
      var ki = B.apiHost + "/" + kn + "?" + kd + "&ie=utf-8&oue=1&fromproduct=jsapi";
      if (!ke) {
        i += "&res=api";
        ki += "&res=api";
      }
      i += "&callback=" + fs + "._rd._cbk" + kj;
      ki += "&callback=" + fs + "._rd._cbk" + kj;
      var kf = window.___abvk ? window.___abvk : jV.getSeckeyCidItem("SECKEY_ABVK");
      var e = jV.getSeckeyCidItem("BMAP_SECKEY");
      var kl = encodeURIComponent(kf + "," + e);
      var T = kf + "," + e;
      i += "&ak=" + eN + "&v=gl&seckey=" + kl + "&timeStamp=" + kh;
      ki += "&ak=" + eN + "&v=gl&seckey=" + T + "&timeStamp=" + kh;
      i += jm()(ki);
      gM.load(i);
    },
    getSeckeyCidItem: function (i) {
      if (navigator.cookieEnabled) {
        var T = new RegExp("(^| )" + i + "=([^;]*)(;|$)");
        var e = document.cookie.match(T);
        if (e) {
          return unescape(e[2]);
        }
        return -1;
      }
      if (localStorage) {
        return localStorage.getItem(i) ? localStorage.getItem(i) : -1;
      }
      if (sessionStorage) {
        return sessionStorage.getItem(i) ? localStorage.getItem(i) : -1;
      }
    }
  };
  window.srqtimer = null;
  window.firstTime = true;
  window.srqcount = 0;
  bx._rd = {};
  var dg = {
    request: function (i, kh) {
      var kd = new Date().getTime();
      var kg = (Math.random() * 100000).toFixed(0);
      if (kh) {
        BMapGL._rd["_cbk" + kg] = function (kj) {
          if (kh) {
            kh(kj);
          }
          delete BMapGL._rd["_cbk" + kg];
        };
        i += "&callback=BMapGL._rd._cbk" + kg;
      }
      function ke(kk) {
        var kj;
        var kl = new RegExp("(^| )" + kk + "=([^;]*)(;|$)");
        if (kj = document.cookie.match(kl)) {
          return unescape(kj[2]);
        } else {
          return -1;
        }
      }
      if (i.indexOf("v=") === -1) {
        i += "&v=gl";
      }
      var kc = window.___abvk ? window.___abvk : this.getSeckeyCidItem("SECKEY_ABVK");
      var e = this.getSeckeyCidItem("BMAP_SECKEY");
      var ki = encodeURIComponent(kc + "," + e);
      var T = kc + "," + e;
      signUrl = i + "&seckey=" + T + "&timeStamp=" + kd;
      i += "&seckey=" + ki + "&timeStamp=" + kd;
      i += jm()(signUrl);
      var kf = bX("script", {
        src: i,
        type: "text/javascript",
        charset: "utf-8"
      });
      if (kf.addEventListener) {
        kf.addEventListener("load", function (kk) {
          var kj = kk.target;
          kj.parentNode.removeChild(kj);
        }, false);
        kf.addEventListener("error", function (kj) {
          if (kh) {
            kh([,,,,,]);
          }
        }, false);
      } else if (kf.attachEvent) {
        kf.attachEvent("onreadystatechange", function (kk) {
          var kj = window.event.srcElement;
          if (kj && (kj.readyState == "loaded" || kj.readyState == "complete")) {
            kj.parentNode.removeChild(kj);
          }
        });
      }
      document.getElementsByTagName("head")[0].appendChild(kf);
      kf = null;
    },
    getSeckeyCidItem: function (i) {
      if (navigator.cookieEnabled) {
        var T = new RegExp("(^| )" + i + "=([^;]*)(;|$)");
        var e = document.cookie.match(T);
        if (e) {
          return unescape(e[2]);
        }
        return -1;
      }
      if (localStorage) {
        return localStorage.getItem(i) ? localStorage.getItem(i) : -1;
      }
      if (sessionStorage) {
        return sessionStorage.getItem(i) ? localStorage.getItem(i) : -1;
      }
    }
  };
  function gH() {
    this._map = null;
    this._container;
    this._type = "control";
    this.blockInfoWindow = true;
    this._visible = true;
  }
  gH.inherits(c8, "Control");
  eX.extend(gH.prototype, {
    initialize: function (e) {
      this._map = e;
      if (this._container) {
        if (this._opts && this._opts.container) {
          this._opts.container.appendChild(this._container);
        } else {
          e.container.appendChild(this._container);
        }
        return this._container;
      }
      return;
    },
    _i: function (e) {
      if (!this._container && this.initialize && bR(this.initialize)) {
        this._container = this.initialize(e);
      }
      this._opts = this._opts || {
        printable: false
      };
      this._setStyle();
      this._setPosition();
      if (this._container) {
        this._container._jsobj = this;
      }
    },
    _setStyle: function () {
      var i = this._container;
      if (i) {
        var e = i.style;
        e.position = "absolute";
        e.zIndex = this._cZIndex || "10";
        e.MozUserSelect = "none";
        if (!this._opts.printable) {
          eX.ac(i, "BMap_noprint");
        }
        eX.on(i, "contextmenu", ho);
      }
    },
    remove: function () {
      this._map = null;
      if (!this._container) {
        return;
      }
      if (this._container.parentNode) {
        this._container.parentNode.removeChild(this._container);
      }
      this._container._jsobj = null;
      this._container = null;
    },
    _render: function (e) {
      if (this._opts && this._opts.container) {
        this._container = bJ(this._opts.container, "<div unselectable=\"on\"></div>");
      } else {
        var i = "<div unselectable=\"on\"></div>";
        if (e && e.config.autoSafeArea && ct()) {
          this._safeAreaContainer = bJ(this._map.container, i);
          this._safeAreaContainer.style.position = "absolute";
          this._safeAreaContainer.style.bottom = "env(safe-area-inset-bottom)";
          this._container = bJ(this._safeAreaContainer, i);
        } else {
          this._container = bJ(this._map.container, i);
        }
      }
      if (this._visible === false) {
        this._container.style.display = "none";
      }
      return this._container;
    },
    _setPosition: function () {
      this.setAnchor(this._opts.anchor);
    },
    setAnchor: function (kc) {
      if (this.anchorFixed || typeof kc !== "number" || isNaN(kc) || kc < BMAP_ANCHOR_TOP_LEFT || kc > BMAP_ANCHOR_BOTTOM_RIGHT) {
        kc = this.defaultAnchor;
      }
      this._opts.offset = this._opts.offset || this.defaultOffset;
      var T = this._opts.anchor;
      this._opts.anchor = kc;
      if (!this._container) {
        return;
      }
      var ke = this._container;
      var e = this._opts.offset.width;
      var kd = this._opts.offset.height;
      ke.style.left = ke.style.top = ke.style.right = ke.style.bottom = "auto";
      switch (kc) {
        case BMAP_ANCHOR_TOP_LEFT:
          ke.style.top = kd + "px";
          ke.style.left = e + "px";
          break;
        case BMAP_ANCHOR_TOP_RIGHT:
          ke.style.top = kd + "px";
          ke.style.right = e + "px";
          break;
        case BMAP_ANCHOR_BOTTOM_LEFT:
          ke.style.bottom = kd + "px";
          ke.style.left = e + "px";
          break;
        case BMAP_ANCHOR_BOTTOM_RIGHT:
          ke.style.bottom = kd + "px";
          ke.style.right = e + "px";
          break;
        default:
          break;
      }
      var i = ["TL", "TR", "BL", "BR"];
      eX.rc(this._container, "anchor" + i[T]);
      eX.ac(this._container, "anchor" + i[kc]);
    },
    getAnchor: function () {
      return this._opts.anchor;
    },
    setOffset: function (e) {
      if (!e) {
        return;
      }
      this._opts = this._opts || {};
      this._opts.offset = new i0(e.width, e.height);
      if (!this._container) {
        return;
      }
      this.setAnchor(this._opts.anchor);
    },
    getOffset: function () {
      return this._opts.offset;
    },
    getDom: function () {
      return this._container;
    },
    show: function () {
      if (this._visible === true) {
        return;
      }
      this._visible = true;
      if (this._container) {
        this._container.style.display = "";
      }
      this.dispatchEvent(new fJ("onshow"));
    },
    hide: function () {
      if (this._visible === false) {
        return;
      }
      this._visible = false;
      if (this._container) {
        this._container.style.display = "none";
      }
      this.dispatchEvent(new fJ("onhide"));
    },
    isPrintable: function () {
      return !!this._opts.printable;
    },
    isVisible: function () {
      if (!this._container && !this._map) {
        return false;
      }
      return !!this._visible;
    },
    _asyncLoadCode: function () {
      var e = this;
      g2.load("control", function () {
        if (e._asyncDraw) {
          e._asyncDraw();
        }
      });
    }
  });
  var eg = {
    TOP_LEFT: 0,
    TOP_RIGHT: 1,
    BOTTOM_LEFT: 2,
    BOTTOM_RIGHT: 3
  };
  bx.ControlAnchor = eg;
  window.BMAP_ANCHOR_TOP_LEFT = 0;
  window.BMAP_ANCHOR_TOP_RIGHT = 1;
  window.BMAP_ANCHOR_BOTTOM_LEFT = 2;
  window.BMAP_ANCHOR_BOTTOM_RIGHT = 3;
  function f5(e) {
    gH.call(this);
    e = e || {};
    this._opts = {
      printable: false
    };
    eX.extend(this._opts, e);
    this._copyrightCollection = [];
    this.defaultAnchor = BMAP_ANCHOR_BOTTOM_LEFT;
    this.defaultOffset = new i0(5, 2);
    this.setAnchor(e.anchor);
    this._canShow = true;
    this.sateMapStyle = false;
    this.blockInfoWindow = false;
    this._asyncLoadCode();
  }
  f5.inherits(gH, "CopyrightControl");
  eX.extend(f5.prototype, {
    initialize: function (e) {
      this._map = e;
      return this._container;
    },
    addCopyright: function (kc) {
      var e = {
        minZoom: 0,
        bounds: null,
        content: "",
        mapType: ""
      };
      for (var T in kc) {
        e[T] = kc[T];
      }
      if (this._map) {
        var kf = e.minZoom;
        if (kf === -1 || kf < this._map.getMinZoom() || kf > this._map.getMaxZoom()) {
          e.minZoom = this._map.getMinZoom();
        }
        if (e.mapType !== "" && !ej[e.mapType]) {
          e.mapType = BMAPGL_NORMAL_MAP;
        }
      }
      var kd = this.getCopyright(kc.id);
      if (kd) {
        for (var ke in e) {
          kd[ke] = e[ke];
        }
      } else {
        this._copyrightCollection.push(e);
      }
    },
    getCopyright: function (kc) {
      for (var T = 0, e = this._copyrightCollection.length; T < e; T++) {
        if (this._copyrightCollection[T].id === kc) {
          return this._copyrightCollection[T];
        }
      }
    },
    addSateMapStyle: function () {
      this.sateMapStyle = true;
      if (this._container) {
        eX.ac(this._container, "BMap_cpyCtrl_w");
      }
    },
    removeSateMapStyle: function () {
      this.sateMapStyle = false;
      if (this._container) {
        eX.rc(this._container, "BMap_cpyCtrl_w");
      }
    }
  });
  function bs(e) {
    gH.call(this);
    e = e || {};
    this.canCheckSize = e.canCheckSize === false ? false : true;
    this.curCityName = "";
    this.curCityCode = "";
    this.defaultOffset = new i0(10, 10);
    this.defaultAnchor = eg.TOP_LEFT;
    this.onChangeBefore = [];
    this.onChangeAfter = [];
    this.onChangeSuccess = [];
    this._opts = {
      printable: false,
      offset: e.offset || this.defaultOffset,
      anchor: e.anchor || this.defaultAnchor,
      expand: !!e.expand
    };
    if (e.onChangeBefore && bR(e.onChangeBefore)) {
      this.onChangeBefore.push(e.onChangeBefore);
    }
    if (e.onChangeAfter && bR(e.onChangeAfter)) {
      this.onChangeAfter.push(e.onChangeAfter);
    }
    if (e.onChangeSuccess && bR(e.onChangeSuccess)) {
      this.onChangeSuccess.push(e.onChangeSuccess);
    }
    this.setAnchor(e.anchor);
    this._asyncLoadCode();
  }
  bs.inherits(gH, "CityListControl");
  eX.extend(bs.prototype, {
    initialize: function (e) {
      this._map = e;
      return this._container;
    }
  });
  function kb(e) {
    gH.call(this);
    e = e || {};
    this._opts = {
      printable: false
    };
    this._opts = eX.extend(eX.extend(this._opts, {
      unit: "metric"
    }), e);
    this.defaultAnchor = BMAP_ANCHOR_BOTTOM_LEFT;
    this.defaultOffset = new i0(81, 18);
    if (bW()) {
      this.defaultOffset = new i0(75, 10);
    }
    this.setAnchor(e.anchor);
    this._units = {
      metric: {
        name: "metric",
        conv: 1,
        incon: 1000,
        u1: "米",
        u2: "公里"
      },
      us: {
        name: "us",
        conv: 3.2808,
        incon: 5280,
        u1: "英尺",
        u2: "英里"
      }
    };
    this.sateMapStyle = false;
    if (!this._units[this._opts.unit]) {
      this._opts.unit = "metric";
    }
    this._scaleText = null;
    this._numberArray = {};
    this._asyncLoadCode();
  }
  window.BMAP_UNIT_METRIC = "metric";
  window.BMAP_UNIT_IMPERIAL = "us";
  kb.inherits(gH, "ScaleControl");
  eX.extend(kb.prototype, {
    initialize: function (e) {
      this._map = e;
      return this._container;
    },
    setUnit: function (e) {
      this._opts.unit = this._units[e] && this._units[e].name || this._opts.unit;
    },
    getUnit: function () {
      return this._opts.unit;
    },
    addSateMapStyle: function () {
      this.sateMapStyle = true;
      var e = this._container;
      if (e) {
        eX.ac(e.children[0], "dark");
      }
    },
    removeSateMapStyle: function () {
      this.sateMapStyle = false;
      var e = this._container;
      if (e) {
        eX.rc(e.children[0], "dark");
      }
    }
  });
  window.BMAP_NAVIGATION_CONTROL_LARGE = 0;
  window.BMAP_NAVIGATION_CONTROL_SMALL = 1;
  window.BMAP_NAVIGATION_CONTROL_PAN = 2;
  window.BMAP_NAVIGATION_CONTROL_ZOOM = 3;
  window.BMAP_NAVIGATION_CONTROL_ANIM = 4;
  function jH(e) {
    gH.call(this);
    e = e || {};
    this._opts = {
      printable: false
    };
    eX.extend(this._opts, e);
    this.controlHeight = [{
      width: 65,
      height: 227,
      zoomHeight: 227,
      zoomWidth: 37,
      sliderHeight: 180
    }, {
      width: 65,
      height: 47,
      zoomHeight: this._opts.forceNew === true ? 56 : 47,
      zoomWidth: 37,
      sliderHeight: 0
    }, {
      width: 37,
      height: 57,
      zoomHeight: 0,
      zoomWidth: 0,
      sliderHeight: 0
    }, {
      width: 26,
      height: 56,
      zoomHeight: 56,
      zoomWidth: 6,
      sliderHeight: 0
    }, {
      width: 56,
      height: 47,
      zoomHeight: 47,
      zoomWidth: 37,
      sliderHeight: 180
    }];
    this.defaultAnchor = BMAP_ANCHOR_TOP_LEFT;
    this.defaultOffset = new i0(10, 10);
    this.setAnchor(e.anchor);
    this.setType(e.type);
    this._maxTotalZoomLv = 19;
    this._minZoomLevel = -1;
    this._maxZoomLevel = -1;
    this._totalZoomLv = -1;
    this._sliderInterval = 10;
    this._sliderHeight = 180;
    this._minBarY = 1;
    this._maxBarY = -1;
    this._curBarY = -1;
    this._zoomDom = null;
    this._zoomBtnDom = null;
    this._sliderDom = null;
    this._sliderBaseDom = null;
    this._cZIndex = "1100";
    this._asyncLoadCode();
  }
  jH.inherits(gH, "NavigationControl");
  eX.extend(jH.prototype, {
    initialize: function (e) {
      this._map = e;
      return this._container;
    },
    setType: function (e) {
      if (typeof e == "number" && e >= BMAP_NAVIGATION_CONTROL_LARGE && e <= BMAP_NAVIGATION_CONTROL_ANIM) {
        this._opts.type = e;
      } else {
        this._opts.type = BMAP_NAVIGATION_CONTROL_LARGE;
      }
    },
    getType: function () {
      return this._opts.type;
    }
  });
  function v(i) {
    gH.call(this);
    i = i || {};
    this._opts = {
      printable: false
    };
    this.defaultAnchor = BMAP_ANCHOR_TOP_RIGHT;
    this.defaultOffset = new i0(10, 10);
    this.setAnchor(i.anchor);
    this._opts = eX.extend(eX.extend(this._opts, {
      offset: this.defaultOffset,
      enableSwitch: true
    }), i);
    var e = this;
    g2.load("control", function () {
      e._asyncDraw();
    });
  }
  v.inherits(gH, "MapTypeControl");
  eX.extend(v.prototype, {
    initialize: function (e) {
      this._map = e;
      return this._container;
    },
    showStreetLayer: function (e) {
      this._map.showStreetLayer(e);
    }
  });
  function jc(e) {
    gH.call(this);
    e = e || {};
    this._opts = {};
    this._opts = eX.extend(this._opts, e);
    this._zoomInDisabled = false;
    this._zoomOutDisabled = false;
    this._zoomInTapped = false;
    this._zoomOutTapped = false;
    this.defaultAnchor = eg.BOTTOM_RIGHT;
    this.defaultOffset = new i0(15, 20);
    this.setAnchor(e.anchor);
    this._asyncLoadCode();
  }
  jc.inherits(gH, "ZoomControl");
  eX.extend(jc.prototype, {
    initialize: function (e) {
      this._map = e;
      return this._container;
    }
  });
  function go(e) {
    gH.call(this);
    e = e || {};
    this._opts = {
      autoZoom: true,
      autoViewport: true
    };
    this._opts = eX.extend(this._opts, e);
    this.defaultAnchor = eg.BOTTOM_LEFT;
    this.defaultOffset = new i0(10, 50);
    this.watchPosition = this._opts.watchPosition || false;
    this.useCompass = this._opts.useCompass || false;
    this.locMarker = null;
    this.locLevel = 16;
    this.setAnchor(this._opts.anchor);
    this.onLocationStart = e.onLocationStart || null;
    this._asyncLoadCode();
  }
  go.inherits(gH, "LocationControl");
  eX.extend(go.prototype, {
    initialize: function (e) {
      this._map = e;
      return this._container;
    },
    startLocation: function () {
      this._startLocationCalled = true;
    },
    stopLocationTrace: function () {},
    setOptions: function (e) {
      e = e || {};
      eX.extend(this._opts, e);
    }
  });
  function bA(e) {
    gH.call(this);
    e = e || {};
    this._opts = {};
    this._opts = eX.extend(this._opts, e);
    this.defaultAnchor = eg.BOTTOM_LEFT;
    this.defaultOffset = new i0(5, 15);
    if (bW()) {
      this.defaultOffset = new i0(10, 10);
    }
    this.setAnchor(e.anchor);
  }
  bA.inherits(gH, "LogoControl");
  eX.extend(bA.prototype, {
    initialize: function (i) {
      this._map = i;
      var e = this._container = document.createElement("div");
      e.innerHTML = "<img src=\"" + B.apiHost + "/images/logo_hd.png\"  style=\"height:21px;width:62px;\"/>";
      i.getContainer().appendChild(e);
      return e;
    }
  });
  function au(e, i) {
    this._map = e;
    this._indoorInfo = i;
    this._visible = true;
    this._adjustVisible = true;
    this._isMobile = bW();
    this._sizeConfig = {
      FLOOR_BTN_HEIGHT: this._isMobile ? 35 : 26,
      SWITCH_ARROW_HEIGHT: this._isMobile ? 20 : 15
    };
    this._init();
  }
  au.prototype._init = function () {
    this._render();
    this._bindDom();
    this._bind();
    this._adjustDisplayHeight();
    var e = new fJ("onindoor_bar_show");
    e.uid = this._indoorInfo.uid;
    this._map.dispatchEvent(e);
  };
  au.prototype._render = function () {
    if (!this._indoorInfo) {
      return;
    }
    var kg = this._isMobile;
    var e = this._div = bX("div");
    eX.ac(e, "floor-select-container");
    if (kg) {
      eX.ac(e, "mobile");
    }
    if (kg) {
      eX.ac(e, "all-border-radius");
    }
    var i = this._btnTop = bX("button");
    eX.ac(i, "floor-switch-top");
    eX.ac(i, "top-border-radius");
    var ke = bX("div");
    eX.ac(ke, "floor-switch-top-icon");
    i.appendChild(ke);
    var kd = this._btnBottom = bX("button");
    var T = bX("div");
    eX.ac(T, "floor-switch-bottom-icon");
    kd.appendChild(T);
    eX.ac(kd, "floor-switch-bottom");
    eX.ac(kd, "bottom-border-radius");
    var kc = this._floorsContainer = bX("div");
    eX.ac(kc, "floors-container");
    kc.appendChild(this._createFloorsDom());
    this._div.appendChild(i);
    this._div.appendChild(kc);
    this._div.appendChild(kd);
    var kh = 0;
    if (this._btnTop.style.display === "") {
      kh = 2 * this._sizeConfig.SWITCH_ARROW_HEIGHT;
    }
    this._div.style.height = parseInt(this._floorsContainer.style.height, 10) + kh + "px";
    this._map.getContainer().appendChild(this._div);
    if (!kg) {
      var kf = this;
      setTimeout(function () {
        kf._div.style.right = "20px";
      }, 20);
    }
  };
  au.prototype._createFloorsDom = function () {
    if (!this._indoorInfo) {
      return;
    }
    var T = this._ol = bX("ol");
    var ke = this._indoorInfo.currentFloor;
    for (var kd = this._indoorInfo.floors.length - 1; kd >= 0; kd--) {
      var kf = this._indoorInfo.floors[kd].floorName;
      var e = bX("li");
      var kc = bX("button");
      eX.ac(kc, "btn-select-floor");
      if (kd === ke) {
        eX.ac(kc, "selected");
      }
      kc.setAttribute("data-floor", kd);
      kc.innerHTML = kf;
      e.appendChild(kc);
      T.appendChild(e);
    }
    return T;
  };
  au.prototype._updateUI = function () {
    if (!this._ol) {
      this._render();
      this._bind();
      this._adjustDisplayHeight();
      return;
    }
    this._ol = null;
    this._ol = this._createFloorsDom();
    this._floorsContainer.innerHTML = "";
    this._floorsContainer.appendChild(this._ol);
    this._adjustDisplayHeight();
  };
  au.prototype._bindDom = function () {
    var e = this;
    eX.on(this._floorsContainer, "click", function (kc) {
      var T = kc.target || kc.srcElement;
      if (T.tagName.toLowerCase() === "button") {
        e._map.showIndoor(e._indoorInfo.uid, parseInt(T.getAttribute("data-floor"), 10));
        var i = new fJ("onindoor_bar_click");
        i.uid = e._indoorInfo.uid;
        e._map.dispatchEvent(i);
      }
    });
    eX.on(this._floorsContainer, "mouseover", function (T) {
      var i = T.target;
      if (i.tagName.toLowerCase() === "button") {
        eX.ac(i, "hover");
      }
    });
    eX.on(this._floorsContainer, "mouseout", function (T) {
      var i = T.target;
      if (i.tagName.toLowerCase() === "button") {
        eX.rc(i, "hover");
      }
    });
    eX.on(this._floorsContainer, "touchstart", function (T) {
      var i = T.target;
      if (i.tagName.toLowerCase() === "button") {
        eX.ac(i, "onmousedown");
      }
    });
    eX.on(this._floorsContainer, "touchend", function (T) {
      var i = T.target;
      if (i.tagName.toLowerCase() === "button") {
        eX.rc(i, "onmousedown");
      }
    });
    eX.on(this._btnTop, "mouseover", function (i) {
      if (this._disable) {
        return;
      }
      eX.ac(this, "hover");
    });
    eX.on(this._btnTop, "mouseout", function (i) {
      eX.rc(this, "hover");
    });
    eX.on(this._btnBottom, "mouseover", function (i) {
      if (this._disable) {
        return;
      }
      eX.ac(this, "hover");
    });
    eX.on(this._btnBottom, "mouseout", function (i) {
      eX.rc(this, "hover");
    });
    eX.on(this._btnTop, "touchstart", function (i) {
      if (this.className.indexOf("disable") > -1) {
        return;
      }
      eX.ac(this, "onmousedown");
    });
    eX.on(this._btnTop, "touchend", function (i) {
      eX.rc(this, "onmousedown");
    });
    eX.on(this._btnBottom, "touchstart", function (i) {
      if (this.className.indexOf("disable") > -1) {
        return;
      }
      eX.ac(this, "onmousedown");
    });
    eX.on(this._btnBottom, "touchend", function (i) {
      eX.rc(this, "onmousedown");
    });
    eX.on(this._btnTop, "click", function (i) {
      e._setBarSliderTop(parseInt(e._ol.style.top, 10) + 26);
    });
    eX.on(this._btnBottom, "click", function (i) {
      e._setBarSliderTop(parseInt(e._ol.style.top, 10) - 26);
    });
    eX.on(this._div, "mousemove", ai);
    eX.on(this._div, "wheel", ho);
    eX.on(this._div, "mousewheel", ho);
    this._map.addEventListener("resize", function () {
      e._adjustDisplayHeight();
    });
  };
  au.prototype._adjustDisplayHeight = function () {
    if (!this._indoorInfo) {
      return;
    }
    var ke = this._map.getSize().height;
    var kf = this._sizeConfig.FLOOR_BTN_HEIGHT;
    var kg = ke - 291 - 100;
    if (this._isMobile) {
      kg = ke - 12 - 108 - this._map.config.bottomOffset;
    }
    var e = this._indoorInfo.floors.length;
    var T = e * kf;
    var kc = e;
    var ki = 0;
    var kj = this._floorsContainer.children[0];
    if (T > kg) {
      this._showArrow = true;
      eX.rc(kj.children[0].children[0], "top-border-radius");
      eX.rc(kj.children[e - 1].children[0], "bottom-border-radius");
    } else {
      this._showArrow = false;
      eX.ac(kj.children[0].children[0], "top-border-radius");
      eX.ac(kj.children[e - 1].children[0], "bottom-border-radius");
    }
    while (T > kg) {
      if (kc === 0) {
        break;
      }
      kc--;
      ki = 2 * this._sizeConfig.SWITCH_ARROW_HEIGHT;
      T = kc * kf + ki;
    }
    this._currentDisplayHeight = T;
    if (kc < 3) {
      this._setAdjustVisbile(false);
    } else {
      this._setAdjustVisbile(true);
    }
    this._floorsContainer.style.height = kc * kf + "px";
    var kd = this._indoorInfo.currentFloor;
    var i = e - kd;
    var kh = kd - 1;
    this._div.style.height = parseInt(this._floorsContainer.style.height, 10) + ki + "px";
    var kk = -(e - (kd + Math.round(kc / 2))) * kf;
    this._setBarSliderTop(kk);
    if (kc < e) {
      eX.show(this._btnTop);
      eX.show(this._btnBottom);
    } else {
      eX.hide(this._btnTop);
      eX.hide(this._btnBottom);
      this._setBarSliderTop(0);
    }
    if (this._isMobile) {
      this._div.style.bottom = 108 + this._map.config.bottomOffset + "px";
    }
  };
  au.prototype._setBarSliderTop = function (kc) {
    var T = 26;
    var i = this._indoorInfo.floors.length;
    var e = i * T;
    if (this._currentDisplayHeight) {
      if (this._showArrow) {
        e = this._currentDisplayHeight - 30;
      } else {
        e = this._currentDisplayHeight;
      }
    }
    if (e - kc >= i * T) {
      kc = e - i * T;
      eX.ac(this._btnBottom, "disable");
      eX.rc(this._btnBottom, "hover");
      this._btnBottom._disable = true;
    } else {
      eX.rc(this._btnBottom, "disable");
      this._btnBottom._disable = false;
    }
    if (kc >= 0) {
      kc = 0;
      eX.ac(this._btnTop, "disable");
      eX.rc(this._btnTop, "hover");
      this._btnTop._disable = true;
    } else {
      eX.rc(this._btnTop, "disable");
      this._btnTop._disable = false;
    }
    this._ol.style.top = kc + "px";
  };
  au.prototype._setAdjustVisbile = function (e) {
    if (this._adjustVisible === e) {
      return;
    }
    this._adjustVisible = e;
    if (e && this._visible) {
      this._div.style.right = "20px";
    } else {
      this._div.style.right = "-30px";
    }
  };
  au.prototype._bind = function () {
    var i = this._map;
    var e = this;
    i.on("indoor_status_changed", function (kg) {
      if (e._visible === false) {
        return;
      }
      var T = e._ol;
      var ke = kg.uid;
      if (!ke) {
        return;
      }
      var kf = kg.floor;
      for (var kd = 0; kd < T.children.length; kd++) {
        var kc = T.children[kd].children[0];
        if (parseInt(kc.getAttribute("data-floor"), 10) === kf) {
          eX.ac(kc, "selected");
        } else {
          eX.rc(kc, "selected");
        }
      }
    });
    i.on("zoomend", function (T) {
      if (this.getZoom() < 17) {
        e._setAdjustVisbile(false);
      } else {
        e._setAdjustVisbile(true);
      }
    });
  };
  au.prototype.setInfo = function (e) {
    if (this._indoorInfo && this._indoorInfo.uid === e.uid) {
      return;
    }
    this._indoorInfo = e;
    this._updateUI();
  };
  au.prototype.show = function () {
    if (this._visible === true) {
      return;
    }
    this._visible = true;
    if (!this._isMobile) {
      this._div.style.right = "20px";
    } else {
      this._div.style.display = "";
    }
    var e = new fJ("onindoor_bar_show");
    e.uid = this._indoorInfo.uid;
    this._map.dispatchEvent(e);
  };
  au.prototype.hide = function () {
    if (this._visible === false) {
      return;
    }
    this._visible = false;
    if (!this._isMobile) {
      this._div.style.right = "-30px";
    } else {
      this._div.style.display = "none";
    }
  };
  function eZ(e) {
    this._opts = e || {};
    this.defaultOffset = new i0(2, 80);
    this.defaultAnchor = BMAP_ANCHOR_TOP_RIGHT;
    if (this._opts.anchor === undefined) {
      this.setAnchor(this.defaultAnchor);
    } else {
      this.setAnchor(this._opts.anchor);
    }
    this._firstAnimation = true;
  }
  eZ.inherits(gH, "NavigationControl3D");
  eX.extend(eZ.prototype, {
    initialize: function (T) {
      this._map = T;
      this._createDom();
      this._bindDom();
      this._bind();
      if (!bW()) {
        this._headingControl = new iF(this._map, this._div);
      }
      this._tiltControl = new cS(this._map, this._div);
      this._render();
      var i = this._map.getMapType();
      var e = this;
      if (i === "B_EARTH_MAP" || this._map._renderType === "webgl") {
        e._div.style.opacity = "1";
        e._div.style.visibility = "visible";
      } else {
        e._div.style.opacity = "0";
        e._div.style.visibility = "hidden";
      }
      return this._container;
    },
    _createDom: function () {
      var i = this._div = document.createElement("div");
      this._container = i;
      var e = i.style;
      e.position = "absolute";
      e.zIndex = 5;
      e.width = "52px";
      e.height = "82px";
      e.right = "-3px";
      e.bottom = "79px";
      e.opacity = "0";
      e.visibility = "hidden";
      e.WebkitTransition = e.transition = "opacity .3s ease-out,visibility .3s ease-out";
    },
    _render: function () {
      var e = document.getElementById("map-operate");
      if (e) {
        e.appendChild(this._div);
      } else {
        this._map.getContainer().appendChild(this._div);
      }
    },
    _bindDom: function () {
      this._div.addEventListener("mousemove", ai);
    },
    _bind: function () {
      if (this._map._renderType === "webgl") {
        return;
      }
      var e = this;
      this._map.on("maptypechange", function () {
        if (this.mapType === "B_EARTH_MAP") {
          if (e._firstAnimation) {
            e._firstAnimation = false;
            setTimeout(function () {
              e._div.style.opacity = "1";
              e._div.style.visibility = "visible";
            }, 300);
          } else {
            e._div.style.opacity = "1";
            e._div.style.visibility = "visible";
          }
        } else {
          e._div.style.opacity = "0";
          e._div.style.visibility = "hidden";
        }
      });
    }
  });
  function iF(T, i) {
    this._map = T;
    this._target = T;
    var kc = T.temp.originMapType || T.mapType;
    if (kc === "B_EARTH_MAP" && T._earth) {
      this._target = T._earth;
    }
    this._outContainer = i || T.getContainer();
    this._imgRatio = gd() >= hK.HIGH_RES_MIN_RATIO ? 2 : 1;
    this._imgPath = B.imgPath + "earth-navi-control-pc4" + (this._imgRatio === 2 ? "-2x.png" : ".png");
    this._enabled = true;
    var e = this;
    this._setHeadingOptions = {
      callback: function () {
        e._target.setLock(false);
      }
    };
    this._init();
  }
  eX.extend(iF.prototype, {
    _init: function () {
      this._createDom();
      this._render();
      this._bindDom();
      this._bind();
      this._updateUI();
      this._checkEnable();
    },
    _checkEnable: function () {
      if (this._target.getZoom() >= this._target._enableHeadingZoom) {
        this.enable();
      } else {
        this.disable();
      }
    },
    _createDom: function () {
      var i = this._div = bX("div");
      var e = i.style;
      e.position = "absolute";
      e.zIndex = 5;
      e.top = "0";
      e.left = "0";
      e.width = "52px";
      e.height = "54px";
      e.background = "url(" + this._imgPath + ") no-repeat";
      e.backgroundSize = "266px auto";
      this._rotateCCW = this._createButton();
      this._rotateCCW.title = "逆时针转动";
      e = this._rotateCCW.style;
      e.left = "2px";
      e.top = "5px";
      e.zIndex = "1";
      e.width = "15px";
      e.height = "42px";
      e.backgroundPosition = "-75px -5px";
      this._rotateCW = this._createButton();
      this._rotateCW.title = "顺时针转动";
      e = this._rotateCW.style;
      e.right = "2px";
      e.top = "5px";
      e.zIndex = "1";
      e.width = "15px";
      e.height = "42px";
      e.backgroundPosition = "-75px -5px";
      e.WebkitTransform = e.transform = "scaleX(-1)";
      this._compass = this._createButton();
      this._compass.title = "恢复正北方向";
      e = this._compass.style;
      e.left = "19px";
      e.top = "4px";
      e.width = "14px";
      e.height = "44px";
      e.backgroundPosition = "-56px -4px";
      e.WebkitTransform = e.transform = "rotate(0deg)";
      this._div.appendChild(this._rotateCCW);
      this._div.appendChild(this._compass);
      this._div.appendChild(this._rotateCW);
      this._domRendered = true;
    },
    _createButton: function () {
      var e = bX("button");
      var i = e.style;
      i.position = "absolute";
      i.outline = "none";
      i.border = "none";
      i.background = "url(" + this._imgPath + ") no-repeat";
      i.backgroundSize = "266px auto";
      i.cursor = "pointer";
      return e;
    },
    _render: function () {
      this._outContainer.appendChild(this._div);
    },
    enable: function () {
      this._enabled = true;
      if (this._domRendered) {
        this._rotateCCW.style.cursor = "pointer";
        this._rotateCCW.style.opacity = 1;
        this._rotateCW.style.cursor = "pointer";
        this._rotateCW.style.opacity = 1;
        this._compass.style.cursor = "pointer";
        this._compass.style.opacity = 1;
      }
    },
    disable: function () {
      this._enabled = false;
      if (this._domRendered) {
        this._rotateCCW.style.cursor = "";
        this._rotateCCW.style.opacity = 0.4;
        this._rotateCW.style.cursor = "";
        this._rotateCW.style.opacity = 0.4;
        this._compass.style.cursor = "";
        this._compass.style.opacity = 0.4;
      }
    },
    _bindDom: function () {
      iy(this._div, ["mousedown", "click", "dblclick"]);
      var i = this._map;
      var e = this;
      this._rotateCW.addEventListener("click", function () {
        if (e._isOperating || e._enabled === false) {
          return;
        }
        if (e._target.getLock()) {
          return;
        }
        if (e._target.getHeading() === 360) {
          e._target.setHeading(0);
        }
        e._target.setLock(true);
        e._target.setHeading(e._target.getHeading() + 90, e._setHeadingOptions);
        i.fire(new fJ("onrotatecwclick"));
      }, false);
      this._rotateCCW.addEventListener("click", function () {
        if (e._isOperating || e._enabled === false) {
          return;
        }
        if (e._target.getLock()) {
          return;
        }
        if (e._target.getHeading() === -360) {
          e._target.setHeading(0);
        }
        e._target.setLock(true);
        e._target.setHeading(e._target.getHeading() - 90, e._setHeadingOptions);
        i.fire(new fJ("onrotateccwclick"));
      }, false);
      this._rotateCW.addEventListener("mouseover", function () {
        if (e._enabled === false) {
          return;
        }
        this.style.backgroundPosition = "-89px -5px";
      }, false);
      this._rotateCW.addEventListener("mouseout", function () {
        if (e._enabled === false) {
          return;
        }
        this.style.backgroundPosition = "-75px -5px";
      }, false);
      this._rotateCCW.addEventListener("mouseover", function () {
        if (e._enabled === false) {
          return;
        }
        this.style.backgroundPosition = "-89px -5px";
      }, false);
      this._rotateCCW.addEventListener("mouseout", function () {
        if (e._enabled === false) {
          return;
        }
        this.style.backgroundPosition = "-75px -5px";
      }, false);
      this._compass.addEventListener("click", function () {
        if (e._isOperating || e._enabled === false) {
          return;
        }
        if (e._target.getLock()) {
          return;
        }
        e._target.setLock(true);
        var T = false;
        if (e._target.getTilt() !== 0) {
          T = true;
          e._target.setTilt(0, e._setHeadingOptions);
        }
        if (e._target.getHeading() % 360 !== 0) {
          T = true;
          e._target.resetHeading(e._setHeadingOptions);
        }
        if (!T) {
          e._target.setLock(false);
        }
        i.fire(new fJ("oncompassclick"));
      }, false);
    },
    _bind: function () {
      var e = this;
      this._bindTarget(this._target);
      if (this._map._renderType === "webgl") {
        this._map.addEventListener("maptypechange", function (i) {
          if (this.mapType === "B_EARTH_MAP") {
            e._target = e._map._earth;
          } else {
            e._target = e._map;
          }
          e._bindTarget(e._target);
          e._checkEnable();
        });
      }
    },
    _bindTarget: function (i) {
      if (i === this._map && this._mapBinded) {
        return;
      }
      if (i === this._map._earth && this._earthBinded) {
        return;
      }
      var e = this;
      i.addEventListener("heading_changed", function (T) {
        e._updateUI();
      });
      i.addEventListener("animation_start", function (T) {
        e._isOperating = true;
      });
      i.addEventListener("animation_end", function (T) {
        e._isOperating = false;
      });
      i.on("load", function () {
        e._checkEnable();
      });
      i.on("zoom_changed", function () {
        e._checkEnable();
      });
      if (i === this._map) {
        this._mapBinded = true;
      } else {
        this._earthBinded = true;
      }
    },
    _updateUI: function () {
      var e = this._target.getHeading();
      var i = this._compass.style;
      i.WebkitTransform = i.transform = "rotate(" + e + "deg)";
    },
    hide: function () {
      this._div.style.display = "none";
    },
    show: function () {
      this._div.style.display = "block";
    }
  });
  function cS(T, i) {
    this._map = T;
    this._target = T;
    var kc = T.temp.originMapType || T.mapType;
    if (kc === "B_EARTH_MAP" && T._earth) {
      this._target = T._earth;
    }
    this._outContainer = i || T.getContainer();
    this._imgRatio = gd() >= hK.HIGH_RES_MIN_RATIO ? 2 : 1;
    this._imgPath = B.imgPath + "gl-navi-control-pc4" + (this._imgRatio === 2 ? "-2x.png" : ".png");
    this._enabled = true;
    var e = this;
    this._setTiltOptions = {
      callback: function () {
        e._target.setLock(false);
      }
    };
    this._init();
  }
  eX.extend(cS.prototype, {
    _init: function () {
      this._createDom();
      this._render();
      this._bindDom();
      this._bind();
      this._checkEnable();
    },
    _checkEnable: function () {
      if (this._target.getZoom() >= this._target._enableTiltZoom) {
        this.enable();
      } else {
        this.disable();
      }
    },
    _createDom: function () {
      var e = this._div = bX("button");
      e.title = "倾斜";
      var i = e.style;
      i.position = "absolute";
      i.zIndex = 5;
      i.outline = "none";
      i.border = "none";
      i.cursor = "pointer";
      i.width = "26px";
      i.height = "26px";
      i.top = "56px";
      i.right = "13px";
      i.background = "url(" + this._imgPath + ") no-repeat #fff";
      i.backgroundSize = "266px auto";
      i.backgroundPosition = "-110px 1px";
      i.boxShadow = "1px 2px 1px rgba(0, 0, 0, 0.15)";
    },
    enable: function () {
      this._enabled = true;
      if (this._div) {
        this._div.style.cursor = "pointer";
      }
      this._updateUI();
    },
    disable: function () {
      this._enabled = false;
      if (this._div) {
        this._div.style.cursor = "";
      }
      this._updateUI();
    },
    _render: function () {
      this._outContainer.appendChild(this._div);
    },
    _bindDom: function () {
      var e = this;
      this._div.addEventListener("mousedown", function (kc) {
        if (!e._enabled) {
          return;
        }
        if (e._target.getLock()) {
          return;
        }
        var i = e._target.getTilt();
        var T;
        if (i === e._map.getCurrentMaxTilt()) {
          T = "out";
        } else if (i === 0) {
          T = "in";
        } else {
          T = e._preTrend ? e._preTrend : "in";
        }
        e._curTrend = T;
        e._clickTimer = setTimeout(function () {
          e._map.fire(new fJ("ontiltmsdown"));
          e._tiltAni = new fy({
            duration: 9999999,
            render: function (kd) {
              i = e._target.getTilt();
              if (T === "in" && i < e._map.getCurrentMaxTilt()) {
                e._target.setTilt(i + 1, {
                  noAnimation: true
                });
              } else if (T === "out" && i > 0) {
                e._target.setTilt(i - 1, {
                  noAnimation: true
                });
              }
            },
            finish: function () {
              e._tiltAni = null;
            }
          });
          e._clickTimer = null;
        }, 200);
        kc.stopPropagation();
      }, false);
      this._div.addEventListener("mouseup", function (i) {
        if (!e._enabled) {
          return;
        }
        if (e._tiltAni) {
          e._tiltAni.stop();
        }
        e._preTrend = e._curTrend;
      }, false);
      this._div.addEventListener("click", function (kc) {
        if (!e._enabled) {
          return;
        }
        if (!e._clickTimer) {
          return;
        }
        if (e._target.getLock()) {
          return;
        }
        clearTimeout(e._clickTimer);
        e._map.fire(new fJ("ontiltclick"));
        var i = e._target.getTilt();
        e._target.setLock(true);
        kc.stopPropagation();
        var T = e._map.getCurrentMaxTilt();
        if (e._curTrend === "in") {
          e._target.setTilt(T, e._setTiltOptions);
        } else if (e._curTrend === "out") {
          e._target.setTilt(0, e._setTiltOptions);
        } else if (i < T) {
          e._target.setTilt(T, e._setTiltOptions);
        } else {
          e._target.setTilt(0, e._setTiltOptions);
        }
      }, false);
      this._div.addEventListener("mouseover", function (i) {
        if (!e._enabled) {
          return;
        }
        e._mouseOver = true;
        e._updateUI();
      }, false);
      this._div.addEventListener("mouseout", function (i) {
        if (!e._enabled) {
          return;
        }
        e._mouseOver = false;
        e._updateUI();
      }, false);
      iy(this._div, ["mousedown", "click", "dblclick"]);
    },
    _bind: function () {
      var e = this;
      var i = this._map;
      this._bindTarget(this._target);
      if (this._map._renderType === "webgl") {
        this._map.addEventListener("maptypechange", function (T) {
          if (this.mapType === "B_EARTH_MAP") {
            e._target = e._map._earth;
          } else {
            e._target = e._map;
          }
          e._bindTarget(e._target);
          e._checkEnable();
        });
      }
    },
    _bindTarget: function (i) {
      if (i === this._map && this._mapBinded) {
        return;
      }
      if (i === this._map._earth && this._earthBinded) {
        return;
      }
      var e = this;
      i.on("load", function () {
        e._checkEnable();
      });
      i.on("zoom_changed", function () {
        e._checkEnable();
      });
      i.on("tilt_changed", function () {
        e._updateUI();
      });
      if (i === this._map) {
        this._mapBinded = true;
      } else {
        this._earthBinded = true;
      }
    },
    _updateUI: function () {
      var T = this._target.getTilt();
      var i = 0;
      var kc = 0;
      var e = 0;
      if (T > 0) {
        i = 78;
      }
      if (this._mouseOver) {
        e = 52;
      }
      if (this._enabled === false) {
        kc = 26;
        e = 0;
        i = 0;
      }
      var kd = "-" + (110 + i + kc + e) + "px 1px";
      if (this._div) {
        this._div.style.backgroundPosition = kd;
      }
      if (this._enabled) {
        if (T > 0) {
          if (this._div) {
            this._div.title = "恢复";
          }
        } else if (this._div) {
          this._div.title = "倾斜";
        }
      } else if (this._div) {
        this._div.title = "请放大地图后操作";
      }
    },
    hide: function () {
      this._div.style.display = "none";
    },
    show: function () {
      this._div.style.display = "block";
    }
  });
  function hm(i) {
    c8.call(this);
    this._opts = {
      container: null,
      cursor: "default",
      marker: true
    };
    this._opts = eX.extend(this._opts, i);
    this._type = "contextmenu";
    this._map = null;
    this._container;
    this._left = 0;
    this._top = 0;
    this._items = [];
    this._rItems = [];
    this._dividers = [];
    this._enable = true;
    this.curPixel = null;
    this.curPoint = null;
    this._isOpen = false;
    var e = this;
    g2.load("menu", function () {
      e._draw();
    });
  }
  hm.inherits(c8, "ContextMenu");
  eX.extend(hm.prototype, {
    initialize: function (i, e) {
      this._map = i;
      this._overlay = e || null;
    },
    remove: function () {
      this._map = this._overlay = null;
    },
    addItem: function (kd, e) {
      if (!kd || kd._type != "menuitem" || kd._text == "" || kd._width <= 0) {
        return;
      }
      for (var kc = 0, T = this._items.length; kc < T; kc++) {
        if (this._items[kc] === kd) {
          return;
        }
      }
      if (e === undefined || e > this._items.length - 1) {
        e = -1;
      }
      kd._insertIndex = e;
      if (e === -1) {
        this._items.push(kd);
        this._rItems.push(kd);
      } else {
        this._items.splice(e, 0, kd);
        this._rItems.splice(e, 0, kd);
      }
    },
    removeItem: function (kc) {
      if (!kc || kc._type != "menuitem") {
        return;
      }
      for (var T = 0, e = this._items.length; T < e; T++) {
        if (this._items[T] === kc) {
          this._items[T].remove();
          this._items.splice(T, 1);
          delete kc._insertIndex;
          e--;
        }
      }
      for (var T = 0, e = this._rItems.length; T < e; T++) {
        if (this._rItems[T] === kc) {
          this._rItems[T].remove();
          this._rItems.splice(T, 1);
          delete kc._insertIndex;
          e--;
        }
      }
    },
    addSeparator: function (e) {
      if (e === undefined || e > this._items.length - 1) {
        e = -1;
      }
      var i = {
        _type: "divider",
        _dIndex: this._dividers.length,
        _insertIndex: e
      };
      this._dividers.push({
        dom: null
      });
      if (e === -1) {
        this._items.push(i);
      } else {
        this._items.splice(e, 0, i);
      }
    },
    removeSeparator: function (T) {
      if (!this._dividers[T]) {
        return;
      }
      for (var kc = 0, e = this._items.length; kc < e; kc++) {
        if (this._items[kc] && this._items[kc]._type == "divider" && this._items[kc]._dIndex == T) {
          this._items.splice(kc, 1);
          e--;
        }
        if (this._items[kc] && this._items[kc]._type == "divider" && this._items[kc]._dIndex > T) {
          this._items[kc]._dIndex--;
        }
      }
      this._dividers.splice(T, 1);
    },
    getDom: function () {
      return this._container;
    },
    show: function () {
      if (this._isOpen == true) {
        return;
      }
      this._isOpen = true;
    },
    hide: function () {
      if (this._isOpen == false) {
        return;
      }
      this._isOpen = false;
    },
    setCursor: function (e) {
      if (!e) {
        return;
      }
      this._opts.cursor = e;
    },
    getItem: function (e) {
      return this._rItems[e];
    },
    enable: function () {
      this._enable = true;
    },
    disable: function () {
      this._enable = false;
    }
  });
  function hW(T, kc, i) {
    if (!T || !kc || typeof kc != "function") {
      return;
    }
    c8.call(this);
    this._opts = {
      width: 100,
      id: ""
    };
    i = i || {};
    this._opts.width = i.width * 1 ? i.width : 100;
    this._opts.id = i.id ? i.id : "";
    this._text = T + "";
    this._callback = kc;
    this._map = null;
    this._type = "menuitem";
    this._contextmenu = null;
    this._container = null;
    this._enabled = true;
    var e = this;
    g2.load("menu", function () {
      e._draw();
    });
  }
  hW.inherits(c8, "MenuItem");
  eX.extend(hW.prototype, {
    initialize: function (e, i) {
      this._map = e;
      this._contextmenu = i;
    },
    remove: function () {
      this._contextmenu = null;
      this._map = null;
    },
    setText: function (e) {
      if (!e) {
        return;
      }
      this._text = e + "";
    },
    getDom: function () {
      return this._container;
    },
    enable: function () {
      this._enabled = true;
    },
    disable: function () {
      this._enabled = false;
    }
  });
  function hY(e, i) {
    this.setSouthWest(e);
    this.setNorthEast(i);
  }
  eX.extend(hY.prototype, {
    isEmpty: function () {
      return this.sw === null && this.ne === null;
    },
    equals: function (e) {
      if (!e || e.isEmpty() || this.isEmpty()) {
        return false;
      }
      return this.sw.equals(e.sw) && this.ne.equals(e.ne);
    },
    containsBounds: function (e) {
      if (!e || e.isEmpty() || this.isEmpty()) {
        return false;
      }
      return e.sw.lng > this.sw.lng && e.ne.lng < this.ne.lng && e.sw.lat > this.sw.lat && e.ne.lat < this.ne.lat;
    },
    getCenter: function () {
      if (this.isEmpty()) {
        return null;
      }
      return new cx((this.sw.lng + this.ne.lng) / 2, (this.sw.lat + this.ne.lat) / 2);
    },
    intersects: function (T) {
      if (!T || T.isEmpty() || this.isEmpty()) {
        return null;
      }
      if (Math.max(T.sw.lng, T.ne.lng) < Math.min(this.sw.lng, this.ne.lng) || Math.min(T.sw.lng, T.ne.lng) > Math.max(this.sw.lng, this.ne.lng) || Math.max(T.sw.lat, T.ne.lat) < Math.min(this.sw.lat, this.ne.lat) || Math.min(T.sw.lat, T.ne.lat) > Math.max(this.sw.lat, this.ne.lat)) {
        return null;
      }
      var kd = Math.max(this.sw.lng, T.sw.lng);
      var i = Math.min(this.ne.lng, T.ne.lng);
      var kc = Math.max(this.sw.lat, T.sw.lat);
      var e = Math.min(this.ne.lat, T.ne.lat);
      return new hY(new cx(kd, kc), new cx(i, e));
    },
    setMinMax: function () {
      this.minX = this.sw ? this.sw.lng : null;
      this.minY = this.sw ? this.sw.lat : null;
      this.maxX = this.ne ? this.ne.lng : null;
      this.maxY = this.ne ? this.ne.lat : null;
    },
    containsPoint: function (e) {
      if (!e) {
        return;
      }
      return e.lng >= this.sw.lng && e.lng <= this.ne.lng && e.lat >= this.sw.lat && e.lat <= this.ne.lat;
    },
    extend: function (e) {
      if (!e) {
        return;
      }
      var i = e.lng;
      var T = e.lat;
      if (!this.sw) {
        this.sw = e.clone();
      }
      if (!this.ne) {
        this.ne = e.clone();
      }
      if (this.sw.lng > i) {
        this.sw.lng = i;
      }
      if (this.ne.lng < i) {
        this.ne.lng = i;
      }
      if (this.sw.lat > T) {
        this.sw.lat = T;
      }
      if (this.ne.lat < T) {
        this.ne.lat = T;
      }
    },
    getMin: function () {
      return this.sw;
    },
    getMax: function () {
      return this.ne;
    },
    getSouthWest: function () {
      return this.sw;
    },
    getNorthEast: function () {
      return this.ne;
    },
    setSouthWest: function (e) {
      this.sw = e ? e.clone() : null;
    },
    setNorthEast: function (e) {
      this.ne = e ? e.clone() : null;
    },
    clone: function () {
      return new hY(this.sw, this.ne);
    },
    toSpan: function () {
      if (this.isEmpty()) {
        return new i0(0, 0);
      }
      return new i0(Math.abs(this.ne.lng - this.sw.lng), Math.abs(this.ne.lat - this.sw.lat));
    },
    div: function (e) {
      if (!e || e.isEmpty() || this.isEmpty()) {
        return 0;
      }
      return (this.ne.lng - this.sw.lng) * (this.ne.lat - this.sw.lat) / ((e.ne.lng - e.sw.lng) * (e.ne.lat - e.sw.lat));
    },
    makeNormalizedPoint: function (e) {
      this.normalizedTopLeft = this.pointTopLeft.clone();
      this.normalizedTopRight = this.pointTopRight.clone();
      this.normalizedBottomRight = this.pointBottomRight.clone();
      this.normalizedBottomLeft = this.pointBottomLeft.clone();
      while (e < 0) {
        e += 360;
      }
      e = e % 360;
      if (e >= 0 && e < 90 || e >= 270 && e < 360) {
        if (this.normalizedTopRight.lng < this.normalizedTopLeft.lng) {
          this.normalizedTopRight.lng += hK.WORLD_SIZE_MC;
        }
        if (this.normalizedBottomRight.lng < this.normalizedBottomLeft.lng) {
          this.normalizedBottomRight.lng += hK.WORLD_SIZE_MC;
        }
      } else {
        if (this.normalizedTopLeft.lng < this.normalizedTopRight.lng) {
          this.normalizedTopLeft.lng += hK.WORLD_SIZE_MC;
        }
        if (this.normalizedBottomLeft.lng < this.normalizedBottomRight.lng) {
          this.normalizedBottomLeft.lng += hK.WORLD_SIZE_MC;
        }
      }
    },
    toString: function () {
      return "Bounds";
    }
  });
  function cx(e, i) {
    if (isNaN(e)) {
      e = dj(e);
      e = isNaN(e) ? 0 : e;
    }
    if (typeof e === "string") {
      e = parseFloat(e);
    }
    if (isNaN(i)) {
      i = dj(i);
      i = isNaN(i) ? 0 : i;
    }
    if (typeof i === "string") {
      i = parseFloat(i);
    }
    this.lng = e;
    this.lat = i;
  }
  cx.prototype.equals = function (i) {
    if (!i) {
      return false;
    }
    var kc = Math.abs(this.lat - i.lat);
    var T = Math.abs(this.lng - i.lng);
    var e = 1e-8;
    if (kc < e && T < e) {
      return true;
    }
    return false;
  };
  cx.prototype.similar = function (i) {
    if (!i) {
      return false;
    }
    var kc = Math.abs(this.lat - i.lat);
    var T = Math.abs(this.lng - i.lng);
    var e = 0.00001;
    if (kc < e && T < e) {
      return true;
    }
    return false;
  };
  cx.prototype.clone = function () {
    return new cx(this.lng, this.lat);
  };
  cx.prototype.add = function (e) {
    return new cx(this.lng + e.lng, this.lat + e.lat);
  };
  cx.prototype.sub = function (e) {
    return new cx(this.lng - e.lng, this.lat - e.lat);
  };
  cx.prototype.mult = function (e) {
    return new cx(this.lng * e, this.lat * e);
  };
  cx.prototype.div = function (e) {
    return new cx(this.lng / e, this.lat / e);
  };
  cx.prototype.mag = function () {
    return Math.sqrt(this.lng * this.lng + this.lat * this.lat);
  };
  cx.prototype.toString = function () {
    return "Point";
  };
  cx.serialize = function (i, e) {
    return [i.lng, i.lat];
  };
  cx.deserialize = function (e) {
    return new cx(e[0], e[1]);
  };
  cx.prototype.toGeoJSON = function () {
    var i = "Point";
    var T = [this.lng, this.lat];
    var e = {
      type: "Feature",
      geometry: {
        type: i,
        coordinates: T
      },
      properties: this.properties
    };
    return e;
  };
  function i9() {}
  eX.extend(i9, {
    EARTHRADIUS: 6370996.81,
    MCBAND: [12890594.86, 8362377.87, 5591021, 3481989.83, 1678043.12, 0],
    LLBAND: [86, 60, 45, 30, 15, 0],
    MC2LL: [[1.410526172116255e-8, 0.00000898305509648872, -1.9939833816331, 200.9824383106796, -187.2403703815547, 91.6087516669843, -23.38765649603339, 2.57121317296198, -0.03801003308653, 17337981.2], [-7.435856389565537e-9, 0.000008983055097726239, -0.78625201886289, 96.32687599759846, -1.85204757529826, -59.36935905485877, 47.40033549296737, -16.50741931063887, 2.28786674699375, 10260144.86], [-3.030883460898826e-8, 0.00000898305509983578, 0.30071316287616, 59.74293618442277, 7.357984074871, -25.38371002664745, 13.45380521110908, -3.29883767235584, 0.32710905363475, 6856817.37], [-1.981981304930552e-8, 0.000008983055099779535, 0.03278182852591, 40.31678527705744, 0.65659298677277, -4.44255534477492, 0.85341911805263, 0.12923347998204, -0.04625736007561, 4482777.06], [3.09191371068437e-9, 0.000008983055096812155, 0.00006995724062, 23.10934304144901, -0.00023663490511, -0.6321817810242, -0.00663494467273, 0.03430082397953, -0.00466043876332, 2555164.4], [2.890871144776878e-9, 0.000008983055095805407, -3.068298e-8, 7.47137025468032, -0.00000353937994, -0.02145144861037, -0.00001234426596, 0.00010322952773, -0.00000323890364, 826088.5]],
    LL2MC: [[-0.0015702102444, 111320.7020616939, 1704480524535203, -10338987376042340, 26112667856603880, -35149669176653700, 26595700718403920, -10725012454188240, 1800819912950474, 82.5], [0.0008277824516172526, 111320.7020463578, 647795574.6671607, -4082003173.641316, 10774905663.51142, -15171875531.51559, 12053065338.62167, -5124939663.577472, 913311935.9512032, 67.5], [0.00337398766765, 111320.7020202162, 4481351.045890365, -23393751.19931662, 79682215.47186455, -115964993.2797253, 97236711.15602145, -43661946.33752821, 8477230.501135234, 52.5], [0.00220636496208, 111320.7020209128, 51751.86112841131, 3796837.749470245, 992013.7397791013, -1221952.21711287, 1340652.697009075, -620943.6990984312, 144416.9293806241, 37.5], [-0.0003441963504368392, 111320.7020576856, 278.2353980772752, 2485758.690035394, 6070.750963243378, 54821.18345352118, 9540.606633304236, -2710.55326746645, 1405.483844121726, 22.5], [-0.0003218135878613132, 111320.7020701615, 0.00369383431289, 823725.6402795718, 0.46104986909093, 2351.343141331292, 1.58060784298199, 8.77738589078284, 0.37238884252424, 7.45]],
    getDistanceByMC: function (ke, kc) {
      if (!ke || !kc) {
        return 0;
      }
      var i;
      var kd;
      var e;
      var T;
      ke = this.convertMC2LL(ke);
      if (!ke) {
        return 0;
      }
      i = iB(ke.lng);
      kd = iB(ke.lat);
      kc = this.convertMC2LL(kc);
      if (!kc) {
        return 0;
      }
      e = iB(kc.lng);
      T = iB(kc.lat);
      return this.getDistance(i, e, kd, T);
    },
    getDistanceByLL: function (ke, kc) {
      if (!ke || !kc) {
        return 0;
      }
      ke.lng = this.getLoop(ke.lng, -180, 180);
      ke.lat = this.getRange(ke.lat, -80, 84);
      kc.lng = this.getLoop(kc.lng, -180, 180);
      kc.lat = this.getRange(kc.lat, -80, 84);
      var i;
      var e;
      var kd;
      var T;
      i = iB(ke.lng);
      kd = iB(ke.lat);
      e = iB(kc.lng);
      T = iB(kc.lat);
      return this.getDistance(i, e, kd, T);
    },
    proximityCovertMC2LL: function (e) {
      if (e === null) {
        return e;
      }
      if (e.lng < 180 && e.lng > -180 && e.lat < 90 && e.lat > -90) {
        return e;
      }
      return this.convertMC2LL(e);
    },
    convertMC2LL: function (e) {
      if (e === null) {
        return e;
      }
      if (!e) {
        return new cx(0, 0);
      }
      var T;
      var kd;
      T = new cx(Math.abs(e.lng), Math.abs(e.lat));
      for (var kc = 0; kc < this.MCBAND.length; kc++) {
        if (T.lat >= this.MCBAND[kc]) {
          kd = this.MC2LL[kc];
          break;
        }
      }
      var ke = this.convertor(e, kd);
      return new cr(ke.lat, ke.lng);
    },
    convertLL2MC: function (kf) {
      if (!kf) {
        return new cx(0, 0);
      }
      var kh = kf.lat;
      var kc = kf.lng;
      kc = this.getLoop(kf.lng, -180, 180);
      kh = cb(kh, -85, 85);
      var ke;
      for (var kd = 0; kd < this.LLBAND.length; kd++) {
        if (kh >= this.LLBAND[kd]) {
          ke = this.LL2MC[kd];
          break;
        }
      }
      if (!ke) {
        for (kd = 0; kd < this.LLBAND.length; kd++) {
          if (kh <= -this.LLBAND[kd]) {
            ke = this.LL2MC[kd];
            break;
          }
        }
      }
      var T = new cx(kc, kh);
      var kg = this.convertor(T, ke);
      var e = new cx(kg.lng, kg.lat);
      e.latLng = new cr(kf.lat, kf.lng);
      return e;
    },
    convertor: function (T, kc) {
      if (!T || !kc) {
        return;
      }
      var e = kc[0] + kc[1] * Math.abs(T.lng);
      var i = Math.abs(T.lat) / kc[9];
      var kd = kc[2] + kc[3] * i + kc[4] * i * i + kc[5] * i * i * i + kc[6] * i * i * i * i + kc[7] * i * i * i * i * i + kc[8] * i * i * i * i * i * i;
      e *= T.lng < 0 ? -1 : 1;
      kd *= T.lat < 0 ? -1 : 1;
      return new cx(e, kd);
    },
    getDistance: function (i, e, kc, T) {
      return this.EARTHRADIUS * Math.acos(Math.sin(kc) * Math.sin(T) + Math.cos(kc) * Math.cos(T) * Math.cos(e - i));
    },
    getRange: function (T, i, e) {
      if (i != null) {
        T = Math.max(T, i);
      }
      if (e != null) {
        T = Math.min(T, e);
      }
      return T;
    },
    getLoop: function (T, i, e) {
      while (T > e) {
        T -= e - i;
      }
      while (T < i) {
        T += e - i;
      }
      return T;
    },
    tileToBoundRange: function (T) {
      var i = T.col;
      var kj = T.row;
      var ki = T.baseTileSize;
      var kg = Math.pow(2, 18 - T.zoom);
      var ke = {
        lbx: i * ki,
        lby: kj * ki,
        rtx: (i + 1) * ki,
        rty: (kj + 1) * ki
      };
      var e = {
        lbx: ke.lbx * kg,
        lby: ke.lby * kg,
        rtx: ke.rtx * kg,
        rty: ke.rty * kg
      };
      var kh = new cx(e.lbx, e.lby);
      var kd = new cx(e.rtx, e.rty);
      var kc = this.convertMC2LL(kh);
      var kf = this.convertMC2LL(kd);
      return {
        MC: new hY(kh, kd),
        LL: new hY(kc, kf)
      };
    }
  });
  eX.extend(i9.prototype, {
    lnglatToMercator: function (e) {
      return i9.convertLL2MC(e);
    },
    lngLatToPoint: function (e) {
      var i = i9.convertLL2MC(e);
      return new fi(i.lng, i.lat);
    },
    mercatorToLnglat: function (e) {
      return i9.convertMC2LL(e);
    },
    pointToLngLat: function (i) {
      var e = new cx(i.x, i.y);
      var T = i9.convertMC2LL(e);
      return new cr(T.lat, T.lng);
    },
    pointToPixel: function (i, ke, kd, kc) {
      if (!i) {
        return;
      }
      i = this.lnglatToMercator(i);
      var T = this.getZoomUnits(ke);
      var e = Math.round((i.lng - kd.lng) / T + kc.width / 2);
      var kf = Math.round((kd.lat - i.lat) / T + kc.height / 2);
      return new fi(e, kf);
    },
    mercatorToPixel: function (ke, kd, kc, T) {
      if (!ke) {
        return;
      }
      var i = this.getZoomUnits(kd);
      var e = Math.round((ke.lng - kc.lng) / i + T.width / 2);
      var kf = Math.round((kc.lat - ke.lat) / i + T.height / 2);
      return new fi(e, kf);
    },
    pixelToPoint: function (kc, kf, ke, kd) {
      if (!kc) {
        return;
      }
      var i = this.getZoomUnits(kf);
      var T = ke.lng + i * (kc.x - kd.width / 2);
      var kg = ke.lat - i * (kc.y - kd.height / 2);
      var e = new cx(T, kg);
      return this.mercatorToLnglat(e);
    },
    tileToBound: function (kc, kg) {
      var i = kc.col;
      var kj = kc.row;
      var ki = kc.baseTileSize;
      var kh = this.getZoomUnits(kc.zoom);
      var T = {
        x: Math.round(kg.lng / kh),
        y: Math.round(kg.lat / kh)
      };
      var ke = {
        lbx: i * ki,
        lby: kj * ki,
        rtx: (i + 1) * ki,
        rty: (kj + 1) * ki
      };
      var e = {
        lbx: kg.lng + (ke.lbx - T.x) * kh,
        lby: kg.lat + (ke.lby - T.y) * kh,
        rtx: kg.lng + (ke.rtx - T.x) * kh,
        rty: kg.lat + (ke.rty - T.y) * kh
      };
      var kd = i9.convertMC2LL(new cx(e.lbx, e.lby));
      var kf = i9.convertMC2LL(new cx(e.rtx, e.rty));
      return {
        MC: new hY(new cx(e.lbx, e.lby), new cx(e.rtx, e.rty)),
        LL: new hY(kd, kf)
      };
    },
    getZoomUnits: function (e) {
      return Math.pow(2, 18 - e);
    },
    setCoordType: function (e) {
      this.coordsType = e;
    }
  });
  function dB() {}
  eX.extend(dB, {
    RADIUS: 6378137,
    EXTENT4326: [-180, -90, 180, 90],
    WORLD_EXTENT: [-180, -85, 180, 85],
    HALF_SIZE: 20037508.342789244,
    METERS_PER_UNIT: 111319.49079327358,
    EXTENT3857: [-20037508.342789244, -20037508.342789244, 20037508.342789244, 20037508.342789244],
    MAX_SAFE_Y: 238107693.26496765,
    origin: [-20037508.342789244, 20037508.342789244],
    size: 156543.03392804097,
    gridSize: [256, 256],
    resolutions: [156543.03392804097, 78271.51696402048, 39135.75848201024, 19567.87924100512, 9783.93962050256, 4891.96981025128, 2445.98490512564, 1222.99245256282, 611.49622628141, 305.748113140705, 152.8740565703525, 76.43702828517625, 38.21851414258813, 19.109257071294063, 9.554628535647032, 4.777314267823516, 2.388657133911758, 1.194328566955879, 0.5971642834779395, 0.29858214173896974, 0.14929107086948487, 0.07464553543474244, 0.03732276771737122],
    gridScaleFrom3857ToBDMC: 0.5971642834779395,
    gridScaleFromBDMCTo3857: 1.674581061974954,
    calcResolutions: function (i) {
      if (this.resolutions.length - 1 < i) {
        this.resolutions = [];
        for (var e = 0; e < i; ++e) {
          this.resolutions.push(this.size / Math.pow(2, e));
        }
      }
      return this.resolutions;
    },
    forEachTileCoord: function (ki, kh, T, kf) {
      var e = this.getTileRangeForExtentFactory(ki, kh, T);
      for (var kd = e.minX, kg = e.maxX; kd <= kg; ++kd) {
        for (var kc = e.minY, ke = e.maxY; kc <= ke; ++kc) {
          kf([kh, kd, kc]);
        }
      }
    },
    getTileRangeForExtentFactory: function (T, kd, i, kc) {
      var e;
      switch (i.source) {
        case "BD09MC":
          if (i.target === "EPSG3857") {
            e = this.getBDTileRangeForExtentAndZ(T, kd, kc);
          } else {
            e = this.getTileRangeForExtentAndZ(T, kd, kc);
          }
          break;
        case "EPSG3857":
          e = this.getTileRangeForExtentAndZ(T, kd, kc);
          break;
        default:
          e = this.getTileRangeForExtentAndZ(T, kd, kc);
          break;
      }
      return e;
    },
    getBDTileRangeForExtentAndZ: function (T, kd, kc) {
      var i = [0, 0, 0];
      this.getBDTileCoordForXYAndZ_(T[0], T[1], kd, false, i);
      var e = i[1];
      var ke = i[2];
      this.getBDTileCoordForXYAndZ_(T[2], T[3], kd, true, i);
      return this.createOrUpdateTileRange(e, i[1], ke, i[2], kc);
    },
    getTileRangeForExtentAndZ: function (T, kd, kc) {
      var i = [0, 0, 0];
      this.getTileCoordForXYAndZ_(T[0], T[3], kd, false, i);
      var e = i[1];
      var ke = i[2];
      this.getTileCoordForXYAndZ_(T[2], T[1], kd, true, i);
      return this.createOrUpdateTileRange(e, i[1], ke, i[2], kc);
    },
    getBDTileCoordForXYAndZ_: function (e, kg, ke, kd, kc) {
      var kf = 256 * Math.pow(2, 18 - ke);
      var T = e / kf;
      var i = kg / kf;
      if (kd) {
        T = Math.ceil(T) - 1;
        i = Math.ceil(i) - 1;
      } else {
        T = Math.floor(T);
        i = Math.floor(i);
      }
      return this.createOrUpdateTileCoord(ke, T, i, kc);
    },
    getTileCoordForXYAndZ_: function (kj, ki, kg, kh, e) {
      var kk = this.origin;
      var i = this.resolutions.length === 0 ? this.calcResolutions(21)[kg] : this.resolutions[kg];
      var km = this.gridSize;
      var kc = kh ? 0.5 : 0;
      var T = kh ? 0.5 : 0;
      var kl = Math.floor((kj - kk[0]) / i + kc);
      var ke = Math.floor((kk[1] - ki) / i + T);
      var kf = kl / km[0];
      var kd = ke / km[1];
      if (kh) {
        kf = Math.ceil(kf) - 1;
        kd = Math.ceil(kd) - 1;
      } else {
        kf = Math.floor(kf);
        kd = Math.floor(kd);
      }
      return this.createOrUpdateTileCoord(kg, kf, kd, e);
    },
    getTileCoordForCoordAndZ: function (T, i, e) {
      return this.getTileCoordForXYAndZ_(T[0], T[1], i, false, e);
    },
    getTileRangeExtent: function (T, kf) {
      var kg = this.origin;
      if (this.resolutions.length === 0) {
        this.calcResolutions(23);
      }
      var kd = this.resolutions[T[0]];
      var kh = this.gridSize;
      var ke = kg[0] + T[1] * kh[0] * kd;
      var kc = kg[1] - (T[2] + 1) * kh[1] * kd;
      var i = ke + kh[0] * kd;
      var e = kc + kh[1] * kd;
      return this.createOrUpdateTileRange(ke, i, kc, e, kf);
    },
    getTileLeftBottomMCPoint: function (kd, T) {
      var i = this.origin;
      if (this.resolutions.length === 0) {
        this.calcResolutions(23);
      }
      var kc = this.resolutions[kd[0]];
      var kf = this.gridSize;
      var e = i[0] + kd[1] * kf[0] * kc;
      var kg = i[1] - (kd[2] + 1) * kf[1] * kc;
      var ke = gcoord.transform([e, kg], gcoord.EPSG3857, gcoord.BD09MC);
      return ke;
    },
    getRangeExtent: function (i, kk, kg, km, kc) {
      var kh = this.calPiexlResolution(km, kc);
      var kf = kk / 2 * kh;
      var ki = kg / 2 * kh;
      var ke = i[0] - kf;
      var T = i[0] + kf;
      var kd = i[1] - ki;
      var e = i[1] + ki;
      var kj = gcoord.transform([ke, kd], gcoord[kc.target], gcoord[kc.source]);
      var kl = gcoord.transform([T, e], gcoord[kc.target], gcoord[kc.source]);
      return this.createOrUpdateTileRange(kj[0], kl[0], kj[1], kl[1]);
    },
    getMousePoint: function (kf, ke, i, kd, T) {
      var kc = j8(kf, ke);
      return this.calLngLatByMapViewPixelInverse(kc.clientPos, i, ke.width, ke.height, kd, T);
    },
    calLngLatByMapViewPixelInverse: function (kc, e, i, kj, kk, T) {
      var kf = this.calPiexlResolution(kk, T);
      var ke = kc.x - i / 2;
      var kd = kc.y - kj / 2;
      var kh = e[0] + ke * kf;
      var kg = e[1] - kd * kf;
      var ki = gcoord.transform([kh, kg], gcoord[T.target], gcoord[T.source]);
      return ki;
    },
    calPiexlResolution: function (T, i) {
      var e;
      switch (i.target) {
        case "BD09MC":
          e = Math.pow(2, 18 - T);
          break;
        case "EPSG3857":
          e = this.resolutions[Math.floor(T)];
          break;
        default:
          e = Math.pow(2, 18 - T);
          break;
      }
      return e;
    },
    getXYZCellPixelCoor: function (kf, kd, kc, i) {
      var kh = this.gridSize;
      var kg;
      var ke;
      switch (i.source) {
        case "GCJ02":
        case "EPSG3857":
          var T = Math.pow(2, kc - 1) - (kd + 1);
          var e = kf - Math.pow(2, kc - 1);
          kg = e * kh[0];
          ke = T * kh[1];
          break;
        case "BD09MC":
          if (i.target === "EPSG3857") {
            kg = kf * kh[0];
            ke = kd * kh[1];
          } else {
            var T = Math.pow(2, kc - 1) - (kd + 1);
            var e = kf - Math.pow(2, kc - 1);
            kg = e * kh[0];
            ke = T * kh[1];
          }
        default:
          break;
      }
      return {
        x: kg,
        y: ke
      };
    },
    mcToPixel: function (i) {
      var T = this.resolutions[Math.floor(zoom)];
      var e = i.lng / T;
      var kc = i.lat / T;
      return [e, kc];
    },
    getBaiduCellPixelCoor: function (e, kc, T) {
      var i = 256;
      return {
        x: e * i,
        y: kc * i
      };
    },
    getRelativePixelCoor: function (ke, kc) {
      var i = this.origin;
      var kd = ke[0];
      var T = this.resolutions[Math.floor(kd)];
      var kf = this.gridSize;
      var e = i[0] / T + ke[1] * kf[0];
      var kg = i[1] / T - (ke[2] + 1) * kf[1];
      return [kc[0] - e, kc[1] - kg];
    },
    getPointPixelCoor: function (e, kh, i) {
      var kf;
      var ke;
      var T = Math.pow(2, 18 - kh);
      var kc = this.resolutions[Math.floor(kh)];
      var kd = i9.convertMC2LL(e);
      switch (i.source) {
        case "GCJ02":
          var kg = gcoord.transform([kd.lng, kd.lat], gcoord.BD09LL, gcoord.GCJ02);
          kg = gcoord.transform(kg, gcoord.WGS84, gcoord.EPSG3857);
          kf = kg[0] / kc;
          ke = kg[1] / kc;
          break;
        case "BD09LL":
        case "EPSG3857":
          var kg = gcoord.transform([kd.lng, kd.lat], gcoord.BD09LL, gcoord.EPSG3857);
          kf = kg[0] / kc;
          ke = kg[1] / kc;
          break;
        case "BD09MC":
          kf = e.lng / T;
          ke = e.lat / T;
          if (i.target === "BD09MC") {
            kf *= dB.gridScaleFromBDMCTo3857;
            ke *= dB.gridScaleFromBDMCTo3857;
          }
        default:
          break;
      }
      return [kf, ke];
    },
    getResolutionScale: function (i, e) {
      var T;
      switch (e.target) {
        case "BD09MC":
          T = this.gridScaleFrom3857ToBDMC;
          break;
        case "EPSG3857":
          T = this.gridScaleFromBDMCTo3857;
          break;
        default:
          T = this.gridScaleFrom3857ToBDMC;
          break;
      }
      return T;
    },
    getBaiduResolutionScale: function (T) {
      var i = this.resolutions[Math.floor(T)];
      var e = Math.pow(2, 18 - T);
      var kc = e / i;
      return kc;
    },
    getTileCoordCenter: function (T) {
      var e = this.origin;
      if (this.resolutions.length === 0) {
        this.calcResolutions(23);
      }
      var i = this.resolutions[T[0]];
      var kc = this.gridSize;
      return [e[0] + (T[1] + 0.5) * kc[0] * i, e[1] - (T[2] + 0.5) * kc[1] * i];
    },
    transformBDmcPoint: function (kd, i) {
      i = i || {};
      var T = i.source || "EPSG3857";
      var kc = i9.convertMC2LL(new cx(kd.lng, kd.lat));
      var e;
      switch (T) {
        case "GCJ02":
          e = gcoord.transform([kc.lng, kc.lat], gcoord.BD09LL, gcoord.GCJ02);
          e = gcoord.transform(e, gcoord.WGS84, gcoord.EPSG3857);
          break;
        case "EPSG3857":
          e = gcoord.transform([kc.lng, kc.lat], gcoord.BD09LL, gcoord.EPSG3857);
          break;
        case "BD09MC":
          if (i.target === "EPSG3857") {
            e = gcoord.transform([kc.lng, kc.lat], gcoord.BD09LL, gcoord.EPSG3857);
          } else {
            e = [kd.lng, kd.lat];
          }
          break;
        default:
          e = gcoord.transform([kc.lng, kc.lat], gcoord.BD09LL, gcoord[T]);
          break;
      }
      return e;
    },
    transformPointArr: function (e, i, T) {
      return gcoord.transform(e, gcoord[i || "BD09LL"], gcoord[T || "BD09MC"]);
    },
    getTilesLoop: function (T, e) {
      var i = Math.pow(2, T);
      while (e > i - 1) {
        e = e - i;
      }
      while (e < 0) {
        e = e + i;
      }
      return e;
    },
    getLoopBox: function (e, kc) {
      var i = this.HALF_SIZE * 2;
      if (e[0] > 0 && kc[2] < 0) {
        kc[2] = kc[2] + i;
      } else if (e[0] < 0 && kc[0] > 0) {
        kc[0] = kc[0] - i;
      }
      return kc;
    },
    createOrUpdateTileCoord: function (T, e, kc, i) {
      if (i !== undefined) {
        i[0] = T;
        i[1] = e;
        i[2] = kc;
        return i;
      } else {
        return [T, e, kc];
      }
    },
    createOrUpdateTileRange: function (e, kc, kd, T, i) {
      if (i !== undefined) {
        i.minX = e;
        i.maxX = kc;
        i.minY = kd;
        i.maxY = T;
        return i;
      } else {
        return {
          minX: e,
          maxX: kc,
          minY: kd,
          maxY: T
        };
      }
    },
    fromEPSG4326: function (T, kh, kf) {
      var kd = T.length;
      var ke = kf > 1 ? kf : 2;
      var e = kh;
      if (e === undefined) {
        if (ke > 2) {
          e = T.slice();
        } else {
          e = new Array(kd);
        }
      }
      for (var kc = 0; kc < kd; kc += ke) {
        e[kc] = this.HALF_SIZE * T[kc] / 180;
        var kg = this.RADIUS * Math.log(Math.tan(Math.PI * (+T[kc + 1] + 90) / 360));
        if (kg > this.MAX_SAFE_Y) {
          kg = this.MAX_SAFE_Y;
        } else if (kg < -this.MAX_SAFE_Y) {
          kg = -this.MAX_SAFE_Y;
        }
        e[kc + 1] = kg;
      }
      return e;
    },
    toEPSG4326: function (T, kg, kf) {
      var kd = T.length;
      var ke = kf > 1 ? kf : 2;
      var e = kg;
      if (e === undefined) {
        if (ke > 2) {
          e = T.slice();
        } else {
          e = new Array(kd);
        }
      }
      for (var kc = 0; kc < kd; kc += ke) {
        e[kc] = 180 * T[kc] / this.HALF_SIZE;
        e[kc + 1] = 360 * Math.atan(Math.exp(T[kc + 1] / this.RADIUS)) / Math.PI - 90;
      }
      return e;
    },
    findParentGridAndPosition: function (kc, km, kl, kg, kh, kj, kf) {
      if (kl - 1 < 0) {
        return false;
      }
      var kn = kc;
      var ki = km;
      var T = kl;
      for (var ke = 1; ke <= kf; ke++) {
        var e = this.findParent(kn, ki, T, ke);
        if (!e) {
          return false;
        }
        var kk = this.getTileKey(e);
        var kd = kg.getData(kk);
        if (kd && kd.status === "ready") {
          if (kh[kk]) {
            continue;
          }
          kj.setData(kd, this.drawIndex, 0);
          kh[kk] = true;
          return true;
        }
        kn = e.col;
        ki = e.row;
        T = e.zoom;
      }
    },
    findParent: function (i, kd, T, kc) {
      if (T - 1 < 0) {
        return null;
      }
      var e = i % 2;
      var ke = kd % 2;
      return {
        col: Math.floor(i / 2),
        row: Math.floor(kd / 2),
        sonX: e,
        sonY: ke,
        thumbLB: [e * 0.5, 1 - ke * 0.5 - 0.5],
        thumbRT: [e * 0.5 + 0.5, 1 - ke * 0.5],
        radio: Math.pow(2, kc),
        zoom: T - 1,
        useZoom: T - 1
      };
    },
    getTileKey: function (e, kc) {
      kc = kc || {};
      var i = typeof kc.useZoom === "number" ? kc.useZoom : e.useZoom;
      var T = e.style || this.mapStyleId || "default";
      return this.mapType + "_" + T + "_" + e.col + "_" + e.row + "_" + e.zoom + "_" + i;
    },
    lon2tile: function (i, e) {
      return Math.floor((i + 180) / 360 * Math.pow(2, e));
    },
    lat2tile: function (T, i) {
      var e = Math.tan(T * Math.PI / 180) + 1 / Math.cos(T * Math.PI / 180);
      return Math.floor((1 - Math.log(e) / Math.PI) / 2 * Math.pow(2, i));
    },
    tile2long: function (e, i) {
      return e / Math.pow(2, i) * 360 - 180;
    },
    tile2lat: function (T, e) {
      var i = Math.PI - 2 * Math.PI * T / Math.pow(2, e);
      return 180 / Math.PI * Math.atan(0.5 * (Math.exp(i) - Math.exp(-i)));
    }
  });
  function cr(i, e) {
    if (i < -90) {
      i = -90;
    } else if (i > 90) {
      i = 90;
    }
    while (e < -180) {
      e += 360;
    }
    while (e > 180) {
      e -= 360;
    }
    e = e || 0;
    i = i || 0;
    cx.call(this, e, i);
  }
  cr.inherits(cx, "LatLng");
  eX.extend(cr.prototype, {
    equals: function (e) {
      return this.lat === e.lat && this.lng === e.lng;
    },
    clone: function () {
      return new cr(this.lat, this.lng);
    },
    add: function (e) {
      return new cr(this.lng + e.lng, this.lat + e.lat);
    },
    sub: function (e) {
      return new cr(this.lat - e.lat, this.lng - e.lng);
    },
    mult: function (e) {
      return new cr(this.lng * e, this.lat * e);
    },
    div: function (e) {
      return new cr(this.lng / e, this.lat / e);
    },
    mag: function () {
      return Math.sqrt(this.lng * this.lng + this.lat * this.lat);
    },
    getLngSpan: function (e) {
      var i = this.lng;
      var T = Math.abs(e - i);
      if (T > 180) {
        T = 360 - T;
      }
      return T;
    },
    toString: function () {
      return "LatLng";
    },
    toGeoJSON: function () {
      var i = "Point";
      var T = [this.lng, this.lat];
      var e = {
        type: "Feature",
        geometry: {
          type: i,
          coordinates: T
        },
        properties: this.properties
      };
      return e;
    }
  });
  function cG(e, i) {
    if (e && !i) {
      i = e;
    }
    this._sw = this._ne = null;
    this._swLng = this._swLat = null;
    this._neLng = this._neLat = null;
    if (e) {
      this._sw = new cr(e.lat, e.lng);
      this._ne = new cr(i.lat, i.lng);
      this._swLng = e.lng;
      this._swLat = e.lat;
      this._neLng = i.lng;
      this._neLat = i.lat;
    }
  }
  eX.extend(cG.prototype, {
    isEmpty: function () {
      return !this._sw || !this._ne;
    },
    equals: function (e) {
      if (this.isEmpty()) {
        return false;
      }
      return this.getSouthWest().equals(e.getSouthWest()) && this.getNorthEast().equals(e.getNorthEast());
    },
    getSouthWest: function () {
      return this._sw;
    },
    getNorthEast: function () {
      return this._ne;
    },
    containsBounds: function (e) {
      if (this.isEmpty() || e.isEmpty()) {
        return false;
      }
      return e._swLng > this._swLng && e._neLng < this._neLng && e._swLat > this._swLat && e._neLat < this._neLat;
    },
    getCenter: function () {
      if (this.isEmpty()) {
        return null;
      }
      return new cr((this._swLat + this._neLat) / 2, (this._swLng + this._neLng) / 2);
    },
    intersects: function (T) {
      if (Math.max(T._swLng, T._neLng) < Math.min(this._swLng, this._neLng) || Math.min(T._swLng, T._neLng) > Math.max(this._swLng, this._neLng) || Math.max(T._swLat, T._neLat) < Math.min(this._swLat, this._neLat) || Math.min(T._swLat, T._neLat) > Math.max(this._swLat, this._neLat)) {
        return false;
      }
      var kd = Math.max(this._swLng, T._swLng);
      var i = Math.min(this._neLng, T._neLng);
      var kc = Math.max(this._swLat, T._swLat);
      var e = Math.min(this._neLat, T._neLat);
      this._sw = new cr(kc, kd);
      this._ne = new cr(e, i);
      this._swLng = kd;
      this._swLat = kc;
      this._neLng = i;
      this._neLat = e;
      return true;
    },
    containsPoint: function (e) {
      if (this.isEmpty()) {
        return false;
      }
      return e.lng >= this._swLng && e.lng <= this._neLng && e.lat >= this._swLat && e.lat <= this._neLat;
    },
    extend: function (e) {
      var i = e.lng;
      var T = e.lat;
      if (!this._sw) {
        this._sw = new cr(0, 0);
      }
      if (!this._ne) {
        this._ne = new cr(0, 0);
      }
      if (!this._swLng || this._swLng > i) {
        this._sw.lng = this._swLng = i;
      }
      if (!this._neLng || this._neLng < i) {
        this._ne.lng = this._neLng = i;
      }
      if (!this._swLat || this._swLat > T) {
        this._sw.lat = this._swLat = T;
      }
      if (!this._neLat || this._neLat < T) {
        this._ne.lat = this._neLat = T;
      }
    },
    toSpan: function () {
      if (this.isEmpty()) {
        return new cr(0, 0);
      }
      return new cr(Math.abs(this._neLat - this._swLat), Math.abs(this._neLng - this._swLng));
    },
    union: function (i) {
      if (i.isEmpty()) {
        return false;
      }
      var e = i.getSouthWest();
      var T = i.getNorthEast();
      if (this._swLat > e.lat) {
        this._swLat = e.lat;
      }
      if (this._swLng > e.lng) {
        this._swLng = e.lng;
      }
      if (this._neLat < T.lat) {
        this._neLat = T.lat;
      }
      if (this._neLng < T.lng) {
        this._neLng = T.lng;
      }
      this._sw = new cr(this._swLat, this._swLng);
      this._ne = new cr(this._neLat, this._neLng);
      return true;
    },
    toString: function () {
      return this._swLat + ", " + this._swLng + ", " + this._neLat + ", " + this._neLng;
    }
  });
  window.COORDINATES_WGS84 = 1;
  window.COORDINATES_WGS84_MC = 2;
  window.COORDINATES_GCJ02 = 3;
  window.COORDINATES_GCJ02_MC = 4;
  window.COORDINATES_BD09 = 5;
  window.COORDINATES_BD09_MC = 6;
  window.COORDINATES_MAPBAR = 7;
  window.COORDINATES_51 = 8;
  function fS() {}
  fS.inherits(c8, "Convertor");
  eX.extend(fS.prototype, {
    translate: function (i, kd, kc, T) {
      kd = kd || 1;
      kc = kc || 5;
      if (i.length > 10) {
        if (T) {
          T({
            status: 25
          });
        }
        return;
      }
      var e = B.apiHost + "?qt=coords&coords=";
      eX.each(i, function (ke) {
        e += ke.lng + "," + ke.lat + ";";
      });
      e = e.replace(/;$/gi, "");
      e = e + "&from=" + kd + "&to=" + kc + "&v=gl&type=webgl&ak=" + eN;
      dg.request(e, function (kf) {
        data = kf.content;
        if (typeof data !== "undefined" && data !== null && data.status === 0) {
          var ke = [];
          eX.each(data.result, function (kg) {
            ke.push(new cx(kg.x, kg.y));
          });
          delete data.result;
          data.points = ke;
        } else if (kf.result && kf.result.error) {
          data = {
            status: kf.result.errror,
            message: "访问错误，请参考错误状态码https://lbsyun.baidu.com/index.php?title=webapi/appendix"
          };
        }
        if (T) {
          T(data);
        }
      });
    }
  });
  var ed = {
    idle: 0,
    freeze: 1,
    zooming: 2,
    dragging: 3,
    moving: 4,
    readyToDrag: 5,
    readyToPinch: 6,
    pinching: 7,
    stdMapCtrlDrag: 8,
    KEY_LEFT: 37,
    KEY_UP: 38,
    KEY_RIGHT: 39,
    KEY_DOWN: 40,
    arrowOpCodes: {
      37: 1,
      38: 2,
      39: 4,
      40: 8
    }
  };
  var aj = {
    _map: null,
    _html: "<div class='BMap_opMask' unselectable='on'></div>",
    _maskElement: null,
    _cursor: "default",
    inUse: false,
    show: function (e) {
      if (!this._map) {
        this._map = e;
      }
      this.inUse = true;
      if (!this._maskElement) {
        this._createMask(e);
      }
      this._maskElement.style.display = "block";
    },
    _createMask: function (i) {
      if (!this._map) {
        this._map = i;
      }
      if (!this._map) {
        return;
      }
      var e = this._maskElement = bJ(this._map.container, this._html);
      eX.on(e, "mouseup", function (T) {
        if (T.button == 2) {
          ho(T);
        }
      });
      eX.on(e, "contextmenu", ho);
      e.style.display = "none";
    },
    getDrawPoint: function (kc, kf, kd) {
      kc = window.event || kc;
      var i = kc.offsetX || kc.layerX || 0;
      var ke = parseInt(kc.offsetY) || parseInt(kc.layerY) || 0;
      var T = kc.target || kc.srcElement;
      if (T != aj.getDom(this._map) && kf == true) {
        while (T && T != this._map.container) {
          if (!(T.clientWidth == 0 && T.clientHeight == 0 && T.offsetParent && T.offsetParent.nodeName.toLowerCase() == "td")) {
            i += T.offsetLeft;
            ke += T.offsetTop;
          }
          T = T.offsetParent;
        }
      }
      if (T != aj.getDom(this._map) && T != this._map.container) {
        return;
      }
      if (typeof i === "undefined" || typeof ke === "undefined") {
        return;
      }
      if (isNaN(i) || isNaN(ke)) {
        return;
      }
      if (kd) {
        i = i + kd.x;
        ke = ke + kd.y;
      }
      return this._map.pixelToPointIn(new fi(i, ke));
    },
    hide: function () {
      if (!this._map) {
        return;
      }
      this.inUse = false;
      if (this._maskElement) {
        this._maskElement.style.display = "none";
      }
    },
    getDom: function (e) {
      if (!this._maskElement) {
        this._createMask(e);
      }
      return this._maskElement;
    },
    setCursor: function (e) {
      this._cursor = e || "default";
      if (this._maskElement) {
        this._maskElement.style.cursor = this._cursor;
      }
    }
  };
  function aR() {
    this._type = "overlay";
  }
  aR.inherits(eX.BaseClass, "Overlay");
  aR.getZIndex = function (i, e) {
    i = i * 1;
    if (!i) {
      return 0;
    }
    if (e) {
      i = i9.convertMC2LL(new cx(0, i)).lat;
    }
    return i * -100000 << 1;
  };
  eX.extend(aR.prototype, {
    _i: function (T) {
      this._map = T;
      if (!this.domElement && bR(this.initialize)) {
        this.domElement = this.initialize(T);
        if (this.domElement) {
          this.domElement.style.WebkitUserSelect = "none";
          if (this.enableDraggingMap !== undefined && !this.enableDraggingMap && !(this instanceof s)) {
            var i = ["mousedown", "mouseout", "mouseover", "click", "keydown", "selectstart"];
            var e = this;
            eX.each(i, function (kc) {
              eX.on(e.domElement, kc, ai);
            });
          }
        }
      }
      this.draw();
    },
    initialize: function (e) {
      throw "initialize方法未实现";
    },
    draw: function () {
      throw "draw方法未实现";
    },
    remove: function () {
      if (this.domElement && this.domElement.parentNode) {
        this.domElement.parentNode.removeChild(this.domElement);
      }
      this.domElement = null;
      this.dispatchEvent(new fJ("onremove"));
    },
    hide: function () {
      this._visible = false;
      eX.hide(this.domElement);
    },
    show: function () {
      this._visible = true;
      eX.show(this.domElement);
    },
    getMap: function () {
      return this._map;
    },
    dispose: function () {
      eX.BaseClass.prototype.decontrol.call(this);
    }
  });
  function eA() {
    eX.BaseClass.call(this);
    aR.call(this);
    this._visible = true;
    this._visibleInternal = true;
    this.zIndex = 0;
    this.infoWindow = null;
    this._dblclickTime = 0;
  }
  eA.inherits(aR, "OverlayInternal");
  eX.extend(eA.prototype, {
    initialize: function (e) {
      this.map = e;
      eX.BaseClass.call(this, this.hashCode);
      return null;
    },
    draw: function () {},
    remove: function () {
      this.decontrol();
      aR.prototype.remove.call(this);
    },
    destroy: function () {},
    hide: function () {
      this._visible = false;
    },
    show: function () {
      this._visible = true;
    },
    getDom: function () {
      return this.domElement;
    },
    getContainer: function () {
      return this.domElement;
    },
    setClassName: function () {},
    setConfig: function (i) {
      if (!i) {
        return;
      }
      for (var e in i) {
        if (i.hasOwnProperty(e)) {
          this._config[e] = i[e];
        }
      }
    },
    getPoint: function (T, kc) {
      if (!T) {
        return this.point;
      } else {
        var e = kc ? kc.width : 0;
        var kd = kc ? kc.height : 0;
        if (this.map) {
          var i = this.map.pointToPixelIn(this.point);
          if (this._config && this._config.offset) {
            i.x = i.x + this._config.offset.width + e;
            i.y = i.y + this._config.offset.height + kd;
          } else {
            i.x = i.x + e;
            i.y = i.y + kd;
          }
          return this.map.pixelToPointIn(i);
        }
      }
    },
    setZIndex: function (e) {
      this.zIndex = e;
    },
    isVisible: function () {
      if (!this.domElement) {
        return false;
      }
      return !!this._visible;
    },
    enableMassClear: function () {
      this._config.enableMassClear = true;
    },
    disableMassClear: function () {
      this._config.enableMassClear = false;
    },
    showInternal: function () {
      this._visibleInternal = true;
    },
    hideInternal: function (e) {
      this._visibleInternal = false;
      this._hideInternalReason = e;
    },
    addContextMenu: function (e) {
      this._menu = e;
    },
    removeContextMenu: function (e) {
      this._menu = null;
    }
  });
  function aP(e) {
    this.map = e;
    this._overlays = {};
    this._overlayArray = [];
    this._customOverlays = [];
    e._overlays = this._overlays;
    e._overlayArray = this._overlayArray;
    e._customOverlays = this._customOverlays;
    this._zoomingOrMoving = false;
    this._init();
  }
  aP.prototype._init = function () {
    if (this.map._renderType !== "webgl") {
      this._createOverlayContainers();
    } else {
      this._createWebGLOverlayContainers();
    }
    this._bind();
  };
  aP.prototype._createOverlayContainers = function () {
    var e = this.map;
    e.temp.overlayDiv = e.overlayDiv = this._createOverlayDiv(e.platform, 200);
    e.temp.overlayDivEx = e.overlayDivEx = this._createOverlayDiv(e.platform, 50);
    e._panes.floatPane = this._createOverlayDiv(e.temp.overlayDiv, 800);
    e._panes.markerMouseTarget = this._createOverlayDiv(e.temp.overlayDiv, 700);
    e._panes.floatShadow = this._createOverlayDiv(e.temp.overlayDiv, 600);
    e._panes.labelPane = this._createOverlayDiv(e.temp.overlayDiv, 500);
    e._panes.markerPane = this._createOverlayDiv(e.temp.overlayDiv, 400);
    if (e.isCanvasMap()) {
      e._panes.mapPane = this._createOverlayDiv(e.temp.overlayDivEx, 50);
    } else {
      e._panes.mapPane = this._createOverlayDiv(e.temp.overlayDiv, 200);
    }
  };
  aP.prototype._createWebGLOverlayContainers = function () {
    var e = this.map;
    e.temp.overlayDiv = e.overlayDiv = this._createOverlayDiv(e.platform, 200);
    e._panes.floatPane = this._createOverlayDiv(e.temp.overlayDiv, 800);
    e._panes.markerMouseTarget = this._createOverlayDiv(e.temp.overlayDiv, 700);
    e._panes.floatShadow = this._createOverlayDiv(e.temp.overlayDiv, 600);
    e._panes.labelPane = this._createOverlayDiv(e.temp.overlayDiv, 500);
    e._panes.markerPane = this._createOverlayDiv(e.temp.overlayDiv, 400);
  };
  aP.prototype._createOverlayDiv = function (e, kc) {
    var T = bX("div");
    var i = T.style;
    i.position = "absolute";
    i.top = i.left = i.width = i.height = "0";
    i.zIndex = kc;
    e.appendChild(T);
    return T;
  };
  aP.prototype._bind = function () {
    var kd = this.map;
    var kc = this;
    function i(kf) {
      kc.draw(kf);
    }
    if (kd._renderType !== "webgl") {
      kd.addEventListener("load", i);
      kd.addEventListener("moveend", i);
      kd.addEventListener("resize", i);
      kd.addEventListener("zoomend", i);
      kd.addEventListener("zooming_inner", i);
    } else {
      kd.on("update", i);
    }
    kd.on("destroy", function () {
      kd._overlays = {};
      kd._overlayArray = [];
      kd._customOverlays = [];
      kd.overlayDiv = null;
      kd.overlayDivEx = null;
      var kf = Object.keys(kd._panes);
      for (var kg = 0; kg < kf.length; kg++) {
        kd._panes[kf[kg]] = null;
      }
      var kh = Object.keys(kd.temp);
      for (var kg = 0; kg < kh.length; kg++) {
        kd.temp[kh[kg]] = null;
      }
    });
    kd.addEventListener("zoomend", function (kf) {
      if (this.mapType === "B_EARTH_MAP") {
        if (this._earth.getZoom() < this._earth.zoomForNight + 1) {
          this.temp.overlayDiv.style.display = "none";
          if (this.temp.overlayDivEx) {
            this.temp.overlayDivEx.style.display = "none";
          }
        } else if (this.temp.overlayDiv.style.display === "none") {
          this.temp.overlayDiv.style.display = "";
          if (this.temp.overlayDivEx) {
            this.temp.overlayDivEx.style.display = "";
          }
          if (this.temp.infoWin && this.temp.infoWin.isOpen()) {
            this.temp.infoWin.redraw();
          }
        }
      }
    });
    kd.addEventListener("oncenterandzoom", function (kf) {
      kc.draw(kf);
      if (this.mapType === "B_EARTH_MAP") {
        if (this._earth.getZoom() < this._earth.zoomForNight + 1) {
          this.temp.overlayDiv.style.display = "none";
          if (this.temp.overlayDivEx) {
            this.temp.overlayDivEx.style.display = "none";
          }
        } else if (this.temp.overlayDiv.style.display === "none") {
          this.temp.overlayDiv.style.display = "";
          if (this.temp.overlayDivEx) {
            this.temp.overlayDivEx.style.display = "";
          }
          if (this.temp.infoWin && this.temp.infoWin.isOpen()) {
            this.temp.infoWin.redraw();
          }
        }
      }
    });
    kd.addEventListener("maptypechange", function (kf) {
      if (this.mapType === "B_EARTH_MAP") {
        if (this._panes.mapPane) {
          this._panes.mapPane.style.display = "none";
        }
        if (this._earth.getZoom() < this._earth.zoomForNight + 1) {
          this.temp.overlayDiv.style.display = "none";
          if (this.temp.overlayDivEx) {
            this.temp.overlayDivEx.style.display = "none";
          }
        } else if (this.temp.overlayDiv.style.display === "none") {
          this.temp.overlayDiv.style.display = "";
          if (this.temp.overlayDivEx) {
            this.temp.overlayDivEx.style.display = "";
          }
          if (this.temp.infoWin && this.temp.infoWin.isOpen()) {
            this.temp.infoWin.redraw();
          }
        }
        if (this._panes.markerPane) {
          this._panes.markerPane.style.display = "none";
        }
      } else {
        if (this._panes.mapPane) {
          this._panes.mapPane.style.display = "";
        }
        if (this._panes.markerPane) {
          this._panes.markerPane.style.display = "";
        }
        if (this.temp.overlayDiv.style.display === "none") {
          this.temp.overlayDiv.style.display = "";
          if (this.temp.overlayDivEx) {
            this.temp.overlayDivEx.style.display = "";
          }
          if (this.temp.infoWin && this.temp.infoWin.isOpen()) {
            this.temp.infoWin.redraw();
          }
        }
      }
      kc.draw(kf);
    });
    kd.on("earthstatuschange", function ke(kf) {
      kc.draw(kf);
    });
    kd.addEventListener("addoverlay", function (kj) {
      var kg = kj.target;
      if (kg instanceof eA) {
        if (!kc._overlays[kg.hashCode]) {
          kc._overlays[kg.hashCode] = kg;
          kc._overlayArray.push(kg);
        }
      } else {
        var ki = false;
        for (var kh = 0, kf = kc._customOverlays.length; kh < kf; kh++) {
          if (kc._customOverlays[kh] === kg) {
            ki = true;
            break;
          }
        }
        if (!ki) {
          kc._customOverlays.push(kg);
        }
      }
    });
    kd.addEventListener("removeoverlay", function (ki) {
      var kg = ki.target;
      if (kg instanceof eA) {
        delete kc._overlays[kg.hashCode];
        for (var kh = 0; kh < kc._overlayArray.length; kh++) {
          if (kc._overlayArray[kh] === kg) {
            kc._overlayArray.splice(kh, 1);
            break;
          }
        }
      } else {
        for (var kh = 0, kf = kc._customOverlays.length; kh < kf; kh++) {
          if (kc._customOverlays[kh] === kg) {
            kc._customOverlays.splice(kh, 1);
            break;
          }
        }
      }
    });
    kd.addEventListener("clearoverlays", function (kh) {
      this.closeInfoWindow();
      this.closeSimpleInfoWindow();
      for (var kg in kc._overlays) {
        if (kc._overlays[kg]._config.enableMassClear) {
          this.removeOverlay(kc._overlays[kg]);
        }
      }
      for (var kf = kc._customOverlays.length - 1; kf >= 0; kf--) {
        if (kc._customOverlays[kf].enableMassClear !== false) {
          this.removeOverlay(kc._customOverlays[kf]);
          kc._customOverlays.splice(kf, 1);
        }
      }
    });
    kd.addEventListener("infowindowopen", function (kg) {
      var kf = this.infoWindow;
      if (kf) {
        eX.hide(kf.popDom);
        eX.hide(kf.shadowDom);
      }
    });
    function T() {
      if (this.getMapType() === "B_EARTH_MAP" || this._renderType === "webgl") {
        if (kc._zoomingOrMoving === false) {
          this._panes.markerMouseTarget.style.display = "none";
          kc._zoomingOrMoving = true;
        }
      }
    }
    function e(kh) {
      if (this.getMapType() === "B_EARTH_MAP" || this._renderType === "webgl") {
        if (kc._zoomingOrMoving === true) {
          if (this._panes.markerMouseTarget) {
            this._panes.markerMouseTarget.style.display = "";
          }
          kc._zoomingOrMoving = false;
          for (var kg = 0; kg < kc._overlayArray.length; kg++) {
            var kf = kc._overlayArray[kg];
            if (kf instanceof jP === true) {
              kf.draw(kh);
            }
          }
        }
      }
    }
    kd.addEventListener("tilt_changed", e);
    kd.addEventListener("heading_changed", e);
    kd.addEventListener("movestart", T);
    kd.addEventListener("moveend", e);
    kd.addEventListener("zoomstart", T);
    kd.addEventListener("zoomend", e);
    kd.addEventListener("animation_start", T);
    kd.addEventListener("animation_end", e);
    kd.addEventListener("displayoptions_changed", function (kf) {
      if (this._displayOptions.overlay === false) {
        this.temp.overlayDiv.style.display = "none";
      } else {
        this.temp.overlayDiv.style.display = "";
      }
    });
  };
  aP.prototype.draw = function (kf) {
    kf = kf || {};
    if (this.map.getMapType() === "B_EARTH_MAP") {
      for (var kd = 0; kd < this._overlayArray.length; kd++) {
        var T = this._overlayArray[kd];
        if (T instanceof iz === true) {
          continue;
        }
        if (this._zoomingOrMoving) {
          if (T instanceof jP === true) {
            continue;
          }
        }
        T.draw(kf);
      }
    } else {
      for (var kd = 0, kc = this._overlayArray.length; kd < kc; kd++) {
        var T = this._overlayArray[kd];
        if (this._zoomingOrMoving && T instanceof jP === true) {
          continue;
        }
        T.draw(kf);
      }
    }
    eX.each(this._customOverlays, function (e) {
      e.draw(kf);
    });
    if (this.map.temp.infoWin) {
      this.map.temp.infoWin.setPosition(kf.center, kf.zoom);
    }
    if (this.map.getMapType() !== "B_EARTH_MAP" && this.map._renderType !== "webgl") {
      if (bx.DrawerSelector) {
        var ke = bx.DrawerSelector.getDrawer(this.map);
        ke.setPalette();
      }
    }
  };
  bx.register(function (e) {
    e._overlayMgr = new aP(e);
  });
  function iz(e) {
    eA.call(this);
    this._config = {
      strokeColor: "#000",
      strokeWeight: 2,
      strokeOpacity: 1,
      strokeStyle: "solid",
      dashArray: null,
      strokeLineCap: "round",
      strokeLineJoin: "round",
      enableMassClear: true,
      getParseTolerance: null,
      getParseCacheIndex: null,
      enableParse: true,
      enableEditing: false,
      mouseOverTolerance: 5,
      geodesic: false,
      linkRight: false,
      clip: true,
      texture: null,
      textureSize: null,
      textureZoomWithMap: false,
      textureRepeat: true
    };
    this.setConfig(e);
    if (this._config.strokeOpacity < 0 || this._config.strokeOpacity > 1) {
      this._config.strokeOpacity = 1;
    }
    if (this._config.fillOpacity < 0 || this._config.fillOpacity > 1) {
      this._config.fillOpacity = 1;
    }
    if (this._config.strokeStyle !== "solid" && this._config.strokeStyle !== "dashed" && this._config.strokeStyle !== "dotted") {
      this._config.strokeStyle = "solid";
    }
    this.domElement = null;
    this._bounds = new hY();
    this.points = [];
    this.greatCirclePoints = [];
    this._parseCache = [];
    this._holesCache = [];
    this._parseCacheGL = [];
    this._parseCacheGLRaw = [];
    this._areaCacheGL = [];
    this._strokeStyleInfoForGL = [[]];
    this._fillStyleInfoForGL = "";
    this.vertexMarkers = [];
    this._temp = {};
  }
  iz.JOININDEX = {
    miter: 0,
    round: 1,
    bevel: 2
  };
  iz.CAPINDEX = {
    round: 0,
    butt: 1,
    square: 2
  };
  iz.inherits(eA, "Graph");
  iz.getGraphPoints = function (i) {
    var e = [];
    if (!i || i.length === 0) {
      return e;
    }
    if (typeof i === "string") {
      var T = i.split(";");
      eX.each(T, function (kd) {
        var kc = kd.split(",");
        e.push(new cx(kc[0], kc[1]));
      });
    }
    if (i.constructor === Array && i.length > 0) {
      e = i;
    }
    return e;
  };
  iz.parseTolerance = {
    0: [0.09, 0.005, 0.0001, 0.00001],
    1: [9000, 500, 20, 1]
  };
  eX.extend(iz.prototype, {
    initialize: function (e) {
      this.map = e;
      return null;
    },
    draw: function () {},
    setPoints: function (e) {
      this._clearCache();
      this.points = iz.getGraphPoints(e).slice(0);
      this._calcBounds();
    },
    setPathIn: function (e) {
      this.setPoints(e);
    },
    _calcBounds: function () {
      if (!this.points) {
        return;
      }
      var e = this;
      e._bounds = new hY();
      if (!this.hasMultipleParts) {
        eX.each(this.points, function (i) {
          e._bounds.extend(i);
        });
      } else {
        eX.each(this.points, function (i) {
          eX.each(i, function (T) {
            e._bounds.extend(T);
          });
        });
      }
    },
    getPoints: function () {
      return this.points;
    },
    getPathIn: function () {
      return this.points;
    },
    setPointAt: function (i, e) {
      if (!e || !this.points[i]) {
        return;
      }
      this._clearCache();
      this.points[i] = new cx(e.lng, e.lat);
      this._calcBounds();
    },
    setPositionAt: function (i, e) {
      if (!e || !this.points[i]) {
        return;
      }
      var T = i9.convertLL2MC(e);
      this.setPointAt(i, T);
    },
    setOptions: function (i) {
      i = i || {};
      for (var e in i) {
        if (i.hasOwnProperty(e)) {
          this._config[e] = i[e];
        }
      }
    },
    setStrokeColor: function (e) {
      this._config.strokeColor = e;
    },
    getStrokeColor: function () {
      return this._config.strokeColor;
    },
    setStrokeLineCap: function (e) {
      this._config.strokeLineCap = e;
    },
    getStrokeLineCap: function () {
      return this._config.strokeLineCap;
    },
    setStrokeLineJoin: function (e) {
      this._config.strokeLineJoin = e;
    },
    getStrokeLineJoin: function () {
      return this._config.strokeLineJoin;
    },
    setStrokeWeight: function (e) {
      if (e > 0) {
        this._config.strokeWeight = e;
      }
    },
    getStrokeWeight: function () {
      return this._config.strokeWeight;
    },
    setStrokeOpacity: function (e) {
      if (!e || e > 1 || e < 0) {
        return;
      }
      this._config.strokeOpacity = e;
    },
    getStrokeOpacity: function () {
      return this._config.strokeOpacity;
    },
    setFillOpacity: function (e) {
      if (e > 1 || e < 0) {
        return;
      }
      this._config.fillOpacity = e;
    },
    getFillOpacity: function () {
      return this._config.fillOpacity;
    },
    setStrokeStyle: function (e) {
      if (e !== "solid" && e !== "dashed" && e !== "dotted") {
        return;
      }
      this._config.strokeStyle = e;
    },
    getStrokeStyle: function () {
      return this._config.strokeStyle;
    },
    setFillColor: function (e) {
      this._config.fillColor = e || "";
    },
    getFillColor: function () {
      return this._config.fillColor;
    },
    getBoundsIn: function () {
      this._bounds.setMinMax();
      return this._bounds;
    },
    getBounds: function () {
      var e = this.getBoundsIn();
      var i = new hY(i9.convertMC2LL(e.getSouthWest()), i9.convertMC2LL(e.getNorthEast()));
      i.setMinMax();
      return i;
    },
    remove: function () {
      if (this.map) {
        this.map.removeEventListener("onmousemove", this._graphMouseEvent);
        this.map.removeEventListener("onclick", this._graphClickEvent);
      }
      eA.prototype.remove.call(this);
      this._clearCache();
      var e = new fJ("onlineupdate");
      e.action = "remove";
      e.overlay = this;
      this.fire(e);
    },
    enableEditing: function () {
      if (this.points.length < 2) {
        return;
      }
      this._config.enableEditing = true;
      var e = this;
      g2.load("poly", function () {
        e.addVertexs();
      }, true);
    },
    disableEditing: function () {
      this._config.enableEditing = false;
      var e = this;
      g2.load("poly", function () {
        e.clearVertexs();
      }, true);
    },
    getLength: function () {
      if (typeof this._length === "number") {
        return this._length;
      }
      if (typeof this._config.totalLength === "number") {
        this._length = this._config.totalLength;
        return this._length;
      }
      var T = 0;
      if (this.points.length <= 1) {
        this._length = 0;
        return T;
      }
      for (var e = 0; e < this.points.length - 1; e++) {
        T += es(this.points[e], this.points[e + 1]);
      }
      this._length = T;
      return T;
    },
    getParsedPoints: function () {
      var e = this._simplification(this.points);
      if (this.hasMultipleParts) {
        return e;
      }
      return [e];
    },
    _simplification: function (kh) {
      var e = this.map;
      var kg = this.getParseCacheIndex(e.getZoom());
      var kj;
      if (this._parseCache[kg]) {
        kj = this._parseCache[kg];
      } else {
        var ke = kh;
        if (this.greatCirclePoints.length > 0) {
          ke = this.greatCirclePoints;
        }
        var kd = e.config.coordType === 2 ? 1 : e.config.coordType;
        var kf = this.getParseTolerance(e.getZoom(), kd);
        if (!this.hasMultipleParts) {
          var ki = dR(ke, kf);
        } else {
          var ki = [];
          for (var T = 0; T < ke.length; T++) {
            var kc = dR(ke[T], kf);
            ki.push(kc);
          }
        }
        kj = this._parseCache[kg] = ki;
      }
      return kj;
    },
    _clearCache: function () {
      this._length = null;
      this._parseCache.length = 0;
      this._parseCacheGL.length = 0;
      this._parseCacheGLRaw.length = 0;
      this._areaCacheGL.length = 0;
    },
    canRenderDataBeMerged: function () {
      var e = this._config;
      if (e.texture) {
        return false;
      }
      return true;
    }
  });
  if (eX.Browser.ie && document.namespaces && !document.namespaces.olv) {
    document.namespaces.add("olv", "urn:schemas-microsoft-com:vml");
  }
  function bq(ke, kc, kl) {
    var ki = false;
    var kg = false;
    var kj = false;
    var kn = new fi(ke.x, ke.y);
    var km = new fi(kc.x, kc.y);
    var kd = fK(kn, kl);
    var T = fK(km, kl);
    var kk;
    var kp;
    var ko;
    var kh = kl.minX;
    var kf = kl.minY;
    var i = kl.maxX;
    var e = kl.maxY;
    do {
      if (kd.all == 0 && T.all == 0) {
        ki = true;
        kj = true;
      } else if ((kd.all & T.all) != 0) {
        kj = true;
      } else {
        if (kd.all != 0) {
          kk = kd;
        } else {
          kk = T;
        }
        if (kk.top) {
          kp = kn.x + (km.x - kn.x) * (kf - kn.y) / (km.y - kn.y);
          ko = kf;
        } else if (kk.bottom) {
          kp = kn.x + (km.x - kn.x) * (e - kn.y) / (km.y - kn.y);
          ko = e;
        } else if (kk.right) {
          ko = kn.y + (km.y - kn.y) * (i - kn.x) / (km.x - kn.x);
          kp = i;
        } else if (kk.left) {
          ko = kn.y + (km.y - kn.y) * (kh - kn.x) / (km.x - kn.x);
          kp = kh;
        }
        kg = true;
        if (kk.all == kd.all) {
          kn.x = Math.round(kp);
          kn.y = Math.round(ko);
          kd = fK(kn, kl);
        } else {
          km.x = Math.round(kp);
          km.y = Math.round(ko);
          T = fK(km, kl);
        }
      }
    } while (!kj);
    if (ki) {
      return {
        pixel0: new fi(kn.x, kn.y),
        pixel1: new fi(km.x, km.y),
        clip: kg ? true : false
      };
    }
  }
  function fK(i, kd) {
    var T = {
      top: 0,
      bottom: 0,
      right: 0,
      left: 0,
      all: 0
    };
    var e = i.x;
    var kc = i.y;
    if (kc < kd.minY) {
      T.top = 8;
      T.all += T.top;
    } else if (kc > kd.maxY) {
      T.bottom = 4;
      T.all += T.bottom;
    }
    if (e > kd.maxX) {
      T.right = 2;
      T.all += T.right;
    } else if (e < kd.minX) {
      T.left = 1;
      T.all += T.left;
    }
    return T;
  }
  function dI(e) {
    e = e.replace(/,/gm, " ");
    e = e.replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm, "$1 $2");
    e = e.replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm, "$1 $2");
    e = e.replace(/([MmZzLlHhVvCcSsQqTtAa])([^\s])/gm, "$1 $2");
    e = e.replace(/([^\s])([MmZzLlHhVvCcSsQqTtAa])/gm, "$1 $2");
    e = e.replace(/([0-9])([+\-])/gm, "$1 $2");
    e = e.replace(/(\.[0-9]*)(\.)/gm, "$1 $2");
    e = e.replace(/([Aa](\s+[0-9]+){3})\s+([01])\s*([01])/gm, "$1 $3 $4 ");
    e = dI.compressSpaces(e);
    e = dI.trim(e);
    this.PathParser = new function (i) {
      this.tokens = i.split(" ");
      this.reset = function () {
        this.i = -1;
        this.command = "";
        this.previousCommand = "";
        this.start = new dI.Point(0, 0);
        this.control = new dI.Point(0, 0);
        this.current = new dI.Point(0, 0);
        this.points = [];
        this.angles = [];
      };
      this.isEnd = function () {
        return this.i >= this.tokens.length - 1;
      };
      this.isCommandOrEnd = function () {
        if (this.isEnd()) {
          return true;
        }
        return this.tokens[this.i + 1].match(/^[A-Za-z]$/) != null;
      };
      this.isRelativeCommand = function () {
        switch (this.command) {
          case "m":
          case "l":
          case "h":
          case "v":
          case "c":
          case "s":
          case "q":
          case "t":
          case "a":
          case "z":
            return true;
            break;
        }
        return false;
      };
      this.getToken = function () {
        this.i++;
        return this.tokens[this.i];
      };
      this.getScalar = function () {
        return parseFloat(this.getToken());
      };
      this.nextCommand = function () {
        this.previousCommand = this.command;
        this.command = this.getToken();
      };
      this.getPoint = function () {
        var T = new dI.Point(this.getScalar(), this.getScalar());
        return this.makeAbsolute(T);
      };
      this.getAsControlPoint = function () {
        var T = this.getPoint();
        this.control = T;
        return T;
      };
      this.getAsCurrentPoint = function () {
        var T = this.getPoint();
        this.current = T;
        return T;
      };
      this.getReflectedControlPoint = function () {
        if (this.previousCommand.toLowerCase() != "c" && this.previousCommand.toLowerCase() != "s" && this.previousCommand.toLowerCase() != "q" && this.previousCommand.toLowerCase() != "t") {
          return this.current;
        }
        var T = new dI.Point(2 * this.current.x - this.control.x, 2 * this.current.y - this.control.y);
        return T;
      };
      this.makeAbsolute = function (T) {
        if (this.isRelativeCommand()) {
          T.x += this.current.x;
          T.y += this.current.y;
        }
        return T;
      };
      this.addMarker = function (kc, kd, T) {
        if (T != null && this.angles.length > 0 && this.angles[this.angles.length - 1] == null) {
          this.angles[this.angles.length - 1] = this.points[this.points.length - 1].angleTo(T);
        }
        this.addMarkerAngle(kc, kd == null ? null : kd.angleTo(kc));
      };
      this.addMarkerAngle = function (kc, T) {
        this.points.push(kc);
        this.angles.push(T);
      };
      this.getMarkerPoints = function () {
        return this.points;
      };
      this.getMarkerAngles = function () {
        for (var kc = 0; kc < this.angles.length; kc++) {
          if (this.angles[kc] == null) {
            for (var T = kc + 1; T < this.angles.length; T++) {
              if (this.angles[T] != null) {
                this.angles[kc] = this.angles[T];
                break;
              }
            }
          }
        }
        return this.angles;
      };
    }(e);
    this.bounds = function () {
      return this.draw(null);
    };
    this.draw = function (kw) {
      var ky = this.PathParser;
      ky.reset();
      var kj = new dI.BoundingBox();
      if (kw != null) {
        kw.beginPath();
      }
      while (!ky.isEnd()) {
        ky.nextCommand();
        switch (ky.command) {
          case "M":
          case "m":
            var kt = ky.getAsCurrentPoint();
            ky.addMarker(kt);
            kj.addPoint(kt.x, kt.y);
            if (kw != null) {
              kw.moveTo(kt.x, kt.y);
            }
            ky.start = ky.current;
            while (!ky.isCommandOrEnd()) {
              var kt = ky.getAsCurrentPoint();
              ky.addMarker(kt, ky.start);
              kj.addPoint(kt.x, kt.y);
              if (kw != null) {
                kw.lineTo(kt.x, kt.y);
              }
            }
            break;
          case "L":
          case "l":
            while (!ky.isCommandOrEnd()) {
              var kC = ky.current;
              var kt = ky.getAsCurrentPoint();
              ky.addMarker(kt, kC);
              kj.addPoint(kt.x, kt.y);
              if (kw != null) {
                kw.lineTo(kt.x, kt.y);
              }
            }
            break;
          case "H":
          case "h":
            while (!ky.isCommandOrEnd()) {
              var kc = new dI.Point((ky.isRelativeCommand() ? ky.current.x : 0) + ky.getScalar(), ky.current.y);
              ky.addMarker(kc, ky.current);
              ky.current = kc;
              kj.addPoint(ky.current.x, ky.current.y);
              if (kw != null) {
                kw.lineTo(ky.current.x, ky.current.y);
              }
            }
            break;
          case "V":
          case "v":
            while (!ky.isCommandOrEnd()) {
              var kc = new dI.Point(ky.current.x, (ky.isRelativeCommand() ? ky.current.y : 0) + ky.getScalar());
              ky.addMarker(kc, ky.current);
              ky.current = kc;
              kj.addPoint(ky.current.x, ky.current.y);
              if (kw != null) {
                kw.lineTo(ky.current.x, ky.current.y);
              }
            }
            break;
          case "C":
          case "c":
            while (!ky.isCommandOrEnd()) {
              var kA = ky.current;
              var ke = ky.getPoint();
              var kf = ky.getAsControlPoint();
              var kl = ky.getAsCurrentPoint();
              ky.addMarker(kl, kf, ke);
              kj.addBezierCurve(kA.x, kA.y, ke.x, ke.y, kf.x, kf.y, kl.x, kl.y);
              if (kw != null) {
                kw.bezierCurveTo(ke.x, ke.y, kf.x, kf.y, kl.x, kl.y);
              }
            }
            break;
          case "S":
          case "s":
            while (!ky.isCommandOrEnd()) {
              var kA = ky.current;
              var ke = ky.getReflectedControlPoint();
              var kf = ky.getAsControlPoint();
              var kl = ky.getAsCurrentPoint();
              ky.addMarker(kl, kf, ke);
              kj.addBezierCurve(kA.x, kA.y, ke.x, ke.y, kf.x, kf.y, kl.x, kl.y);
              if (kw != null) {
                kw.bezierCurveTo(ke.x, ke.y, kf.x, kf.y, kl.x, kl.y);
              }
            }
            break;
          case "Q":
          case "q":
            while (!ky.isCommandOrEnd()) {
              var kA = ky.current;
              var kf = ky.getAsControlPoint();
              var kl = ky.getAsCurrentPoint();
              ky.addMarker(kl, kf, kf);
              kj.addQuadraticCurve(kA.x, kA.y, kf.x, kf.y, kl.x, kl.y);
              if (kw != null) {
                kw.quadraticCurveTo(kf.x, kf.y, kl.x, kl.y);
              }
            }
            break;
          case "T":
          case "t":
            while (!ky.isCommandOrEnd()) {
              var kA = ky.current;
              var kf = ky.getReflectedControlPoint();
              ky.control = kf;
              var kl = ky.getAsCurrentPoint();
              ky.addMarker(kl, kf, kf);
              kj.addQuadraticCurve(kA.x, kA.y, kf.x, kf.y, kl.x, kl.y);
              if (kw != null) {
                kw.quadraticCurveTo(kf.x, kf.y, kl.x, kl.y);
              }
            }
            break;
          case "A":
          case "a":
            while (!ky.isCommandOrEnd()) {
              var kA = ky.current;
              var ki = ky.getScalar();
              var kh = ky.getScalar();
              var T = ky.getScalar() * (Math.PI / 180);
              var kk = ky.getScalar();
              var kg = ky.getScalar();
              var kl = ky.getAsCurrentPoint();
              var kF = new dI.Point(Math.cos(T) * (kA.x - kl.x) / 2 + Math.sin(T) * (kA.y - kl.y) / 2, -Math.sin(T) * (kA.x - kl.x) / 2 + Math.cos(T) * (kA.y - kl.y) / 2);
              var kx = Math.pow(kF.x, 2) / Math.pow(ki, 2) + Math.pow(kF.y, 2) / Math.pow(kh, 2);
              if (kx > 1) {
                ki *= Math.sqrt(kx);
                kh *= Math.sqrt(kx);
              }
              var kp = (kk == kg ? -1 : 1) * Math.sqrt((Math.pow(ki, 2) * Math.pow(kh, 2) - Math.pow(ki, 2) * Math.pow(kF.y, 2) - Math.pow(kh, 2) * Math.pow(kF.x, 2)) / (Math.pow(ki, 2) * Math.pow(kF.y, 2) + Math.pow(kh, 2) * Math.pow(kF.x, 2)));
              if (isNaN(kp)) {
                kp = 0;
              }
              var ko = new dI.Point(kp * ki * kF.y / kh, kp * -kh * kF.x / ki);
              var kd = new dI.Point((kA.x + kl.x) / 2 + Math.cos(T) * ko.x - Math.sin(T) * ko.y, (kA.y + kl.y) / 2 + Math.sin(T) * ko.x + Math.cos(T) * ko.y);
              var kv = function (kG) {
                return Math.sqrt(Math.pow(kG[0], 2) + Math.pow(kG[1], 2));
              };
              var kr = function (kH, kG) {
                return (kH[0] * kG[0] + kH[1] * kG[1]) / (kv(kH) * kv(kG));
              };
              var kD = function (kH, kG) {
                return (kH[0] * kG[1] < kH[1] * kG[0] ? -1 : 1) * Math.acos(kr(kH, kG));
              };
              var kE = kD([1, 0], [(kF.x - ko.x) / ki, (kF.y - ko.y) / kh]);
              var kn = [(kF.x - ko.x) / ki, (kF.y - ko.y) / kh];
              var km = [(-kF.x - ko.x) / ki, (-kF.y - ko.y) / kh];
              var kB = kD(kn, km);
              if (kr(kn, km) <= -1) {
                kB = Math.PI;
              }
              if (kr(kn, km) >= 1) {
                kB = 0;
              }
              var ku = 1 - kg ? 1 : -1;
              var kz = kE + ku * (kB / 2);
              var i = new dI.Point(kd.x + ki * Math.cos(kz), kd.y + kh * Math.sin(kz));
              ky.addMarkerAngle(i, kz - ku * Math.PI / 2);
              ky.addMarkerAngle(kl, kz - ku * Math.PI);
              kj.addPoint(kl.x, kl.y);
              if (kw != null) {
                var kr = ki > kh ? ki : kh;
                var ks = ki > kh ? 1 : ki / kh;
                var kq = ki > kh ? kh / ki : 1;
                kw.translate(kd.x, kd.y);
                kw.rotate(T);
                kw.scale(ks, kq);
                kw.arc(0, 0, kr, kE, kE + kB, 1 - kg);
                kw.scale(1 / ks, 1 / kq);
                kw.rotate(-T);
                kw.translate(-kd.x, -kd.y);
              }
            }
            break;
          case "Z":
          case "z":
            if (kw != null) {
              kw.closePath();
            }
            ky.current = ky.start;
        }
      }
      return kj;
    };
    this.getMarkers = function () {
      var kc = this.PathParser.getMarkerPoints();
      var ke = this.PathParser.getMarkerAngles();
      var kd = [];
      for (var T = 0; T < kc.length; T++) {
        kd.push([kc[T], ke[T]]);
      }
      return kd;
    };
  }
  dI.trim = function (e) {
    return e.replace(/^\s+|\s+$/g, "");
  };
  dI.compressSpaces = function (e) {
    return e.replace(/[\s\r\t\n]+/gm, " ");
  };
  dI.Point = function (e, i) {
    this.x = e;
    this.y = i;
  };
  dI.Point.prototype.angleTo = function (e) {
    return Math.atan2(e.y - this.y, e.x - this.x);
  };
  dI.Point.prototype.applyTransform = function (e) {
    var i = this.x * e[0] + this.y * e[2] + e[4];
    var T = this.x * e[1] + this.y * e[3] + e[5];
    this.x = i;
    this.y = T;
  };
  dI.BoundingBox = function (i, kc, e, T) {
    this.x1 = Number.NaN;
    this.y1 = Number.NaN;
    this.x2 = Number.NaN;
    this.y2 = Number.NaN;
    this.x = function () {
      return this.x1;
    };
    this.y = function () {
      return this.y1;
    };
    this.width = function () {
      return this.x2 - this.x1;
    };
    this.height = function () {
      return this.y2 - this.y1;
    };
    this.addPoint = function (kd, ke) {
      if (kd != null) {
        if (isNaN(this.x1) || isNaN(this.x2)) {
          this.x1 = kd;
          this.x2 = kd;
        }
        if (kd < this.x1) {
          this.x1 = kd;
        }
        if (kd > this.x2) {
          this.x2 = kd;
        }
      }
      if (ke != null) {
        if (isNaN(this.y1) || isNaN(this.y2)) {
          this.y1 = ke;
          this.y2 = ke;
        }
        if (ke < this.y1) {
          this.y1 = ke;
        }
        if (ke > this.y2) {
          this.y2 = ke;
        }
      }
    };
    this.addX = function (kd) {
      this.addPoint(kd, null);
    };
    this.addY = function (kd) {
      this.addPoint(null, kd);
    };
    this.addBoundingBox = function (kd) {
      this.addPoint(kd.x1, kd.y1);
      this.addPoint(kd.x2, kd.y2);
    };
    this.addQuadraticCurve = function (ki, kh, ke, kd, kk, kj) {
      var kg = ki + 2 / 3 * (ke - ki);
      var kf = kh + 2 / 3 * (kd - kh);
      var km = kg + 1 / 3 * (kk - ki);
      var kl = kf + 1 / 3 * (kj - kh);
      this.addBezierCurve(ki, kh, kg, km, kf, kl, kk, kj);
    };
    this.addBezierCurve = function (kq, kp, kh, kf, km, kk, ks, kr) {
      var ki = [kq, kp];
      var kg = [kh, kf];
      var ke = [km, kk];
      var kd = [ks, kr];
      this.addPoint(ki[0], ki[1]);
      this.addPoint(kd[0], kd[1]);
      for (jo = 0; jo <= 1; jo++) {
        var kt = function (kx) {
          return Math.pow(1 - kx, 3) * ki[jo] + 3 * Math.pow(1 - kx, 2) * kx * kg[jo] + 3 * (1 - kx) * Math.pow(kx, 2) * ke[jo] + Math.pow(kx, 3) * kd[jo];
        };
        var kv = 6 * ki[jo] - 12 * kg[jo] + 6 * ke[jo];
        var kw = -3 * ki[jo] + 9 * kg[jo] - 9 * ke[jo] + 3 * kd[jo];
        var ku = 3 * kg[jo] - 3 * ki[jo];
        if (kw == 0) {
          if (kv == 0) {
            continue;
          }
          var ko = -ku / kv;
          if (ko > 0 && ko < 1) {
            if (jo == 0) {
              this.addX(kt(ko));
            }
            if (jo == 1) {
              this.addY(kt(ko));
            }
          }
          continue;
        }
        var kj = Math.pow(kv, 2) - 4 * ku * kw;
        if (kj < 0) {
          continue;
        }
        var kn = (-kv + Math.sqrt(kj)) / (2 * kw);
        if (kn > 0 && kn < 1) {
          if (jo == 0) {
            this.addX(kt(kn));
          }
          if (jo == 1) {
            this.addY(kt(kn));
          }
        }
        var kl = (-kv - Math.sqrt(kj)) / (2 * kw);
        if (kl > 0 && kl < 1) {
          if (jo == 0) {
            this.addX(kt(kl));
          }
          if (jo == 1) {
            this.addY(kt(kl));
          }
        }
      }
    };
    this.isPointInBox = function (kd, ke) {
      return this.x1 <= kd && kd <= this.x2 && this.y1 <= ke && ke <= this.y2;
    };
    this.addPoint(i, kc);
    this.addPoint(e, T);
  };
  function fg(i, e) {
    this.id = bx.getGUID("symbol_icon_");
    this.size = i instanceof i0 ? i : new i0(2, 2);
    this.anchor = e instanceof i0 ? e : new i0(this.size.width / 2, this.size.height / 2);
    this.data = null;
    this.offset = this.anchor;
    this.imageSize = this.size;
    this.imageOffset = new i0(0, 0);
    this.style = {
      scale: 1,
      rotation: 0
    };
    this.srcSetObject = {};
    this._initOptions = {
      size: this.size,
      scale: this.style.scale,
      rotation: this.style.rotation
    };
    this.overlay = null;
    this.isReDraw = false;
  }
  fg.prototype.add = function () {
    const e = document.createElement("canvas");
    e.width = this.size.width;
    e.height = this.size.height;
    this.context = e.getContext("2d");
  };
  fg.prototype.remove = function () {
    if (this.context) {
      this.context.clearRect(0, 0, this.context.canvas.width, this.context.canvas.height);
      this.context.canvas.width = 0;
      this.context.canvas.height = 0;
    }
    this.context = null;
    this.data = null;
  };
  fg.prototype.render = function (e) {
    return true;
  };
  fg.prototype.resetInitOptions = function () {
    this._initOptions = new i0(this.size.width, this.size.height);
    this._initOptions.scale = this.style.scale;
    this._initOptions.rotation = this.style.rotation;
  };
  fg.prototype.update = function () {
    var e = this.overlay;
    if (e) {
      if (e.domElement) {
        var kc = (this.style.scale - this._initOptions.scale) / this._initOptions.scale;
        if (kc >= 0) {
          kc = kc + 1;
        } else {
          kc = 1 + kc;
        }
        var i = this._initOptions.rotation === 0 ? this.style.rotation : this.style.rotation - this._initOptions.rotation;
        while (i < 0) {
          i += 360;
        }
        var T = e.domElement.style;
        T.width = this._initOptions.width + "px";
        T.height = this._initOptions.height + "px";
        T.transform = "rotate(" + i + "deg) scale(" + kc + ")";
      }
      if (!this.isReDraw) {
        this._refresh(e);
      }
    }
  };
  fg.prototype._refresh = function (e) {
    e.textureCoord = e.textureCoordGLMap = null;
    var i = new fJ("onstatus_change");
    i.overlay = e;
    i.action = "setIcon";
    i.imageUrlChanged = true;
    setTimeout(function () {
      e.fire(i);
    }, 100);
  };
  fg.prototype.generateRenderData = function () {
    var i = this.offset = this.anchor;
    var e = this.size;
    var T = [];
    T.push(-i.width, i.height - e.height, 0);
    T.push(e.width - i.width, i.height - e.height, 0);
    T.push(e.width - i.width, i.height, 0);
    T.push(-i.width, i.height - e.height, 0);
    T.push(e.width - i.width, i.height, 0);
    T.push(-i.width, i.height, 0);
    return {
      vertex: T
    };
  };
  fg.prototype.getCurrentImageUrl = function () {
    return this.id;
  };
  fg.prototype.getRenderData = function () {
    this._renderData = this.generateRenderData();
    return this._renderData;
  };
  fg.prototype.toString = function () {
    return "Symbol";
  };
  var fw = {
    14: "m-0.00573,-10c-5.51975,0 -9.99427,4.47453 -9.99427,9.99428c0,5.51974 4.47452,9.99425 9.99427,9.99425c5.51972,0 9.99426,-4.47452 9.99426,-9.99425c0,-5.51975 -4.47453,-9.99428 -9.99426,-9.99428zm0,17.92491c-4.37412,0 -7.93132,-3.55788 -7.93132,-7.93063c0,-4.37345 3.5572,-7.93134 7.93132,-7.93134c4.37411,0 7.93062,3.55721 7.93062,7.93134c0,4.37412 -3.55789,7.93063 -7.93062,7.93063zm-0.00068,-15.4088c-0.38027,0 -0.68696,0.30807 -0.68696,0.68765l0,6.34078l-4.15752,1.81815c-0.34794,0.15266 -0.50611,0.55837 -0.35344,0.90632c0.11278,0.25787 0.36445,0.4119 0.6292,0.4119c0.09214,0 0.18635,-0.01857 0.27575,-0.05845l4.55635,-1.99279c0.00344,-0.00137 0.00619,-0.00275 0.00894,-0.00412l0.00275,-0.00138c0.01032,-0.00413 0.01581,-0.01376 0.02545,-0.01719c0.07151,-0.03576 0.13821,-0.07771 0.19185,-0.1341c0.02337,-0.02338 0.03644,-0.05364 0.05431,-0.08045c0.03301,-0.04401 0.06946,-0.08733 0.0894,-0.14028c0.0165,-0.04126 0.01787,-0.08596 0.02613,-0.12997c0.00894,-0.04469 0.02614,-0.08389 0.02614,-0.1286l0,-6.7905c0,-0.37889 -0.30807,-0.68697 -0.68833,-0.68697z",
    13: "m-0.00706,-9.5c-5.24281,0 -9.49294,4.25065 -9.49294,9.49294c0,5.24331 4.25014,9.49294 9.49294,9.49294c5.24281,0 9.49294,-4.24964 9.49294,-9.49294c0,-5.2423 -4.25013,-9.49294 -9.49294,-9.49294zm3.08857,3.85997c0.61044,0 1.10279,0.96873 1.10279,2.16271s-0.49384,2.1647 -1.10279,2.1647c-0.60844,0 -1.10228,-0.96873 -1.10228,-2.16372s0.49434,-2.16369 1.10228,-2.16369zm-6.28628,0c0.60844,0 1.10228,0.96873 1.10228,2.16271s-0.49284,2.1647 -1.10228,2.1647s-1.10277,-0.96873 -1.10277,-2.16372s0.49383,-2.16369 1.10277,-2.16369zm3.21167,12.16493c-1.87667,0 -3.63373,-1.14814 -5.14663,-3.14239c1.56571,1.02156 3.27993,1.59064 5.07786,1.59064c1.90905,0 3.72343,-0.63985 5.36539,-1.78497c-1.54429,2.11685 -3.35767,3.33672 -5.29662,3.33672l-0.00001,0z",
    12: "m9.27295,5.92958l-2.64443,-4.57961c-0.79727,-1.37992 -2.10131,-3.63983 -2.8986,-5.01973l-2.64441,-4.57858c-0.79782,-1.38093 -2.10186,-1.38093 -2.89913,0l-2.64335,4.57858c-0.79728,1.3799 -2.10188,3.63981 -2.89916,5.01973l-2.64387,4.57961c-0.79728,1.38101 -0.14472,2.50988 1.44983,2.50988l16.37221,0c1.59561,0 2.24711,-1.12887 1.45091,-2.50988l0,0zm-8.88166,0.70811l-1.56837,0l0,-1.50484l1.56837,0l0,1.50484zm-0.07527,-2.61447l-1.41621,0l-0.14044,-6.44231l1.68427,0l-0.12761,6.44231l0,0z",
    11: "m8.08295,-6.56414l-3.59319,0l0,-1.43586l-8.98155,0l0,1.43586l-3.59321,0c-1.0569,0 -1.915,0.85509 -1.915,1.91159l0,9.92258c0,1.05357 0.8581,1.91158 1.915,1.91158l16.16796,0c1.05692,0 1.91501,-0.85801 1.91501,-1.91158l0,-9.92258c0,-1.0565 -0.85809,-1.91159 -1.91501,-1.91159l0,0zm-8.08397,12.66884c-3.20143,0 -5.80643,-2.60031 -5.80643,-5.79596c0,-3.19569 2.605,-5.79891 5.80643,-5.79891s5.80789,2.60322 5.80789,5.79891c0,3.19565 -2.60794,5.79596 -5.80789,5.79596zm0,-9.6804c-2.15036,0 -3.89142,1.7394 -3.89142,3.88444c0,2.14503 1.74252,3.8844 3.89142,3.8844c2.1489,0 3.89141,-1.73937 3.89141,-3.8844c0,-2.14503 -1.74105,-3.88444 -3.89141,-3.88444z",
    10: "m0,-10c-0.20885,0 -0.39491,0.08583 -0.55177,0.24149c-0.15674,0.15536 -0.28646,0.37838 -0.39429,0.65665c-0.21586,0.55655 -0.34853,1.33844 -0.42114,2.27477c-0.07231,0.93446 -0.08474,2.02273 -0.05447,3.18765c-2.58175,1.05925 -7.81787,3.24648 -8.23854,3.73474c-0.56001,0.65029 -0.37908,1.3954 -0.15331,1.89002l8.608,-1.75235c0.18202,2.28374 0.4407,4.5455 0.66615,6.31771c-0.8418,0.24646 -2.41323,0.73303 -2.73754,1.03474c-0.4469,0.41562 -0.4469,1.75793 -0.4469,1.75793l3.52318,-0.28665c0.08286,0.57874 0.13486,0.9163 0.13486,0.9163l0.00511,0.03042l0.02778,0l0.06486,0l0.02778,0l0.00511,-0.03042c0,0 0.05185,-0.33756 0.13486,-0.9163l3.52424,0.28665c0,0 0,-1.34231 -0.44688,-1.75793c-0.32446,-0.30172 -1.89697,-0.7895 -2.73847,-1.0358c0.22484,-1.76681 0.4832,-4.02001 0.66507,-6.29634l8.50712,1.73203c0.22561,-0.49462 0.40765,-1.23973 -0.15237,-1.89002c-0.41538,-0.48221 -5.52504,-2.62071 -8.1386,-3.69423c0.03119,-1.17999 0.01971,-2.28285 -0.05353,-3.22816l0,-0.00233c-0.07263,-0.93523 -0.20545,-1.71635 -0.42114,-2.27244c-0.10784,-0.27827 -0.23634,-0.50114 -0.3932,-0.65665c-0.15689,-0.15567 -0.34293,-0.24149 -0.55195,-0.24149l0,0l0,0l0,0l0.00001,0l0,0l-0.00003,0.00001z",
    3: "m-10,0l10,-10l10,10l-10,10l-10,-10z",
    5: "M0,0 L-5,-15 0,-10 5,-15 z",
    6: "M0,0 L5,15 0,10 -5,15z",
    7: "M-5,-15 L0,0 5,-15",
    8: "M-5,15 L0,0 5,15",
    9: "m0,-24c-4.4183,0 -8,3.58167 -8,8c0,1.42102 0.3816,2.75 1.0312,3.90601c0.1079,0.19202 0.221,0.38098 0.3438,0.56299l6.625,11.53101l6.625,-11.53101c0.102,-0.151 0.19,-0.31097 0.281,-0.46899l0.063,-0.09399c0.649,-1.15601 1.031,-2.48499 1.031,-3.90601c0,-4.41833 -3.582,-8 -8,-8zm0,4c2.209,0 4,1.79089 4,4c0,2.20898 -1.791,4 -4,4c-2.2091,0 -4,-1.79102 -4,-4c0,-2.20911 1.7909,-4 4,-4z"
  };
  var b6 = {
    BMap_Symbol_SHAPE_CIRCLE: 1,
    BMap_Symbol_SHAPE_RECTANGLE: 2,
    BMap_Symbol_SHAPE_RHOMBUS: 3,
    BMap_Symbol_SHAPE_STAR: 4,
    BMap_Symbol_SHAPE_BACKWARD_CLOSED_ARROW: 5,
    BMap_Symbol_SHAPE_FORWARD_CLOSED_ARROW: 6,
    BMap_Symbol_SHAPE_BACKWARD_OPEN_ARROW: 7,
    BMap_Symbol_SHAPE_FORWARD_OPEN_ARROW: 8,
    BMap_Symbol_SHAPE_POINT: 9,
    BMap_Symbol_SHAPE_PLANE: 10,
    BMap_Symbol_SHAPE_CAMERA: 11,
    BMap_Symbol_SHAPE_WARNING: 12,
    BMap_Symbol_SHAPE_SMILE: 13,
    BMap_Symbol_SHAPE_CLOCK: 14
  };
  function dK(i, e) {
    fg.call(this);
    e = e || {};
    this.style = {
      anchor: e.anchor || new i0(0, 0),
      fillColor: e.fillColor || "#000",
      fillOpacity: e.fillOpacity || 0,
      scale: e.scale || 1,
      rotation: e.rotation || 0,
      strokeColor: e.strokeColor || "#000",
      strokeOpacity: e.strokeOpacity === undefined ? 1 : e.strokeOpacity,
      strokeWeight: e.strokeWeight
    };
    this._type = typeof i === "number" ? i : "UserDefined";
    this._anchor = this.style.anchor;
    this._originOffset = new i0(0, 0);
    this.anchor = new i0(0, 0);
    this._rawPath = i;
    this._buildPath(true);
  }
  dK.inherits(fg, "SVGSymbol");
  dK.generateKey = function (kc, i) {
    if (!kc) {
      return null;
    }
    if (parseInt(kc)) {
      kc = parseInt(kc);
    }
    if (typeof kc === "number") {
      if (!fw[kc] && ![0, 1, 2, 0, 4][kc]) {
        return null;
      }
    }
    var e = {
      anchor: i.anchor || new i0(0, 0),
      fillColor: i.fillColor || "#000",
      fillOpacity: i.fillOpacity || 0,
      scale: i.scale || 1,
      rotation: i.rotation || 0,
      strokeColor: i.strokeColor || "#000",
      strokeOpacity: i.strokeOpacity === undefined ? 1 : i.strokeOpacity,
      strokeWeight: i.strokeWeight
    };
    var T = o({
      path: kc,
      style: e
    });
    return "symbol_svg_icon_" + T;
  };
  eX.extend(dK.prototype, {
    _buildPath: function (kn) {
      var kh = this;
      var kj = kh._rawPath;
      if (parseInt(kj)) {
        kj = parseInt(kj);
      }
      if (fw[kj]) {
        kj = fw[kj];
      }
      kh.id = dK.generateKey(kj, kh.style);
      if (!kh.id) {
        return;
      }
      switch (kj) {
        case b6.BMap_Symbol_SHAPE_CIRCLE:
          var kk = kh._calSize(2);
          var ki = kk;
          var ks = kh.style.scale;
          var kd = kh._anchor;
          this.size = new i0(kk, ki);
          this.anchor = new i0(kk / 2 + kd.width * ks, ki / 2 + kd.height * ks);
          kh.path = b6.BMap_Symbol_SHAPE_CIRCLE;
          break;
        case b6.BMap_Symbol_SHAPE_RECTANGLE:
          var kk = kh._calSize(4);
          var ki = kh._calSize(2);
          var kd = kh._anchor;
          var kp = kh.style.strokeWeight !== undefined ? kh.style.strokeWeight : kh.style.scale;
          var ks = kh.style.scale;
          this.size = new i0(kk, ki);
          this._originOffset = new i0(Math.floor(-kp / 2), Math.floor(-kp / 2));
          this.anchor = new i0(kk / 2 + kd.width * ks, ki / 2 + kd.height * ks);
          kh.path = b6.BMap_Symbol_SHAPE_RECTANGLE;
          break;
        case b6.BMap_Symbol_SHAPE_STAR:
          var kk = kh._calSize(20);
          var ki = kk;
          var kd = kh._anchor;
          var ks = kh.style.scale;
          this.size = new i0(kk, ki);
          this.anchor = new i0(kk / 2 + kd.width * ks, ki / 2 + kd.height * ks);
          kh.path = b6.BMap_Symbol_SHAPE_STAR;
          break;
        default:
          var kj = new dI(kj);
          var kc = kj.bounds();
          var km = kh.style.rotation * Math.PI / 180;
          var kp = kh.style.strokeWeight !== undefined ? kh.style.strokeWeight : kh.style.scale;
          var ks = kh.style.scale;
          var kd = kh._anchor;
          var kr = new i0(Math.floor(kc.x1 * ks - kp / 2), Math.floor(kc.y1 * ks - kp / 2));
          var e = {
            topleft: new fi(Math.floor(kc.x1 * ks - kp / 2) - ks * kd.width, Math.floor(kc.y1 * ks - kp / 2) - ks * kd.height),
            bottomleft: new fi(Math.floor(kc.x1 * ks - kp / 2) - ks * kd.width, Math.ceil(kc.y2 * ks - kp / 2) - ks * kd.height),
            topright: new fi(Math.ceil(kc.x2 * ks + kp / 2) - ks * kd.width, Math.floor(kc.y1 * ks - kp / 2) - ks * kd.height),
            bottomright: new fi(Math.ceil(kc.x2 * ks + kp / 2) - ks * kd.width, Math.ceil(kc.y2 * ks + kp / 2) - ks * kd.height)
          };
          var i = {};
          var kq = [];
          var kg = [];
          var ko = e.topleft.x === 0 ? 0 : Math.atan(e.topleft.y / e.topleft.x);
          var T = ko + km;
          for (var kl in e) {
            var kf = Math.cos(km) * e[kl].x - Math.sin(km) * e[kl].y;
            var ke = Math.sin(km) * e[kl].x + Math.cos(km) * e[kl].y;
            i[kl] = new fi(kf, ke);
            kq.push(kf);
            kg.push(ke);
          }
          xmax = Math.max.apply(Math, kq);
          ymax = Math.max.apply(Math, kg);
          xmin = Math.min.apply(Math, kq);
          ymin = Math.min.apply(Math, kg);
          this.size = new i0(Math.ceil(xmax - xmin), Math.ceil(ymax - ymin));
          this.anchor = new i0(-xmin, -ymin);
          this._originOffset = new i0(xmin - i.topleft.x, ymin - i.topleft.y);
          this._innerOffset = new fi(kr.width, kr.height);
          this._rotationAngle = km;
          kh.path = kj;
          break;
      }
      this.imageSize = new i0(this.size.width, this.size.height);
      this.offset = this.anchor;
      if (kn) {
        this.resetInitOptions();
      }
    },
    _calSize: function (e) {
      if (this.style.strokeWeight) {
        return e * this.style.scale + this.style.strokeWeight % 3 + this.style.strokeWeight;
      } else {
        return e * this.style.scale + this.style.scale + this.style.scale % 2;
      }
    },
    render: function (T) {
      var ki = this;
      var kc = this.style.scale;
      var kj;
      var kk = this.size;
      if (this.context) {
        kj = this.context;
        if (this.context.canvas.width / 2 !== this.size.width || this.context.canvas.height / 2 !== this.size.height) {
          this.context.canvas.width = this.size.width * 2;
          this.context.canvas.height = this.size.height * 2;
        }
        kj.clearRect(0, 0, this.size.width * 2, this.size.height * 2);
        kj.fillStyle = hB.convert2rgba(ki.style.fillColor, ki.style.fillOpacity);
        kj.strokeStyle = hB.convert2rgba(ki.style.strokeColor, ki.style.strokeOpacity);
        kj.save();
      } else {
        return false;
      }
      kj.scale(2, 2);
      kj.lineCap = "round";
      kj.lineJoin = "round";
      kj.lineWidth = ki.style.strokeWeight || kc;
      if (ki._originOffset) {
        kj.translate(-ki._originOffset.width, -ki._originOffset.height);
      }
      if (ki._rotationAngle) {
        kj.rotate(ki._rotationAngle);
      }
      if (ki._innerOffset) {
        kj.translate(-ki._innerOffset.x, -ki._innerOffset.y);
      }
      switch (ki.path) {
        case b6.BMap_Symbol_SHAPE_CIRCLE:
          kj.arc(kk.width / 2, kk.height / 2, kc, 0, 2 * Math.PI);
          break;
        case b6.BMap_Symbol_SHAPE_RECTANGLE:
          kj.rect(0, 0, 4 * kc, 2 * kc);
          break;
        case b6.BMap_Symbol_SHAPE_STAR:
          kj.beginPath();
          var ke = kk.width / 2;
          var kg = kc * 10;
          var kd = 2 * Math.PI / 10;
          for (var kf = 11; kf != 0; kf--) {
            var e = kg * (kf % 2 + 1) / 2;
            var kh = kd * kf;
            kj.lineTo(e * Math.sin(kh) + ke, e * Math.cos(kh) + ke);
          }
          kj.closePath();
          break;
        default:
          kj.lineWidth = kj.lineWidth / kc;
          kj.scale(kc, kc);
          ki.path.draw(kj);
      }
      kj.fill();
      kj.stroke();
      kj.restore();
      this.data = kj.getImageData(0, 0, this.size.width * 2, this.size.height * 2);
      return true;
    },
    setPath: function (e) {
      this._rawPath = e;
      this._buildPath();
      this.update();
    },
    setAnchor: function (e) {
      this._anchor = this.style.anchor = e;
      this._buildPath();
      this.update();
    },
    setRotation: function (e) {
      this.style.rotation = e;
      this._buildPath();
      this.update();
    },
    setScale: function (e) {
      this.style.scale = e;
      this._buildPath();
      this.update();
    },
    setStrokeWeight: function (e) {
      this.style.strokeWeight = e;
      this._buildPath();
      this.update();
    },
    setStrokeColor: function (e) {
      e = hB.convert2rgba(e, this.style.strokeOpacity);
      this.style.strokeColor = e;
      this._buildPath();
      this.update();
    },
    setStrokeOpacity: function (e) {
      this.style.strokeOpacity = e;
      this._buildPath();
      this.update();
    },
    setFillOpacity: function (e) {
      this.style.fillOpacity = e;
      this._buildPath();
      this.update();
    },
    setFillColor: function (e) {
      this.style.fillColor = e;
      this._buildPath();
      this.update();
    }
  });
  bx.SymbolShapeType = b6;
  function jt(ke, kc, T) {
    if (!ke || !kc) {
      return;
    }
    this.imageUrl = null;
    this.imageDom = null;
    if (typeof ke === "string") {
      this.imageUrl = ke;
    } else {
      this.imageDom = ke;
      if (!this.imageDom.id) {
        this.imageDom.id = bx.getGUID("icon_dom_");
      }
    }
    this.size = kc;
    var kd = new i0(Math.floor(kc.width / 2), Math.floor(kc.height / 2));
    var i = {
      offset: kd,
      imageOffset: new i0(0, 0)
    };
    T = T || {};
    for (var e in T) {
      i[e] = T[e];
    }
    if (T.anchor) {
      i.offset = T.anchor;
    }
    this.anchor = this.offset = i.offset;
    this.imageOffset = i.imageOffset;
    this.infoWindowOffset = T.infoWindowOffset || this.offset;
    this.printImageUrl = T.printImageUrl || "";
    this.imageSize = T.imageSize || this.size;
    this.srcSetObject = {};
    this.setImageSrcset(T.srcset || T.srcSet);
  }
  jt.prototype.setImageUrl = function (e) {
    if (!e) {
      return;
    }
    this.imageUrl = e;
    this._renderData = null;
  };
  jt.prototype.getCurrentImageUrl = function () {
    if (window.devicePixelRatio > 1 && this.srcSetObject["2x"]) {
      return this.srcSetObject["2x"];
    }
    return this.imageUrl;
  };
  jt.prototype.setPrintImageUrl = function (e) {
    if (!e) {
      return;
    }
    this.printImageUrl = e;
  };
  jt.prototype.setSize = function (e) {
    if (!e) {
      return;
    }
    this.size = new i0(e.width, e.height);
    this._renderData = null;
  };
  jt.prototype.setOffset = function (e) {
    if (!e) {
      return;
    }
    this.anchor = this.offset = new i0(e.width, e.height);
    this._renderData = null;
  };
  jt.prototype.setAnchor = function (e) {
    this.setOffset(e);
  };
  jt.prototype.setImageOffset = function (e) {
    if (!e) {
      return;
    }
    this.imageOffset = new i0(e.width, e.height);
    this._renderData = null;
  };
  jt.prototype.setInfoWindowOffset = function (e) {
    if (!e) {
      return;
    }
    this.infoWindowOffset = new i0(e.width, e.height);
  };
  jt.prototype.setImageSize = function (e) {
    if (!e) {
      return;
    }
    this.imageSize = new i0(e.width, e.height);
  };
  jt.prototype.setImageSrcset = function (T) {
    var e = "";
    if (!T) {
      return;
    }
    for (var i in T) {
      if (T.hasOwnProperty(i)) {
        this.srcSetObject[i] = T[i];
        e = T[i] + " " + i + ",";
      }
    }
    this.srcSet = e;
  };
  jt.prototype.toString = function () {
    return "Icon";
  };
  jt.prototype.generateRenderData = function (ke) {
    var T = this.offset;
    var e = this.size;
    var kg = this.imageOffset;
    var kf = [];
    kf.push(-T.width, T.height - e.height, 0);
    kf.push(e.width - T.width, T.height - e.height, 0);
    kf.push(e.width - T.width, T.height, 0);
    kf.push(-T.width, T.height - e.height, 0);
    kf.push(e.width - T.width, T.height, 0);
    kf.push(-T.width, T.height, 0);
    if (ke !== 0) {
      for (var kd = 0; kd < kf.length; kd += 3) {
        var kc = vec2.fromValues(kf[kd], kf[kd + 1]);
        vec2.rotate(kc, kc, [0, 0], iB(-ke));
        kf[kd] = kc[0];
        kf[kd + 1] = kc[1];
      }
    }
    return {
      vertex: kf
    };
  };
  jt.prototype.getRenderData = function (e) {
    this._renderData = this.generateRenderData(e);
    return this._renderData;
  };
  function d2(T, i) {
    eX.BaseClass.call(this);
    this.content = T;
    this.map = null;
    this._config = {
      width: 0,
      height: 0,
      maxWidth: 600,
      offset: new i0(0, 0),
      title: "",
      maxContent: "",
      enableMaximize: false,
      enableAutoPan: true,
      enableCloseOnClick: true,
      margin: [10, 10, 40, 10],
      collisions: [[10, 10], [10, 10], [10, 10], [10, 10]],
      ifMaxScene: false,
      canScroll: false,
      onClosing: function () {
        return true;
      }
    };
    this.setConfig(i);
    if (this._config.width !== 0) {
      if (this._config.width < 220) {
        this._config.width = 220;
      }
      if (this._config.width > 730) {
        this._config.width = 730;
      }
    }
    if (this._config.height !== 0) {
      if (this._config.height < 60) {
        this._config.height = 60;
      }
      if (this._config.height > 650) {
        this._config.height = 650;
      }
    }
    if (this._config.maxWidth !== 0) {
      if (this._config.maxWidth < 220) {
        this._config.maxWidth = 220;
      }
      if (this._config.maxWidth > 730) {
        this._config.maxWidth = 730;
      }
    }
    this.isWinMax = false;
    this.IMG_PATH = B.imgPath;
    this.overlay = null;
    var e = this;
    g2.load("infowindow", function () {
      e._draw();
    });
  }
  d2.inherits(eX.BaseClass, "InfoWindow");
  eX.extend(d2.prototype, {
    setWidth: function (e) {
      e = e * 1;
      if (!e && e !== 0 || isNaN(e) || e < 0) {
        return;
      }
      if (e !== 0) {
        if (e < 220) {
          e = 220;
        }
        if (e > 730) {
          e = 730;
        }
      }
      this._config.width = e;
    },
    setHeight: function (e) {
      e = e * 1;
      if (!e && e !== 0 || isNaN(e) || e < 0) {
        return;
      }
      if (e !== 0) {
        if (e < 60) {
          e = 60;
        }
        if (e > 650) {
          e = 650;
        }
      }
      this._config.height = e;
    },
    setMaxWidth: function (e) {
      e = e * 1;
      if (!e && e !== 0 || isNaN(e) || e < 0) {
        return;
      }
      if (e !== 0) {
        if (e < 220) {
          e = 220;
        }
        if (e > 730) {
          e = 730;
        }
      }
      this._config.maxWidth = e;
    },
    setTitle: function (e) {
      this._config.title = e || "";
    },
    setContent: function (e) {
      this.content = e || "";
    },
    getContent: function () {
      return this.content;
    },
    setMaxContent: function (e) {
      this._config.maxContent = e || "";
    },
    redraw: function () {},
    enableAutoPan: function () {
      this._config.enableAutoPan = true;
    },
    disableAutoPan: function () {
      this._config.enableAutoPan = false;
    },
    enableCloseOnClick: function () {
      this._config.enableCloseOnClick = true;
    },
    disableCloseOnClick: function () {
      this._config.enableCloseOnClick = false;
    },
    enableMaximize: function () {
      this._config.enableMaximize = true;
    },
    disableMaximize: function () {
      this._config.enableMaximize = false;
    },
    show: function () {
      this._visible = true;
    },
    hide: function () {
      this._visible = false;
    },
    close: function () {
      this.hide();
    },
    dispose: function () {
      eX.BaseClass.prototype.decontrol.call(this);
    },
    maximize: function () {
      this.isWinMax = true;
    },
    restore: function () {
      this.isWinMax = false;
    },
    setConfig: function (i) {
      if (!i) {
        return;
      }
      for (var e in i) {
        if (typeof this._config[e] === typeof i[e]) {
          this._config[e] = i[e];
        }
      }
    },
    isVisible: function () {
      return this.isOpen();
    },
    isOpen: function () {
      return false;
    },
    getPointIn: function () {
      if (this.overlay && this.overlay.getPoint) {
        return this.overlay.getPoint();
      }
    },
    getTitle: function () {
      return this._config.title || "";
    },
    getPosition: function () {
      return this.latLng;
    },
    getPoint: function () {
      var e = this.getPointIn();
      if (this.map.config.coordType === BMAP_COORD_GCJ02) {
        var i = i9.convertMC2LL(e);
        return eG(i);
      }
      return i9.convertMC2LL(e);
    },
    getOffset: function () {
      return this._config.offset;
    },
    dispose: function () {
      eX.BaseClass.prototype.decontrol.call(this);
    },
    toString: function () {
      return "InfoWindow";
    }
  });
  hK.prototype.openInfoWindow = function (T, e) {
    T.latLng = new cr(e.lat, e.lng);
    var i = i9.convertLL2MC(e);
    this.openInfoWindowIn(T, i);
  };
  hK.prototype.closeInfoWindow = function () {
    var e = this.temp.infoWin || this.temp._infoWin;
    if (e && e.overlay) {
      e.overlay.closeInfoWindow();
    }
  };
  hK.prototype.openInfoWindowIn = function (kc, e) {
    if (!kc || kc.toString() !== "InfoWindow" || !e || e.toString() !== "Point") {
      return;
    }
    var i = this.temp;
    if (!i.marker) {
      var T = new jt(B.imgPath + "blank.gif", {
        width: 1,
        height: 1
      });
      i.marker = new jP(e, {
        icon: T,
        width: 1,
        height: 1,
        offset: new i0(0, 0),
        infoWindowOffset: new i0(0, 0),
        clickable: false
      });
      i.marker._fromMap = 1;
    } else {
      i.marker.setPoint(e);
    }
    this.addOverlay(i.marker);
    i.marker.show();
    i.marker.openInfoWindow(kc);
  };
  eA.prototype.openInfoWindow = function (e) {
    if (this.map) {
      this.map.closeInfoWindow();
      e._visible = true;
      this.map.temp._infoWin = e;
      e.overlay = this;
      eX.BaseClass.call(e, e.hashCode);
    }
  };
  eA.prototype.closeInfoWindow = function () {
    if (this.map && this.map.temp._infoWin) {
      this.map.temp._infoWin._visible = false;
      this.map.temp._infoWin.decontrol();
      this.map.temp._infoWin = null;
    }
  };
  function bd(T, i) {
    eA.call(this);
    this.content = T;
    this.map = null;
    this.domElement = null;
    this._config = {
      width: 0,
      offset: new i0(0, 0),
      styles: {
        backgroundColor: "#fff",
        border: "1px solid #f00",
        padding: "1px",
        whiteSpace: "nowrap",
        fontSize: "12px",
        zIndex: "80",
        MozUserSelect: "none"
      },
      point: null,
      enableMassClear: true
    };
    i = i || {};
    this.setConfig(i);
    if (this._config.width < 0) {
      this._config.width = 0;
    }
    this.point = this._config.point;
    var e = this;
    g2.load("marker", function () {
      e._draw();
    });
  }
  bd.inherits(eA, "Label");
  eX.extend(bd.prototype, {
    setPoint: function (e) {
      if (e && e.toString() === "Point" && !this.getMarker()) {
        if (this.coordType === BMAP_COORD_GCJ02) {
          var i = iu(e, 3);
          this.point = this._config.point = new cx(i.lng, i.lat);
        } else {
          this.point = this._config.point = new cx(e.lng, e.lat);
        }
      }
    },
    setContent: function (e) {
      this.content = e;
    },
    getContent: function (e) {
      return this.content;
    },
    setOpacity: function (e) {
      if (e >= 0 && e <= 1) {
        this._config.opacity = e;
      }
    },
    setOffset: function (e) {
      if (!e || e.toString() !== "Size") {
        return;
      }
      this._config.offset = new i0(e.width, e.height);
    },
    getOffset: function () {
      return this._config.offset;
    },
    setStyle: function (e) {
      e = e || {};
      this._config.styles = eX.extend(this._config.styles, e);
    },
    setStyles: function (e) {
      this.setStyle(e);
    },
    setTitle: function (e) {
      this._config.title = e || "";
    },
    getTitle: function () {
      return this._config.title;
    },
    setMarker: function (e) {
      if (this._marker && this._marker !== e) {
        this._marker._config.label = null;
      }
      this._marker = e;
      if (e) {
        this.point = this._config.point = e.getPoint();
      } else {
        this.point = this._config.point = null;
      }
    },
    getMarker: function () {
      return this._marker || null;
    },
    getPositionIn: function () {
      return this.getPoint();
    }
  });
  function hR(T, i) {
    var kc = {};
    for (var e in i) {
      if (i.hasOwnProperty(e)) {
        if (e === "position") {
          kc.point = i9.convertLL2MC(i[e]);
          this.latLng = new cr(i[e].lat, i[e].lng);
        } else {
          kc[e] = i[e];
        }
      }
    }
    bd.call(this, T, kc);
  }
  hR.inherits(bd, "LabelOut");
  eX.extend(hR.prototype, {
    toString: function () {
      return "Label";
    },
    setPosition: function (e) {
      this.latLng = new cr(e.lat, e.lng);
      var i = i9.convertLL2MC(e);
      this.setPoint(i);
    },
    getPosition: function () {
      return this.latLng;
    }
  });
  window.BMAP_ANIMATION_DROP = 1;
  window.BMAP_ANIMATION_BOUNCE = 2;
  function jP(e, i) {
    eA.call(this);
    i = i || {};
    this.delFlag = i.delFlag;
    this.point = e;
    this._rotation = 0;
    this.map = null;
    this._animation = null;
    this.domElement = null;
    this.iconDom = null;
    this.infoWindowDom = null;
    this.siblingElement = null;
    this.textureCoord = null;
    this.textureCoordGLMap = null;
    this.collisionDetectionFailed = false;
    this._config = {
      offset: new i0(0, 0),
      opacity: 1,
      icon: null,
      title: "",
      infoWindow: null,
      label: null,
      baseZIndex: 0,
      clickable: true,
      zIndexFixed: false,
      isTop: false,
      enableMassClear: true,
      enableDragging: false,
      raiseOnDrag: false,
      restrictDraggingArea: false,
      startAnimation: "",
      enableCollisionDetection: false,
      rank: 0,
      enableDraggingMap: false
    };
    this.setOptions(i);
    this._isDragging = false;
    var T = this;
    g2.load("marker", function () {
      T._draw();
    });
  }
  jP.TOP_ZINDEX = aR.getZIndex(-90) + 1000000;
  jP.DRAG_ZINDEX = jP.TOP_ZINDEX + 1000000;
  jP._injectMethond = function (e) {
    eX.extend(jP.prototype, e);
  };
  jP.inherits(eA, "Marker");
  eX.extend(jP.prototype, {
    toString: function () {
      return "Marker";
    },
    setOptions: function (e) {
      this.setConfig(e);
      if (!e.icon) {
        this._config.icon = new jt(B.imgPath + "marker_red.png", new i0(23, 25), {
          offset: new i0(10, 25),
          infoWindowOffset: new i0(10, 0)
        });
      }
    },
    setIcon: function (e) {
      if (e) {
        this._config.icon = e;
        this.textureCoord = this.textureCoordGLMap = null;
      }
    },
    getIcon: function () {
      return this._config.icon;
    },
    setLabel: function (e) {
      if (!(e instanceof bd)) {
        return;
      }
      this._config.label = e;
      e._config.enableMassClear = this._config.enableMassClear;
      e.setPoint(this.point);
    },
    getLabel: function () {
      return this._config.label;
    },
    enableDragging: function () {
      this._config.enableDragging = true;
    },
    disableDragging: function () {
      this._config.enableDragging = false;
    },
    setPoint: function (e) {
      if (e) {
        if (this.map.config.coordType === BMAP_COORD_GCJ02) {
          var i = iu(e, 3);
          this.point = this._config.point = new cx(i.lng, i.lat);
          this.latLng = i9.convertMC2LL(i);
        } else {
          this.point = this._config.point = new cx(e.lng, e.lat);
          this.latLng = i9.convertMC2LL(e);
        }
      }
    },
    setPositionIn: function (e) {
      this.setPoint(e);
    },
    getPositionIn: function () {
      return this.getPoint();
    },
    setTop: function (i, e) {
      this._config.isTop = !!i;
      if (i) {
        this._addi = e || 0;
      }
    },
    setTitle: function (e) {
      this._config.title = e || "";
    },
    getTitle: function () {
      return this._config.title;
    },
    setOffset: function (e) {
      if (e) {
        this._config.offset = e;
      }
    },
    getOffset: function () {
      return this._config.offset;
    },
    setAnimation: function (e) {
      this._animation = e;
    },
    setRank: function (e) {
      this._config.rank = e;
    },
    getRank: function () {
      return this._config.rank;
    },
    setRotation: function (e) {
      while (e < 0) {
        e += 360;
      }
      this._rotation = e % 360;
    },
    getRotation: function () {
      return this._rotation;
    }
  });
  function s(e, T) {
    this.latLng = new cr(e.lat, e.lng);
    var i = i9.convertLL2MC(e);
    jP.call(this, i, T);
  }
  s.inherits(jP, "MarkerOut");
  eX.extend(s.prototype, {
    toString: function () {
      return "Marker";
    },
    toGeoJSON: function () {
      var i = "Point";
      var T = [this.latLng.lng, this.latLng.lat];
      var e = {
        type: "Feature",
        geometry: {
          type: i,
          coordinates: T
        },
        properties: this.properties
      };
      return e;
    },
    updateByGeoJSON: function (T) {
      var e = new gw();
      var ke = e.readFeaturesFromObject(T) || [];
      for (var kc = 0, kd = ke.length; kc < kd; ++kc) {
        if (ke[kc] instanceof s) {
          this.properties = ke[kc].properties;
          this.setPosition(ke[kc].getPosition());
          break;
        }
      }
    },
    setPosition: function (e) {
      this.latLng = new cr(e.lat, e.lng);
      var i = i9.convertLL2MC(e);
      this.setPositionIn(i);
    },
    getPosition: function () {
      return this.latLng;
    }
  });
  window.BMAP_SHAPE_CIRCLE = 1;
  window.BMAP_SHAPE_RECT = 2;
  function ef(i, e, T) {
    eA.call(this, e, T);
    this.domElement = null;
    this.point = i;
    T = T || {};
    this._config = {};
    this._config.height = e || 0;
    this._config.size = typeof T.size === "number" ? T.size : 50;
    this._config.fillOpacity = typeof T.fillOpacity === "number" ? T.fillOpacity : 0.8;
    this._config.shape = typeof T.shape === "number" ? T.shape : 1;
    cb(this._config.fillOpacity, 0, 1);
    if (T.fillColor === "") {
      this._config.fillColor = "";
    } else {
      this._config.fillColor = T.fillColor ? T.fillColor : "#f00";
    }
    this._config.icon = T.icon instanceof jt || T.icon instanceof fg ? T.icon : "";
    this._config.enableMassClear = T.enableMassClear || true;
    var kc = this;
    g2.load("marker", function () {
      kc._draw();
    });
  }
  ef.inherits(eA, "Marker3D");
  eX.extend(ef.prototype, {
    setPoint: function (e) {
      if (this.map.config.coordType === BMAP_COORD_GCJ02) {
        var T = iu(e, 3);
        this.point = this._config.point = new cx(T.lng, T.lat);
        this.latLng = i9.convertMC2LL(T);
      } else {
        this.point = this._config.point = new cx(e.lng, e.lat);
        this.latLng = i9.convertMC2LL(e);
      }
      var i = new fJ("onstatus_change");
      i.overlay = this;
      i.action = "setPoint";
      this.fire(i);
    },
    setPositionIn: function (e) {
      this.setPoint(e);
    },
    getPositionIn: function () {
      return this.getPoint();
    },
    setDomAttribute: function (i, T) {
      var e = new fJ("onlineupdate");
      e.overlay = this;
      this.dispatchEvent(e);
    }
  });
  function ec(i, e, kc) {
    this.latLng = new cr(i.lat, i.lng);
    var T = i9.convertLL2MC(i);
    ef.call(this, T, e, kc);
  }
  ec.inherits(ef, "Marker3d");
  eX.extend(ec.prototype, {
    toString: function () {
      return "Marker3D";
    },
    setHeight: function (e) {
      this._config.height = Number(e);
      this.draw();
      var i = new fJ("onlineupdate");
      i.overlay = this;
      this.dispatchEvent(i);
    },
    getHeight: function () {
      return this._config.height;
    },
    setFillOpacity: function (e) {
      if (e > 1 || e < 0) {
        return;
      }
      this._config.fillOpacity = e;
      this.setDomAttribute("fillopacity", e);
    },
    getFillOpacity: function () {
      return this._config.fillOpacity;
    },
    setFillColor: function (e) {
      this._config.fillColor = e || "";
      this.setDomAttribute("fillcolor", e);
    },
    getFillColor: function () {
      return this._config.fillColor;
    },
    setIcon: function (i) {
      if (!i || !this.map) {
        return;
      }
      this._config.icon = i;
      if (this._config.icon) {
        var e = this._config.icon.getCurrentImageUrl();
        var kc = i.getCurrentImageUrl() !== e;
        this._config.icon = i;
        this.textureCoord = this.textureCoordGLMap = null;
        this.draw();
        var T = new fJ("onstatus_change");
        T.overlay = this;
        T.action = "setIcon";
        T.imageUrlChanged = kc;
        this.fire(T);
      }
    },
    getIcon: function () {
      return this._config.icon;
    },
    setPosition: function (e) {
      this.latLng = new cr(e.lat, e.lng);
      var i = i9.convertLL2MC(e);
      this.setPositionIn(i);
    },
    getPosition: function () {
      var e = this.getPositionIn();
      return i9.convertMC2LL(e);
    }
  });
  function fT(T, e) {
    iz.call(this, e);
    this._normalizedBounds = new hY();
    this.setPoints(T);
    var i = this;
    g2.load("poly", function () {
      i._draw();
    });
  }
  fT.inherits(iz, "Polyline");
  eX.extend(fT.prototype, {
    getBoundsIn: function (e) {
      if (!e) {
        this._bounds.setMinMax();
        return this._bounds;
      }
      this._normalizedBounds.setMinMax();
      return this._normalizedBounds;
    },
    setPoints: function (kf) {
      this._clearCache();
      this.points = iz.getGraphPoints(kf).slice(0);
      if (this._config.geodesic === true) {
        this.greatCirclePoints.length = 0;
        for (var kd = 0; kd < this.points.length - 1; kd++) {
          this.calcGreatCirclePoints(this.points[kd], this.points[kd + 1]);
        }
      } else if (this._config.linkRight) {
        var kg = [];
        var ke = null;
        for (var kd = 0; kd < this.points.length - 1; kd++) {
          if (!kd) {
            kg.push(this.points[kd]);
          }
          var T = ke || this.points[kd];
          ke = this.points[kd + 1];
          var kc = es(ke, T);
          if (kc > 15437726) {
            if (ke.lng < T.lng) {
              ke.lng += hK.WORLD_SIZE_MC;
            } else {
              ke.lng -= hK.WORLD_SIZE_MC;
            }
          }
          kg.push(ke);
        }
        this.points = kg;
      }
      this._calcBounds();
      this.draw();
      var e = new fJ("onlineupdate");
      e.overlay = this;
      this.dispatchEvent(e);
      if (this._visible && this._config.enableEditing === true && !this._config.geodesic) {
        if (this.clearVertexs) {
          this.clearVertexs();
        }
        if (this.addVertexs) {
          this.addVertexs();
        }
      }
    },
    _calcBounds: function () {
      if (!this.points) {
        return;
      }
      var e = this;
      e._bounds.setNorthEast(null);
      e._bounds.setSouthWest(null);
      if (e.greatCirclePoints && e.greatCirclePoints.length > 0) {
        eX.each(e.greatCirclePoints, function (i) {
          e._bounds.extend(i);
        });
      } else {
        eX.each(e.points, function (i) {
          e._bounds.extend(i);
        });
      }
      e._normalizedBounds.setSouthWest(e._bounds.getSouthWest());
      e._normalizedBounds.setNorthEast(e._bounds.getNorthEast());
      if (e._normalizedBounds.sw.lng < -hK.WORLD_SIZE_MC_HALF || e._normalizedBounds.ne.lng > hK.WORLD_SIZE_MC_HALF) {
        e._normalizedBounds.sw.lng = -hK.WORLD_SIZE_MC_HALF;
        e._normalizedBounds.ne.lng = hK.WORLD_SIZE_MC_HALF;
      }
    },
    calcGreatCirclePoints: function (kc, T) {
      var ke = kc.latLng;
      var kd = T.latLng;
      if (ke.equals(kd)) {
        return;
      }
      var e = i9.getDistance(iB(ke.lng), iB(ke.lat), iB(kd.lng), iB(kd.lat));
      if (e < 250000) {
        return;
      }
      var ki = Math.round(e / 150000);
      var km = this.calcAngularDistance(ke, kd);
      this.greatCirclePoints.push(kc);
      var kl = ke.lng;
      var kk = kc;
      for (var kf = 0; kf < ki; kf++) {
        var kh = this.calcMiddlePoint(ke, kd, kf / ki, km);
        var kj = i9.convertLL2MC(kh);
        var kg = kj.lng;
        var kn = es(kj, kk);
        if (kn > 30037726) {
          if (kj.lng < kk.lng) {
            kj.lng += hK.WORLD_SIZE_MC;
          } else {
            kj.lng -= hK.WORLD_SIZE_MC;
          }
        }
        this.greatCirclePoints.push(kj);
        kk = kj;
      }
      var kn = es(T, kk);
      if (kn > 30037726) {
        if (T.lng < kk.lng) {
          T.lng += hK.WORLD_SIZE_MC;
        } else {
          T.lng -= hK.WORLD_SIZE_MC;
        }
      }
      this.greatCirclePoints.push(T);
    },
    calcMiddlePoint: function (kj, ki, kk, ko) {
      var kd = kj.lat;
      var kc = ki.lat;
      var kn = kj.lng;
      var kl = ki.lng;
      var kp = iB(kd);
      var km = iB(kc);
      var i = iB(kn);
      var e = iB(kl);
      var kr = Math.sin((1 - kk) * ko) / Math.sin(ko);
      var kq = Math.sin(kk * ko) / Math.sin(ko);
      var kg = kr * Math.cos(kp) * Math.cos(i) + kq * Math.cos(km) * Math.cos(e);
      var kf = kr * Math.cos(kp) * Math.sin(i) + kq * Math.cos(km) * Math.sin(e);
      var ke = kr * Math.sin(kp) + kq * Math.sin(km);
      var T = Math.atan2(ke, Math.sqrt(Math.pow(kg, 2) + Math.pow(kf, 2)));
      var kh = Math.atan2(kf, kg);
      return new cx(e9(kh), e9(T));
    },
    calcAngularDistance: function (kd, i) {
      var ke = iB(kd.lat);
      var kc = iB(i.lat);
      var T = iB(kd.lng);
      var e = iB(i.lng);
      return Math.acos(Math.sin(ke) * Math.sin(kc) + Math.cos(ke) * Math.cos(kc) * Math.cos(Math.abs(e - T)));
    }
  });
  function bl(kd, e) {
    if (!kd || kd.length === 0) {
      return;
    }
    var kc = [];
    for (var T = 0; T < kd.length; T++) {
      kc[T] = i9.convertLL2MC(kd[T]);
    }
    fT.call(this, kc, e);
  }
  bl.inherits(fT, "PolylineOut");
  eX.extend(bl.prototype, {
    toString: function () {
      return "Polyline";
    },
    toGeoJSON: function () {
      var kc = "LineString";
      var kd = [];
      var ke = this.getPath();
      for (var T = 0; T < ke.length; T++) {
        kd.push([ke[T].lng, ke[T].lat]);
      }
      var e = {
        type: "Feature",
        geometry: {
          type: kc,
          coordinates: kd
        },
        properties: this.properties
      };
      return e;
    },
    updateByGeoJSON: function (T) {
      var e = new gw();
      var ke = e.readFeaturesFromObject(T) || [];
      for (var kc = 0, kd = ke.length; kc < kd; ++kc) {
        if (ke[kc] instanceof bl) {
          this.properties = ke[kc].properties;
          this.setPath(ke[kc].getPath());
          break;
        }
      }
    },
    setPath: function (kc) {
      if (!kc || kc.length === 0) {
        return;
      }
      var T = [];
      for (var e = 0; e < kc.length; e++) {
        T[e] = i9.convertLL2MC(kc[e]);
      }
      this.setPathIn(T);
      this._mouseEventPixels = null;
    },
    getPath: function () {
      var e = this.getPathIn();
      if (!e || e.length === 0) {
        return [];
      }
      var kc = [];
      for (var T = 0; T < e.length; T++) {
        kc[T] = i9.convertMC2LL(e[T]);
      }
      return kc;
    },
    getBounds: function (i) {
      var e = this.getBoundsIn(i);
      var T = new hY(i9.convertMC2LL(e.getSouthWest()), i9.convertMC2LL(e.getNorthEast()));
      return T;
    }
  });
  function gO(T, kc, e) {
    iz.call(this, e);
    this._normalizedBounds = new hY();
    this._cps = kc;
    this._path = T;
    this.setPoints(T);
    var i = this;
    g2.load("poly", function () {
      i._draw();
    });
  }
  gO.inherits(fT, "BezierCurve");
  eX.extend(gO.prototype, {
    getBoundsIn: function (e) {
      if (!e) {
        this._bounds.setMinMax();
        return this._bounds;
      }
      this._normalizedBounds.setMinMax();
      return this._normalizedBounds;
    },
    setPoints: function (e) {
      this._clearCache();
      this.points = iz.getGraphPoints(e).slice(0);
      this.points = this.calcBezierPoints(this.points, this._cps);
      this._calcBounds();
    },
    _calcBounds: function () {
      if (!this.points) {
        return;
      }
      var e = this;
      e._bounds.setNorthEast(null);
      e._bounds.setSouthWest(null);
      if (e.greatCirclePoints && e.greatCirclePoints.length > 0) {
        eX.each(e.greatCirclePoints, function (i) {
          e._bounds.extend(i);
        });
      } else {
        eX.each(e.points, function (i) {
          e._bounds.extend(i);
        });
      }
      e._normalizedBounds.setSouthWest(e._bounds.getSouthWest());
      e._normalizedBounds.setNorthEast(e._bounds.getNorthEast());
      if (e._normalizedBounds.sw.lng < -hK.WORLD_SIZE_MC_HALF || e._normalizedBounds.ne.lng > hK.WORLD_SIZE_MC_HALF) {
        e._normalizedBounds.sw.lng = -hK.WORLD_SIZE_MC_HALF;
        e._normalizedBounds.ne.lng = hK.WORLD_SIZE_MC_HALF;
      }
    },
    getPathIn: function () {
      return this._path;
    },
    setPathIn: function (e) {
      this._path = e;
      this.setPoints(e);
    },
    getCpsIn: function () {
      return this._cps;
    },
    setCpsIn: function (e) {
      this._cps = e;
      this.setPoints(this._path);
    },
    calcBezierPoints: function (kc, ke) {
      var T = [];
      for (var e = 0; e < kc.length - 1; e++) {
        var kd = [kc[e], ke[e][0], ke[e][1], kc[e + 1]];
        T = T.concat(this.bezierbetweenTwoP(kd));
      }
      return T;
    },
    bezierbetweenTwoP: function (ke) {
      var T = 100;
      var kd = 1 / T;
      var e = [];
      for (var kc = 0; kc < T; kc++) {
        e.push(this.getPointOnCubicBezier(ke, kc * kd));
      }
      return e;
    },
    getPointOnCubicBezier: function (kf, kj) {
      var i;
      var ke;
      var kc;
      var kk;
      var kd;
      var T;
      var ki;
      var e;
      var kh;
      var kg;
      kc = 3 * (kf[1].lng - kf[0].lng);
      ke = 3 * (kf[2].lng - kf[1].lng) - kc;
      i = kf[3].lng - kf[0].lng - kc - ke;
      T = 3 * (kf[1].lat - kf[0].lat);
      kd = 3 * (kf[2].lat - kf[1].lat) - T;
      kk = kf[3].lat - kf[0].lat - T - kd;
      ki = kj * kj;
      e = ki * kj;
      kh = i * e + ke * ki + kc * kj + kf[0].lng;
      kg = kk * e + kd * ki + T * kj + kf[0].lat;
      return new cx(kh, kg);
    }
  });
  function cH(kd, kf, e) {
    if (!kd || kd.length === 0) {
      return;
    }
    this.userPath = kd;
    this.userCps = kf;
    var kc = [];
    for (var T = 0; T < kd.length; T++) {
      kc[T] = i9.convertLL2MC(kd[T]);
    }
    if (!kf || kf.length === 0) {
      return;
    }
    var ke = [];
    for (var T = 0; T < kf.length; T++) {
      ke[T] = [];
      ke[T][0] = i9.convertLL2MC(kf[T][0]);
      if (kf[T][1]) {
        ke[T][1] = i9.convertLL2MC(kf[T][1]);
      } else {
        ke[T][1] = i9.convertLL2MC(kf[T][0]);
      }
    }
    gO.call(this, kc, ke, e);
  }
  cH.inherits(gO, "BezierCurveOut");
  eX.extend(cH.prototype, {
    toString: function () {
      return "BezierCurve";
    },
    setPath: function (kc) {
      if (!kc || kc.length === 0) {
        return;
      }
      this.userPath = kc;
      var T = [];
      for (var e = 0; e < kc.length; e++) {
        T[e] = i9.convertLL2MC(kc[e]);
      }
      this.setPathIn(T);
      this._mouseEventPixels = null;
    },
    getPath: function () {
      return this.userPath;
      var e = this.getPathIn();
      if (!e || e.length === 0) {
        return [];
      }
      var kc = [];
      for (var T = 0; T < e.length; T++) {
        kc[T] = i9.convertMC2LL(e[T]);
      }
      return kc;
    },
    getControlPoints: function () {
      return this.userCps;
      var e = this.getCpsIn();
      if (!e || e.length === 0) {
        return [];
      }
      var kc = [];
      for (var T = 0; T < e.length; T++) {
        kc[T] = [];
        kc[T][0] = i9.convertMC2LL(e[T][0]);
        kc[T][1] = i9.convertMC2LL(e[T][1]);
      }
      return kc;
    },
    setControlPoints: function (kc) {
      if (!kc || kc.length === 0) {
        return;
      }
      this.userCps = kc;
      var T = [];
      for (var e = 0; e < kc.length; e++) {
        T[e] = [];
        T[e][0] = i9.convertLL2MC(kc[e][0]);
        if (kc[e][1]) {
          T[e][1] = i9.convertLL2MC(kc[e][1]);
        } else {
          T[e][1] = i9.convertLL2MC(kc[e][0]);
        }
      }
      this.setCpsIn(T);
    },
    getBounds: function (i) {
      var e = this.getBoundsIn(i);
      var T = new hY(i9.convertMC2LL(e.getSouthWest()), i9.convertMC2LL(e.getNorthEast()));
      return T;
    }
  });
  function el(e, T) {
    iz.call(this, T);
    this._normalizedBounds = new hY();
    this.setPoints(e);
    var i = this;
    g2.load("poly", function () {
      i._draw();
    });
  }
  el.inherits(fT, "PolylineMultipart");
  eX.extend(el.prototype, {
    setPoints: function (e) {
      if (!e) {
        return;
      }
      this._clearCache();
      this.points = this._unifyArgs(e);
      this._calcBounds();
    },
    _unifyArgs: function (T) {
      var e = [];
      var i = [];
      if (T.constructor === Array) {
        if (T[0].constructor === cx) {
          i.push(T);
        } else {
          i = T;
        }
      } else if (typeof T === "string") {
        i.push(T);
      }
      eX.each(i, function (kc) {
        e.push(iz.getGraphPoints(kc));
      });
      return e;
    },
    setPointAt: function (i, e, T) {
      T = T || 0;
      if (!e || !this.points[T] || !this.points[T][i]) {
        return;
      }
      this._clearCache();
      this.points[T][i] = new cx(e.lng, e.lat);
      this._calcBounds();
    },
    getBoundsIn: function (e) {
      if (!e) {
        this._bounds.setMinMax();
        return this._bounds;
      }
      this._normalizedBounds.setMinMax();
      return this._normalizedBounds;
    },
    _calcBounds: function () {
      if (!this.points) {
        return;
      }
      var e = this;
      e._bounds.setNorthEast(null);
      e._bounds.setSouthWest(null);
      if (e.greatCirclePoints && e.greatCirclePoints.length > 0) {
        eX.each(e.greatCirclePoints, function (i) {
          e._bounds.extend(i);
        });
      } else {
        eX.each(e.points, function (i) {
          eX.each(i, function (T) {
            e._bounds.extend(T);
          });
        });
      }
      e._normalizedBounds.setSouthWest(e._bounds.getSouthWest());
      e._normalizedBounds.setNorthEast(e._bounds.getNorthEast());
      if (e._normalizedBounds.sw.lng < -hK.WORLD_SIZE_MC_HALF || e._normalizedBounds.ne.lng > hK.WORLD_SIZE_MC_HALF) {
        e._normalizedBounds.sw.lng = -hK.WORLD_SIZE_MC_HALF;
        e._normalizedBounds.ne.lng = hK.WORLD_SIZE_MC_HALF;
      }
    }
  });
  function hh(T, e) {
    iz.call(this, e);
    e = e || {};
    if (typeof e.fillOpacity === "number") {
      this._config.fillOpacity = e.fillOpacity;
    } else {
      this._config.fillOpacity = 0.6;
    }
    cb(this._config.fillOpacity, 0, 1);
    if (e.fillColor === "") {
      this._config.fillColor = "";
    } else {
      this._config.fillColor = e.fillColor ? e.fillColor : "#fff";
    }
    this._parseFillCacheWebGL = [];
    this.setPoints(T, e);
    var i = this;
    g2.load("poly", function () {
      i._draw();
    });
  }
  hh.inherits(iz, "Polygon");
  eX.extend(hh.prototype, {
    setPoints: function (ke) {
      var kc = [];
      if (typeof ke === "string" || ke.length === 1 || ke[0] instanceof cx || ke[0] instanceof cr || this instanceof gW || ke.length === 0) {
        if (ke.length === 1) {
          ke = ke[0];
        }
        var e = this._processSinglePointArray(ke);
        this._userPoints = e.userPoints;
        kc = e.innerPoints;
        this.hasMultipleParts = false;
      } else {
        this._userPoints = [];
        for (var kd = 0; kd < ke.length; kd++) {
          var T = this._processSinglePointArray(ke[kd]);
          this._userPoints.push(T.userPoints);
          kc.push(T.innerPoints);
        }
        this.hasMultipleParts = true;
      }
      iz.prototype.setPoints.call(this, kc);
    },
    setPathIn: function (e) {
      this.setPoints(e);
    },
    _processSinglePointArray: function (e) {
      var i = iz.getGraphPoints(e).slice(0);
      innerPoints = i.slice(0);
      if (innerPoints.length > 1 && !innerPoints[0].equals(innerPoints[innerPoints.length - 1])) {
        innerPoints.push(new cx(innerPoints[0].lng, innerPoints[0].lat));
      }
      return {
        userPoints: i,
        innerPoints: innerPoints
      };
    },
    setPointAt: function (i, e) {
      if (!this._userPoints[i]) {
        return;
      }
      this._clearCache();
      this._userPoints[i] = new cx(e.lng, e.lat);
      this.points[i] = new cx(e.lng, e.lat);
      if (i === 0 && !this.points[0].equals(this.points[this.points.length - 1])) {
        this.points[this.points.length - 1] = new cx(e.lng, e.lat);
      }
      this._calcBounds();
    },
    setPositionAt: function (i, e) {
      if (!this._userPoints[i]) {
        return;
      }
      var T = i9.convertLL2MC(e);
      this.setPointAt(i, T);
    },
    getPoints: function () {
      var e = this._userPoints;
      if (e.length === 0) {
        e = this.points;
      }
      return e;
    },
    getPathIn: function () {
      return this.getPoints();
    }
  });
  function iG(T, e) {
    if (!T || T.length === 0) {
      return;
    }
    var i = this.setPath(T, true);
    hh.call(this, i, e);
  }
  iG.inherits(hh, "PolygonOut");
  eX.extend(iG.prototype, {
    toString: function () {
      return "Polygon";
    },
    toGeoJSON: function () {
      var kd = "Polygon";
      var ke = [];
      var kg = this.getPath();
      if (this.hasMultipleParts) {
        kd = "Multi" + kd;
        for (var kc = 0; kc < kg.length; kc++) {
          var kf = [];
          for (var T = 0; T < kg.length; T++) {
            kf.push([kg[kc][T].lng, kg[kc][T].lat]);
          }
          ke.push(kf);
        }
      } else {
        for (var kc = 0; kc < kg.length; kc++) {
          ke.push([kg[kc].lng, kg[kc].lat]);
        }
      }
      var e = {
        type: "Feature",
        geometry: {
          type: kd,
          coordinates: [ke]
        },
        properties: this.properties
      };
      return e;
    },
    updateByGeoJSON: function (T) {
      var e = new gw();
      var ke = e.readFeaturesFromObject(T) || [];
      for (var kc = 0, kd = ke.length; kc < kd; ++kc) {
        if (ke[kc] instanceof iG) {
          this.properties = ke[kc].properties;
          this.setPath(ke[kc].getPath());
          break;
        }
      }
    },
    setPath: function (kh, T) {
      if (!kh || kh.length === 0) {
        return;
      }
      var kg = [];
      if (typeof kh === "string" || kh[0] instanceof cx || kh[0] instanceof cr) {
        var e = this._processSinglePointArray(kh);
        for (var kf = 0; kf < e.innerPoints.length; kf++) {
          kg[kf] = i9.convertLL2MC(e.innerPoints[kf]);
        }
      } else {
        for (var kf = 0; kf < kh.length; kf++) {
          var kc = this._processSinglePointArray(kh[kf]);
          var ke = [];
          for (var kd = 0; kd < kc.innerPoints.length; kd++) {
            ke[kd] = i9.convertLL2MC(kc.innerPoints[kd]);
          }
          kg.push(ke);
        }
      }
      if (T) {
        return kg;
      }
      this.setPathIn(kg);
      this._mouseEventPixels = null;
    },
    getPath: function () {
      var e = this.getPathIn();
      if (!e || e.length === 0) {
        return [];
      }
      var ke = [];
      if (this.hasMultipleParts) {
        for (var kc = 0; kc < e.length; kc++) {
          var kd = [];
          for (var T = 0; T < e[kc].length; T++) {
            kd[T] = i9.convertMC2LL(e[kc][T]);
          }
          ke.push(kd);
        }
      } else {
        for (var kc = 0; kc < e.length; kc++) {
          ke[kc] = i9.convertMC2LL(e[kc]);
        }
      }
      return ke;
    }
  });
  function gW(i, e, T) {
    this.point = i;
    this.radius = Math.abs(e);
    hh.call(this, [], T);
  }
  gW.parseTolerance = {
    0: [0.01, 0.0001, 0.00001, 0.000004],
    1: [1000, 10, 1, 0.4]
  };
  gW.inherits(hh, "Circle");
  eX.extend(gW.prototype, {
    initialize: function (e) {
      this.map = e;
      this.points = this._getPerimeterPoints(this.point, this.radius);
      this._calcBounds();
      return null;
    },
    getPoint: function () {
      return this.point;
    },
    setPoint: function (e) {
      if (!e) {
        return;
      }
      this.point = e;
      this.latLng = i9.convertMC2LL(e);
    },
    setCenterIn: function (e) {
      var i = arguments[1];
      this.setPoint(e, i);
    },
    setRadius: function (e) {
      this.radius = Math.abs(e);
    },
    getCenterIn: function () {
      return this.point;
    },
    getRadius: function () {
      return this.radius;
    },
    _getPerimeterPoints: function (e, kj) {
      if (!e || !kj || !this.map) {
        return [];
      }
      var T = this.map;
      var kg = e.lng;
      var ke = e.lat;
      var kp = i9.convertMC2LL(e);
      kg = kp.lng;
      ke = kp.lat;
      var kq = [];
      var kl = kj / i9.EARTHRADIUS;
      var ki = Math.PI / 180 * ke;
      var ko = Math.PI / 180 * kg;
      for (var kh = 0; kh < 360; kh += 9) {
        var kf = Math.PI / 180 * kh;
        var km = Math.asin(Math.sin(ki) * Math.cos(kl) + Math.cos(ki) * Math.sin(kl) * Math.cos(kf));
        var kk = Math.atan2(Math.sin(kf) * Math.sin(kl) * Math.cos(ki), Math.cos(kl) - Math.sin(ki) * Math.sin(km));
        var kn = (ko - kk + Math.PI) % (2 * Math.PI) - Math.PI;
        var kd = new cr(km * (180 / Math.PI), kn * (180 / Math.PI));
        kq.push(i9.convertLL2MC(kd));
      }
      var kc = kq[0];
      kq.push(new cx(kc.lng, kc.lat));
      if (kc) {
        this._radiusMercator = Math.sqrt(Math.pow(kc.lng - this.point.lng, 2) + Math.pow(kc.lat - this.point.lat, 2));
      } else {
        this._radiusMercator = this.radius;
      }
      return kq;
    }
  });
  function aU(i, e, kc) {
    this.latLng = new cr(i.lat, i.lng);
    var T = i9.convertLL2MC(i);
    gW.call(this, T, e, kc);
  }
  aU.inherits(gW, "CircleOut");
  eX.extend(aU.prototype, {
    toString: function () {
      return "Circle";
    },
    setCenter: function (e) {
      this.latLng = new cr(e.lat, e.lng);
      var i = i9.convertLL2MC(e);
      this.setCenterIn(i);
    },
    getCenter: function () {
      return this.latLng;
    },
    getPath: function () {
      var e = this.getPathIn();
      if (!e || e.length === 0) {
        return [];
      }
      var kc = [];
      for (var T = 0; T < e.length; T++) {
        kc[T] = i9.convertMC2LL(e[T]);
      }
      return kc;
    },
    toGeoJSON: function () {
      var kc = "Polygon";
      var kd = [];
      var ke = this.getPath();
      for (var T = 0; T < ke.length; T++) {
        kd.push([ke[T].lng, ke[T].lat]);
      }
      var e = {
        type: "Feature",
        geometry: {
          type: kc,
          coordinates: [kd]
        },
        properties: this.properties
      };
      return e;
    },
    updateByGeoJSON: function (e) {}
  });
  function j1(kc, e, i) {
    iz.call(this, i);
    i = i || {};
    if (typeof i.topFillOpacity === "number") {
      this._config.topFillOpacity = i.topFillOpacity;
    } else {
      this._config.topFillOpacity = 0.6;
    }
    if (typeof i.sideFillOpacity === "number") {
      this._config.sideFillOpacity = i.sideFillOpacity;
    } else {
      this._config.sideFillOpacity = 0.8;
    }
    cb(this._config.sideFillOpacity, 0, 1);
    if (i.topFillColor === "") {
      this._config.topFillColor = "";
    } else {
      this._config.topFillColor = i.topFillColor ? i.topFillColor : "#fff";
    }
    if (i.sideFillColor === "") {
      this._config.sideFillColor = "";
    } else {
      this._config.sideFillColor = i.sideFillColor ? i.sideFillColor : "#fff";
    }
    this._parseFillCacheWebGL = [];
    this.setPoints(kc, i);
    this._config.altitude = e || 0;
    var T = this;
    g2.load("poly", function () {
      T._draw();
    });
  }
  j1.inherits(iz, "Prism");
  eX.extend(j1.prototype, {
    setPoints: function (ke) {
      var kc = [];
      if (typeof ke === "string" || ke[0] instanceof cx || ke[0] instanceof cr || this instanceof gW || ke.length === 0) {
        var e = this._processSinglePointArray(ke);
        this._userPoints = e.userPoints;
        kc = e.innerPoints;
        this.hasMultipleParts = false;
      } else {
        this._userPoints = [];
        for (var kd = 0; kd < ke.length; kd++) {
          var T = this._processSinglePointArray(ke[kd]);
          this._userPoints.push(T.userPoints);
          kc.push(T.innerPoints);
        }
        this.hasMultipleParts = true;
      }
      iz.prototype.setPoints.call(this, kc);
    },
    setPathIn: function (e) {
      this.setPoints(e);
    },
    _processSinglePointArray: function (e) {
      var i = iz.getGraphPoints(e).slice(0);
      innerPoints = i.slice(0);
      if (innerPoints.length > 1 && !innerPoints[0].equals(innerPoints[innerPoints.length - 1])) {
        innerPoints.push(new cx(innerPoints[0].lng, innerPoints[0].lat));
      }
      return {
        userPoints: i,
        innerPoints: innerPoints
      };
    },
    setPointAt: function (i, e) {
      if (!this._userPoints[i]) {
        return;
      }
      this._clearCache();
      this._userPoints[i] = new cx(e.lng, e.lat);
      this.points[i] = new cx(e.lng, e.lat);
      if (i === 0 && !this.points[0].equals(this.points[this.points.length - 1])) {
        this.points[this.points.length - 1] = new cx(e.lng, e.lat);
      }
      this._calcBounds();
    },
    getPoints: function () {
      var e = this._userPoints;
      if (e.length === 0) {
        e = this.points;
      }
      return e;
    },
    getPathIn: function () {
      return this.getPoints();
    },
    setTopFillOpacity: function (e) {
      if (e > 1 || e < 0) {
        return;
      }
      this._config.topFillOpacity = e;
      this._setDomAttribute("topfillopacity", e);
    },
    getTopFillOpacity: function () {
      return this._config.topFillOpacity;
    },
    setSideFillOpacity: function (e) {
      if (e > 1 || e < 0) {
        return;
      }
      this._config.sideFillOpacity = e;
      this._setDomAttribute("sidefillopacity", e);
    },
    getSideFillOpacity: function () {
      return this._config.sideFillOpacity;
    },
    setTopFillColor: function (e) {
      this._config.topFillColor = e || "";
      this._setDomAttribute("topfillcolor", e);
    },
    getTopFillColor: function () {
      return this._config.topFillColor;
    },
    setSideFillColor: function (e) {
      this._config.sideFillColor = e || "";
      this._setDomAttribute("sidefillcolor", e);
    },
    getSideFillColor: function () {
      return this._config.sideFillColor;
    },
    setAltitude: function (e) {
      this._config.altitude = Number(e);
      this.draw();
      var i = new fJ("onlineupdate");
      i.overlay = this;
      this.dispatchEvent(i);
    },
    getAltitude: function () {
      return this._config.altitude;
    }
  });
  function br(kg, ke, kh) {
    if (!kg || kg.length === 0) {
      return;
    }
    this.userPath = kg;
    var e = [];
    if (typeof kg === "string" || kg[0] instanceof cx || kg[0] instanceof cr) {
      var ki = this._processSinglePointArray(kg);
      for (var kd = 0; kd < ki.innerPoints.length; kd++) {
        e[kd] = i9.convertLL2MC(ki.innerPoints[kd]);
      }
    } else {
      for (var kd = 0; kd < kg.length; kd++) {
        var kf = this._processSinglePointArray(kg[kd]);
        var T = [];
        for (var kc = 0; kc < kf.innerPoints.length; kc++) {
          T[kc] = i9.convertLL2MC(kf.innerPoints[kc]);
        }
        e.push(T);
      }
    }
    j1.call(this, e, ke, kh);
  }
  br.inherits(j1, "PrismOut");
  eX.extend(br.prototype, {
    toString: function () {
      return "Prism";
    },
    setPath: function (kc) {
      if (!kc || kc.length === 0) {
        return;
      }
      this.userPath = kc;
      var T = [];
      for (var e = 0; e < kc.length; e++) {
        T[e] = i9.convertLL2MC(kc[e]);
      }
      this.setPathIn(T);
      this._mouseEventPixels = null;
    },
    getPath: function () {
      return this.userPath;
      var e = this.getPathIn();
      if (!e || e.length === 0) {
        return [];
      }
      var kc = [];
      for (var T = 0; T < e.length; T++) {
        kc[T] = i9.convertMC2LL(e[T]);
      }
      return kc;
    }
  });
  function bY(kd, i) {
    iz.call(this, i);
    i = i || {};
    this._config.type = i.type || "image";
    this._config.url = i.url || "";
    this._config.opacity = typeof i.opacity === "number" ? i.opacity : 1;
    this._config.sysType = i.sysType !== "fixed" ? "geo" : "fixed";
    this._config.top = i.top || false;
    this.isReDraw = i.isReDraw || false;
    this.drawHook = i.drawHook instanceof Function ? i.drawHook : null;
    cb(this._config.opacity, 0, 1);
    if (i.type === "image" && i.isPixelMap) {
      this._config.isPixelMap = i.isPixelMap || false;
      var T = i.pixelMap || {};
      this._config.colors = T.colors || ["#F9F871", "#FFC75F", "#FF9671", "#FF6F91", "#D65DB1", "#845EC2"];
      this._config.positions = T.positions || [0, 0.2, 0.4, 0.6, 0.8, 1];
      this._config.domain = T.domain || [0, 255];
      this._config.clamp = T.clamp || this._config.domain;
      this._config.noData = T.noData !== undefined ? T.noData : -99999;
      this._config.fomularC = T.fomularC || "float generateValue(vec4 pixel){return pixel.r * 255.;}";
      this._config.fomularJS = T.fomularJS || function (ke) {
        return ke.r;
      };
      this._config.maskPng = T.maskPng || null;
      this._config.maskData = T.maskData || -1;
      this._config.maskCoord = T.maskCoord || null;
      this.fHashcode = o({
        str: this._config.fomularC
      });
      var e = this.canPixelMap();
      if (e) {
        this.isPixelMap = true;
        this.setPixelMap();
      }
    }
    this._parseFillCacheWebGL = [];
    if (this._config.sysType === "fixed") {
      this.points = kd;
    } else {
      this.setPoints(kd, i);
    }
    var kc = this;
    g2.load("poly", function () {
      kc._draw();
    });
  }
  bY.inherits(iz, "GroundOverlay");
  eX.extend(bY.prototype, {
    setPoints: function (i) {
      var e = iz.getGraphPoints(i).slice(0);
      this.hasMultipleParts = false;
      iz.prototype.setPoints.call(this, e);
    },
    setPathIn: function (e) {
      this.setPoints(e);
    },
    getPoints: function () {
      return this.points;
    },
    getPathIn: function () {
      return this.getPoints();
    },
    canPixelMap: function () {
      if (this._config.colors && this._config.positions) {
        return true;
      }
      return false;
    },
    setPixelMap: function () {
      if (!this._config.isPixelMap || !this.canPixelMap()) {
        return;
      }
      var i = this._config.colors;
      var e = this._config.positions;
      this.pHashcode = o({
        colors: i,
        positions: e
      });
      this.pixelColorMap = hB.generateColorRamp(i, e);
    },
    setDomain: function (e) {
      if (e instanceof Array && e.length === 2) {
        this._config.domain = e;
        this.doOnceDraw();
      }
    },
    setClamp: function (e) {
      if (e instanceof Array && e.length === 2) {
        this._config.clamp = e;
        this.doOnceDraw();
      }
    },
    setMaskPng: function (i) {
      this._config.maskPng = i;
      if (this.map) {
        var e = new fJ("hide");
        e.overlay = this;
        this.dispatchEvent(e);
        var e = new fJ("show");
        e.overlay = this;
        this.dispatchEvent(e);
      }
      this.doOnceDraw();
    },
    setMaskData: function (e) {
      this._config.maskData = e;
      this.doOnceDraw();
    },
    setMaskCoord: function (e) {
      this._config.maskCoord = e;
      this.maskUV = null;
      this.doOnceDraw();
    },
    setNoData: function (e) {
      this._config.noData = e;
      this.doOnceDraw();
    },
    setPositions: function (e) {
      this._config.positions = e;
      this.setPixelMap();
      this.doOnceDraw();
    },
    setColors: function (e) {
      this._config.colors = e;
      this.setPixelMap();
      this.doOnceDraw();
    },
    setBounds: function (kd, kc) {
      if (!(kd instanceof hY)) {
        return false;
      }
      var kf = [new cx(kd.sw.lng, kd.ne.lat), new cx(kd.ne.lng, kd.ne.lat), new cx(kd.ne.lng, kd.sw.lat), new cx(kd.sw.lng, kd.sw.lat)];
      var e = iz.getGraphPoints(kf).slice(0);
      var ke = [];
      for (var T = 0; T < e.length; T++) {
        ke[T] = i9.convertLL2MC(e[T]);
      }
      this.setPoints(ke);
      if (kc) {
        return true;
      }
      this.doOnceDraw();
    },
    setOpacity: function (e) {
      if (e > 1 || e < 0) {
        return;
      }
      this._config.opacity = e;
      this.doOnceDraw();
    },
    getOpacity: function () {
      return this._config.opacity;
    },
    setImage: function (e, T) {
      this._config.src = e;
      this._texture = null;
      var i = this;
      if (this.imageLoad) {
        this.imageLoad(this._config.src, function (kc, kd) {
          if (kd) {
            i._texture = kc;
            if (T) {
              i.setBounds(T, true);
            }
            i.doOnceDraw();
          }
        });
      }
    },
    setFomular: function (e, i) {
      if (e && i) {
        this._config.fomularJS = e;
        this._config.fomularC = i;
        this.fHashcode = o({
          str: this._config.fomularC
        });
        this.doOnceDraw();
      }
    },
    setIsPixelMap: function (e) {
      this.isPixelMap = e;
      this.doOnceDraw();
    },
    getImagePixel: function (kc) {
      if (!this._config.isPixelMap || !this.canPixelMap()) {
        return null;
      }
      if (!this.getImageMaskPixel(kc)) {
        return null;
      }
      if (this.imageObject) {
        var T = Math.floor((kc.lng - this.points[3].lng) / this.lngMC);
        var e = Math.floor((-kc.lat + this.points[3].lat) / this.latMC);
        var i = Math.floor((e * this.imageObject.width + T) * 4);
        if (T > this.imageObject.width || T < 0) {
          return null;
        }
        if (e > this.imageObject.height || e < 0) {
          return null;
        }
        if (i + 3 > this.imageObject.data.data.length) {
          return null;
        }
        return [this.imageObject.data.data[i], this.imageObject.data.data[i + 1], this.imageObject.data.data[i + 2], this.imageObject.data.data[i + 3]];
      }
      return null;
    },
    getValue: function (i) {
      if (this._config.isPixelMap && i && this._config.fomularJS) {
        if (!(i instanceof Array)) {
          i = this.getImagePixel(i.point);
        }
        var e = this._config.fomularJS({
          r: i[0],
          g: i[1],
          b: i[2],
          a: i[3]
        });
        if (e >= this._config.clamp[0] && e <= this._config.clamp[1]) {
          return e;
        }
      }
      return null;
    },
    setImageObject: function (T) {
      var e = document.createElement("canvas");
      e.width = T.width;
      e.height = T.height;
      var i = e.getContext("2d");
      i.drawImage(T, 0, 0, T.width, T.height);
      this.imageObject = {
        width: T.width,
        height: T.height,
        data: i.getImageData(0, 0, T.width, T.height)
      };
      this.updatePixelMc();
      i = null;
      e = null;
    },
    updatePixelMc: function () {
      if (this.imageObject) {
        var e = Math.abs(this.points[2].lng - this.points[0].lng);
        var i = Math.abs(this.points[2].lat - this.points[0].lat);
        this.lngMC = e / this.imageObject.width;
        this.latMC = i / this.imageObject.height;
      }
    },
    setMaskImageObject: function (T) {
      var e = document.createElement("canvas");
      e.width = T.width;
      e.height = T.height;
      var i = e.getContext("2d");
      i.drawImage(T, 0, 0, T.width, T.height);
      this.imageMaskObject = {
        width: T.width,
        height: T.height,
        data: i.getImageData(0, 0, T.width, T.height)
      };
      i = null;
      e = null;
    },
    getImageMaskPixel: function (e) {
      if (!this.imageMaskObject) {
        return true;
      }
      var kc = this._toOverlayPixelsGL([e]);
      var kh = this.maskOverlayPixels;
      var ke = kh[1][0] - kh[0][0];
      var kd = kh[1][1] - kh[0][1];
      var T = Math.floor((kc[0][0] - kh[0][0]) / ke * this.imageMaskObject.width);
      var i = Math.floor((-kc[0][1] + kh[1][1]) / kd * this.imageMaskObject.height);
      var kg = Math.floor((i * this.imageMaskObject.width + T) * 4);
      if (T > this.imageMaskObject.width || T < 0) {
        return null;
      }
      if (i > this.imageMaskObject.height || i < 0) {
        return null;
      }
      var kf = this.imageMaskObject.data.data;
      if (kg + 3 > kf.length) {
        return false;
      }
      if (kf[kg + 3] > 0) {
        if (this._config.maskData > -1 && this._config.maskData !== kf[kg]) {
          return false;
        }
        return true;
      }
      return false;
    },
    doOnceDraw: function () {
      var e = new fJ("onlineupdate");
      e.overlay = this;
      this.dispatchEvent(e);
    },
    destroy: function () {
      this.points = [];
      this.imageMaskObject = null;
    }
  });
  function fY(kd, T) {
    if (!kd) {
      return;
    }
    T = T || {};
    var ke = [];
    if (T.sysType === "fixed") {
      ke = kd;
    } else {
      var kf = [new cx(kd.sw.lng, kd.ne.lat), new cx(kd.ne.lng, kd.ne.lat), new cx(kd.ne.lng, kd.sw.lat), new cx(kd.sw.lng, kd.sw.lat)];
      var e = iz.getGraphPoints(kf).slice(0);
      for (var kc = 0; kc < e.length; kc++) {
        ke[kc] = i9.convertLL2MC(e[kc]);
      }
    }
    bY.call(this, ke, T);
  }
  fY.inherits(bY, "GroundOverlayOut");
  eX.extend(fY.prototype, {
    toString: function () {
      return "GroundOverlay";
    }
  });
  function bL(i, e) {
    aR.call(this, e);
    if (!i || !e.point || !bR(i)) {
      throw new Error("参数类型错误");
    }
    e = e || {};
    this.point = e.point;
    this.createDom = i;
    this.offsetX = e.offsetX || 0;
    this.offsetY = e.offsetY || 0;
    this.minZoom = e.minZoom || 3;
    this.maxZoom = e.maxZoom || 21;
    this.properties = e.properties || {};
    this.enableMassClear = e.enableMassClear || false;
    this.enableDraggingMap = e.enableDraggingMap || false;
    this.customLayer = null;
  }
  bL.inherits(aR, "CustomOverlay");
  eX.extend(bL.prototype, {
    initialize: function (e) {
      this.map = e;
      this.div = document.createElement("div");
      this.div.id = "cus_overlay";
      this.div.appendChild(this.createDom(this.properties));
      this.map.getPanes().labelPane.appendChild(this.div);
      return this.div;
    },
    draw: function () {
      if (!this.div || !this.map) {
        return;
      }
      var T = this.div.clientWidth / 2;
      var i = this.div.clientHeight - 25;
      var e = this.map.pointToOverlayPixel(this.point);
      this.div.style.position = "absolute";
      this.div.style.left = e.x - T + this.offsetX + "px";
      this.div.style.top = e.y - i + this.offsetY + "px";
    },
    addEventListener: function (T, kd) {
      if (!this.div || !this.map) {
        return;
      }
      var i = this;
      var kc = this.map;
      function e(kh) {
        var kf = new fJ("onclick").inherit(kh);
        var kg = kh.srcElement || kh.target;
        var ke = kh.clientX || kh.pageX;
        var kj = kh.clientY || kh.pageY;
        if (kh && kf && kg && ke && kj) {
          var ki = eX.Dom.getOffset(kc.container);
          kf.pixel = new fi(ke - ki.left, kj - ki.top);
          kf.latLng = kc.pixelToPoint(kf.pixel);
        }
        return kf;
      }
      switch (T) {
        case "mouseover":
          eX.on(this.div, "mouseover", function (kf) {
            var ke = e(kf);
            i.dispatchEvent(ke);
            kd(ke);
          });
          break;
        case "mouseout":
          eX.on(this.div, "mouseout", function (kf) {
            var ke = e(kf);
            i.dispatchEvent(ke);
            kd(ke);
          });
          break;
        case "click":
          eX.on(this.div, "click", function (kf) {
            var ke = e(kf);
            i.dispatchEvent(ke);
            kd(ke);
          });
          break;
        default:
          break;
      }
    },
    setPoint: function (e) {
      if (e instanceof cx) {
        this.div.innerHTML = "";
        this.div.appendChild(this.createDom(this.properties));
        this.point = e;
        var kc = this.div.clientWidth / 2;
        var T = this.div.clientHeight - 25;
        var i = this.map.pointToOverlayPixel(this.point);
        this.div.style.position = "absolute";
        this.div.style.left = i.x - kc + this.offsetX + "px";
        this.div.style.top = i.y - T + this.offsetY + "px";
      }
    },
    getPoint: function () {
      return this.point;
    },
    setProperties: function (e) {
      if (e instanceof Object) {
        Object.assign(this.properties, e);
        this.div.innerHTML = "";
        this.div.appendChild(this.createDom(this.properties));
      }
    },
    getProperties: function () {
      return this.properties;
    },
    toString: function () {
      return "CustomOverlay";
    }
  });
  var av = {};
  function h1(T, i) {
    eX.BaseClass.call(this);
    this.content = T;
    this.map = null;
    this._config = {
      width: 0,
      height: 0,
      maxWidth: 600,
      offset: new i0(0, 0),
      title: "",
      maxContent: "",
      enableMaximize: false,
      enableAutoPan: true,
      enableCloseOnClick: true,
      margin: [10, 10, 40, 10],
      collisions: [[10, 10], [10, 10], [10, 10], [10, 10]],
      ifMaxScene: false,
      onClosing: function () {
        return true;
      }
    };
    this.setConfig(i);
    if (this._config.width < 50) {
      this._config.width = 50;
    }
    if (this._config.width > 730) {
      this._config.width = 730;
    }
    if (this._config.height != 0) {
      if (this._config.height < 50) {
        this._config.height = 50;
      }
      if (this._config.height > 650) {
        this._config.height = 650;
      }
    }
    if (this._config.maxWidth !== 0) {
      if (this._config.maxWidth < 50) {
        this._config.maxWidth = 50;
      }
      if (this._config.maxWidth > 730) {
        this._config.maxWidth = 730;
      }
    }
    this.isWinMax = false;
    this.IMG_PATH = B.imgPath;
    this.overlay = null;
    var e = this;
    g2.load("simpleInfowindow", function () {
      e._draw();
    });
  }
  h1.inherits(eX.BaseClass, "SimpleInfoWindow");
  eX.extend(h1.prototype, {
    setWidth: function (e) {
      e = e * 1;
      if (!e && e != 0 || isNaN(e) || e < 0) {
        return;
      }
      if (e != 0) {
        if (e < 50) {
          e = 50;
        }
        if (e > 730) {
          e = 730;
        }
      }
      this._config.width = e;
    },
    setHeight: function (e) {
      e = e * 1;
      e -= 10;
      if (!e && e != 0 || isNaN(e) || e < 0) {
        return;
      }
      if (e != 0) {
        if (e < 50) {
          e = 50;
        }
        if (e > 650) {
          e = 650;
        }
      }
      this._config.height = e;
    },
    setMaxWidth: function (e) {
      e = e * 1;
      if (!e && e != 0 || isNaN(e) || e < 0) {
        return;
      }
      if (e != 0) {
        if (e < 50) {
          e = 50;
        }
        if (e > 730) {
          e = 730;
        }
      }
      this._config.maxWidth = e;
    },
    setTitle: function (e) {
      this._config.title = e || "";
    },
    setContent: function (e) {
      this.content = e || "";
    },
    setMaxContent: function (e) {
      this._config.maxContent = e || "";
    },
    redraw: function () {},
    enableAutoPan: function () {
      this._config.enableAutoPan = true;
    },
    disableAutoPan: function () {
      this._config.enableAutoPan = false;
    },
    enableCloseOnClick: function () {
      this._config.enableCloseOnClick = true;
    },
    disableCloseOnClick: function () {
      this._config.enableCloseOnClick = false;
    },
    enableMaximize: function () {
      this._config.enableMaximize = true;
    },
    disableMaximize: function () {
      this._config.enableMaximize = false;
    },
    show: function () {
      this._visible = true;
    },
    hide: function () {
      this._visible = false;
    },
    close: function () {
      this.hide();
    },
    dispose: function () {
      eX.BaseClass.prototype.decontrol.call(this);
    },
    maximize: function () {
      this.isWinMax = true;
    },
    restore: function () {
      this.isWinMax = false;
    },
    setConfig: function (i) {
      if (!i) {
        return;
      }
      for (var e in i) {
        if (typeof this._config[e] == typeof i[e]) {
          this._config[e] = i[e];
        }
      }
    },
    isVisible: function () {
      return this.isOpen();
    },
    isOpen: function () {
      return false;
    },
    getPoint: function () {
      if (this.overlay && this.overlay.getPoint) {
        return this.overlay.getPoint();
      }
    },
    getOffset: function () {
      return this._config.offset;
    },
    dispose: function () {
      eX.BaseClass.prototype.decontrol.call(this);
    },
    toString: function () {
      return "SimpleInfoWindow";
    }
  });
  hK.prototype.openSimpleInfoWindow = function (kc, e) {
    if (!kc || kc.toString() != "SimpleInfoWindow" || !e || e.toString() != "Point") {
      return;
    }
    var i = this.temp;
    if (!i.marker) {
      var T = new jt(B.imgPath + "blank.gif", {
        width: 1,
        height: 1
      });
      i.marker = new jP(e, {
        icon: T,
        width: 1,
        height: 1,
        offset: new i0(0, 0),
        infoWindowOffset: new i0(0, 0),
        clickable: false
      });
      i.marker._fromMap = 1;
    } else {
      i.marker.setPoint(e);
    }
    this.addOverlay(i.marker);
    i.marker.show();
    i.marker.openSimpleInfoWindow(kc);
  };
  hK.prototype.closeSimpleInfoWindow = function () {
    var e = this.temp.infoWin || this.temp._infoWin;
    if (e && e.overlay) {
      e.overlay.closeSimpleInfoWindow();
    }
  };
  eA.prototype.openSimpleInfoWindow = function (e) {
    if (this.map) {
      this.map.closeSimpleInfoWindow();
      e._visible = true;
      this.map.temp._infoWin = e;
      e.overlay = this;
      eX.BaseClass.call(e, e.hashCode);
    }
  };
  eA.prototype.closeSimpleInfoWindow = function () {
    if (this.map && this.map.temp._infoWin) {
      this.map.temp._infoWin._visible = false;
      this.map.temp._infoWin.decontrol();
      this.map.temp._infoWin = null;
    }
  };
  function cj(T, e) {
    iz.call(this, e);
    e = e || {};
    this._config.showRegion = e.showRegion || "inside";
    this._config.isBuildingMask = e.isBuildingMask && true;
    this._config.isPoiMask = e.isPoiMask && true;
    this._config.isMapMask = e.isMapMask && true;
    this._config.path = T;
    this._parseFillCacheWebGL = [];
    this.setPoints(T, e);
    var i = this;
    g2.load("poly", function () {
      i._draw();
    });
  }
  cj.inherits(iz, "MapMask");
  eX.extend(cj.prototype, {
    setPoints: function (i) {
      var e = iz.getGraphPoints(i).slice(0);
      this.hasMultipleParts = false;
      iz.prototype.setPoints.call(this, e);
    },
    setPathIn: function (e) {
      this.setPoints(e);
    },
    _processSinglePointArray: function (e) {
      var i = iz.getGraphPoints(e).slice(0);
      innerPoints = i.slice(0);
      if (innerPoints.length > 1 && !innerPoints[0].equals(innerPoints[innerPoints.length - 1])) {
        innerPoints.push(new cx(innerPoints[0].lng, innerPoints[0].lat));
      }
      return {
        userPoints: i,
        innerPoints: innerPoints
      };
    },
    getPoints: function () {
      var e = this._userPoints;
      if (e.length === 0) {
        e = this.points;
      }
      return e;
    },
    getPathIn: function () {
      return this.getPoints();
    }
  });
  function jY(ke, T) {
    if (!ke || ke.length === 0) {
      return;
    }
    var kd = [];
    if (ke[0] instanceof cx) {
      var e = this._processSinglePointArray(ke);
      for (var kc = 0; kc < e.innerPoints.length; kc++) {
        kd[kc] = i9.convertLL2MC(e.innerPoints[kc]);
      }
    }
    cj.call(this, kd, T);
  }
  jY.inherits(cj, "MapMaskOut");
  eX.extend(jY.prototype, {
    toString: function () {
      return "MapMask";
    }
  });
  function fi(e, i) {
    e = isNaN(e) ? 0 : e;
    i = isNaN(i) ? 0 : i;
    this.x = e;
    this.y = i;
  }
  fi.prototype.equals = function (e) {
    if (!e) {
      return false;
    }
    return e.x === this.x && e.y === this.y;
  };
  fi.prototype.clone = function () {
    return new fi(this.x, this.y);
  };
  fi.prototype.toString = function () {
    return "Pixel";
  };
  function i0(i, e) {
    if (typeof i !== "number") {
      this.width = parseFloat(i);
    } else {
      this.width = i;
    }
    if (typeof e !== "number") {
      this.height = parseFloat(e);
    } else {
      this.height = e;
    }
  }
  i0.prototype.equals = function (e) {
    return !!(e && this.width === e.width && this.height === e.height);
  };
  i0.prototype.toString = function () {
    return "Size";
  };
  var j4 = {
    B_NORMAL_MAP: {
      tileUrls: dy(B.tileDomain, B.rasterTilePath),
      vectorTileUrls: dy(B.tileDomain, B.vectorTilePath),
      tileSize: 256,
      baseUnits: 256,
      zoomLevelMin: 3,
      zoomLevelMax: 19,
      minDataZoom: 3,
      maxDataZoom: 19,
      minZoom: 3,
      maxZoom: 19,
      webgl: {
        minZoom: 3,
        maxZoom: 25
      },
      zoomLevelBase: 18,
      errorUrl: B.imgPath + "bg.png",
      bounds: new hY(new cx(-21364736, -11708041.66), new cx(23855104, 12474104.17)),
      imgExtend: "png"
    },
    B_SATELLITE_MAP: {
      tileUrls: ["//maponline0.bdimg.com/starpic/?qt=satepc&", "//maponline1.bdimg.com/starpic/?qt=satepc&", "//maponline2.bdimg.com/starpic/?qt=satepc&", "//maponline3.bdimg.com/starpic/?qt=satepc&"],
      tileSize: 256,
      baseUnits: 256,
      zoomLevelMin: 3,
      zoomLevelMax: 19,
      minDataZoom: 3,
      maxDataZoom: 19,
      minZoom: 3,
      maxZoom: 19,
      zoomLevelBase: 18,
      errorUrl: B.imgPath + "bg.png",
      bounds: new hY(new cx(-21364736, -10616832), new cx(23855104, 15859712)),
      imgExtend: "png"
    },
    B_STREET_MAP: {
      tileUrls: dy(B.tileDomain, B.rasterTilePath),
      tileSize: 256,
      baseUnits: 256,
      zoomLevelMin: 3,
      zoomLevelMax: 19,
      minDataZoom: 3,
      maxDataZoom: 19,
      minZoom: 3,
      maxZoom: 19,
      zoomLevelBase: 18,
      errorUrl: B.imgPath + "bg.png",
      bounds: new hY(new cx(-21364736, -10616832), new cx(23855104, 15859712)),
      imgExtend: "png"
    },
    BMAP_CUSTOM_LAYER: {
      tileUrls: [""],
      tileSize: 256,
      baseUnits: 256,
      zoomLevelMin: 1,
      zoomLevelMax: 19,
      minDataZoom: 3,
      maxDataZoom: 19,
      minZoom: 3,
      maxZoom: 19,
      zoomLevelBase: 18,
      errorUrl: B.imgPath + "blank.gif",
      bounds: new hY(new cx(-21364736, -10616832), new cx(23855104, 15859712)),
      imgExtend: "png"
    },
    B_EARTH_MAP: {
      tileUrls: [""],
      tileSize: 256,
      baseUnits: 256,
      zoomLevelMin: 3,
      zoomLevelMax: 19,
      minDataZoom: 3,
      maxDataZoom: 19,
      minZoom: 3,
      maxZoom: 19,
      webgl: {
        minZoom: 3,
        maxZoom: 21
      },
      zoomLevelBase: 18,
      errorUrl: B.imgPath + "blank.gif",
      bounds: new hY(new cx(-21364736, -10616832), new cx(23855104, 15859712)),
      imgExtend: "png"
    },
    B_NONE_MAP: {
      tileUrls: "",
      tileSize: 256,
      baseUnits: 256,
      zoomLevelMin: 3,
      zoomLevelMax: 19,
      minDataZoom: 3,
      maxDataZoom: 19,
      minZoom: 3,
      maxZoom: 19,
      zoomLevelBase: 18,
      errorUrl: B.imgPath + "bg.png",
      bounds: new hY(new cx(-21364736, -11708041.66), new cx(23855104, 12474104.17)),
      imgExtend: "png"
    }
  };
  var ej = j4;
  function cM(kf, kg, T, e, ke) {
    if (ke && ej[ke]) {
      this.mapTypeName = ke;
    } else {
      this.mapTypeName = BMAP_NORMAL_MAP;
    }
    if (kf && kf instanceof Array) {
      var kd = true;
      for (var kc = 0; kc < kf.length; kc++) {
        if (kf[kc] instanceof hY) {
          continue;
        } else {
          kd = false;
          break;
        }
      }
      if (kd) {
        this.bounds = kf;
      }
    }
    if (typeof kg === "number" && kg >= ej[this.mapTypeName].webgl.minZoom) {
      if (ej[this.mapTypeName].webgl) {
        if (kg >= ej[this.mapTypeName].webgl.minZoom) {
          this.minZoom = kg;
        } else {
          this.minZoom = ej[this.mapTypeName].webgl.minZoom;
        }
      } else if (kg >= ej[this.mapTypeName].minZoom) {
        this.minZoom = kg;
      } else {
        this.minZoom = ej[this.mapTypeName].minZoom;
      }
    }
    if (typeof T === "number") {
      if (ej[this.mapTypeName].webgl) {
        if (T <= ej[this.mapTypeName].webgl.maxZoom) {
          this.maxZoom = T;
        } else {
          this.maxZoom = ej[this.mapTypeName].webgl.maxZoom;
        }
      } else if (T <= ej[this.mapTypeName].maxZoom) {
        this.maxZoom = T;
      } else {
        this.maxZoom = ej[this.mapTypeName].maxZoom;
      }
    }
    if (this.maxZoom < this.minZoom) {
      this.maxZoom = null;
    }
    if (e && typeof e === "function") {
      this.tileUrlFunction = e;
    }
  }
  eX.extend(cM.prototype, {
    addBoundary: function (e) {
      if (e instanceof hY) {
        if (this.bounds) {
          this.bounds.push(e);
        } else {
          this.bounds = [e];
        }
      }
    },
    setTileUrlFunction: function (e) {
      if (e && typeof e === "function") {
        this.tileUrlFunction = e;
      }
    },
    crossPoint: function (e, kc, kd) {
      if (kd < this.minZoom || kd > this.maxZoom) {
        return false;
      }
      var ke = this.containsPoint(e, kd);
      if (ke) {
        return ke;
      }
      for (var T = 0; T < this.bounds.length; T++) {
        if (this.bounds[T].intersects(kc)) {
          ke = true;
          break;
        }
      }
      return ke;
    },
    containsPoint: function (e, kc) {
      if (!e || !(e instanceof cx) || !this.isValid()) {
        return false;
      }
      var kd = false;
      if (kc < this.minZoom || kc > this.maxZoom) {
        return kd;
      }
      for (var T = 0; T < this.bounds.length; T++) {
        if (this.bounds[T].containsPoint(e)) {
          kd = true;
          break;
        }
      }
      return kd;
    },
    isValid: function () {
      return this.bounds && this.minZoom && this.maxZoom && this.tileUrlFunction;
    },
    toString: function () {
      return "PrivateRegionDataModel";
    }
  });
  function hJ(kh, i, kd, T, kc) {
    this.mgr = kh;
    this.position = kd;
    this._cbks = [];
    this.name = kh.getTileName(T, kc, kh.map.config.style);
    this.info = T;
    this._transparentPng = kc.isTransparentPng();
    var ki = bX("img");
    h0(ki);
    ki.galleryImg = false;
    var kg = ki.style;
    kg.position = "absolute";
    kg.width = kh.tileSize + "px";
    kg.height = kh.tileSize + "px";
    kg.left = kd[0] + "px";
    kg.top = kd[1] + "px";
    this.img = ki;
    this.src = i;
    if (eB && kd._offsetX === 0) {
      kg.opacity = 0;
      kg.willChange = "opacity";
    }
    var kf = this;
    this.img.onload = function (kq) {
      if (!kf.mgr) {
        return;
      }
      var kl = kf.mgr;
      var kj = kl.bufferTiles;
      if (kl.bufferNumber > 0) {
        kj[kf.name] = kf;
        kj.push(kf.name);
      }
      var kn = kj.length - kl.bufferNumber;
      for (var ko = 0; kn > 0 && ko < kj.length; ko++) {
        var kp = kj[ko];
        if (!kl.mapTiles[kp]) {
          if (kj[kp]) {
            kj[kp].mgr = null;
            var km = kj[kp].img;
            if (km.parentNode) {
              im(km);
              km.parentNode.removeChild(km);
            }
            km = null;
            kj[kp].img = null;
            kj[kp] = null;
            delete kj[kp];
          }
          kj.splice(ko, 1);
          ko--;
          kn--;
        }
      }
      kf.loaded = true;
      kl.imgNumber++;
      if (!aS(kf.img)) {
        if (kc.tilesDiv) {
          kc.tilesDiv.appendChild(kf.img);
        }
      }
      var kq = new fJ("onimagechange");
      kq.action = "show";
      kq.tile = kf.name;
      kl.map.dispatchEvent(kq);
      if (eB && kd._offsetX === 0) {
        var kk = new fy({
          fps: 10,
          duration: 300,
          render: function (e) {
            if (kf.img && kf.img.style) {
              kf.img.style.opacity = e * 1;
            }
          },
          finish: function () {
            if (kf.img && kf.img.style) {
              delete kf.img.style.opacity;
              kf.img.style.willChange = "auto";
            }
          }
        });
      }
      kf._callCbks();
    };
    this.img.onerror = function (kl) {
      kf.error = true;
      kf._callCbks();
      if (!kf.mgr) {
        return;
      }
      var kj = kf.mgr;
      var kk = ej[kc.mapType];
      if (kk.errorUrl) {
        kf.img.src = kk.errorUrl;
      }
      if (!aS(kf.img)) {
        if (kc.tilesDiv) {
          kc.tilesDiv.appendChild(kf.img);
        }
      }
    };
    ki = null;
    var ke = new fJ("onimagebefore");
    ke.tile = kf.name;
    kh.map.dispatchEvent(ke);
  }
  hJ.prototype._addLoadCbk = function (e) {
    this._cbks.push(e);
  };
  hJ.prototype._load = function () {
    if (FeBrowser.ie <= 6 && FeBrowser.ie > 0 && this._transparentPng) {
      this.img.src = B.imgPath + "blank.gif";
    } else {
      this.img.src = this.src;
    }
  };
  hJ.prototype._callCbks = function () {
    var T = this;
    for (var e = 0; e < T._cbks.length; e++) {
      T._cbks[e]();
    }
    T._cbks.length = 0;
  };
  var eB = !eX.Browser.ie || eX.Browser.ie > 8;
  function jh(e) {
    this.tileLayers = [];
    this.map = e;
    this.bufferNumber = 300;
    this.mapTiles = [];
    this.bufferTiles = [];
    this.config = ej[this.map.mapType];
    this.errorUrl = this.config.errorUrl;
    this.tileSize = this.config.tileSize;
    this.baseUnits = this.config.baseUnits;
    this.baseZoomLevel = this.config.zoomLevelBase;
    this.tileURLs = this.config.tileUrls;
    this.imgNumber = 0;
    this.numLoading = 0;
    this.temp = {};
  }
  bx.register(function (i) {
    if (i._renderType === "webgl") {
      return;
    }
    var e = i.tileMgr = new jh(i);
    i.addEventListener("mousewheel", function (T) {
      e.mouseWheel(T);
    });
    i.addEventListener("dblclick", function (T) {
      e.dblClick(T);
    });
    i.addEventListener("rightdblclick", function (T) {
      e.dblClick(T);
    });
    i.addEventListener("minuspress", function (T) {
      e.keypress(T);
    });
    i.addEventListener("pluspress", function (T) {
      e.keypress(T);
    });
    i.addEventListener("load", function (T) {
      if (this.mapType === BMAP_EARTH_MAP) {
        return;
      }
      e.loadTiles();
    });
    i.addEventListener("zoomstartcode", function (T) {
      if (this.mapType === BMAP_EARTH_MAP) {
        return;
      }
      e._zoom(T);
    });
    i.addEventListener("moving", function (T) {
      if (this.mapType === BMAP_EARTH_MAP) {
        return;
      }
      e.moveGridTiles();
    });
    i.addEventListener("resize", function (T) {
      if (this.mapType === BMAP_EARTH_MAP) {
        return;
      }
      e.resizeMap(T);
    });
    i.addEventListener("addtilelayer", function (T) {
      e.addTileLayer(T);
    });
    i.addEventListener("removetilelayer", function (T) {
      e.removeTileLayer(T);
    });
  });
  eX.extend(jh.prototype, {
    addTileLayer: function (kc) {
      var T = this;
      var i = kc.target;
      T.tileLayers.push(i);
      if (T.map.loaded) {
        T.moveGridTiles();
      }
    },
    removeTileLayer: function (kj) {
      var kk = this;
      var kh = kj.target;
      var kf = kh.mapType;
      var ke = kk.mapTiles;
      var km = kk.bufferTiles;
      for (var T in km) {
        var kc = T.split("-")[1];
        if (kc == kf) {
          delete km[T];
        }
      }
      for (var T in ke) {
        var kc = T.split("-")[1];
        if (kc == kf) {
          delete ke[T];
        }
      }
      if (kk.zoomsDiv && kk.zoomsDiv.parentNode) {
        kk.zoomsDiv.parentNode.removeChild(kk.zoomsDiv);
        kk.zoomsDiv.innerHTML = "";
      }
      var kd = kk.map;
      if (kd.deepZoom) {
        var kl = kd.deepZoom.preDeepZoomDiv;
        if (kl && kl.parentNode) {
          kl.parentNode.removeChild(kl);
        }
      }
      for (var ki = 0, kg = kk.tileLayers.length; ki < kg; ki++) {
        if (kh == kk.tileLayers[ki]) {
          kk.tileLayers.splice(ki, 1);
        }
      }
      kk.moveGridTiles();
    },
    hideDeepZoomDiv: function () {
      var i = this;
      var T = i.map;
      if (T.deepZoom) {
        var e = T.deepZoom.preDeepZoomDiv;
        if (e && e.style.display != "none") {
          e.style.display = "none";
        }
      }
    },
    getTileLayer: function (kd) {
      var kc = this;
      for (var T = 0, e = kc.tileLayers.length; T < e; T++) {
        tilelayer = kc.tileLayers[T];
        if (tilelayer.mapType == kd) {
          return tilelayer;
        }
      }
      return null;
    },
    _zoom: function (T) {
      var i = this;
      if (i.zoomsDiv && i.zoomsDiv.style.display != "none") {
        i.zoomsDiv.style.display = "none";
      }
      i.hideDeepZoomDiv();
      i.moveGridTiles();
    },
    resizeMap: function (i) {
      this.loaded = false;
      this.moveGridTiles();
    },
    _checkTilesLoaded: function () {
      this.numLoading--;
      var e = this;
      if (this.numLoading == 0) {
        if (this._checkLoadedTimer) {
          clearTimeout(this._checkLoadedTimer);
          this._checkLoadedTimer = null;
        }
        this._checkLoadedTimer = setTimeout(function () {
          if (e.numLoading == 0) {
            e.map.dispatchEvent(new fJ("ontilesloaded"));
          }
          e._checkLoadedTimer = null;
        }, 80);
      }
    },
    getTileName: function (e, T, i) {
      var kd = T.mapType;
      var kc = "TILE-" + kd + "-" + i + "-" + e[0] + "-" + e[1] + "-" + e[2];
      return kc;
    },
    hideTile: function (kc, T) {
      var i = kc.img;
      if (aS(i)) {
        if (kc.loaded) {
          this.imgNumber--;
        }
        if (i.parentNode) {
          im(i);
          i.parentNode.removeChild(i);
        }
      }
      var kd = new fJ("onimagechange");
      kd.tile = this.getTileName(kc.info, T, this.map.config.style);
      kd.action = "hide";
      delete this.mapTiles[kc.name];
      if (!kc.loaded) {
        im(i);
        kc._callCbks();
        i = null;
        kc.img = null;
        kc.mgr = null;
      }
      this.map.dispatchEvent(kd);
    },
    loadTiles: function () {
      var i = this;
      if (eX.Browser.ie) {
        try {
          document.execCommand("BackgroundImageCache", false, true);
        } catch (T) {}
      }
      if (this.zoomsDiv && this.zoomsDiv.style.display != "none") {
        this.zoomsDiv.style.display = "none";
      }
      i.hideDeepZoomDiv();
      i.moveGridTiles();
    },
    getCell: function (kd, kc) {
      var e = this.baseUnits * Math.pow(2, this.baseZoomLevel - kc);
      var T = parseInt(kd.lng / e);
      var i = parseInt(kd.lat / e);
      return [T, i, e * (T + 0.5), e * (i + 0.5)];
    },
    moveGridTiles: function () {
      var kq = this.map;
      var kz = kq.getMapType();
      var kx = this.tileLayers.length;
      var kv = kq.centerPoint;
      if (kz !== BMAP_SATELLITE_MAP) {
        kv = e0.calcLoopCenterPoint(kv);
      }
      var kh = kq.width;
      var kL = kq.getZoomUnits();
      var kw = kL * kh;
      var kB = kv.lng - kw / 2;
      var km = kv.lng + kw / 2;
      var kp = e0.isAddWidth(kB, km);
      for (var kD = 0; kD < kx; kD++) {
        var kd = this.tileLayers[kD];
        if (kd.baseLayer || kx == 1) {
          this.tilesDiv = kd.tilesDiv;
        }
        var kr = ej[kd.mapType];
        var kc = kq.zoomLevel;
        var kG = kq.getZoomUnits(kq.zoomLevel);
        var kl = kr.baseUnits * Math.pow(2, kr.zoomLevelBase - kc);
        var kj = Math.floor(kv.lng / kl);
        var kC = Math.floor(kv.lat / kl);
        var ko = kr.tileSize;
        var ks = [kj, kC, (kv.lng - kj * kl) / kl * ko, (kv.lat - kC * kl) / kl * ko];
        var kk = kp ? kq.width / 2 * 1.5 : kq.width / 2;
        var kn = ks[0] - Math.ceil((kk - ks[2]) / ko);
        var kK = ks[1] - Math.ceil((kq.height / 2 - ks[3]) / ko);
        var kE = ks[0] + Math.ceil((kk + ks[2]) / ko);
        var kt = ks[1] + Math.ceil((kq.height / 2 + ks[3]) / ko);
        var ki = [];
        for (var kI = kn; kI < kE; kI++) {
          for (var kH = kK; kH < kt; kH++) {
            ki.push([kI, kH]);
            var ky = "id_" + kI + "_" + kH + "_" + kc;
            ki[ky] = true;
          }
        }
        if (kd.mapType !== BMAP_SATELLITE_MAP) {
          ki = e0.calcLoopTiles(ki, kc);
        }
        ki.sort(function (i) {
          return function (kN, kO) {
            return 0.4 * Math.abs(kN[0] - i[0]) + 0.6 * Math.abs(kN[1] - i[1]) - (0.4 * Math.abs(kO[0] - i[0]) + 0.6 * Math.abs(kO[1] - i[1]));
          };
        }([ks[0], ks[1]]));
        var T = this.mapTiles;
        var e = -kv.lng / kG;
        var kM = kv.lat / kG;
        var kA = [e, kM];
        for (var ku in T) {
          var kf = T[ku];
          var kJ = kf.info;
          if (!kJ) {
            continue;
          }
          var ky = "id_" + kJ[0] + "_" + kJ[1] + "_" + kJ[2];
          if (!ki[ky]) {
            this.hideTile(kf, kd);
          }
        }
        var ke = -kq.offsetX + kq.width / 2;
        var kg = -kq.offsetY + kq.height / 2;
        kd.tilesDiv.style.left = Math.round(e + ke) - kA[0] + "px";
        kd.tilesDiv.style.top = Math.round(kM + kg) - kA[1] + "px";
        this.numLoading += ki.length;
        for (var kI = 0, kF = ki.length; kI < kF; kI++) {
          this.showTile([ki[kI][0], ki[kI][1], kq.zoomLevel], kA, kd, kI, kq.config.style);
        }
      }
    },
    showTile: function (kf, ke, ki, kn) {
      this.centerPos = ke;
      var kg = ej[ki.mapType];
      var kj = this.map.config.style;
      var kc = this.getTileName(kf, ki, kj);
      var kd = kf[0] * kg.tileSize + ke[0];
      var T = (-1 - kf[1]) * kg.tileSize + ke[1];
      var km = [kd, T];
      var kh = null;
      if (ki.mapType !== BMAP_SATELLITE_MAP) {
        kh = e0.calcLoopParam(kf[0], kf[2]);
        var kl = kh.offsetX;
        km[0] += kl;
        km._offsetX = kl;
      }
      var kq = this;
      var kp = this.mapTiles[kc];
      if (kp) {
        kp.img.style.left = km[0] + "px";
        kp.img.style.top = km[1] + "px";
        if (kp.loaded) {
          this._checkTilesLoaded();
        } else {
          kp._addLoadCbk(function () {
            kq._checkTilesLoaded();
          });
        }
        return;
      }
      kp = this.bufferTiles[kc];
      if (kp) {
        this.imgNumber++;
        ki.tilesDiv.insertBefore(kp.img, ki.tilesDiv.lastChild);
        this.mapTiles[kc] = kp;
        kp.img.style.left = km[0] + "px";
        kp.img.style.top = km[1] + "px";
        if (kp.loaded) {
          this._checkTilesLoaded();
        } else {
          kp._addLoadCbk(function () {
            kq._checkTilesLoaded();
          });
        }
        var ko = new fJ("onimagechange");
        ko.action = "cache";
        ko.tile = this.getTileName(kf, ki, kj);
        this.map.dispatchEvent(ko);
      } else {
        var kk = new fi(kf[0], kf[1]);
        if (kh) {
          kk.x = kh.col;
        }
        var i = ki.getTilesUrl(kk, kf[2]);
        kp = new hJ(this, i, km, kf, ki);
        kp._addLoadCbk(function () {
          kq._checkTilesLoaded();
        });
        kp._load();
        this.mapTiles[kc] = kp;
        hg(this.map);
      }
    },
    mouseWheel: function (kg) {
      var kf = this.map;
      if (!kf.config.enableWheelZoom) {
        return;
      }
      var kh = kf.zoomLevel + (kg.trend === true ? 1 : -1);
      var kd = kf._getProperZoom(kh);
      if (kd.exceeded) {
        var T = new fJ("onzoomexceeded");
        T.targetZoom = kh;
        kf.dispatchEvent(T);
        return;
      }
      kf.dispatchEvent(new fJ("onzoomstart"));
      kf.lastLevel = kf.zoomLevel;
      kf.zoomLevel = kd.zoom;
      var i = kg.pixel;
      var kc = kf.pixelToPointIn(i, {
        zoom: kf.lastLevel
      });
      var ke = kf.getZoomUnits(kf.zoomLevel);
      kf.centerPoint = new cx(kc.lng + ke * (kf.width / 2 - i.x), kc.lat - ke * (kf.height / 2 - i.y));
      this.zoom(i);
    },
    dblClick: function (T) {
      var i = this.map;
      if (!i.config.enableDblclickZoom) {
        return;
      }
      if (i.mapType === "B_EARTH_MAP") {
        return;
      }
      if (i.currentOperation === ed.dragging) {
        return;
      }
      if (T.type == "onrightdblclick") {
        i.zoomOut(T.point);
      } else {
        i.zoomIn(T.point);
      }
    },
    keypress: function (T) {
      var i = this.map;
      if (i.getMapType() === BMAP_EARTH_MAP) {
        return;
      }
      if (T.type == "onpluspress") {
        i.zoomIn();
      } else {
        i.zoomOut();
      }
    }
  });
  function hv(kc) {
    this.opts = kc || {};
    this.copyright = this.opts.copyright || {};
    this.transparentPng = this.opts.transparentPng || false;
    this.png8 = this.opts.png8 || false;
    this.baseLayer = this.opts.baseLayer || false;
    this.dataType = this.opts.dataType || 1;
    this.transform = this.opts.transform || 0;
    this.spanLevel = this.opts.spanLevel || 0;
    this.isFlat = !this.opts.isFlat ? false : true;
    this.showLabel = this.opts.showLabel === false ? false : true;
    var e = this.opts.tileTypeName || "web";
    this.tileType = hZ.getInstance(e);
    this.clipTile = this.opts.clipTile || false;
    this._type = "tilelayer";
    var i = bW() ? 128 : 256;
    this.cacheSize = this.opts.cacheSize || i;
    var T = this;
    this.tileCache = new az(this.cacheSize, {
      clearCallback: function (kd) {
        if (kd.label) {
          if (kd.label.textImageBitmap) {
            kd.label.textImageBitmap.close();
          }
          if (kd.label.indoorTextImageBitmap) {
            kd.label.indoorTextImageBitmap.close();
          }
        }
        T._removeIndoorData(kd);
      }
    });
    this.scaler = gd() >= 1.5 ? 2 : 1;
    this.normalUdt = jO("ditu", "normal").udt;
    this.numLoading = 0;
    this.numTileLoading = 0;
    this.firstTileLoad = false;
    this.retry = this.opts.retry || false;
    this.retryTime = this.opts.retryTime || 600;
    this.useThumbData = false;
    this.useThumbData = this.opts.useThumbData || false;
    if (this.baseLayer) {
      this.useThumbData = true;
    }
    if (typeof this.opts.customLayer === "boolean") {
      this.customLayer = this.opts.customLayer;
    } else {
      this.customLayer = true;
    }
  }
  hv.inherits(c8, "TileLayer");
  eX.extend(hv.prototype, {
    isTransparentPng: function () {
      return this.transparentPng;
    },
    getTilesUrl: function (kj, e) {
      var T = ej[this.mapType];
      if (typeof T !== "object") {
        return null;
      }
      var kc = kj.x;
      var kk = kj.y;
      if (this.mapType !== BMAP_SATELLITE_MAP) {
        var kk = e0.calcLoopParam(kk, e).col;
      }
      var i = "";
      if (this.opts.tileUrlTemplate) {
        i = this.opts.tileUrlTemplate;
        i = i.replace(/\{X\}/, kk);
        i = i.replace(/\{Y\}/, kc);
        i = i.replace(/\{Z\}/, e);
      } else {
        if (this.mapType === BMAPGL_NORMAL_MAP) {
          var ki = this.isCanvasMap ? 0 : 1;
          var ke = T.tileUrls[Math.abs(kk + kc) % T.tileUrls.length];
          if (window.offLineIPAddress) {
            ke = window.offLineIPAddress + "tile5/";
          }
          var kd = this.map.config.style;
          i = ke + "?qt=vtile&x=" + kc + "&y=" + kk + "&z=" + e + (kd === "default" ? "" : "&styleId=1") + "&styles=pl&udt=" + this.normalUdt + "&scaler=" + this.scaler + "&showtext=" + ki;
          i = i.replace(/-(\d+)/gi, "M$1");
        }
        if (this.mapType === BMAP_SATELLITE_MAP) {
          var kf = jO("ditu", "satellite");
          var kh = kf.ver;
          var kg = kf.udt;
          i = T.tileUrls[Math.abs(kk + kc) % T.tileUrls.length] + "u=x=" + kc + ";y=" + kk + ";z=" + e + ";v=" + kh + ";type=sate&fm=46&udt=" + kg;
          i = i.replace(/-(\d+)/gi, "M$1");
        }
      }
      return i;
    },
    initialize: function (kf) {
      this.map = kf;
      if (kf._renderType === "webgl") {
        var ke = null;
        if (this.customLayer !== false) {
          ke = this.getTilesUrl;
        }
        eX.extend(this, fe);
        this.labelProcessor = new jb(this);
        this.callbackDataQueue = [];
        if (ke) {
          this.getTilesUrl = ke;
        }
        var T = this;
        kf.on("indoor_data_refresh", function (kg) {
          if (!T.baseLayer) {
            return;
          }
          T._refreshIndoorData(kg.uid, kg.floor);
        });
        kf.on("custom_labels_ready", function (kg) {
          if (!T.baseLayer && kg.model === "custom") {
            return;
          }
          if (kg.model === "custom" && T.drawIndex === 0 || kg.model === "mvt_" + T.drawIndex) {
            T._doWorkAfterLabelImageLoad(kg.virtualTile, kg.labelCanvas, null, kg.imgKey);
          }
        });
        kf.on("glmoduleloaded", function () {
          if (!T.baseLayer) {
            return;
          }
          T.updateAllIconsTextureCoords();
        });
        kf.on("layer_update", function (kh) {
          if (T.dataType === 2 && kf.customLoaded) {
            T.clearCache();
            var kg = new fJ("onlayer_clear");
            kf.fire(kg);
          }
        });
        if (this.ontology && this.ontology._initEvent) {
          this.ontology._initEvent(kf);
        }
      }
      if (!kf.temp.layerZIndex) {
        kf.temp.layerZIndex = 0;
      }
      this.zIndex = this.zIndex || 1;
      if (kf.getRenderType() === "dom") {
        this.zIndex = kf.tileMgr.tileLayers.length;
      } else if (this.baseLayer) {
        this.zIndex = 0;
      } else if (this.zIndex > 0) {
        this.adjustZIndex();
      } else {
        var e = kf._featureMgr.result.bkData;
        this.zIndex = e.length || 1;
      }
      if (!kf.temp.layid) {
        kf.temp.layid = 0;
      }
      if (!this.opts.mapType) {
        this.mapType = "BMAP_CUSTOM_LAYER_" + kf.temp.layid;
        kf.temp.layid++;
      } else {
        this.mapType = this.opts.mapType;
      }
      var kc = ej[this.mapType];
      if (!kc) {
        ej[this.mapType] = {
          tileUrls: [],
          tileSize: 256,
          baseUnits: 256,
          zoomLevelMin: 1,
          zoomLevelMax: 19,
          minZoom: 3,
          maxZoom: 19,
          minDataZoom: 3,
          maxDataZoom: 19,
          zoomLevelBase: 18,
          errorUrl: B.imgPath + "/blank.gif",
          bounds: new hY(new cx(-21364736, -10616832), new cx(23855104, 15859712)),
          imgExtend: "png"
        };
      }
      if (kf._renderType !== "webgl") {
        var kd = bJ(kf.platform, "<div style=\"position:absolute;z-index:" + this.zIndex + "\"></div>");
        kd.style.display = "";
        kd.style.left = Math.ceil(-kf.offsetX + kf.width / 2) + "px";
        kd.style.top = Math.ceil(-kf.offsetY + kf.height / 2) + "px";
        this.tilesDiv = kd;
      }
      this.isCanvasMap = kf.isCanvasMap();
      this.lastZoom = kf.getZoom();
      var i = this;
      this.addEventListener("initDrawData", function (kg) {
        if (i.opts.boundary) {
          i.addBoundary(i.opts.boundary);
        }
      });
      kf.on("destroy", function () {
        i.destroy();
      });
    },
    clearCache: function () {
      this.tileCache.clear();
      this.map._featureMgr.clearData(this.drawIndex);
      this.map._featureMgr.setLabelData([], this.drawIndex);
      this.map._featureMgr.clearLabelOverlayData(this.drawIndex);
      this.labelProcessor.iconCache.clear();
    },
    remove: function () {
      if (this.tilesDiv && this.tilesDiv.parentNode) {
        this.tilesDiv.innerHTML = "";
        this.tilesDiv.parentNode.removeChild(this.tilesDiv);
      }
      delete this.tilesDiv;
    },
    getCopyright: function () {
      return this.copyright;
    },
    getMapType: function () {
      return this.mapType;
    },
    adjustZIndex: function () {
      if (this.map && this.map._featureMgr) {
        var e = this.map._featureMgr.result.bkData;
        while (e[this.zIndex]) {
          this.zIndex += 1;
        }
      }
    },
    _getAdjoinZIndex: function (kd) {
      var T = this.zIndex;
      if (this.map && this.map._featureMgr) {
        var e = this.map._featureMgr.result.bkData;
        if (kd === "up") {
          for (var kc = this.zIndex + 1; kc < e.length; kc++) {
            if (e[kc]) {
              T = kc + 1;
              break;
            }
          }
        } else {
          for (var kc = this.zIndex - 1; kc > 0; kc--) {
            if (e[kc]) {
              T = kc;
              break;
            }
          }
        }
      }
      return T;
    },
    setZIndex: function (e) {
      this.setTargetZIndex(e);
    },
    setTargetZIndex: function (e) {
      if (this.removeLabel) {
        this.removeLabel(this.zIndex);
      }
      this.zIndex = e;
      this.drawIndex = e;
      if (this.tilesDiv) {
        this.tilesDiv.style.zIndex = e;
      }
    },
    calcLoopParam: function (e, i) {
      return e0.calcLoopParam(e, i);
    },
    addBoundary: function (ke) {
      if (!ke || !this.map) {
        return;
      }
      if (typeof ke === "string") {
        ke = [ke];
      }
      for (var kc = 0; kc < ke.length; kc++) {
        var T = new BMapGL.Polygon(ke[kc]);
        if (T && bR(T._i)) {
          var kd = new fJ("onbeforeaddoverlay", T);
          kd.overlay = T;
          kd.isLayerMask = true;
          this.map.dispatchEvent(kd);
          T._i(this.map);
          if (this.boundary) {
            this.boundary.push(T);
          } else {
            this.boundary = [T];
          }
        }
      }
      this.updateBoundary();
    },
    clearBoundary: function () {
      this.boundary = false;
      this.updateBoundary();
    },
    updateBoundary: function () {
      if (this.boundary === undefined || !this.map) {
        return;
      }
      var i = this.map._featureMgr.result.bkData;
      if (i[this.zIndex]) {
        i[this.zIndex].showRegion = this.opts.showRegion;
        i[this.zIndex].boundary = this.boundary;
        this.map.dispatchEvent(new fJ("onrefresh"));
        if (this.boundary === false) {
          var T = new fJ("onremoveLayerMask");
          T.hasLayerBoundary = this.map._featureMgr.hasLayerBoundary();
          this.map.dispatchEvent(T);
        }
      }
    },
    destroy: function () {
      this.copyright = null;
      this.clearCache();
    }
  });
  function m(i, e, T) {
    this.bounds = i;
    this.content = e;
    this.mapType = T;
  }
  m.inherits(c8, "Copyright");
  var ep = {
    get: function (e) {
      if (!ep.singleton) {
        ep.singleton = new f4(e);
      }
      return ep.singleton;
    }
  };
  function f4(i) {
    this._map = i;
    this._tileMgr = i.tileMgr;
    this._animationDiv = null;
    this._preAnimationDiv = null;
    this._animation = null;
    this._baseLayerDiv = null;
    this._transformStyleName = c6.ifSupportCSS3("transform", true);
    this._transformOriginStyleName = c6.ifSupportCSS3("transformOrigin", true);
    this._preZoomTimes = 1;
    this._preRenderTick = 1;
    this._enableCanvas2dMap = !!(i.getRenderType() === "canvas");
    this._isIE9 = !!(eX.Browser.ie === 9);
    var e = this;
    i.addEventListener("maptypechange", function () {
      e.hide();
    });
    i.addEventListener("load", function () {
      e.hide();
    });
  }
  eX.extend(f4.prototype, {
    prepareLayer: function () {
      var kc = this._map;
      var e = this._tileMgr;
      this._canvas2dMapMgr = kc.canvas2dMapMgr;
      var T = this._baseLayerDiv = e.tilesDiv;
      if (!this._animationDiv) {
        var i = this._preAnimationDiv;
        if (i) {
          if (i.parentNode) {
            i.parentNode.removeChild(i);
          }
          this._preAnimationDiv = null;
        }
        this._preAnimationDiv = this._animationDiv = T.cloneNode(true);
        kc.platform.insertBefore(this._animationDiv, kc.platform.firstChild);
      }
      this.show();
    },
    prepareAniParam: function () {
      var kc = this._animationDiv;
      if (!kc) {
        return;
      }
      var e = kc.children.length;
      var T;
      this._zoomAniInfo = [];
      for (var kd = e - 1; kd > -1; kd--) {
        var ke = {};
        T = kc.children[kd].style;
        ke.top = parseInt(T.top, 10);
        ke.left = parseInt(T.left, 10);
        this._zoomAniInfo[kd] = ke;
      }
    },
    prepareLabelLayer: function () {
      var kd = this._map;
      if (this._enableCanvas2dMap && kd.canvas2dMapMgr) {
        if (this.touchZoomLabelCanvas) {
          this.touchZoomLabelCanvas.parentNode.removeChild(this.touchZoomLabelCanvas);
        }
        var i = kd.canvas2dMapMgr._labelCanvas;
        this.touchZoomLabelCanvas = i.cloneNode(false);
        var e = this.touchZoomLabelCanvas.getContext("2d");
        e.drawImage(i, 0, 0);
        kd.platform.insertBefore(this.touchZoomLabelCanvas, kd.platform.firstChild);
        var kc = parseInt(i.style.left, 10);
        var T = parseInt(i.style.top, 10);
        this.touchZoomLabelCanvas.style.zIndex = 9;
        this.touchZoomLabelCanvas.style[this._transformOriginStyleName] = this._fixPosition.x - (kd.offsetX + kc) + "px " + (this._fixPosition.y - (kd.offsetY + T)) + "px";
        i.style.visibility = "hidden";
      }
    },
    show: function () {
      if (this._animationDiv) {
        this._animationDiv.style.visibility = "";
      }
    },
    showLabel: function () {
      var i = this._map;
      if (this._enableCanvas2dMap && i.canvas2dMapMgr) {
        var e = i.canvas2dMapMgr._labelCanvas;
        if (e) {
          e.style.visibility = "";
        }
        if (this.touchZoomLabelCanvas) {
          this.touchZoomLabelCanvas.style.zIndex = -2;
          this.touchZoomLabelCanvas.style.visibility = "hidden";
        }
      }
    },
    hide: function () {
      if (this._animationDiv) {
        this._animationDiv.style.visibility = "hidden";
      }
      if (this._preAnimationDiv) {
        this._preAnimationDiv.style.visibility = "hidden";
      }
    },
    hideNonAnimationLayers: function () {
      var kc = this._map;
      if (kc.getRenderType() === "dom") {
        if (kc.overlayDiv) {
          kc.overlayDiv.style.visibility = "hidden";
        }
        if (kc.overlayDivEx) {
          kc.overlayDivEx.style.visibility = "hidden";
        }
      }
      var ke = kc.tileMgr.tileLayers;
      var kd;
      for (var T = 0, e = ke.length; T < e; T++) {
        kd = ke[T];
        kd.tilesDiv.style.visibility = "hidden";
      }
    },
    showNonAnimationLayers: function () {
      var kc = this._map;
      if (kc.getRenderType() === "dom") {
        if (kc.overlayDiv) {
          kc.overlayDiv.style.visibility = "";
        }
        if (kc.overlayDivEx) {
          kc.overlayDivEx.style.visibility = "";
        }
      }
      var ke = kc.tileMgr.tileLayers;
      var kd;
      for (var T = 0, e = ke.length; T < e; T++) {
        kd = ke[T];
        kd.tilesDiv.style.visibility = "";
      }
    },
    setFixPosition: function (e) {
      this._fixPosition = e;
    },
    setZoom: function (e, ki) {
      var kf = this._fixPosition;
      var ko = this._map;
      var kp = this._baseLayerDiv;
      var kg = {
        x: kf.x - parseInt(kp.style.left, 10) - ko.offsetX,
        y: kf.y - parseInt(kp.style.top, 10) - ko.offsetY
      };
      var kc = this._animationDiv;
      if (!kc) {
        return;
      }
      var km = kc.children.length;
      var kk;
      var kn = this._transformStyleName;
      var ke = this._transformOriginStyleName;
      var kq = this;
      var ks;
      var kh;
      for (var kl = km - 1; kl > -1; kl--) {
        var kj = this._zoomAniInfo[kl];
        kk = kc.children[kl].style;
        var kd = kj.left - kg.x;
        var T = kj.top - kg.y;
        kj.dx = kd * e - kd;
        kj.dy = T * e - T;
        kj.preDx = kd - kd;
        kj.preDy = T - T;
        ks = kj.preDx + (kj.dx - kj.preDx);
        kh = kj.preDy + (kj.dy - kj.preDy) + ki;
        kk.left = kj.left + ks + "px";
        kk.top = kj.top + kh + "px";
        kk.width = kk.height = 256 * e + "px";
      }
      if (this._enableCanvas2dMap) {
        var kr = !kq._isIE9 ? "translate3d(0px, " + ki + "px, 0) scale(" + e + ")" : "translate(0px, " + ki + "px) scale(" + e + ")";
        this.touchZoomLabelCanvas.style[kn] = kr;
      }
    },
    setZoomFinish: function () {
      this._animationDiv = null;
    },
    startAnimation: function (kf) {
      this.prepareLayer();
      this.hideNonAnimationLayers();
      var ky = this._map;
      if (this.touchZoomLabelCanvas) {
        this.touchZoomLabelCanvas.style.display = "none";
      }
      kf = kf || {};
      var kw = kf.zoomCount || 0;
      var kk = kf.fixPosition;
      var ku = kf.fixMCPosition;
      var ki = kf.pixOffset;
      this._zoomCount = kw;
      var kc = ky.getZoom();
      var kx = kc + kw;
      var e = ky.config.enableContinuousZoom;
      var ko = 0.5;
      var kj = 5;
      var T = Math.pow(2, kw);
      var kA = this._baseLayerDiv;
      var kl = {
        x: kk.x - parseInt(kA.style.left, 10) - ky.offsetX,
        y: kk.y - parseInt(kA.style.top, 10) - ky.offsetY
      };
      var kg = this._animationDiv;
      var ks = kg.children.length;
      var kC = this._preZoomTimes;
      var kv = [];
      var kt = this._transformStyleName;
      var kh = this._transformOriginStyleName;
      for (var kr = ks - 1; kr > -1; kr--) {
        var kp = {};
        var kq = kg.children[kr].style;
        kp.top = parseInt(kq.top, 10);
        kp.left = parseInt(kq.left, 10);
        var ke = kp.left - kl.x;
        var kd = kp.top - kl.y;
        kp.dx = ke * T - ke;
        kp.dy = kd * T - kd;
        kp.preDx = ke * kC - ke;
        kp.preDy = kd * kC - kd;
        kv[kr] = kp;
      }
      var kz = this;
      var kn;
      var kB;
      var km;
      this._zoomAni = new fy({
        fps: 60,
        duration: e ? 500 : 1,
        transition: function (i) {
          i = i * kj / (2 * ko);
          return kj * i - ko * i * i;
        },
        render: function (kL) {
          kL = kL * (4 * ko) / (kj * kj);
          kn = kC + kL * (T - kC);
          var kE = kc + p(kn);
          var kJ = null;
          var kI = 0;
          var kM = 0;
          if (kf.onAnimationBeforeLooping) {
            var kN = kf.onAnimationBeforeLooping(kL, kE);
            kJ = kN.loopingCenter;
            kI = kN.yDiff;
            kM = kN.totalYDiff;
          }
          for (var kF = kv.length - 1; kF > -1; kF--) {
            var kG = kv[kF];
            if (kg.children[kF]) {
              var kK = kg.children[kF].style;
              kB = kG.preDx + (kG.dx - kG.preDx) * kL - ki.width * kL;
              km = kG.preDy + (kG.dy - kG.preDy) * kL - ki.height * kL + kI;
              kK.left = kG.left + kB + "px";
              kK.top = kG.top + km + "px";
              kK.height = kK.width = 256 * kn + "px";
            }
          }
          var kD = ki.width * kL;
          var kH = ki.height * kL;
          if (ky.isRestrict) {
            if (kz._enableCanvas2dMap) {
              kz._canvas2dMapMgr.clearLabel();
            }
          } else if (kz._enableCanvas2dMap) {
            kz._canvas2dMapMgr.drawLabel(kn, kk, kc, kx, kw, kL, kD, kH, kM, kI);
          }
          kz._preZoomTimes = kn;
          kz._preRenderTick = kL;
          if (kf.onAnimationLooping) {
            kf.onAnimationLooping(kL, kE, kJ);
          }
        },
        finish: function () {
          kz._preZoomTimes = 1;
          kz._zoomAni = null;
          kz._animationDiv = null;
          if (kf.onAnimationFinish) {
            kf.onAnimationFinish();
          }
          kz.showNonAnimationLayers();
        }
      });
      return this._zoomAni;
    },
    stopAnimation: function () {
      if (this._zoomAni) {
        this._zoomAni.stop();
        this._zoomAni = null;
      }
    }
  });
  function j9(e) {
    this._initVars(e);
    this._initColorCanvas();
    this._bindEvent(e);
  }
  eX.extend(j9.prototype, {
    _initVars: function (e) {
      this._map = e._map;
      this._canvas2dMapMgr = e;
      this._labelCtx = e._labelCtx;
      this.ratio = this._map.config.ratio;
      this.sizeRatio = this.ratio > 1 ? 2 : 1;
      this.RANK1 = 1000000;
      this.RANK2 = 2000000;
      this.RANK3 = 3000000;
      this.RANK4 = 4000000;
      this.RANK5 = 5000000;
    },
    _initColorCanvas: function () {
      var i = 256;
      var T = bX("canvas");
      var e = T.style;
      e.width = i + "px";
      e.height = i + "px";
      T.width = i;
      T.height = i;
      this._colorCvsSize = i;
      this._colorCvs = T;
      this._colorCtx = T.getContext("2d");
    },
    getLabelImageData: function (kp) {
      var ko = kp.textImg;
      var T = kp.textPos;
      var km = this.ratio;
      var kk = this.sizeRatio / km;
      var kd = this._colorCtx;
      var kh = this._colorCvsSize;
      kd.clearRect(0, 0, kh, kh);
      var kj = 0;
      var e = 0;
      var kg = 0;
      for (var ki = 0; ki < T.length; ki++) {
        if (T[ki].width > kj) {
          kj = T[ki].width;
          e = ki;
          kg = T[ki].drawX;
        }
      }
      kj /= kk;
      var kl = 0;
      for (var ki = 0, kf = T.length; ki < kf; ki++) {
        var kn = T[ki];
        var kq;
        if (ki === e) {
          kq = 0;
        } else {
          kq = kn.drawX - kg;
        }
        kd.drawImage(ko, kn.srcX, kn.srcY, kn.width, kn.height, kq, kl, kn.width / kk, kn.height / kk);
        if (kn.width / kk > kj) {
          kj = kn.width / kk;
        }
        kl += kn.height / kk + 2 * km;
      }
      var kc = kd.getImageData(0, 0, kj, kl);
      var ke = kd.getImageData(0, 0, kj, kl);
      return [kc, ke];
    },
    _bindEvent: function (i) {
      var e = this;
      var T = i._map;
      T.addEventListener("onspotmouseover", function (kf) {
        if (!this.isCanvasMap() || !this.temp.isPermitSpotOver) {
          return;
        }
        if (kf.spots.length > 0) {
          var ke = kf.spots[0].userdata.uid;
          var kd = kf.spots[0].userdata.name;
          var kc = e.findLabelByUid(ke, kd);
          if (kc) {
            e._toHighLightColor(kc);
          }
        }
      });
      T.addEventListener("onspotmouseout", function (kf) {
        if (!this.isCanvasMap() || !this.temp.isPermitSpotOver) {
          return;
        }
        if (kf.spots.length > 0) {
          var ke = kf.spots[0].userdata.uid;
          var kd = kf.spots[0].userdata.name;
          var kc = e.findLabelByUid(ke, kd);
          if (kc) {
            e._toDefaultColor(kc);
          }
        }
      });
      T.addEventListener("onspotclick", function (kf) {
        if (!this.isCanvasMap() || !this.temp.isPermitSpotOver) {
          return;
        }
        if (kf.spots && kf.spots.length > 0) {
          var ke = kf.spots[0].userdata.uid;
          var kd = kf.spots[0].userdata.name;
          var kc = e.findLabelByUid(ke, kd);
          if (kc) {
            e._changeBaseMapState(kc);
          }
        } else {
          e._recoverNormalState();
        }
      });
      T.on("spot_status_reset", function () {
        e._recoverNormalState();
      });
      T.on("spot_highlight", function (kd) {
        var kc = e.findLabelByUid(kd.uid);
        if (kc) {
          e._changeBaseMapState(kc);
        }
      });
    },
    _getTextBound: function (kn) {
      if (!kn.textPos) {
        return null;
      }
      var kl = this.ratio;
      var kj = this.sizeRatio / kl;
      var T = kn.textPos;
      var km = kn.baseDrawX;
      var kk = kn.baseDrawY;
      var kh = km * kl + (T[0].drawX - km) / kj;
      var kf = kk * kl + (T[0].drawY - kk) / kj;
      var kd = kh + T[0].width / kj;
      var e = kf + T[0].height / kj;
      for (var ki = 0, kg = T.length; ki < kg; ki++) {
        var ko = T[ki];
        var ke = km * kl + (ko.drawX - km) / kj;
        if (ke < kh) {
          kh = ke;
        }
        var kc = kk * kl + (ko.drawY - kk) / kj;
        if (kc < kf) {
          kf = kc;
        }
        if (ke + ko.width > kd) {
          kd = ke + ko.width;
        }
        if (kc + ko.height > e) {
          e = kc + ko.height;
        }
      }
      return [kh, kf, kd, e];
    },
    _toHighLightColor: function (T) {
      if (T._tempRank && T._tempRank == this.RANK5) {
        return;
      }
      var kg = this._getTextBound(T);
      if (!kg) {
        return;
      }
      var kc = Math.round(kg[0]);
      var i = Math.round(kg[1]);
      var e = this.getLabelImageData(T);
      var ke = e[0];
      var kd = e[1];
      var kf = this._canvas2dMapMgr.getFilterImageData(ke, this.RANK5);
      T._oldImgData = kd;
      this._labelCtx.putImageData(kf, kc, i);
    },
    _toDefaultColor: function (e) {
      if (e._tempRank && e._tempRank == this.RANK5) {
        return;
      }
      if (e._oldImgData) {
        var i = this.sizeRatio;
        var T = this._getTextBound(e);
        if (!T) {
          return;
        }
        this._labelCtx.putImageData(e._oldImgData, Math.round(T[0]), Math.round(T[1]));
        e._oldImgData = null;
      }
    },
    _changeBaseMapState: function (kc) {
      var T = this._canvas2dMapMgr;
      var i = kc.guid;
      var e = kc.guidExt;
      var kd = {
        guid: i,
        name: kc.name,
        guidExt: e
      };
      T._labelStrategy.setStrategyInfo(kd);
      T._loadData();
    },
    _recoverNormalState: function () {
      var e = this._canvas2dMapMgr;
      e._labelStrategy.setStrategyInfo(null);
      e._loadData();
    },
    findLabelByUid: function (ke, kc) {
      var kg = this._canvas2dMapMgr;
      var e = kg._computedLabel;
      for (var kd = 0, T = e.length; kd < T; kd++) {
        var kf = e[kd];
        if (!kg.isClickableLabel(kf)) {
          continue;
        }
        if (ke && kf.guid === ke) {
          return kf;
        }
        if (kc && kf.name === kc) {
          return kf;
        }
      }
      return null;
    }
  });
  function E(e) {
    this._initVars(e);
  }
  eX.extend(E.prototype, {
    _initVars: function (e) {
      this._map = e._map;
      this._canvas2dMapMgr = e;
      this.ratio = this._map.config.ratio;
      this._strategyInfo = null;
      this.RANK1 = 1000000;
      this.RANK2 = 2000000;
      this.RANK3 = 3000000;
      this.RANK4 = 4000000;
      this.RANK5 = 5000000;
    },
    setStrategyInfo: function (e) {
      this._strategyInfo = e;
    },
    preComputeLabel: function (ki, k9, kS, ku, k3, lo) {
      var kM = [];
      var kq = ki._centerX;
      var ko = ki._centerY;
      var lp = ku * k3;
      var kY = this.ratio;
      var kh = this._map.getZoom();
      var kH = 0;
      if (kh === 5) {
        kH = 4;
      }
      if (kh === 8) {
        kH = -6;
      }
      ki.sort(function (ll, i) {
        if (ll.x * ll.y < i.x * i.y) {
          return -1;
        } else {
          return 1;
        }
      });
      for (var kJ = 0, kF = ki.length; kJ < kF; kJ++) {
        var le = ki[kJ];
        var kA = le.x;
        var kx = le.y;
        var kv = le.z;
        var kC = e0.calcLoopParam(kA, kv).offsetX;
        var kW = kA * lp;
        var kV = (kx + 1) * lp;
        var kc = (kW - kq) / ku + k9 / 2 + kC;
        var T = (ko - kV) / ku + kS / 2;
        for (var kG = 0, li = le.length; kG < li; kG++) {
          var kk = le[kG];
          var kr = undefined;
          var kp = undefined;
          var lg = undefined;
          var lf = undefined;
          var k5 = kk.baseDrawX = kc + kk.baseX;
          var k4 = kk.baseDrawY = T + kk.baseY;
          if (kk.type == "fixed") {
            var kQ = kk.iconPos;
            var kt = kk.textPos;
            var lk = kk.textImg;
            if (kQ) {
              kQ.drawX = kc + kQ.destX;
              kQ.drawY = T + kQ.destY;
              kr = kQ.drawX;
              kp = kQ.drawY;
              lg = kQ.drawX + kQ.width;
              lf = kQ.drawY + kQ.height;
            }
            if (kt && lk) {
              for (var k6 = 0; k6 < kt.length; k6++) {
                var lj = kt[k6];
                lj.drawX = kc + lj.destX;
                lj.drawY = T + lj.destY;
                if (!kr) {
                  kr = lj.drawX;
                  kp = lj.drawY;
                  lg = lj.drawX + lj.width;
                  lf = lj.drawY + lj.height;
                } else {
                  if (lj.drawX < kr) {
                    kr = lj.drawX;
                  }
                  if (lj.drawY < kp) {
                    kp = lj.drawY;
                  }
                  if (lj.drawX + lj.width > lg) {
                    lg = lj.drawX + lj.width;
                  }
                  if (lj.drawY + lj.height > lf) {
                    lf = lj.drawY + lj.height;
                  }
                }
              }
            }
          } else {
            kk.tileX = kc;
            kk.tileY = T;
            kr = kc + kk.minXOriginal;
            kp = T + kk.minYOriginal;
            lg = kc + kk.maxXOriginal;
            lf = T + kk.maxYOriginal;
          }
          if (kr != undefined) {
            var k8 = k5 + (kr - k5) / kY;
            var k7 = k4 + (kp - k4) / kY;
            var kK = k5 + (lg - k5) / kY;
            var kI = k4 + (lf - k4) / kY;
            kk.minX = k8;
            kk.minY = k7;
            kk.maxX = kK;
            kk.maxY = kI;
            var lc = (k8 + kK) / 2;
            var lb = (k7 + kI) / 2;
            var kT = kq + (lc - k9 / 2) * ku;
            var kR = ko + (kS / 2 - lb) * ku;
            kk.geoX = kT;
            kk.geoY = kR;
            kM.push(kk);
          }
        }
      }
      if (lo) {
        for (var kJ = 0, kF = lo.length; kJ < kF; kJ++) {
          var kE = lo[kJ];
          var k1 = kE[0];
          var kl = kE[1];
          var kQ = k1.iconPos;
          var kf = kQ.geoX;
          var kd = kQ.geoY;
          var k5 = (kf - kq) / ku + k9 / 2;
          var k4 = (ko - kd) / ku + kS / 2;
          var kr = k5 + kQ.destX;
          var kp = k4 + kQ.destY;
          var lg = kr + kQ.width;
          var lf = kp + kQ.height;
          k1.textPos = k1.textPos || k1._textPos;
          var kt = k1.textPos;
          var la = kt[0];
          var kz = k5 + la.destX;
          var kn = k4 + la.destY;
          if (kn < kp) {
            kp = kn;
          }
          if (kz + la.width > lg) {
            lg = kz + la.width;
          }
          if (kn + la.height > lf) {
            lf = kn + la.height;
          }
          if (kt.length === 2) {
            var ky = kt[1];
            var kw = k5 + ky.destX;
            var km = k4 + ky.destY;
            if (km < kp) {
              kp = km;
            }
            if (kw + ky.width > lg) {
              lg = kw + ky.width;
            }
            if (km + ky.height > lf) {
              lf = km + ky.height;
            }
          }
          k1._tempBounds = [kr, kp, lg, lf];
          var kQ = kl.iconPos;
          var kf = kQ.geoX;
          var kd = kQ.geoY;
          var k5 = (kf - kq) / ku + k9 / 2;
          var k4 = (ko - kd) / ku + kS / 2;
          var kr = k5 + kQ.destX;
          var kp = k4 + kQ.destY;
          var lg = kr + kQ.width;
          var lf = kp + kQ.height;
          kl.textPos = kl.textPos || kl._textPos;
          var kt = kl.textPos;
          var la = kt[0];
          var kz = k5 + la.destX;
          var kn = k4 + la.destY;
          if (kz < kr) {
            kr = kz;
          }
          if (kn < kp) {
            kp = kn;
          }
          if (kn + la.height > lf) {
            lf = kn + la.height;
          }
          if (kt.length === 2) {
            var ky = kt[1];
            var kw = k5 + ky.destX;
            var km = k4 + ky.destY;
            if (kw < kr) {
              kr = kw;
            }
            if (km < kp) {
              kp = km;
            }
            if (km + ky.height > lf) {
              lf = km + ky.height;
            }
          }
          kl._tempBounds = [kr, kp, lg, lf];
        }
        for (var kJ = 0, kF = lo.length; kJ < kF; kJ++) {
          var kE = lo[kJ];
          var k1 = kE[0];
          var kl = kE[1];
          if (kJ === 0 && kl.textPos) {
            kl._textPos = kl.textPos;
            delete kl.textPos;
          }
          var ld = k1;
          if (!k1.textPos && kl.textPos) {
            ld = kl;
          }
          var lh = ld._tempBounds;
          for (kG = kJ + 1; kG < kF; kG++) {
            var kD = lo[kG];
            var kN = kD[0];
            var ln = kD[1];
            var ks = 0;
            var lm = kN._tempBounds;
            if (!(lh[2] < lm[0] || lh[0] > lm[2] || lh[3] < lm[1] || lh[1] > lm[3])) {
              ks++;
              if (kN.textPos) {
                kN._textPos = kN.textPos;
                delete kN.textPos;
              }
            }
            var lm = ln._tempBounds;
            if (!(lh[2] < lm[0] || lh[0] > lm[2] || lh[3] < lm[1] || lh[1] > lm[3])) {
              ks++;
              if (ln.textPos) {
                ln._textPos = ln.textPos;
                delete ln.textPos;
              }
            }
            if (ks >= 2) {
              if (ld.textPos) {
                ld._textPos = ld.textPos;
                delete ld.textPos;
              }
            }
          }
        }
        for (var kJ = 0, kF = lo.length; kJ < kF; kJ++) {
          var kE = lo[kJ];
          var k1 = kE[0];
          var kl = kE[1];
          var kO = k1;
          if (!k1.textPos && kl.textPos) {
            kO = kl;
          }
          var kQ = kO.iconPos;
          var kf = kQ.geoX;
          var kd = kQ.geoY;
          var k5 = kO.baseDrawX = (kf - kq) / ku + k9 / 2;
          var k4 = kO.baseDrawY = (ko - kd) / ku + kS / 2;
          kQ.drawX = k5 + kQ.destX;
          kQ.drawY = k4 + kQ.destY;
          var kr = kQ.drawX;
          var kp = kQ.drawY;
          var lg = kQ.drawX + kQ.width;
          var lf = kQ.drawY + kQ.height;
          var kt = kO.textPos;
          if (kt) {
            var la = kt[0];
            la.drawX = k5 + la.destX;
            la.drawY = k4 + la.destY;
            if (la.drawX < kr) {
              kr = la.drawX;
            }
            if (la.drawY < kp) {
              kp = la.drawY;
            }
            if (la.drawX + la.width > lg) {
              lg = la.drawX + la.width;
            }
            if (la.drawY + la.height > lf) {
              lf = la.drawY + la.height;
            }
            if (kt.length === 2) {
              var ky = kt[1];
              ky.drawX = k5 + ky.destX;
              ky.drawY = k4 + ky.destY;
              if (ky.drawX < kr) {
                kr = ky.drawX;
              }
              if (ky.drawY < kp) {
                kp = ky.drawY;
              }
              if (ky.drawX + ky.width > lg) {
                lg = ky.drawX + ky.width;
              }
              if (ky.drawY + ky.height > lf) {
                lf = ky.drawY + ky.height;
              }
            }
          }
          var k8 = k5 + (kr - k5) / kY;
          var k7 = k4 + (kp - k4) / kY;
          var kK = k5 + (lg - k5) / kY;
          var kI = k4 + (lf - k4) / kY;
          kO.minX = k8;
          kO.minY = k7;
          kO.maxX = kK;
          kO.maxY = kI;
          var k0 = (k8 + kK) / 2;
          var kZ = (k7 + kI) / 2;
          var kg = kq + (k0 - k9 / 2) * ku;
          var ke = ko + (kS / 2 - kZ) * ku;
          kO.geoX = kg;
          kO.geoY = ke;
          kM.push(kO);
        }
      }
      var k2 = this._strategyInfo;
      if (k2) {
        var kL = k2.guid;
        var kU = k2.name;
        var kB = k2.guidExt;
        for (var kJ = 0, kF = kM.length; kJ < kF; kJ++) {
          var kj = kM[kJ];
          delete kj._tempRank;
          if (!this._canvas2dMapMgr.isClickableLabel(kj) || kB === 1 && !kj.guidExt) {
            continue;
          }
          if (kL && kL === kj.guid || kU && kU === kj.name) {
            kj._tempRank = this.RANK5;
          }
        }
      } else {
        for (var kJ = 0, kF = kM.length; kJ < kF; kJ++) {
          var kj = kM[kJ];
          if (kj.type == "line" || !kj.iconPos) {
            continue;
          }
          delete kj._tempRank;
        }
      }
      kM.sort(function (lq, ll) {
        var lr = lq._tempRank ? lq._tempRank : lq.rank;
        var i = ll._tempRank ? ll._tempRank : ll.rank;
        if (lr === i) {
          return lq.baseX - ll.baseX;
        }
        return i - lr;
      });
      for (var kJ = 0, kF = kM.length; kJ < kF; kJ++) {
        var ld = kM[kJ];
        ld.isDel = false;
        ld.isFadeout = false;
        ld._schedule = 0;
        ld._isIgnore = false;
        ld.arrIntersectIndex = [];
        for (kG = kJ + 1; kG < kF; kG++) {
          var kP = kM[kG];
          if (!(ld.maxX - kH < kP.minX || ld.minX > kP.maxX - kH || ld.maxY - kH < kP.minY || ld.minY > kP.maxY - kH)) {
            ld.arrIntersectIndex.push(kG);
          }
        }
      }
      for (var kJ = 0, kF = kM.length; kJ < kF; kJ++) {
        var kj = kM[kJ];
        if (kj.isDel == false) {
          var e = kj.arrIntersectIndex;
          for (var kG = 0, li = e.length; kG < li; kG++) {
            var kX = kM[e[kG]];
            kX.isDel = true;
            if (kX.guidExt === 1) {
              kX.isDel = false;
            }
          }
        }
      }
      return kM;
    }
  });
  function Y(e) {
    this._map = e;
    this._initCanvas();
    this._initVars();
    this._bindEvent();
    this._tileType = hZ.getInstance("na");
  }
  bx.register(function (i) {
    if (i.getRenderType() === "canvas") {
      var e = i.config.style;
      if (bx["FeatureStyle" + e]) {
        i.canvas2dMapMgr = new Y(i);
      } else {
        i.loadMapStyleFiles(function () {
          i.canvas2dMapMgr = new Y(i);
          i.canvas2dMapMgr._loadData();
        });
      }
    }
  });
  eX.extend(Y.prototype, {
    _initCanvas: function () {
      var kf = this._map;
      var kd = kf.getSize();
      var kc = kd.width;
      var i = kd.height;
      var e = kf.platform;
      var kg = bX("canvas");
      var ke = kg.style;
      var T = this.ratio = kf.config.ratio;
      this._width = kc;
      this._height = i;
      ke.cssText = "position: absolute;left:0;top:0;width:" + kc + "px;height:" + i + "px;z-index:100;";
      kg.width = kc * T;
      kg.height = i * T;
      this._labelCanvas = kg;
      this._labelCtx = kg.getContext("2d");
      e.appendChild(kg);
    },
    _initVars: function () {
      var e = jO("ditu", "normal");
      this._udt = e.udt;
      this._version = e.ver;
      this._labelDataUrls = ej.B_NORMAL_MAP.vectorTileUrls;
      this._style = bx["FeatureStyle" + this._map.config.style];
      this._labelCount = 0;
      this._vectorDrawLib = new g1(this);
      this._cache = {
        maxNum: 500,
        delNum: 50,
        arrCache: []
      };
      this._computedLabel = null;
      this._spotData = null;
      this._labelStrategy = new E(this);
      this._labelClick = new j9(this);
      this._biz = new er(this);
      this._map.temp.isPermitSpotOver = true;
      this.labelStyleParam = "pl";
      if (this._map.getMapType() === BMAP_SATELLITE_MAP) {
        this.labelStyleParam = "sl";
      }
      this.statRequestCount = 0;
      this.statResponseCount = 0;
    },
    _resizeHandler: function (ke) {
      var kg = this;
      var i = kg._map;
      var kd = i.getSize();
      var T = kd.width;
      var ki = kd.height;
      var kf = this.ratio;
      var kj = this._labelCanvas;
      var kc = kj.style;
      kc.width = T + "px";
      kc.height = ki + "px";
      kj.width = T * kf;
      kj.height = ki * kf;
      kg._width = T;
      kg._height = ki;
      var kh = true;
      kg._loadData(kh);
    },
    _bindEvent: function () {
      var e = this;
      var i = e._map;
      i.addEventListener("load", function (T) {
        e.clearLabel();
        e._loadData();
      });
      i.addEventListener("zoomend", function (T) {
        if (!T.notClearLabel) {
          e.clearLabel();
        }
        e._loadData();
      });
      i.addEventListener("moveend", function (T) {
        e._loadData();
      });
      i.addEventListener("resize", function (T) {
        e._resizeHandler(T);
      });
      i.addEventListener("maptypechange", function (T) {
        if (T.mapType === BMAP_EARTH_MAP) {
          e.hideLabelCanvas();
        } else {
          e.showLabelCanvas();
          if (T.mapType === BMAPGL_NORMAL_MAP) {
            e.labelStyleParam = "pl";
          } else if (T.mapType === BMAP_SATELLITE_MAP) {
            e.labelStyleParam = "sl";
          }
          e._loadData();
        }
      });
      i.addEventListener("streetlayer_show", function (T) {
        if (this.isCanvasMap()) {
          e.showLabelCanvas();
        }
      });
      i.addEventListener("streetlayer_hide", function (T) {
        if (this.isCanvasMap()) {
          e.hideLabelCanvas();
        }
      });
      i.addEventListener("loadbizdata", function (kc) {
        var T = kc.data;
        e._biz.proecessBizData(T, function () {
          e.updateLabel();
        });
      });
      i.addEventListener("unloadbizdata", function (T) {
        e._biz.clearBizData();
        e.updateLabel();
      });
      e.isDrawText = false;
      setTimeout(function () {
        if (!e.isDrawText) {
          i.dispatchEvent(new fJ("onmapwhitescreen"));
        }
      }, 10000);
    },
    getStyle: function () {
      return this._style;
    },
    _getZoomUnits: function (e) {
      return Math.pow(2, 18 - e);
    },
    _createCacheForm: function (T, kg, kf, i) {
      var ke = this;
      var e = ke._cache;
      var kc = e.arrCache;
      var kh = this._getLabelId(T, kg, kf, i);
      var kd = {
        id: kh,
        updateLabelCounter: 0
      };
      kc.push(kd);
      kc[kh] = kd;
      return kd;
    },
    _getLabelId: function (i, kc, T, e) {
      return "_" + i + "_" + kc + "_" + T + "_" + e + "_" + this.labelStyleParam;
    },
    _getCache: function (i, kc, T, e) {
      return this._cache.arrCache[this._getLabelId(i, kc, T, e)];
    },
    _setCacheValue: function (kd, kq, ko, kc, kj) {
      var kl = this;
      var e = kl._cache;
      var kf = e.arrCache;
      var kh = e.maxNum;
      var ke = e.delNum;
      var kp = this._getLabelId(kd, kq, ko, kc);
      var kk = kf[kp];
      if (kj) {
        kk.lb = kj;
      }
      if (kf.length > kh) {
        var T = kf.splice(0, ke);
        for (var ki = 0, kg = T.length; ki < kg; ki++) {
          var km = T[ki];
          var kn = km.id;
          if (kf[kn].lb) {
            kf[kn].lb = null;
          }
          kf[kn] = null;
          delete kf[kn];
        }
        T = null;
      }
    },
    _loadData: function (ko) {
      var kH = this._map;
      if (!kH.isCanvasMap()) {
        return;
      }
      var kh = kH.getCenterIn();
      var kG = e0.calcLoopCenterPoint(kh);
      var kg = this._tileType;
      var kj = this._width / 2;
      var kv = this._height;
      var kw = kH.getZoom();
      var ks = kg.getDataZoom(kw);
      var kl = kH.getZoomUnits(kw);
      var kr = kl * kj;
      var kF = kG.lng - kr;
      var kE = kG.lng + kr;
      var kp = e0.isAddWidth(kF, kE);
      kj = kp ? kj * 1.5 : kj;
      var kq = kg.getTileSize(kw);
      var kd = kg.getMercatorSize(kw, ks);
      var kk = Math.floor(kG.lng / kd);
      var km = Math.floor(kG.lat / kd);
      var ke = [kk, km, (kG.lng - kk * kd) / kd * kq, (kG.lat - km * kd) / kd * kq];
      var ky = ke[0] - Math.ceil((kj - ke[2]) / kq);
      var kC = ke[1] - Math.ceil((kv / 2 - ke[3]) / kq);
      var ku = ke[0] + Math.ceil((kj + ke[2]) / kq);
      var kz = ke[1] + Math.ceil((kv / 2 + ke[3]) / kq);
      kH.temp.isPermitSpotOver = false;
      var e = [];
      for (var kB = ky; kB < ku; kB++) {
        for (var kA = kC; kA < kz; kA++) {
          e.push([kB, kA, ks]);
          var kt = "id_" + kB + "_" + kA + "_" + kw;
          e[kt] = true;
        }
      }
      e._zoom = ks;
      e = e0.calcLoopTiles(e, kw);
      e.sort(function (i) {
        return function (kJ, kK) {
          return 0.4 * Math.abs(kJ[0] - i[0]) + 0.6 * Math.abs(kJ[1] - i[1]) - (0.4 * Math.abs(kK[0] - i[0]) + 0.6 * Math.abs(kK[1] - i[1]));
        };
      }([ke[0], ke[1]]));
      var kn = this._cache.arrCache;
      this._curViewLabels = [];
      var kc = "viewKey_" + Math.floor(kh.lng) + "_" + Math.floor(kh.lat) + "_" + kw;
      this.statRequestCount = 0;
      this.statResponseCount = 0;
      this._labelCount += e.length;
      var ki = kw;
      for (var kB = 0, kx = e.length; kB < kx; kB++) {
        var kk = e[kB][0];
        var km = e[kB][1];
        var T = e[kB][2];
        var kf = this._getLabelId(kk, km, T, ki);
        var kD = kn[kf];
        if (!kD) {
          kD = this._createCacheForm(kk, km, T, ki);
        }
        if (typeof kD.lb === "undefined") {
          kD.lb = null;
          this._loadLabelData(kk, km, T, ki, kq, kc);
          this.statRequestCount++;
        } else if (kD.lb) {
          this._curViewLabels.push(kD.lb);
          this._labelCount--;
        } else {
          if (ko) {
            this._loadLabelData(kk, km, T, ki, kq, kc);
          }
          kD.updateLabelCounter++;
        }
      }
      if (this._labelCount === 0) {
        this.updateLabel();
      }
      var kI = this;
      if (kI.errorTimer) {
        clearTimeout(kI.errorTimer);
      }
      kI.errorTimer = setTimeout(function () {
        if (kI._labelCount !== 0) {
          kI._labelCount = 0;
          kI.updateLabel();
        }
        var kK = new fJ("onloaddatatimeout");
        var kL = 0;
        var kJ = 0;
        var kM = 0;
        var i = 0;
        if (kI.statRequestCount === kI.statResponseCount) {
          kL = 1;
        } else {
          kJ = 1;
        }
        if (kJ === 1) {
          i = kI.statRequestCount - kI.statResponseCount;
          kM = kI.statResponseCount;
        }
        kK.noTimeoutCount = kL;
        kK.timeoutCount = kJ;
        kK.timeoutNoLoaded = i;
        kK.timeoutLoaded = kM;
        kI._map.dispatchEvent(kK);
      }, 500);
    },
    clearLabel: function () {
      var e = this._width;
      var T = this._height;
      var i = this.ratio;
      this._labelCtx.clearRect(0, 0, e * i, T * i);
    },
    updateLabel: function () {
      var i = this._map;
      var e = i.getCenterIn();
      var kc = this._width;
      var kf = this._height;
      var ki = i.getZoom();
      var kh = this._tileType.getTileSize(ki);
      var kg = this._getZoomUnits(ki);
      var T = this._labelCtx;
      this._labelCanvas.style.left = -i.offsetX + "px";
      this._labelCanvas.style.top = -i.offsetY + "px";
      var ke = this._curViewLabels;
      ke._centerX = e.lng;
      ke._centerY = e.lat;
      var kd = this._biz.bizLabels;
      this._computedLabel = this._labelStrategy.preComputeLabel(ke, kc, kf, kg, kh, kd);
      this._computedLabel._zoom = ki;
      this.clearLabel();
      this._vectorDrawLib.drawIconAndText(T, this._computedLabel, ki);
      this._addSpotData();
      i.temp.isPermitSpotOver = true;
      if (ke.length > 0) {
        this.isDrawText = true;
      }
    },
    _loadLabelData: function (kl, kk, kj, T, km, e) {
      var ke = kl.toString();
      var kc = kk.toString();
      var kg = "cbk_" + ke.replace("-", "_") + "_" + kc.replace("-", "__") + "_" + Math.floor(kj);
      var kq = fs + "." + kg;
      var kp = this._labelDataUrls;
      var ki = Math.abs(kl + kk) % kp.length;
      var kv = kp[ki];
      if (window.offLineIPAddress) {
        kv = window.offLineIPAddress + "pvd/";
      }
      var i = this.labelStyleParam;
      var ko = "?qt=vtile";
      var kr = "";
      if (this._map.config.style !== "default") {
        kr = "&styleId=1";
      }
      var kn = "x={x}&y={y}&z={z}&udt={udt}&v={v}&styles={styles}" + kr + "&textonly=1&textimg=1&scaler={scaler}&fn=" + encodeURIComponent(kq);
      var ks = e0.calcLoopParam(kl, kj).col;
      var kh = this.ratio > 1 ? 2 : 1;
      var kf = kn.replace(/{x}/, ks).replace(/{y}/, kk).replace(/{z}/, Math.floor(kj)).replace(/{styles}/, i).replace(/{udt}/, this._udt).replace(/{v}/, this._version).replace(/{scaler}/, kh);
      var kd = kv + ko + "&param=" + window.encodeURIComponent(eT(kf));
      var ku = this;
      var kt = ku._map;
      bx[kg] = function (kw) {
        ku._vectorDrawLib.parseLabelData(kw, kl, kk, kj, T, km, function (kB) {
          var ky = kt.getCenterIn();
          var kC = kt.getZoom();
          var kE = "viewKey_" + Math.floor(ky.lng) + "_" + Math.floor(ky.lat) + "_" + kC;
          ku._labelCount--;
          var kF = ku._getCache(kl, kk, kj, T).updateLabelCounter;
          ku._labelCount -= kF;
          var kz = ku._curViewLabels;
          if (kE === e || ku._labelCount < 0 && kC === kj) {
            kz.push(kB);
          }
          if (kE === e) {
            ku.statResponseCount++;
          }
          if (ku._labelCount <= 0) {
            var kx = new Date().getTime();
            ku.updateLabel();
            var kA = new Date().getTime();
            var kD = new fJ("oncanvasmaploaded");
            kD.drawTime = kA - kx;
            if (ku.statResponseCount === ku.statRequestCount) {
              kD.isAllLoadedDrawing = true;
            }
            kt.dispatchEvent(kD);
          }
          ku._setCacheValue(kl, kk, kj, T, kB);
          delete bx[kg];
        });
      };
      gM.load(kd);
    },
    drawLabel: function (T, kc, kj, i, kh, kd, e, ke, ki, kf) {
      var kg = this;
      if (!kg._computedLabel) {
        return;
      }
      if (kg._computedLabel._zoom !== kj) {
        kg.clearLabel();
        return;
      }
      kg._map.temp.isPermitSpotOver = false;
      kg.clearLabel();
      kg._vectorDrawLib.zoomingIconAndText(this._labelCtx, kg._computedLabel, T, kc, i, kh, kd, e, ke, ki, kf);
    },
    _addSpotData: function () {
      this._spotData = [];
      var kj = this._map.getZoom();
      for (var ke = 0, kd = this._computedLabel.length; ke < kd; ke++) {
        var kg = this._computedLabel[ke];
        if (!this.isClickableLabel(kg) || kg.guidExt === 1 && kg.startScale > kj) {
          continue;
        }
        var kf = [];
        kf[0] = (kg.minX - kg.maxX) / 2;
        kf[1] = (kg.minY - kg.maxY) / 2;
        kf[2] = (kg.maxX - kg.minX) / 2;
        kf[3] = (kg.maxY - kg.minY) / 2;
        var kc = null;
        if (kg.iconPos) {
          kc = new cx(kg.iconPos.geoX, kg.iconPos.geoY);
        }
        var T = kg.name ? kg.name.replace("\\\\", "<br>") : "";
        if (kg.iconPos && kg.iconPos.iconType.indexOf("ditie") > -1 && this._map.getZoom() > 14) {
          T = "";
        }
        var ki = {
          n: T,
          pt: new cx(kg.geoX, kg.geoY),
          userdata: {
            iconPoint: kc,
            uid: kg.guid,
            name: T,
            type: kg.iconPos ? kg.iconPos.iconType : "",
            iconImg: kg.iconImg,
            mapPoi: true,
            adver_log: kg.adver_log || ""
          },
          bd: kf,
          tag: "MAP_SPOT_INFO"
        };
        this._spotData.push(ki);
      }
      var kh = new fJ("onspotsdataready");
      kh.spots = this._spotData;
      this._map._spotDataOnCanvas = this._spotData;
      this._map.dispatchEvent(kh);
    },
    isClickableLabel: function (e) {
      if (e.isDel || !e.guid && !e.name) {
        return false;
      }
      return true;
    },
    getFilterImageData: function (T, kf) {
      var kg = T.data;
      var ke = this._labelStrategy;
      var kf = parseInt(kf);
      for (var kh = 0, kd = kg.length; kh < kd; kh += 4) {
        var e = kg[kh];
        var ki = kg[kh + 1];
        var kj = kg[kh + 2];
        var kk = kg[kh + 3];
        if (kk === 0) {
          continue;
        }
        var kc = Math.round((e + ki + kj) / 3);
        var kl = kc - 90;
        kl = kl < 0 ? 0 : kl;
        if (kf === ke.RANK5) {
          kg[kh] = 51 + kl * 1.3;
          kg[kh + 1] = 133 + kl * 0.8;
          kg[kh + 2] = 255;
        }
      }
      return T;
    },
    showLabelCanvas: function () {
      this._labelCanvas.style.visibility = "";
    },
    hideLabelCanvas: function () {
      this._labelCanvas.style.visibility = "hidden";
    }
  });
  var aT = 5;
  var i5 = 4;
  var gy = 3;
  var M = 2;
  var eq = 1;
  var hu = 0;
  var ka = 3;
  var io = 5;
  var fh = {
    3: {
      start: 3,
      base: 3
    },
    4: {
      start: 4,
      base: 5
    },
    5: {
      start: 4,
      base: 5
    },
    6: {
      start: 6,
      base: 7
    },
    7: {
      start: 6,
      base: 7
    },
    8: {
      start: 8,
      base: 9
    },
    9: {
      start: 8,
      base: 9
    },
    10: {
      start: 10,
      base: 10
    },
    11: {
      start: 11,
      base: 12
    },
    12: {
      start: 11,
      base: 12
    },
    13: {
      start: 11,
      base: 12
    },
    14: {
      start: 14,
      base: 15
    },
    15: {
      start: 14,
      base: 15
    },
    16: {
      start: 16,
      base: 17
    },
    17: {
      start: 16,
      base: 17
    },
    18: {
      start: 18,
      base: 19
    },
    19: {
      start: 18,
      base: 19
    },
    20: {
      start: 18,
      base: 19
    },
    21: {
      start: 18,
      base: 19
    }
  };
  function g1(kc) {
    this._canvas2dMapMgr = kc;
    var i = this.ratio = kc._map.config.ratio;
    this._featureStyle = null;
    this._map = kc._map;
    var T = by();
    var e = "udt=" + T.udt + "&v=" + T.ver;
    this.sizeRatio = this.ratio > 1 ? 2 : 1;
    this._binaryCache = {};
    this._iconCache = {};
    this._initColorCanvas();
  }
  eX.extend(g1.prototype, {
    _initColorCanvas: function () {
      var i = 256;
      var T = bX("canvas");
      var e = T.style;
      e.width = i + "px";
      e.height = i + "px";
      T.width = i;
      T.height = i;
      this._colorCvs = T;
      this._colorCtx = T.getContext("2d");
    },
    parseLabelData: function (i, ke, kd, kc, e, kh, kg) {
      if (!this._featureStyle) {
        this._featureStyle = this._canvas2dMapMgr.getStyle();
      }
      if (!i || !i[0]) {
        kg([]);
        return;
      }
      var kf = this._map.getZoomUnits();
      var T = this;
      this.loadTextPng(i, kh, ke, kd, kc, e, kf, kg);
    },
    loadTextPng: function (kt, kk, ki, kh, kf, i, kd, kc) {
      var ks = this;
      var e = kt[5];
      var kr = this._map;
      var ko = kr.getZoom();
      var T = kr.getSize();
      var kp = T.width;
      var kn = T.height;
      var kq = kr.getCenterIn();
      var kg = kq.lng;
      var ke = kq.lat;
      var km = ki * kk * kd;
      var kl = (kh + 1) * kk * kd;
      if (e) {
        var kj = new Image();
        kj.onload = function () {
          ks.calcIconAndTextInfo(kt, kj, kk, ki, kh, kf, i, kd, km, kl, kc);
          delete this.onload;
        };
        kj.src = e;
      } else {
        setTimeout(function () {
          ks.calcIconAndTextInfo(kt, null, kk, ki, kh, kf, i, kd, km, kl, kc);
        }, 1);
      }
    },
    calcIconAndTextInfo: function (kv, km, kn, kl, ki, kg, kc, ke, kp, ko, kd) {
      var ku = this;
      var kt = ku._featureStyle;
      var kj = [];
      kj.x = kl;
      kj.y = ki;
      kj.z = kg;
      var kk = ku._canvas2dMapMgr;
      var T = kl * ke * kn;
      var ks = (ki + 1) * ke * kn;
      var kf = {
        tileLeft: T,
        tileTop: ks,
        zoomUnits: ke
      };
      var e = [];
      if (kv[0]) {
        for (var kq = 0; kq < kv[0].length; kq++) {
          if (kv[0][kq][0] === ka) {
            e.push(kv[0][kq]);
          }
        }
      }
      var kh = kv[2] || [];
      for (var kq = 0; kq < e.length; kq++) {
        this._getFixedLabelInfo(e[kq], km, kc, ke, kn, kp, ko, kj);
      }
      var kr = Math.pow(2, kc - kg);
      for (kq = 0; kq < kh.length; kq++) {
        this._getLineLabelInfo(kh[kq], km, kg, kc, ke, kn, kp, ko, kr, kj);
      }
      kd(kj);
    },
    _getFixedLabelInfo: function (km, kq, kd, kh, kr, ku, kt, kw) {
      var kl = km[1];
      if (!kl) {
        return;
      }
      var ky = this._map.getZoom();
      var kG = this._map.config.style;
      var kH = this._featureStyle;
      var ki = kd;
      if (ki === 9) {
        ki = 8;
      }
      for (var kD = 0; kD < kl.length; kD++) {
        var kI = kl[kD];
        var e = kI[0];
        var kc = aX.getStyleFromCache(kG, e, "point", ki, kH);
        var kC = aX.getStyleFromCache(kG, e, "pointText", ki, kH);
        if ((!kC || kC.length === 0) && (!kc || kc.length === 0)) {
          if (ki === 5) {
            var kg = kI[1];
            if (!kg) {
              continue;
            }
            for (var kz = 0; kz < kg.length; kz++) {
              var kx = kg[kz][4];
              if (kx && kx[7] === "北京") {
                kc = aX.getStyleFromCache(kG, e, "point", 6, kH);
                kC = aX.getStyleFromCache(kG, e, "pointText", 6, kH);
                break;
              } else {
                continue;
              }
            }
          } else {
            continue;
          }
        }
        var kg = kI[1];
        if (!kg) {
          continue;
        }
        var kE = null;
        var kj = 1;
        var T = 0;
        var kp = 0;
        if (kc && kc[0]) {
          kc = kc[0];
          kE = kc.icon;
          kj = kc.zoom ? kc.zoom / 100 : 1;
        } else {
          kc = null;
        }
        for (var kz = 0; kz < kg.length; kz++) {
          var kx = kg[kz][4];
          if (!kx) {
            continue;
          }
          var kB = kx[2];
          if (!this._isVisible(kB, ky)) {
            continue;
          }
          var kk = kx[12];
          if (kC && kC.length > 0 && !kk) {
            continue;
          }
          var ko = Math.round(kx[0] / 100);
          var kn = Math.round(kx[1] / 100);
          var kA = {
            lng: ku + ko,
            lat: kt - (kr * kh - kn)
          };
          var kf = ko / kh;
          var ke = kr - kn / kh;
          var ks = kx[7] || "";
          var kF = kx[5];
          var kv = {
            type: "fixed",
            name: ks,
            textImg: kq,
            rank: kx[4],
            baseX: kf,
            baseY: ke,
            iconPos: null,
            textPos: null,
            guid: kx[3] || "",
            tracer: kB,
            direction: kF,
            startScale: 3
          };
          if ((kF !== i5 && kk || !kk) && kE !== null) {
            kv.iconPos = this._getIconPosition(kE, kj, kf, ke, kA);
            if (kv.iconPos) {
              T = kv.iconPos.width;
              kp = kv.iconPos.height;
            }
          }
          if (T === 0) {
            kv.direction = i5;
          }
          if (kk) {
            kv.textPos = this._getTextDrawData(kx, kf, ke, T, kp);
          }
          if (kv.textPos || kv.iconPos) {
            kw.push(kv);
          }
        }
      }
    },
    _isVisible: function (e, i) {
      var kc;
      if (!this._binaryCache[e]) {
        kc = e.toString(2);
        if (kc.length < 8) {
          kc = new Array(8 - kc.length + 1).join("0") + kc;
        }
        this._binaryCache[e] = kc;
      }
      kc = this._binaryCache[e];
      var T = fh[i].start;
      return kc[i - T] === "1";
    },
    _getIconPosition: function (kg, ke, T, i, e) {
      var kc = this._map.config.style;
      var kh = bx["iconSetInfo" + kc][kg];
      if (!kh) {
        if (kg.charCodeAt(0) >= 48 && kg.charCodeAt(0) <= 57) {
          kh = bx["iconSetInfo" + kc]["_" + kg];
        }
      }
      if (!kh) {
        return null;
      }
      var kd = kh[0];
      var kf = kh[1];
      kd = kd * ke;
      kf = kf * ke;
      return {
        srcX: 0,
        srcY: 0,
        destX: T - kd / 2,
        destY: i - kf / 2,
        width: kd,
        height: kf,
        geoX: e.lng,
        geoY: e.lat,
        mcPt: e,
        iconType: kg
      };
    },
    _getTextDrawData: function (kn, km, kl, kc, kj) {
      var ks = kn[5];
      if (typeof ks !== "number") {
        ks = 0;
      }
      var kh = this.ratio;
      var kg = kh / 2;
      kc *= kg;
      kj *= kg;
      var ki = kn[12];
      var kd = ki.length;
      var kv = 0;
      var ku = 0;
      var kr = [];
      var kq = 0;
      var kt = 0;
      for (var kp = 0; kp < kd; kp++) {
        kt += Math.round(ki[kp][3]);
      }
      for (var kp = 0; kp < kd; kp++) {
        var kf = ki[kp];
        var ke = kf[0];
        var i = kf[1];
        var T = kf[2];
        var e = kf[3];
        var kw = 2 * kh;
        var ko = 0;
        if (kc !== 0) {
          ko = 2 * kh;
        }
        if (kc === 0) {
          ks = i5;
        }
        switch (ks) {
          case gy:
            var kk = kl - kt / 2 - kw * (kd - 1) / 2;
            kv = km - T - kc / 2 - ko;
            ku = kk + kq + kw * kp;
            break;
          case eq:
            var kk = kl - kt / 2 - kw * (kd - 1) / 2;
            kv = km + kc / 2 + ko;
            ku = kk + kq + kw * kp;
            break;
          case M:
            var kk = kl - kj / 2 - kt - kw * (kd - 1) - kw;
            kv = km - T / 2;
            ku = kk + kq + kw * kp;
            break;
          case hu:
            var kk = kl + kj / 2 + kw / 2;
            kv = km - T / 2;
            ku = kk + kq + kw * kp;
            break;
          case i5:
            var kk = kl - e / 2 - kw * (kd - 1) / 2;
            kv = km - T / 2;
            ku = kk + kq + kw * kp;
            break;
        }
        kq += e;
        if (T > 0 && e > 0) {
          kr.push({
            srcX: ke,
            srcY: i,
            destX: kv,
            destY: ku,
            width: T,
            height: e
          });
        }
      }
      if (kr.length > 0) {
        return kr;
      }
      return null;
    },
    _getLineLabelInfo: function (kk, kc, kd, kz, kM, kr, kx, kw, ky, kq) {
      if (kk.length !== 10) {
        return;
      }
      var kB = this.ratio;
      var T = this.ratio;
      var kI = kk[7].length;
      var ks = kk[1];
      var kK = kk[3];
      var kQ = kk[8];
      var kg = kk[4];
      var e = 2;
      var ke = kg.slice(0, e);
      for (var kN = e; kN < kg.length; kN += e) {
        ke[kN] = ke[kN - e] + kg[kN];
        ke[kN + 1] = ke[kN - (e - 1)] + kg[kN + 1];
      }
      for (var kN = e; kN < kg.length; kN += e) {
        if (kN % (kK * e) === 0 || kN % (kK * e) === 1) {
          continue;
        }
        ke[kN] = ke[kN - e] + kg[kN] / ky;
        ke[kN + 1] = ke[kN - (e - 1)] + kg[kN + 1] / ky;
      }
      for (var kP = 0; kP < kI; kP++) {
        var kL = kk[7][kP];
        if (!this._isVisible(kL, kz)) {
          continue;
        }
        var kD = kk[6][kP];
        var kp = kP * kK * e;
        kg = ke.slice(kp, kp + kK * e);
        var kt = [];
        var kC = undefined;
        var kA = undefined;
        var ko = undefined;
        var kn = undefined;
        var kQ = kk[9].slice(0);
        if (kD) {
          kQ.reverse();
        }
        var kG;
        var kE;
        for (var kO = 0; kO < kK; kO++) {
          var km = kk[5][kK * kP + kO];
          var kH = kg[kO * e] / 100;
          var kF = kg[kO * e + 1] / 100;
          var kl = kQ[kO];
          var kh = kl[0];
          var kj = kl[1];
          var kf = kl[2];
          var ki = kl[3];
          var kv;
          var ku;
          var kS;
          var kR;
          if (kO === 0) {
            kG = kS = kH / kM;
            kE = kr - kF / kM;
            kR = kF / kM;
          } else {
            kS = kH / kM;
            kR = kF / kM;
          }
          var kU = kG + (kS - kG) * T - kf / 2;
          var kT = kE + (kr - kR - kE) * T - ki / 2;
          if (kC === undefined) {
            kC = kG - kf / 2;
            kA = kE - ki / 2;
            ko = kC + kf;
            kn = kA + ki;
          } else {
            if (kU < kC) {
              kC = kU;
            }
            if (kT < kA) {
              kA = kT;
            }
            if (kU + kf > ko) {
              ko = kU + kf;
            }
            if (kT + ki > kn) {
              kn = kT + ki;
            }
          }
          kt.push({
            angle: km,
            srcX: kh,
            srcY: kj,
            destX: kU,
            destY: kT,
            width: kf,
            height: ki
          });
        }
        var kJ = {
          type: "line",
          textImg: kc,
          rank: ks,
          baseX: kG,
          baseY: kE,
          arrWordPos: kt,
          minXOriginal: kC,
          minYOriginal: kA,
          maxXOriginal: ko,
          maxYOriginal: kn,
          text: ""
        };
        kq.push(kJ);
      }
    },
    alterColor: function (kf, e, ke) {
      var T = this._colorCtx;
      var i = this._canvas2dMapMgr;
      T.clearRect(0, 0, kf.width, kf.height);
      T.drawImage(e, kf.srcX, kf.srcY, kf.width, kf.height, 0, 0, kf.width, kf.height);
      var kd = T.getImageData(0, 0, kf.width, kf.height);
      var kc = i.getFilterImageData(kd, ke);
      T.putImageData(kc, 0, 0);
    },
    drawIconAndText: function (kr, kq, e) {
      var ki = this.ratio;
      var kg = this.sizeRatio / ki;
      var kk = 2 / ki;
      var kC = this;
      for (var ku = 0, ks = kq.length; ku < ks; ku++) {
        var kj = kq[ku];
        if (kj.isDel == false) {
          var kd = kj.baseDrawX;
          var kc = kj.baseDrawY;
          if (kj.type == "fixed") {
            var kf = kj.iconPos;
            var kv = kj.textPos;
            var ko = kj.textImg;
            var ky = kj.startScale;
            if (kf && ky <= e) {
              var T = this._iconCache[kf.iconType];
              if (T) {
                if (T.img) {
                  kr.drawImage(T.img, 0, 0, T.img.width, T.img.height, Math.round(kd * ki + (kf.drawX - kd) / kk), Math.round(kc * ki + (kf.drawY - kc) / kk), kf.width / kk, kf.height / kk);
                } else {
                  T.drawLabels.push(kj);
                }
              } else if (!T) {
                this._iconCache[kf.iconType] = {
                  img: null,
                  drawLabels: [kj]
                };
                var kE = new Image();
                kE._iconName = kf.iconType;
                kE.onload = function () {
                  var kK = kC._iconCache[this._iconName];
                  kK.img = this;
                  this.onload = null;
                  for (var kG = 0; kG < kK.drawLabels.length; kG++) {
                    var kI = kK.drawLabels[kG];
                    var kH = kI.baseDrawX;
                    var kF = kI.baseDrawY;
                    var kJ = kI.iconPos;
                    kr.drawImage(this, 0, 0, this.width, this.height, Math.round(kH * ki + (kJ.drawX - kH) / kk), Math.round(kF * ki + (kJ.drawY - kF) / kk), kJ.width / kk, kJ.height / kk);
                  }
                  kK.drawPos = [];
                };
                kE.src = B.getIconSetPath(kC._map.config.style) + kf.iconType + ".png";
              }
            }
            if (kv && ko && ky <= e) {
              for (var kh = 0; kh < kv.length; kh++) {
                var kp = kv[kh];
                if (!kj._tempRank) {
                  kr.drawImage(ko, kp.srcX, kp.srcY, kp.width, kp.height, Math.round(kd * ki + (kp.drawX - kd) / kg), Math.round(kc * ki + (kp.drawY - kc) / kg), kp.width / kg, kp.height / kg);
                } else {
                  this.alterColor(kp, ko, kj._tempRank);
                  kr.drawImage(this._colorCvs, 0, 0, kp.width, kp.height, Math.round(kd * ki + (kp.drawX - kd) / kg), Math.round(kc * ki + (kp.drawY - kc) / kg), kp.width / kg, kp.height / kg);
                }
              }
            }
          } else {
            var ke = kj.arrWordPos;
            var ko = kj.textImg;
            var kn = kj.tileX;
            var kl = kj.tileY;
            for (var kt = 0, km = ke.length; kt < km; kt++) {
              var kw = ke[kt];
              var kD = Math.round(kn + kw.destX);
              var kB = Math.round(kl + kw.destY);
              var kx = kw.angle;
              kD = kd * ki + kD - kd;
              kB = kc * ki + kB - kc;
              if (kx > 10 && kx < 350) {
                kr.save();
                var kA = Math.round(kD + kw.width / 2);
                var kz = Math.round(kB + kw.height / 2);
                kr.translate(kA, kz);
                kr.rotate(-kx / 180 * Math.PI);
                kr.drawImage(ko, kw.srcX, kw.srcY, kw.width, kw.height, -Math.round(kw.width / 2), -Math.round(kw.height / 2), kw.width / kg, kw.height / kg);
                kr.restore();
              } else {
                kr.drawImage(ko, kw.srcX, kw.srcY, kw.width, kw.height, kD, kB, kw.width / kg, kw.height / kg);
              }
            }
          }
        }
      }
    },
    isCollide: function (ke, kn, km, e, kg, T, ki) {
      for (var kd = 0, kc = T.length; kd < kc; kd++) {
        var kh = T[kd];
        var kf = 1 / Math.pow(2, ki + 1);
        var kl = kf * kh[3] / 2;
        var kk = kf * kh[4] / 2;
        var kj = kh[0];
        if (kj != ke) {
          if (!(kn + e < kh[1] - kl || kn > kh[1] + kh[3] + kl || km + kg < kh[2] - kk || km > kh[2] + kh[4] + kk)) {
            return true;
          }
        }
      }
      return false;
    },
    zoomingIconAndText: function (kC, kw, kc, kA, kB, k3, kJ, kk, kP, kI, kt) {
      var k4 = this.ratio;
      var kl = this.sizeRatio / k4;
      var k5 = 2 / k4;
      var lf = k4 / 2;
      var kZ = kA.x;
      var kY = kA.y;
      var kD = 2 * k4;
      if (kt !== 0) {
        kY += kI;
      }
      var ko = undefined;
      var kh = undefined;
      var ke = undefined;
      var kj = undefined;
      var ks = undefined;
      var kO = k3 > 0 ? true : false;
      if (!kO) {
        ko = [];
        var kS = 1 - kJ;
      }
      for (var lb = 0, k9 = kw.length; lb < k9; lb++) {
        var k6 = kw[lb];
        if (k6.isDel == false) {
          var lg = k6.baseDrawX;
          var ld = k6.baseDrawY;
          kC.save();
          kC.translate(-kk * k4, -kP * k4);
          if (k6.isFadeout) {
            if (!kO && k6._schedule <= kJ && !k6._isIgnore) {
              kC.globalAlpha = kS;
              k6._schedule = kJ;
            } else {
              k6._isIgnore = true;
              continue;
            }
          }
          if (k6.type == "fixed") {
            var kE = k6.iconPos;
            var kL = k6.textPos;
            var kf = k6.textImg;
            var kF = k6.startScale;
            var T;
            var kW = 0;
            if (kE) {
              kW = kD;
            }
            if (kE && !k6.iconImg && this._iconCache[kE.iconType]) {
              T = this._iconCache[kE.iconType].img;
            }
            if (kE && kF <= kB && T) {
              kj = kE.width;
              ks = kE.height;
              kh = (kZ + (lg - kZ) * kc) * k4 - kj / 2 / k5;
              ke = (kY + (ld - kY) * kc) * k4 - ks / 2 / k5 + kt;
              if (!kO && this.isCollide(lb, kh, ke, kj, ks, ko, k3)) {
                k6.isFadeout = true;
              }
              kC.drawImage(T, kE.srcX, kE.srcY, T.width, T.height, Math.round(kh), Math.round(ke), kj / k5, ks / k5);
              if (!kO) {
                ko.push([lb, kh, ke, kj, ks]);
              }
            }
            if (kL && kf && kF <= kB) {
              var kK;
              var kM;
              var kv = 0;
              var kH = 0;
              if (kE) {
                kv = kE.width;
                kH = kE.height;
              }
              var kX = kL.length;
              var kn = 0;
              var kN = 0;
              for (var kx = 0; kx < kX; kx++) {
                var k8 = kL[kx];
                kN += k8.height;
                if (kn < k8.width) {
                  kn = k8.width;
                }
              }
              kN += (kx - 1) * kD;
              if (!kO && this.isCollide(lb, kh, ke, kn, kN, ko, k3)) {
                k6.isFadeout = true;
              }
              var k7 = 0;
              for (var kx = 0; kx < kX; kx++) {
                var k8 = kL[kx];
                switch (k6.direction) {
                  case gy:
                    kK = -(kv / 2 / k5 + k8.width + kW);
                    kM = -kN / 2 + k7 + kD * kx;
                    break;
                  case eq:
                    kK = kv / 2 / k5 + kW;
                    kM = -kN / 2 + k7 + kD * kx;
                    break;
                  case M:
                    kK = -k8.width / 2;
                    kM = -kH / 2 / k5 - kN + k7 - kD * (kx + 1);
                    break;
                  case hu:
                    kK = -k8.width / 2;
                    kM = kH / 2 / k5 + k7 + kD * (kx + 1);
                    break;
                  case i5:
                    kK = -k8.width / 2;
                    kM = -kN / 2 + k7 + kD * kx;
                    break;
                }
                k7 += k8.height;
                kh = (kZ + (lg - kZ) * kc) * k4 + kK / kl;
                ke = (kY + (ld - kY) * kc) * k4 + kM / kl;
                +kt;
                kj = k8.width;
                ks = k8.height;
                if (!k6._tempRank) {
                  kC.drawImage(kf, k8.srcX, k8.srcY, kj, ks, Math.round(kh), Math.round(ke), kj / kl, ks / kl);
                } else {
                  this.alterColor(k8, kf, k6._tempRank);
                  kC.drawImage(this._colorCvs, 0, 0, kj, ks, Math.round(kh), Math.round(ke), kj / kl, ks / kl);
                }
                if (!kO) {
                  ko.push([lb, kh, ke, kj, ks]);
                }
              }
            }
          } else {
            var ku = k6.arrWordPos;
            var kf = k6.textImg;
            var le = k6.tileX;
            var lc = k6.tileY;
            var km = ku[0];
            var ki = Math.round(le + km.destX);
            var kg = Math.round(lc + km.destY);
            for (var la = 0, kV = ku.length; la < kV; la++) {
              var k2 = ku[la];
              var li = Math.round(le + k2.destX);
              var lh = Math.round(lc + k2.destY);
              var kz = k2.angle;
              var kU = Math.round((kZ + (lg - kZ) * kc) * k4 - km.width / 2 + li - ki);
              var kT = Math.round((kY + (ld - kY) * kc) * k4 - km.height / 2 + lh - kg);
              kh = kU;
              ke = kT;
              kj = k2.width;
              ks = k2.height;
              if (!kO && this.isCollide(lb, kh, ke, kj, ks, ko, k3)) {
                k6.isFadeout = true;
              }
              if (kz > 10 && kz < 350) {
                var k1 = kU + k2.width / 2;
                var k0 = kT + k2.height / 2;
                var kd = kz / 180 * Math.PI;
                var kG = Math.cos(kd);
                var kp = Math.sin(kd);
                var kR = kG;
                var kq = kG;
                var kQ = kp;
                var kr = -kp;
                var ky = k1 - k1 * kG - k0 * kp;
                var e = k0 + k1 * kp - k0 * kG;
                kC.save();
                kC.transform(kR, kr, kQ, kq, ky, e);
                kC.drawImage(kf, k2.srcX, k2.srcY, kj, ks, kh, ke, kj / kl, ks / kl);
                kC.restore();
              } else {
                kC.drawImage(kf, k2.srcX, k2.srcY, kj, ks, kh, ke, kj / kl, ks / kl);
              }
              if (!kO) {
                ko.push([lb, kh, ke, kj, ks]);
              }
            }
          }
          kC.restore();
        }
      }
    }
  });
  function er(e) {
    this.initVars(e);
  }
  eX.extend(er.prototype, {
    initVars: function (e) {
      this._map = e._map;
      this._canvas2dMapMgr = e;
      this.base64Prefix = "data:image/png;base64,";
      this.bizData = null;
      this.objTextsPng = null;
      this.arrIconsPng = null;
      this.bizLabels = null;
    },
    proecessBizData: function (ke, ki) {
      var kg = this;
      this.bizData = ke;
      this.objTextsPng = null;
      this.arrIconsPng = null;
      var T = ke.textsPng;
      var kk = ke.iconsPng;
      if (!T || !kk) {
        return;
      }
      var kh = new Image();
      kh.onload = function () {
        kg.objTextsPng = this;
        kg.calcIconAndTextInfo(ki);
        this.onload = null;
      };
      kh.src = this.base64Prefix + T;
      var kj = kk.length;
      var e = [];
      for (var kd = 0; kd < kj; kd++) {
        var kf = kk[kd];
        var kc = new Image();
        (function (i) {
          kc.onload = function () {
            kj--;
            e[i] = this;
            if (kj === 0) {
              kg.arrIconsPng = e;
              kg.calcIconAndTextInfo(ki);
            }
            this.onload = null;
          };
        })(kd);
        kc.src = this.base64Prefix + kf;
      }
    },
    calcIconAndTextInfo: function (kl) {
      if (this.objTextsPng && this.arrIconsPng) {
        var kh = this.bizData;
        var kf = kh.pois;
        var e = [];
        for (var ki = 0, ke = kf.length; ki < ke; ki++) {
          var kc = kf[ki];
          var kg = this.arrIconsPng[kc.iconPng];
          var kd = kg.height / 2;
          var kk = {
            type: "fixed",
            name: "",
            textImg: this.objTextsPng,
            iconImg: kg,
            rank: kc.rank,
            iconPos: {
              srcX: 0,
              srcY: 0,
              destX: -kg.width / 2,
              destY: -kd / 2,
              width: kg.width,
              height: kd,
              geoX: kc.x,
              geoY: kc.y,
              iconType: "vectorCustom"
            },
            textPos: this.calcTextPos(kc.pos, kg),
            startScale: kc.from < 12 ? 12 : kc.from,
            guid: kc.guid,
            guidExt: 1,
            adver_log: kc.adver_log || ""
          };
          var T = {
            type: "fixed",
            textDirLeft: "left",
            name: "",
            textImg: this.objTextsPng,
            iconImg: kg,
            rank: kc.rank,
            iconPos: {
              srcX: 0,
              srcY: 0,
              destX: -kg.width / 2,
              destY: -kd / 2,
              width: kg.width,
              height: kd,
              geoX: kc.x,
              geoY: kc.y,
              iconType: "vectorCustom"
            },
            textPos: this.calcTextPosLeft(kc.pos, kg),
            startScale: kc.from < 12 ? 12 : kc.from,
            guid: kc.guid,
            guidExt: 1,
            adver_log: kc.adver_log || ""
          };
          var kj = [kk, T];
          e.push(kj);
        }
        this.bizLabels = e;
        if (kl) {
          kl();
        }
      }
    },
    calcTextPos: function (kf, T) {
      var i = [];
      var ke = kf.length / 4;
      var kd = T.width / 2;
      if (ke === 1) {
        var kc = {
          srcX: kf[0],
          srcY: kf[1],
          destX: kd,
          destY: -kf[3] / 2,
          width: kf[2],
          height: kf[3]
        };
        i.push(kc);
      } else {
        var kc = {
          srcX: kf[0],
          srcY: kf[1],
          destX: kd,
          destY: -kf[3],
          width: kf[2],
          height: kf[3]
        };
        var e = {
          srcX: kf[4],
          srcY: kf[5],
          destX: kd,
          destY: 0,
          width: kf[6],
          height: kf[7]
        };
        i.push(kc);
        i.push(e);
      }
      return i;
    },
    calcTextPosLeft: function (kf, T) {
      var i = [];
      var ke = kf.length / 4;
      var kd = T.width / 2;
      if (ke === 1) {
        var kc = {
          srcX: kf[0],
          srcY: kf[1],
          destX: -kd - kf[2],
          destY: -kf[3] / 2,
          width: kf[2],
          height: kf[3]
        };
        i.push(kc);
      } else {
        var kc = {
          srcX: kf[0],
          srcY: kf[1],
          destX: -kd - kf[2],
          destY: -kf[3],
          width: kf[2],
          height: kf[3]
        };
        var e = {
          srcX: kf[4],
          srcY: kf[5],
          destX: -kd - kf[2],
          destY: 0,
          width: kf[6],
          height: kf[7]
        };
        i.push(kc);
        i.push(e);
      }
      return i;
    },
    clearBizData: function () {
      this.bizData = null;
      this.bizLabels = null;
    }
  });
  var jy = {
    Int8: "BYTE",
    Uint8: "UNSIGNED_BYTE",
    Int16: "SHORT",
    Uint16: "UNSIGNED_SHORT",
    Float32: "FLOAT"
  };
  var h3 = {
    Int8: 1,
    Uint8: 1,
    Int16: 2,
    Uint16: 2,
    Float32: 4
  };
  function w(kc, ke, T, kd) {
    this.arrayBuffer = kc;
    this.attributes = ke.members;
    this.bytesPerElement = 0;
    if (this.attributes) {
      for (var e = 0; e < this.attributes.length; e++) {
        this.bytesPerElement += h3[this.attributes[e].type] * this.attributes[e].components;
      }
    } else {
      this.bytesPerElement = kc.BYTES_PER_ELEMENT * ke.components;
    }
    this.length = kd || kc.byteLength / this.bytesPerElement;
    this.type = T;
    this.arrayType = ke;
  }
  w.prototype.bind = function (i) {
    var e = i[this.type];
    if (!this.buffer) {
      this.buffer = i.createBuffer();
      i.bindBuffer(e, this.buffer);
      i.bufferData(e, this.arrayBuffer, i.STATIC_DRAW);
      this.arrayBuffer = null;
    } else {
      i.bindBuffer(e, this.buffer);
    }
  };
  w.prototype.setVertexAttribPointers = function (kc, e) {
    for (var i = 0; i < this.attributes.length; i++) {
      var kd = this.attributes[i];
      var T = e.attributes[kd.name];
      kc.vertexAttribPointer(T, kd.components, kc[jy[kd.type]], kd.normalize, this.bytesPerElement, kd.offset);
    }
  };
  w.prototype.updateVertexData = function (kc, i, T) {
    this.arrayBuffer = i;
    if (!this.buffer) {
      return this.bind(kc);
    }
    if (T <= this.length) {
      var e = kc[this.type];
      kc.bindBuffer(e, this.buffer);
      kc.bufferData(e, this.arrayBuffer, kc.STATIC_DRAW);
    } else {
      this.destroy(kc);
      this.bind(kc);
    }
    this.length = T;
  };
  w.prototype.destroy = function (e) {
    if (this.buffer) {
      e.deleteBuffer(this.buffer);
      this.buffer = null;
    }
  };
  w.BufferType = {
    VERTEX: "ARRAY_BUFFER",
    ELEMENT: "ELEMENT_ARRAY_BUFFER"
  };
  w.ELEMENT_ATTRIBUTE_TYPE = "Uint16";
  w.VERTEX_ATTRIBUTE_ALIGNMENT = 4;
  function dO() {
    this.boundProgram = null;
    this.boundVertexBuffer = null;
    this.boundElementBuffer = null;
    this.vao = null;
  }
  dO.prototype.bind = function (kg, e, kc, kf) {
    var kd = kg.extVertexArrayObject;
    if (kd === undefined) {
      kd = kg.extVertexArrayObject = kg.getExtension("OES_vertex_array_object");
    }
    if (kd) {
      if (!this.vao) {
        this.vao = kd.createVertexArrayOES();
      }
      kd.bindVertexArrayOES(this.vao);
    } else {}
    if (!this.boundProgram) {
      var kh = kd ? 0 : kg.currentNumAttributes || 0;
      var ke = e.numAttributes;
      var T;
      for (T = kh; T < ke; T++) {
        kg.enableVertexAttribArray(T);
      }
      if (!kd) {
        for (T = ke; T < kh; T++) {
          kg.disableVertexAttribArray(T);
        }
        kg.currentNumAttributes = ke;
      }
      kc.bind(kg);
      kc.setVertexAttribPointers(kg, e);
      if (kf) {
        kf.bind(kg);
      }
      if (kd) {
        this.boundProgram = e;
        this.boundVertexBuffer = kc;
        this.boundElementBuffer = kf;
      }
    }
  };
  dO.prototype.update = function (kg, kc, T, kf, e, i, ke) {
    var kd = kg.extVertexArrayObject;
    if (kd === undefined) {
      kd = kg.extVertexArrayObject = kg.getExtension("OES_vertex_array_object");
    }
    if (kd) {
      kd.bindVertexArrayOES(this.vao);
      if (this.boundVertexBuffer) {
        this.boundVertexBuffer.updateVertexData(kg, T, kf);
        this.boundVertexBuffer.setVertexAttribPointers(kg, this.boundProgram);
      }
      if (e && this.boundElementBuffer) {
        this.boundElementBuffer.updateVertexData(kg, i, ke);
      }
    } else {
      kc.updateVertexData(kg, T, kf);
      if (e) {
        e.updateVertexData(kg, i, ke);
      }
    }
  };
  dO.prototype.unbind = function (i) {
    var e = i.extVertexArrayObject;
    if (e) {
      e.bindVertexArrayOES(null);
      this.boundProgram = null;
      this.boundVertexBuffer = null;
      this.boundElementBuffer = null;
    }
  };
  dO.prototype.destroy = function (i) {
    var e = i.extVertexArrayObject;
    if (e && this.vao) {
      e.deleteVertexArrayOES(this.vao);
      this.vao = null;
      this.boundProgram = null;
      this.boundVertexBuffer = null;
      this.boundElementBuffer = null;
    }
  };
  function C() {}
  eX.extend(C.prototype, {
    centerAndZoomIn: function (T, ki, kj) {
      kj = kj || {};
      if (!this.loaded) {
        this.firstTileLoad = false;
      }
      ki = this._getProperZoom(ki).zoom;
      if (kj.noAnimation !== true && this.loaded) {
        var ke = this._ifUseAnimation(T, ki);
        if (ke) {
          this.flyToIn(T, ki, kj);
          return;
        }
      }
      var kg = this;
      if (!T && !ki) {
        return;
      }
      this._stopAllAnimations();
      if (T && !T.equals(this.centerPoint)) {
        this.fire(new fJ("oncenter_changed"));
      }
      if (ki && ki !== this.zoomLevel) {
        this.fire(new fJ("onzoom_changed"));
      }
      T = T || this.centerPoint;
      ki = ki || this.zoomLevel;
      ki = this._getProperZoom(ki).zoom;
      if (this.mapType === BMAP_EARTH_MAP) {
        if (!this._earth) {
          this.mapType = BMAPGL_NORMAL_MAP;
          this.temp.originMapType = BMAP_EARTH_MAP;
          function kh() {
            kg._earth = new bx.Earth(kg, {
              showRealSunlight: kg.config.showRealSunlight,
              showMilkyway: kg.config.showMilkyway,
              earthBackground: kg.config.earthBackground
            });
            kg._proxyEarthEvents();
            kg._changeEarthMapType(BMAP_EARTH_MAP);
            eX.extend(kg, bx.EarthView.prototype);
            delete kg.temp.originMapType;
          }
          g2.load("earth", function () {
            if (bx["FeatureStyle" + kg.config.style]) {
              kh();
            } else {
              kg.loadMapStyleFiles(function () {
                kh();
              });
            }
          });
        }
      }
      this.lastLevel = this.zoomLevel || ki;
      this.zoomLevel = ki;
      var kf = new fJ("onload");
      kf.point = T;
      kf.zoom = ki;
      this.centerPoint = new cx(T.lng, T.lat);
      this.defaultZoomLevel = this.defaultZoomLevel || this.zoomLevel;
      this.defaultCenter = this.defaultCenter || this.centerPoint;
      if (this.mapType !== BMAP_EARTH_MAP) {
        this.centerPoint = this.restrictCenter(this.centerPoint);
      }
      if (!this.loaded && !(this.temp.originMapType === BMAP_EARTH_MAP)) {
        var i = this.config.defaultMaxBounds;
        var kd = new m(i, "baidu", this.mapType);
        if (this.mapType !== BMAP_NONE_MAP) {
          var kc = new hv({
            mapType: this.mapType,
            copyright: kd,
            dataType: this.mapType === BMAP_SATELLITE_MAP ? gF : hI,
            customLayer: this.mapType === BMAP_SATELLITE_MAP,
            baseLayer: true,
            transparentPng: false,
            tileTypeName: this.mapType === BMAP_SATELLITE_MAP ? "web" : "na"
          });
          kc._isInnerLayer = true;
          this.addTileLayer(kc);
          this.baseLayerAdded = true;
        }
        if (this.mapType === BMAP_SATELLITE_MAP && this.config.showVectorStreetLayer) {
          this._addHybirdVectorMap();
        } else if (this.mapType === BMAP_SATELLITE_MAP && this._isHybridShow === true) {
          this._addHybirdMap();
        }
        this.on("zoom_changed", function () {
          if (this._heading === 0) {
            return;
          }
          if (this.getZoom() < 7 && this.config.restrictCenter === true) {
            kg.resetHeading();
          }
        });
      }
      this.loaded = true;
      this.dispatchEvent(kf);
      if (kj.callback) {
        kj.callback();
      }
    },
    _ifUseAnimation: function (kc, kh) {
      var kg = this.getSize();
      var T = {
        zoom: this.zoomLevel
      };
      var kj = {
        zoom: kh
      };
      var ki = this.pointToPixelIn(this.centerPoint);
      var kd = this.pointToPixelIn(kc, T);
      var kf = this.pointToPixelIn(this.centerPoint, kj);
      var kl = this.pointToPixelIn(kc, kj);
      var ke = Math.abs(ki.x - kd.x);
      var i = Math.abs(ki.y - kd.y);
      var e = Math.abs(kf.x - kl.x);
      var kk = Math.abs(kf.y - kl.y);
      if ((ke > kg.width || i > kg.height) && (e > kg.width || kk > kg.height)) {
        return false;
      }
      return true;
    },
    _setPlatformPosition: function (kj, ki, kl) {
      kl = kl || {};
      if (kj === 0 && ki === 0 && !kl.point) {
        return;
      }
      if (isNaN(kl.initMapOffsetX)) {
        kl.initMapOffsetX = this.offsetX;
      }
      if (isNaN(kl.initMapOffsetY)) {
        kl.initMapOffsetY = this.offsetY;
      }
      var kf = iB(this._heading);
      if (this._tilt > 0) {
        ki = ki / Math.cos(iB(this._tilt));
      }
      var kk = kj * Math.cos(kf) + ki * Math.sin(kf);
      var kh = -kj * Math.sin(kf) + ki * Math.cos(kf);
      kk = kk + kl.initMapOffsetX;
      kh = kh + kl.initMapOffsetY;
      if (kl.point) {
        var i = this.restrictCenter(kl.point);
        if (!i.equals(this.centerPoint)) {
          this.centerPoint = i.clone();
          this.fire(new fJ("oncenter_changed"));
        }
      } else {
        var kc = this.offsetX - kk;
        var e = this.offsetY - kh;
        var kg = this.centerPoint.lng;
        var ke = this.centerPoint.lat;
        var kd = new cx(kg, ke);
        var T = this.getZoomUnits();
        this.centerPoint = this.restrictCenter(new cx(kd.lng + kc * T, kd.lat - e * T), T);
        this.fire(new fJ("oncenter_changed"));
      }
      this.offsetX = kk;
      this.offsetY = kh;
      this.dispatchEvent(new fJ("onmoving"));
    },
    restrictCenter: function (kk, e) {
      if (this.config.restrictCenter === false) {
        return kk;
      }
      e = e || this.getZoomUnits();
      var ki = this.pixelToPointIn(new fi(this.width, 0), {
        center: kk
      });
      var kf = this.pixelToPointIn(new fi(0, this.height), {
        center: kk
      });
      var kl = kk.lng;
      var kq = kk.lat;
      if (this.config.restrictBounds !== null && !this.config.restrictBounds.isEmpty()) {
        var kp = this.config.restrictBounds;
        var T = kp.getSouthWest();
        var kn = kp.getNorthEast();
        var kj = i9.convertLL2MC(T);
        var kd = i9.convertLL2MC(kn);
        var kg = this.calcNewZoomByRestriction(kl, kq, kf, ki, kj.lng, kd.lng, kj.lat, kd.lat);
        if (kg > this.zoomLevel) {
          this.zoomLevel = kg;
          return kk;
        }
        kk.lng = this.calcNewLngByBounds(kl, kf, ki, kj.lng, kd.lng, e);
        kk.lat = this.calcNewLatByBounds(kq, kf, ki, kj.lat, kd.lat, e);
        return kk;
      }
      var kh = this.pixelToPointIn(new fi(0, 0), {
        center: kk
      });
      var kc = this.pixelToPointIn(new fi(0, this.height), {
        center: kk
      });
      if (this.zoomLevel < 5) {
        if (kh.lat > hK.MAX_LAT && kc.lat < hK.MIN_LAT) {
          var i = hK.MAX_LAT - kk.lat;
          var ke = kk.lat - hK.MIN_LAT;
          var ko;
          if (i < ke) {
            ko = i / (this.height / 2);
          } else {
            ko = ke / (this.height / 2);
          }
          var km = 18 - p(ko);
          this.zoomLevel = km;
          return kk;
        }
      }
      if (kh.lat > hK.MAX_LAT) {
        kk.lat = hK.MAX_LAT - this.height / 2 * e;
      } else if (kc.lat < hK.MIN_LAT) {
        kk.lat = hK.MIN_LAT + this.height / 2 * e;
      }
      return kk;
    },
    calcNewZoomByRestriction: function (kj, ki, e, kh, kd, kf, kc, ke) {
      var km = 0;
      var kn = 0;
      if (typeof kc === "number" && typeof ke === "number" && kh.lat > ke && e.lat < kc) {
        var T = ke - ki;
        var i = ki - kc;
        var kg;
        if (T < i) {
          kg = T / (this.height / 2);
        } else {
          kg = i / (this.height / 2);
        }
        km = 18 - p(kg);
      }
      if (typeof kd === "number" && typeof kf === "number" && kh.lng > kf && e.lng < kd) {
        var kl = kf - kj;
        var kk = kj - kd;
        var kg;
        if (kl < kk) {
          kg = kl / (this.width / 2);
        } else {
          kg = kk / (this.width / 2);
        }
        kn = 18 - p(kg);
      }
      return Math.max(km, kn) || this.zoomLevel;
    },
    calcNewLatByBounds: function (i, kc, T, kf, ke, e) {
      var kd = i;
      if (T.lat > ke) {
        kd = ke - this.height / 2 * e;
      } else if (kc.lat < kf) {
        kd = kf + this.height / 2 * e;
      }
      return kd;
    },
    calcNewLngByBounds: function (kf, ke, kc, kd, T, e) {
      var i = kf;
      if (kc.lng > T) {
        i = T - this.width / 2 * e;
      } else if (ke.lng < kd) {
        i = kd + this.width / 2 * e;
      }
      return i;
    },
    zoomTo: function (e, ko, kp) {
      var kk = ej[this.mapType];
      if (!kk) {
        return;
      }
      var kj = this._getProperZoom(e);
      e = kj.zoom;
      if (this.zoomLevel === e) {
        if (kp && kp.callback) {
          kp.callback();
        }
        return;
      }
      var ke = e;
      this.lastLevel = this.zoomLevel;
      kp = kp || {};
      if (this.zoomEventStatus === "idle") {
        this.fire(new fJ("onzoomstart"));
        this.zoomEventStatus = "zooming";
      }
      if (!ko && this.getInfoWindow() && this.temp.infoWin && this.temp.infoWin.isOpen()) {
        ko = i9.convertLL2MC(this.getInfoWindow().getPoint());
      }
      var T = null;
      if (kp.fixPixel) {
        T = kp.fixPixel;
      } else if (ko) {
        T = this.pointToPixelIn(ko, {
          useRound: false
        });
      }
      var kf = this.pixelToPointIn(T);
      var kg = this.centerPoint.clone();
      this.fixPoint = ko;
      this.fixPixel = T;
      this.fixCenter = kg;
      this.mousePosMCPoint = kf;
      if (kp.noAnimation) {
        e = kj.zoom;
        this.zoomLevel = e;
        this.fire(new fJ("onzoom_changed"));
        var kd = this.getCurrentMaxTilt();
        if (this._tilt > kd) {
          this._tilt = kd;
        }
        if (ko) {
          if (this._heading % 360 !== 0 || this._tilt > 0) {
            var i = this._webglMapCamera.fromScreenPixelToMC(T.x, T.y, {
              center: kg,
              zoom: this.zoomLevel
            });
            if (i) {
              var kl = i.sub(kf);
              var kc = kg.sub(kl);
              this.centerPoint = this.restrictCenter(kc);
            }
          } else {
            var ki = this.getZoomUnits();
            var kc = new cx(ko.lng - ki * (T.x - this.width / 2), ko.lat + ki * (T.y - this.height / 2));
            this.centerPoint = this.restrictCenter(kc, ki);
          }
          this.fire(new fJ("oncenter_changed"));
        }
        this._checkFireZoomend();
        if (kp.callback) {
          kp.callback();
        }
        return;
      }
      this._animationInfo.zoom = {
        current: this.zoomLevel,
        diff: e - this.zoomLevel,
        target: e
      };
      var km = this;
      var kn = this._tilt;
      if (this.fixPoint || kn > hK.MAX_DRAG_TILT_L2) {
        kp.renderCallback = function () {
          var kt = km.getCurrentMaxTilt();
          if (km._tilt > kt) {
            km._tilt = kt;
          }
          var ku = km.fixPixel;
          if (!km.fixPixel || !km.fixPoint) {
            return;
          }
          var kq = km.fixPixel;
          var kA = km.fixPoint;
          var kx = km.fixCenter;
          var kv = km.mousePosMCPoint;
          if (km._heading % 360 !== 0 || km._tilt > 0) {
            var kr = km._webglMapCamera.fromScreenPixelToMC(kq.x, kq.y, {
              center: kx,
              zoom: km.zoomLevel,
              tilt: km._tilt
            });
            if (kr) {
              var kz = kr.sub(kv);
              var ks = kx.sub(kz);
              km.centerPoint = km.restrictCenter(ks);
            }
          } else {
            var kw = kq;
            var ky = km.getZoomUnits();
            var ks = new cx(kA.lng - ky * (kw.x - km.width / 2), kA.lat + ky * (kw.y - km.height / 2));
            km.centerPoint = km.restrictCenter(ks, ky);
          }
          km.fire(new fJ("oncenter_changed"));
        };
      }
      if (kp.fromMouseWheel === true) {
        this._startInfiniteZoomAnimation(kp);
        if (kp.callback) {
          kp.callback();
        }
        km._checkFireZoomend();
        return;
      }
      if (!kp.callback) {
        kp.callback = function () {
          km._checkFireZoomend();
        };
      } else {
        var kh = kp.callback;
        kp.callback = function (kq, kr) {
          kh(kq, kr);
          km._checkFireZoomend();
        };
      }
      this._startAnimation(kp);
    },
    _checkFireZoomend: function () {
      var e = this;
      if (e.fireZoomendTimer) {
        clearTimeout(e.fireZoomendTimer);
      }
      e.fireZoomendTimer = setTimeout(function () {
        if (e.zoomEventStatus === "zooming") {
          e.fire(new fJ("onzoomend"));
          e.zoomEventStatus = "idle";
        }
        e.fireZoomendTimer = null;
      }, 150);
    },
    deepZoomMedia: function (e) {
      var i = this;
      if (!i.temp.isStdCtrlBusy) {
        i.temp.isStdCtrlBusy = true;
        i.deepZoomTo(i.zoomLevel + e);
        setTimeout(function () {
          i.temp.isStdCtrlBusy = false;
        }, 400);
      }
    },
    deepZoomTo: function (e) {
      this.zoomTo(e);
    },
    flyToIn: function (T, kG, kr) {
      kr = kr || {};
      var kd = this._getProperZoom(kG);
      kG = kd.zoom;
      if (this.centerPoint.equals(T) && this.zoomLevel === kG && typeof kr.heading !== "number" && typeof kr.tilt !== "number") {
        return;
      }
      var e = this.getHeading() % 360;
      var kj = this.getTilt();
      var kp = 0;
      var kt = 0;
      var km = this.getBounds().containsPoint(T);
      if (typeof kr.heading === "number") {
        kp = kr.heading;
      } else if (km) {
        kp = e;
      }
      if (typeof kr.tilt === "number") {
        kt = kr.tilt;
      } else if (km) {
        kt = kj;
      }
      this._heading = e;
      var kD = kp - e;
      var kz = kt - kj;
      var kn = this;
      var kf = this.zoomLevel;
      var kg = 1.42;
      var kv = this.zoomScale(kG - kf);
      var kI = this.getZoomUnits();
      var kl = this.centerPoint.div(kI);
      var kJ = T.div(kI);
      var kC = this.worldSize();
      var ky = kg;
      var kx = Math.max(this.width, this.height);
      var kw = kx / kv;
      var kk = kJ.sub(kl).mag();
      var i = ky * ky;
      function kF(kL) {
        var kK = (kw * kw - kx * kx + (kL ? -1 : 1) * i * i * kk * kk) / (2 * (kL ? kw : kx) * i * kk);
        return Math.log(Math.sqrt(kK * kK + 1) - kK);
      }
      function kc(kK) {
        return (Math.exp(kK) - Math.exp(-kK)) / 2;
      }
      function kh(kK) {
        return (Math.exp(kK) + Math.exp(-kK)) / 2;
      }
      function kq(kK) {
        return kc(kK) / kh(kK);
      }
      var ki = kF(0);
      var kA = function (kK) {
        return kh(ki) / kh(ki + ky * kK);
      };
      var kB = function (kK) {
        return kx * ((kh(ki) * kq(ki + ky * kK) - kc(ki)) / i) / kk;
      };
      var ke = (kF(1) - ki) / ky;
      if (Math.abs(kk) < 0.000001 || ke === Infinity || isNaN(ke)) {
        if (Math.abs(kx - kw) < 0.000001) {
          this._animationInfo.zoom = {
            current: this.zoomLevel,
            diff: kG - this.zoomLevel
          };
          this._animationInfo.center = {
            current: this.centerPoint,
            diff: T.sub(this.centerPoint)
          };
          this._animationInfo.heading = {
            current: e,
            diff: kp - e
          };
          this._animationInfo.tilt = {
            current: kj,
            diff: kt - kj
          };
          this.setLock(true);
          this._startAnimation({
            callback: function (kK) {
              kn.setLock(false);
              if (kr.callback) {
                kr.callback(kK);
              }
            },
            duration: kr.duration
          });
          return;
        }
        var kH = kw < kx ? -1 : 1;
        ke = Math.abs(Math.log(kw / kx)) / ky;
        kB = function () {
          return 0;
        };
        kA = function (kK) {
          return Math.exp(kH * ky * kK);
        };
      }
      var kE = 1.7;
      if (ke < 0.3) {
        kE = 0.8;
      } else if (ke > 5) {
        kE = (ke - 5) / 2 + kE;
      }
      var ks = kr.duration || 1000 * ke / kE;
      if (isNaN(ks)) {
        var ku = {};
        for (var ko in kr) {
          ku[ko] = kr[ko];
          ku.noAnimation = true;
        }
        this.centerAndZoomIn(T, kG, ku);
        return;
      }
      this.fire(new fJ("onmovestart"));
      this.fire(new fJ("onzoomstart"));
      this.setLock(true);
      this._startAnimation({
        duration: ks,
        renderCallback: function (kK, kL) {
          var kM = kK * ke;
          var kP = kB(kM);
          var kO = kf + kn.scaleZoom(1 / kA(kM));
          if (kO < kn.getMinZoom()) {
            kO = kn.getMinZoom();
          }
          if (kO > kn.getMaxZoom()) {
            kO = kn.getMaxZoom();
          }
          if (kO !== kn.zoomLevel) {
            kn.zoomLevel = kO;
            kn.fire(new fJ("onzoom_changed"));
          }
          kn.centerPoint = kl.add(kJ.sub(kl).mult(kP)).mult(kI);
          kn.fire(new fJ("oncenter_changed"));
          if (typeof kp === "number") {
            var kN = kK / 0.7;
            if (kN > 1) {
              kN = 1;
            }
            kn.setHeading(e + kD * kK, {
              noAnimation: true
            });
          }
          if (typeof kt === "number") {
            kn.setTilt(kj + kz * kK, {
              noAnimation: true
            });
          }
        },
        callback: function (kK, kL) {
          kn.setLock(false);
          if (kL && kL.stop === true) {
            kn.fire(new fJ("onmoveend"));
            kn.fire(new fJ("onzoomend"));
            if (kr.callback) {
              kr.callback(kK);
            }
            return;
          }
          if (kG !== kn.zoomLevel) {
            kn.zoomLevel = kG;
            kn.fire(new fJ("onzoom_changed"));
          }
          kn.fire(new fJ("onmoveend"));
          kn.fire(new fJ("onzoomend"));
          if (kr.callback) {
            kr.callback(kK);
          }
        }
      });
    },
    zoomScale: function (e) {
      return Math.pow(2, e);
    },
    scaleZoom: function (e) {
      return Math.log(e) / Math.LN2;
    },
    panToIn: function (i, T) {
      T = T || {};
      if (!i || i.equals(this.centerPoint)) {
        if (T.callback) {
          T.callback();
        }
        return;
      }
      var kc = this.pointToPixelIn(i);
      var e = Math.round(this.width / 2);
      var ke = Math.round(this.height / 2);
      var kd = this._ifUseAnimation(i, this.zoomLevel);
      if (T.noAnimation === true || kd === false) {
        this._stopAllAnimations();
        this._panToIn(e - kc.x, ke - kc.y, i);
        if (T.callback) {
          T.callback();
        }
        return;
      }
      this.flyToIn(i, this.zoomLevel, T);
    },
    _panToIn: function (i, e, kc) {
      var T = this.temp;
      if (T.operating === true) {
        return;
      }
      if (T.dragAni) {
        T.dragAni.stop(false, {
          readyToMove: true
        });
        T.dragAni = null;
      }
      this.dispatchEvent(new fJ("onmovestart"));
      this._setPlatformPosition(i, e, {
        point: kc
      });
      this.dispatchEvent(new fJ("onmoveend"));
    },
    _stopAllAnimations: function (e) {
      e = e || {};
      if (this._ani) {
        this._ani.stop(!!e.goToEnd, {
          stopCurrentAnimation: e.stopCurrentAnimation
        });
        this._ani = null;
      }
      if (this._infiniteAni) {
        this._infiniteAni.stop();
        this._infiniteAni = null;
      }
    },
    panBy: function (i, e, T) {
      i = Math.round(i) || 0;
      e = Math.round(e) || 0;
      T = T || {};
      if (Math.abs(i) <= this.width && Math.abs(e) <= this.height && T.noAnimation !== true) {
        this._panBy(i, e, T);
      } else {
        this._panToIn(i, e, T.point);
        if (T.callback) {
          T.callback();
        }
      }
    },
    _panBy: function (i, e, kd) {
      if (this.temp.operating === true) {
        return;
      }
      kd = kd || {};
      this.dispatchEvent(new fJ("onmovestart"));
      var kc = this;
      var T = kc.temp;
      T.pl = kc.offsetX;
      T.pt = kc.offsetY;
      if (T.tlPan) {
        T.tlPan.cancel();
      }
      if (T.dragAni) {
        T.dragAni.stop(false, {
          readyToMove: true
        });
        T.dragAni = null;
      }
      T.tlPan = new fy({
        fps: kd.fps || kc.config.fps,
        duration: kd.duration || kc.config.actionDuration,
        transition: kd.transition || gA.easeInOutQuad,
        render: function (ke) {
          this.terminative = kc.temp.operating;
          if (kc.temp.operating) {
            return;
          }
          kc._setPlatformPosition(i * ke, e * ke, {
            initMapOffsetX: T.pl,
            initMapOffsetY: T.pt
          });
        },
        finish: function (ke) {
          kc.dispatchEvent(new fJ("onmoveend"));
          kc.temp.tlPan = false;
          if (kc.temp.stopArrow === true) {
            kc.temp.stopArrow = false;
            if (kc.temp.arrow !== 0) {
              kc._arrow();
            }
          }
        }
      });
    },
    _startAnimation: function (i) {
      var kd = this._animationInfo;
      var T = this;
      i = i || {};
      if (T._ani) {
        T._ani.stop(!!i.goToEnd, {
          stopCurrentAnimation: i.stopCurrentAnimation
        });
      }
      if (T._infiniteAni) {
        T._infiniteAni.stop();
        T._infiniteAni = null;
      }
      var ke = i.duration || 500;
      var kf = i.transition || gA.ease;
      var e = new fJ("onanimation_start");
      this.fire(e);
      if (i.unstopable) {
        kd = this._animationInfoUnstopable;
      }
      var kc = new fy({
        duration: ke,
        transition: kf,
        render: function (ki, kh) {
          for (var kg in kd) {
            if (!kd.hasOwnProperty(kg)) {
              continue;
            }
            var kk = kd[kg].current;
            var kj = kd[kg].diff;
            T._setValueTick(kg, kk, kj, ki);
          }
          if (i.renderCallback) {
            i.renderCallback(ki, kh);
          }
        },
        finish: function (kg) {
          T.fire(new fJ("onanimation_end"));
          if (i.unstopable) {
            T._animationInfoUnstopable = {};
            T._unstopableAni = null;
          } else {
            T._ani = null;
            T._animationInfo = {};
          }
          if (i.mapNeedCbk) {
            i.mapNeedCbk();
          }
          if (i.callback) {
            i.callback(kg);
          }
        },
        onStop: function (kg) {
          kg = kg || {};
          T.fire(new fJ("onanimation_end"));
          if (kg.stopCurrentAnimation) {
            T._animationInfo = {};
          }
          T._ani = null;
          if (i.mapNeedCbk) {
            i.mapNeedCbk();
          }
          if (i.callback) {
            i.callback(null, {
              stop: true
            });
          }
        }
      });
      if (i.unstopable) {
        T._unstopableAni = kc;
      } else {
        T._ani = kc;
      }
    },
    _startInfiniteZoomAnimation: function (e) {
      var i = this;
      if (i._ani) {
        i._ani.stop(!!e.goToEnd, {
          stopCurrentAnimation: e.stopCurrentAnimation
        });
      }
      if (i._infiniteAni) {
        return;
      }
      this.fire(new fJ("onanimation_start"));
      i._infiniteAni = new fy({
        duration: 10000,
        transition: gA.linear,
        render: function () {
          var T = i._animationInfo.zoom;
          if (Math.abs(T.current - T.target) < 0.001) {
            i._setValue("zoom", T.target);
            if (i._infiniteAni) {
              i._infiniteAni.stop();
            }
            return;
          }
          T.current += (T.target - T.current) * 0.35;
          i._setValue("zoom", T.current);
          if (e.renderCallback) {
            e.renderCallback();
          }
        },
        finish: function () {
          i._infiniteAni = null;
          i._animationInfo = {};
          i.fire(new fJ("onanimation_end"));
          if (e.callback) {
            e.callback();
          }
        },
        onStop: function () {
          i._infiniteAni = null;
          i._animationInfo = {};
          i.fire(new fJ("onanimation_end"));
          if (e.callback) {
            e.callback();
          }
        }
      });
    },
    _setValue: function (e, T) {
      if (e === "zoom") {
        this._preZoomLevel = this.zoomLevel;
        var i = this._getProperZoom(T);
        T = i.zoom;
        if (T !== this.zoomLevel) {
          this.zoomLevel = T;
          if (T < 5) {
            this.restrictCenter(this.centerPoint);
          }
          this.fire(new fJ("on" + e + "_changed"));
        }
        return;
      } else if (e === "center") {
        this.centerPoint = T;
      }
      this["_" + e] = T;
      this.fire(new fJ("on" + e + "_changed"));
    },
    _setValueTick: function (e, kd, kc, i) {
      if (e === "center") {
        var T = new cx(kd.lng + kc.lng * i, kd.lat + kc.lat * i);
        this._setValue(e, T);
        return;
      }
      if (e === "zoom") {
        this._setValue(e, Math.pow(kd, 1 - i) * Math.pow(kd + kc, i));
        return;
      }
      this._setValue(e, kd + kc * i);
    },
    setHeading: function (kc, i) {
      i = i || {};
      if (kc === this._heading) {
        if (i.callback) {
          i.callback();
        }
        return;
      }
      var T = ee(this._heading, 360);
      var e = ee(kc, 360);
      if (e === T) {
        this._heading = kc;
        if (i.callback) {
          i.callback();
        }
        return;
      }
      if (i.noAnimation) {
        this._setValue("heading", kc);
        if (i.callback) {
          i.callback();
        }
        return;
      }
      if (i.unstopable) {
        this._animationInfoUnstopable.heading = {
          current: this._heading,
          diff: kc - this._heading
        };
      } else {
        this._animationInfo.heading = {
          current: this._heading,
          diff: kc - this._heading
        };
      }
      this._startAnimation(i);
    },
    resetHeading: function (e) {
      var i = this._heading;
      while (i < 0) {
        i += 360;
      }
      i = i % 360;
      if (i > 180) {
        i -= 360;
      }
      this._heading = i;
      e = e || {};
      e.unstopable = true;
      this.setHeading(0, e);
    },
    getHeading: function () {
      return this._heading;
    },
    setTilt: function (e, i) {
      i = i || {};
      if (e === this._tilt) {
        if (i.callback) {
          i.callback();
        }
        return;
      }
      if (e > hK.MAX_TILT) {
        e = hK.MAX_TILT;
      }
      if (e < hK.MIN_TILT) {
        e = hK.MIN_TILT;
      }
      if (i && i.noAnimation) {
        this._setValue("tilt", e);
        if (i.callback) {
          i.callback();
        }
        return;
      }
      this._animationInfo.tilt = {
        current: this._tilt,
        diff: e - this._tilt
      };
      this._startAnimation(i);
    },
    getTilt: function () {
      return this._tilt;
    },
    getCenterIn: function () {
      return this.centerPoint;
    },
    getZoom: function () {
      return this.zoomLevel;
    },
    getCameraPosition: function (T) {
      T = T || {};
      var e = T.center || this.centerPoint;
      var kc = T.zoom || this.zoomLevel;
      var kf = typeof T.heading === "number" ? T.heading : this._heading;
      var i = typeof T.tilt === "number" ? T.tilt : this._tilt;
      var ke = this._webglMapCamera.generateMVMatrix(e, kc, kf, i);
      var kd = mat4.create(Float32Array);
      mat4.invert(kd, ke);
      return this._webglMapCamera.getPosition(kd);
    }
  });
  function bj(i) {
    this._jobQueue = [];
    this._idleOnlyJobQueue = [];
    var e = this;
    this.isIdle = true;
    i.on("updateframe", function (kc) {
      var T = 12 - kc.frameTime;
      T = T < 1 ? 1 : T;
      e.isIdle = false;
      if (e.idleWorkTimer) {
        clearInterval(e.idleWorkTimer);
        e.idleWorkTimer = null;
      }
      e.runJobs(T);
    });
    this._idleWorkerTicker = function (T) {
      return function () {
        if (T.isIdle) {
          T.runJobs();
          T.runIdleOnlyJobs();
        }
      };
    }(this);
    i.on("mapglidle", function () {
      e.isIdle = true;
      e.runJobs();
      e.runIdleOnlyJobs();
      e.idleWorkTimer = setInterval(e._idleWorkerTicker, bj.MAX_IDLE_TIME);
    });
    i.on("destroy", function () {
      if (e.idleWorkTimer) {
        clearInterval(e.idleWorkTimer);
        e.idleWorkTimer = null;
      }
    });
  }
  bj.MAX_IDLE_TIME = 50;
  bj.MAX_FRAME_TIME = 6;
  bj.prototype.runJobs = function (i) {
    if (this._jobQueue.length === 0) {
      return;
    }
    var kc = ia();
    var e = 0;
    i = i || bj.MAX_FRAME_TIME;
    while (this._jobQueue.length && e < i) {
      var T = this._jobQueue.shift();
      if (T.state !== "invalid") {
        T.call();
      }
      e = ia() - kc;
    }
  };
  bj.prototype.runIdleOnlyJobs = function () {
    if (this._idleOnlyJobQueue.length === 0) {
      return;
    }
    var T = ia();
    var e = 0;
    while (this._idleOnlyJobQueue.length && e < bj.MAX_IDLE_TIME) {
      var i = this._idleOnlyJobQueue.shift();
      if (i.state !== "invalid") {
        i.call();
      }
      e = ia() - T;
    }
  };
  bj.prototype.checkIdleRunning = function () {
    if (this.isIdle && !this.idleWorkTimer) {
      this.runJobs();
      this.runIdleOnlyJobs();
      this.idleWorkTimer = setInterval(this._idleWorkerTicker, 50);
    }
  };
  bj.prototype.addJob = function (e) {
    this._jobQueue.push(e);
    this.checkIdleRunning();
  };
  bj.prototype.clearJobs = function () {
    this._jobQueue.length = 0;
    this._idleOnlyJobQueue.length = 0;
  };
  bj.prototype.addIdleOnlyJob = function (e) {
    this._idleOnlyJobQueue.push(e);
    this.checkIdleRunning();
  };
  var dS = {};
  (function (kf) {
    if (!kj) {
      var kj = 0.000001;
    }
    if (!i) {
      var i = typeof Float32Array !== "undefined" ? Float32Array : Array;
    }
    if (!kd) {
      var kd = Math.random;
    }
    var T = {};
    var ke = Math.PI / 180;
    T.toRadian = function (kk) {
      return kk * ke;
    };
    var ki = {};
    ki.create = function (kl) {
      kl = kl || i;
      var kk = new kl(2);
      kk[0] = 0;
      kk[1] = 0;
      return kk;
    };
    ki.clone = function (kk, km) {
      km = km || i;
      var kl = new km(2);
      kl[0] = kk[0];
      kl[1] = kk[1];
      return kl;
    };
    ki.fromValues = function (kk, kn, km) {
      km = km || i;
      var kl = new km(2);
      kl[0] = kk;
      kl[1] = kn;
      return kl;
    };
    ki.copy = function (kl, kk) {
      kl[0] = kk[0];
      kl[1] = kk[1];
      return kl;
    };
    ki.set = function (kl, kk, km) {
      kl[0] = kk;
      kl[1] = km;
      return kl;
    };
    ki.add = function (km, kl, kk) {
      km[0] = kl[0] + kk[0];
      km[1] = kl[1] + kk[1];
      return km;
    };
    ki.subtract = function (km, kl, kk) {
      km[0] = kl[0] - kk[0];
      km[1] = kl[1] - kk[1];
      return km;
    };
    ki.sub = ki.subtract;
    ki.multiply = function (km, kl, kk) {
      km[0] = kl[0] * kk[0];
      km[1] = kl[1] * kk[1];
      return km;
    };
    ki.mul = ki.multiply;
    ki.divide = function (km, kl, kk) {
      km[0] = kl[0] / kk[0];
      km[1] = kl[1] / kk[1];
      return km;
    };
    ki.div = ki.divide;
    ki.min = function (km, kl, kk) {
      km[0] = Math.min(kl[0], kk[0]);
      km[1] = Math.min(kl[1], kk[1]);
      return km;
    };
    ki.max = function (km, kl, kk) {
      km[0] = Math.max(kl[0], kk[0]);
      km[1] = Math.max(kl[1], kk[1]);
      return km;
    };
    ki.scale = function (km, kl, kk) {
      km[0] = kl[0] * kk;
      km[1] = kl[1] * kk;
      return km;
    };
    ki.scaleAndAdd = function (km, kl, kk, kn) {
      km[0] = kl[0] + kk[0] * kn;
      km[1] = kl[1] + kk[1] * kn;
      return km;
    };
    ki.distance = function (km, kl) {
      var kk = kl[0] - km[0];
      var kn = kl[1] - km[1];
      return Math.sqrt(kk * kk + kn * kn);
    };
    ki.dist = ki.distance;
    ki.squaredDistance = function (km, kl) {
      var kk = kl[0] - km[0];
      var kn = kl[1] - km[1];
      return kk * kk + kn * kn;
    };
    ki.sqrDist = ki.squaredDistance;
    ki.length = function (kl) {
      var kk = kl[0];
      var km = kl[1];
      return Math.sqrt(kk * kk + km * km);
    };
    ki.len = ki.length;
    ki.squaredLength = function (kl) {
      var kk = kl[0];
      var km = kl[1];
      return kk * kk + km * km;
    };
    ki.sqrLen = ki.squaredLength;
    ki.negate = function (kl, kk) {
      kl[0] = -kk[0];
      kl[1] = -kk[1];
      return kl;
    };
    ki.normalize = function (kn, km) {
      var kl = km[0];
      var ko = km[1];
      var kk = kl * kl + ko * ko;
      if (kk > 0) {
        kk = 1 / Math.sqrt(kk);
        kn[0] = km[0] * kk;
        kn[1] = km[1] * kk;
      }
      return kn;
    };
    ki.dot = function (kl, kk) {
      return kl[0] * kk[0] + kl[1] * kk[1];
    };
    ki.cross = function (km, kl, kk) {
      var kn = kl[0] * kk[1] - kl[1] * kk[0];
      km[0] = km[1] = 0;
      km[2] = kn;
      return km;
    };
    ki.lerp = function (km, kl, kk, kn) {
      var kp = kl[0];
      var ko = kl[1];
      km[0] = kp + kn * (kk[0] - kp);
      km[1] = ko + kn * (kk[1] - ko);
      return km;
    };
    ki.random = function (kk, km) {
      km = km || 1;
      var kl = kd() * 2 * Math.PI;
      kk[0] = Math.cos(kl) * km;
      kk[1] = Math.sin(kl) * km;
      return kk;
    };
    ki.transformMat2 = function (kn, km, kl) {
      var kk = km[0];
      var ko = km[1];
      kn[0] = kl[0] * kk + kl[2] * ko;
      kn[1] = kl[1] * kk + kl[3] * ko;
      return kn;
    };
    ki.transformMat2d = function (kn, km, kl) {
      var kk = km[0];
      var ko = km[1];
      kn[0] = kl[0] * kk + kl[2] * ko + kl[4];
      kn[1] = kl[1] * kk + kl[3] * ko + kl[5];
      return kn;
    };
    ki.transformMat3 = function (kn, km, kl) {
      var kk = km[0];
      var ko = km[1];
      kn[0] = kl[0] * kk + kl[3] * ko + kl[6];
      kn[1] = kl[1] * kk + kl[4] * ko + kl[7];
      return kn;
    };
    ki.transformMat4 = function (kn, km, kl) {
      var kk = km[0];
      var ko = km[1];
      kn[0] = kl[0] * kk + kl[4] * ko + kl[12];
      kn[1] = kl[1] * kk + kl[5] * ko + kl[13];
      return kn;
    };
    ki.rotate = function (kn, kl, kk, kr) {
      var kq = kl[0] - kk[0];
      var kp = kl[1] - kk[1];
      var km = Math.sin(kr);
      var ko = Math.cos(kr);
      kn[0] = kq * ko - kp * km + kk[0];
      kn[1] = kq * km + kp * ko + kk[1];
      return kn;
    };
    ki.forEach = function () {
      var kk = ki.create();
      return function (kn, kr, ks, kq, kp, kl) {
        var ko;
        var km;
        if (!kr) {
          kr = 2;
        }
        if (!ks) {
          ks = 0;
        }
        if (kq) {
          km = Math.min(kq * kr + ks, kn.length);
        } else {
          km = kn.length;
        }
        for (ko = ks; ko < km; ko += kr) {
          kk[0] = kn[ko];
          kk[1] = kn[ko + 1];
          kp(kk, kk, kl);
          kn[ko] = kk[0];
          kn[ko + 1] = kk[1];
        }
        return kn;
      };
    }();
    ki.str = function (kk) {
      return "vec2(" + kk[0] + ", " + kk[1] + ")";
    };
    kf.vec2 = ki;
    var kh = {};
    kh.create = function (kl) {
      kl = kl || i;
      var kk = new kl(3);
      kk[0] = 0;
      kk[1] = 0;
      kk[2] = 0;
      return kk;
    };
    kh.clone = function (kk, km) {
      km = km || i;
      var kl = new km(3);
      kl[0] = kk[0];
      kl[1] = kk[1];
      kl[2] = kk[2];
      return kl;
    };
    kh.fromValues = function (kk, ko, km, kn) {
      kn = kn || i;
      var kl = new kn(3);
      kl[0] = kk;
      kl[1] = ko;
      kl[2] = km;
      return kl;
    };
    kh.copy = function (kl, kk) {
      kl[0] = kk[0];
      kl[1] = kk[1];
      kl[2] = kk[2];
      return kl;
    };
    kh.set = function (kl, kk, kn, km) {
      kl[0] = kk;
      kl[1] = kn;
      kl[2] = km;
      return kl;
    };
    kh.add = function (km, kl, kk) {
      km[0] = kl[0] + kk[0];
      km[1] = kl[1] + kk[1];
      km[2] = kl[2] + kk[2];
      return km;
    };
    kh.subtract = function (km, kl, kk) {
      km[0] = kl[0] - kk[0];
      km[1] = kl[1] - kk[1];
      km[2] = kl[2] - kk[2];
      return km;
    };
    kh.sub = kh.subtract;
    kh.multiply = function (km, kl, kk) {
      km[0] = kl[0] * kk[0];
      km[1] = kl[1] * kk[1];
      km[2] = kl[2] * kk[2];
      return km;
    };
    kh.mul = kh.multiply;
    kh.divide = function (km, kl, kk) {
      km[0] = kl[0] / kk[0];
      km[1] = kl[1] / kk[1];
      km[2] = kl[2] / kk[2];
      return km;
    };
    kh.div = kh.divide;
    kh.min = function (km, kl, kk) {
      km[0] = Math.min(kl[0], kk[0]);
      km[1] = Math.min(kl[1], kk[1]);
      km[2] = Math.min(kl[2], kk[2]);
      return km;
    };
    kh.max = function (km, kl, kk) {
      km[0] = Math.max(kl[0], kk[0]);
      km[1] = Math.max(kl[1], kk[1]);
      km[2] = Math.max(kl[2], kk[2]);
      return km;
    };
    kh.scale = function (km, kl, kk) {
      km[0] = kl[0] * kk;
      km[1] = kl[1] * kk;
      km[2] = kl[2] * kk;
      return km;
    };
    kh.scaleAndAdd = function (km, kl, kk, kn) {
      km[0] = kl[0] + kk[0] * kn;
      km[1] = kl[1] + kk[1] * kn;
      km[2] = kl[2] + kk[2] * kn;
      return km;
    };
    kh.distance = function (km, kl) {
      var kk = kl[0] - km[0];
      var ko = kl[1] - km[1];
      var kn = kl[2] - km[2];
      return Math.sqrt(kk * kk + ko * ko + kn * kn);
    };
    kh.dist = kh.distance;
    kh.squaredDistance = function (km, kl) {
      var kk = kl[0] - km[0];
      var ko = kl[1] - km[1];
      var kn = kl[2] - km[2];
      return kk * kk + ko * ko + kn * kn;
    };
    kh.sqrDist = kh.squaredDistance;
    kh.length = function (kl) {
      var kk = kl[0];
      var kn = kl[1];
      var km = kl[2];
      return Math.sqrt(kk * kk + kn * kn + km * km);
    };
    kh.len = kh.length;
    kh.squaredLength = function (kl) {
      var kk = kl[0];
      var kn = kl[1];
      var km = kl[2];
      return kk * kk + kn * kn + km * km;
    };
    kh.sqrLen = kh.squaredLength;
    kh.negate = function (kl, kk) {
      kl[0] = -kk[0];
      kl[1] = -kk[1];
      kl[2] = -kk[2];
      return kl;
    };
    kh.normalize = function (kn, km) {
      var kl = km[0];
      var kp = km[1];
      var ko = km[2];
      var kk = kl * kl + kp * kp + ko * ko;
      if (kk > 0) {
        kk = 1 / Math.sqrt(kk);
        kn[0] = km[0] * kk;
        kn[1] = km[1] * kk;
        kn[2] = km[2] * kk;
      }
      return kn;
    };
    kh.dot = function (kl, kk) {
      return kl[0] * kk[0] + kl[1] * kk[1] + kl[2] * kk[2];
    };
    kh.cross = function (kl, kq, kp) {
      var kk = kq[0];
      var ks = kq[1];
      var kr = kq[2];
      var ko = kp[0];
      var kn = kp[1];
      var km = kp[2];
      kl[0] = ks * km - kr * kn;
      kl[1] = kr * ko - kk * km;
      kl[2] = kk * kn - ks * ko;
      return kl;
    };
    kh.lerp = function (km, kl, kk, kn) {
      var kq = kl[0];
      var kp = kl[1];
      var ko = kl[2];
      km[0] = kq + kn * (kk[0] - kq);
      km[1] = kp + kn * (kk[1] - kp);
      km[2] = ko + kn * (kk[2] - ko);
      return km;
    };
    kh.random = function (kk, ko) {
      ko = ko || 1;
      var km = kd() * 2 * Math.PI;
      var kn = kd() * 2 - 1;
      var kl = Math.sqrt(1 - kn * kn) * ko;
      kk[0] = Math.cos(km) * kl;
      kk[1] = Math.sin(km) * kl;
      kk[2] = kn * ko;
      return kk;
    };
    kh.transformMat4 = function (kn, km, kl) {
      var kk = km[0];
      var kp = km[1];
      var ko = km[2];
      kn[0] = kl[0] * kk + kl[4] * kp + kl[8] * ko + kl[12];
      kn[1] = kl[1] * kk + kl[5] * kp + kl[9] * ko + kl[13];
      kn[2] = kl[2] * kk + kl[6] * kp + kl[10] * ko + kl[14];
      return kn;
    };
    kh.transformMat3 = function (kn, km, kl) {
      var kk = km[0];
      var kp = km[1];
      var ko = km[2];
      kn[0] = kk * kl[0] + kp * kl[3] + ko * kl[6];
      kn[1] = kk * kl[1] + kp * kl[4] + ko * kl[7];
      kn[2] = kk * kl[2] + kp * kl[5] + ko * kl[8];
      return kn;
    };
    kh.transformQuat = function (kq, kw, kk) {
      var kx = kw[0];
      var kv = kw[1];
      var ku = kw[2];
      var ks = kk[0];
      var kr = kk[1];
      var kp = kk[2];
      var kt = kk[3];
      var kn = kt * kx + kr * ku - kp * kv;
      var km = kt * kv + kp * kx - ks * ku;
      var kl = kt * ku + ks * kv - kr * kx;
      var ko = -ks * kx - kr * kv - kp * ku;
      kq[0] = kn * kt + ko * -ks + km * -kp - kl * -kr;
      kq[1] = km * kt + ko * -kr + kl * -ks - kn * -kp;
      kq[2] = kl * kt + ko * -kp + kn * -kr - km * -ks;
      return kq;
    };
    kh.rotateX = function (km, kl, kk, kp) {
      var ko = [];
      var kn = [];
      ko[0] = kl[0] - kk[0];
      ko[1] = kl[1] - kk[1];
      ko[2] = kl[2] - kk[2];
      kn[0] = ko[0];
      kn[1] = ko[1] * Math.cos(kp) - ko[2] * Math.sin(kp);
      kn[2] = ko[1] * Math.sin(kp) + ko[2] * Math.cos(kp);
      km[0] = kn[0] + kk[0];
      km[1] = kn[1] + kk[1];
      km[2] = kn[2] + kk[2];
      return km;
    };
    kh.rotateY = function (km, kl, kk, kp) {
      var ko = [];
      var kn = [];
      ko[0] = kl[0] - kk[0];
      ko[1] = kl[1] - kk[1];
      ko[2] = kl[2] - kk[2];
      kn[0] = ko[2] * Math.sin(kp) + ko[0] * Math.cos(kp);
      kn[1] = ko[1];
      kn[2] = ko[2] * Math.cos(kp) - ko[0] * Math.sin(kp);
      km[0] = kn[0] + kk[0];
      km[1] = kn[1] + kk[1];
      km[2] = kn[2] + kk[2];
      return km;
    };
    kh.rotateZ = function (km, kl, kk, kp) {
      var ko = [];
      var kn = [];
      ko[0] = kl[0] - kk[0];
      ko[1] = kl[1] - kk[1];
      ko[2] = kl[2] - kk[2];
      kn[0] = ko[0] * Math.cos(kp) - ko[1] * Math.sin(kp);
      kn[1] = ko[0] * Math.sin(kp) + ko[1] * Math.cos(kp);
      kn[2] = ko[2];
      km[0] = kn[0] + kk[0];
      km[1] = kn[1] + kk[1];
      km[2] = kn[2] + kk[2];
      return km;
    };
    kh.forEach = function () {
      var kk = kh.create();
      return function (kn, kr, ks, kq, kp, kl) {
        var ko;
        var km;
        if (!kr) {
          kr = 3;
        }
        if (!ks) {
          ks = 0;
        }
        if (kq) {
          km = Math.min(kq * kr + ks, kn.length);
        } else {
          km = kn.length;
        }
        for (ko = ks; ko < km; ko += kr) {
          kk[0] = kn[ko];
          kk[1] = kn[ko + 1];
          kk[2] = kn[ko + 2];
          kp(kk, kk, kl);
          kn[ko] = kk[0];
          kn[ko + 1] = kk[1];
          kn[ko + 2] = kk[2];
        }
        return kn;
      };
    }();
    kh.str = function (kk) {
      return "vec3(" + kk[0] + ", " + kk[1] + ", " + kk[2] + ")";
    };
    kf.vec3 = kh;
    var kg = {};
    kg.create = function (kl) {
      kl = kl || i;
      var kk = new kl(4);
      kk[0] = 0;
      kk[1] = 0;
      kk[2] = 0;
      kk[3] = 0;
      return kk;
    };
    kg.clone = function (kk, km) {
      km = km || i;
      var kl = new km(4);
      kl[0] = kk[0];
      kl[1] = kk[1];
      kl[2] = kk[2];
      kl[3] = kk[3];
      return kl;
    };
    kg.fromValues = function (kk, kp, kn, kl, ko) {
      ko = ko || i;
      var km = new ko(4);
      km[0] = kk;
      km[1] = kp;
      km[2] = kn;
      km[3] = kl;
      return km;
    };
    kg.copy = function (kl, kk) {
      kl[0] = kk[0];
      kl[1] = kk[1];
      kl[2] = kk[2];
      kl[3] = kk[3];
      return kl;
    };
    kg.set = function (km, kk, ko, kn, kl) {
      km[0] = kk;
      km[1] = ko;
      km[2] = kn;
      km[3] = kl;
      return km;
    };
    kg.add = function (km, kl, kk) {
      km[0] = kl[0] + kk[0];
      km[1] = kl[1] + kk[1];
      km[2] = kl[2] + kk[2];
      km[3] = kl[3] + kk[3];
      return km;
    };
    kg.subtract = function (km, kl, kk) {
      km[0] = kl[0] - kk[0];
      km[1] = kl[1] - kk[1];
      km[2] = kl[2] - kk[2];
      km[3] = kl[3] - kk[3];
      return km;
    };
    kg.sub = kg.subtract;
    kg.multiply = function (km, kl, kk) {
      km[0] = kl[0] * kk[0];
      km[1] = kl[1] * kk[1];
      km[2] = kl[2] * kk[2];
      km[3] = kl[3] * kk[3];
      return km;
    };
    kg.mul = kg.multiply;
    kg.divide = function (km, kl, kk) {
      km[0] = kl[0] / kk[0];
      km[1] = kl[1] / kk[1];
      km[2] = kl[2] / kk[2];
      km[3] = kl[3] / kk[3];
      return km;
    };
    kg.div = kg.divide;
    kg.min = function (km, kl, kk) {
      km[0] = Math.min(kl[0], kk[0]);
      km[1] = Math.min(kl[1], kk[1]);
      km[2] = Math.min(kl[2], kk[2]);
      km[3] = Math.min(kl[3], kk[3]);
      return km;
    };
    kg.max = function (km, kl, kk) {
      km[0] = Math.max(kl[0], kk[0]);
      km[1] = Math.max(kl[1], kk[1]);
      km[2] = Math.max(kl[2], kk[2]);
      km[3] = Math.max(kl[3], kk[3]);
      return km;
    };
    kg.scale = function (km, kl, kk) {
      km[0] = kl[0] * kk;
      km[1] = kl[1] * kk;
      km[2] = kl[2] * kk;
      km[3] = kl[3] * kk;
      return km;
    };
    kg.scaleAndAdd = function (km, kl, kk, kn) {
      km[0] = kl[0] + kk[0] * kn;
      km[1] = kl[1] + kk[1] * kn;
      km[2] = kl[2] + kk[2] * kn;
      km[3] = kl[3] + kk[3] * kn;
      return km;
    };
    kg.distance = function (kn, kl) {
      var kk = kl[0] - kn[0];
      var kp = kl[1] - kn[1];
      var ko = kl[2] - kn[2];
      var km = kl[3] - kn[3];
      return Math.sqrt(kk * kk + kp * kp + ko * ko + km * km);
    };
    kg.dist = kg.distance;
    kg.squaredDistance = function (kn, kl) {
      var kk = kl[0] - kn[0];
      var kp = kl[1] - kn[1];
      var ko = kl[2] - kn[2];
      var km = kl[3] - kn[3];
      return kk * kk + kp * kp + ko * ko + km * km;
    };
    kg.sqrDist = kg.squaredDistance;
    kg.length = function (km) {
      var kk = km[0];
      var ko = km[1];
      var kn = km[2];
      var kl = km[3];
      return Math.sqrt(kk * kk + ko * ko + kn * kn + kl * kl);
    };
    kg.len = kg.length;
    kg.squaredLength = function (km) {
      var kk = km[0];
      var ko = km[1];
      var kn = km[2];
      var kl = km[3];
      return kk * kk + ko * ko + kn * kn + kl * kl;
    };
    kg.sqrLen = kg.squaredLength;
    kg.negate = function (kl, kk) {
      kl[0] = -kk[0];
      kl[1] = -kk[1];
      kl[2] = -kk[2];
      kl[3] = -kk[3];
      return kl;
    };
    kg.normalize = function (ko, kn) {
      var kl = kn[0];
      var kq = kn[1];
      var kp = kn[2];
      var km = kn[3];
      var kk = kl * kl + kq * kq + kp * kp + km * km;
      if (kk > 0) {
        kk = 1 / Math.sqrt(kk);
        ko[0] = kn[0] * kk;
        ko[1] = kn[1] * kk;
        ko[2] = kn[2] * kk;
        ko[3] = kn[3] * kk;
      }
      return ko;
    };
    kg.dot = function (kl, kk) {
      return kl[0] * kk[0] + kl[1] * kk[1] + kl[2] * kk[2] + kl[3] * kk[3];
    };
    kg.lerp = function (km, kl, kk, kn) {
      var kq = kl[0];
      var kp = kl[1];
      var ko = kl[2];
      var kr = kl[3];
      km[0] = kq + kn * (kk[0] - kq);
      km[1] = kp + kn * (kk[1] - kp);
      km[2] = ko + kn * (kk[2] - ko);
      km[3] = kr + kn * (kk[3] - kr);
      return km;
    };
    kg.random = function (kk, kl) {
      kl = kl || 1;
      kk[0] = kd();
      kk[1] = kd();
      kk[2] = kd();
      kk[3] = kd();
      kg.normalize(kk, kk);
      kg.scale(kk, kk, kl);
      return kk;
    };
    kg.transformMat4 = function (ko, kn, kl) {
      var kk = kn[0];
      var kq = kn[1];
      var kp = kn[2];
      var km = kn[3];
      ko[0] = kl[0] * kk + kl[4] * kq + kl[8] * kp + kl[12] * km;
      ko[1] = kl[1] * kk + kl[5] * kq + kl[9] * kp + kl[13] * km;
      ko[2] = kl[2] * kk + kl[6] * kq + kl[10] * kp + kl[14] * km;
      ko[3] = kl[3] * kk + kl[7] * kq + kl[11] * kp + kl[15] * km;
      return ko;
    };
    kg.transformQuat = function (kq, kw, kk) {
      var kx = kw[0];
      var kv = kw[1];
      var ku = kw[2];
      var ks = kk[0];
      var kr = kk[1];
      var kp = kk[2];
      var kt = kk[3];
      var kn = kt * kx + kr * ku - kp * kv;
      var km = kt * kv + kp * kx - ks * ku;
      var kl = kt * ku + ks * kv - kr * kx;
      var ko = -ks * kx - kr * kv - kp * ku;
      kq[0] = kn * kt + ko * -ks + km * -kp - kl * -kr;
      kq[1] = km * kt + ko * -kr + kl * -ks - kn * -kp;
      kq[2] = kl * kt + ko * -kp + kn * -kr - km * -ks;
      return kq;
    };
    kg.forEach = function () {
      var kk = kg.create();
      return function (kn, kr, ks, kq, kp, kl) {
        var ko;
        var km;
        if (!kr) {
          kr = 4;
        }
        if (!ks) {
          ks = 0;
        }
        if (kq) {
          km = Math.min(kq * kr + ks, kn.length);
        } else {
          km = kn.length;
        }
        for (ko = ks; ko < km; ko += kr) {
          kk[0] = kn[ko];
          kk[1] = kn[ko + 1];
          kk[2] = kn[ko + 2];
          kk[3] = kn[ko + 3];
          kp(kk, kk, kl);
          kn[ko] = kk[0];
          kn[ko + 1] = kk[1];
          kn[ko + 2] = kk[2];
          kn[ko + 3] = kk[3];
        }
        return kn;
      };
    }();
    kg.str = function (kk) {
      return "vec4(" + kk[0] + ", " + kk[1] + ", " + kk[2] + ", " + kk[3] + ")";
    };
    kf.vec4 = kg;
    var kc = {};
    kc.create = function (kl) {
      kl = kl || i;
      var kk = new kl(4);
      kk[0] = 1;
      kk[1] = 0;
      kk[2] = 0;
      kk[3] = 1;
      return kk;
    };
    kc.clone = function (kk, km) {
      km = km || i;
      var kl = new km(4);
      kl[0] = kk[0];
      kl[1] = kk[1];
      kl[2] = kk[2];
      kl[3] = kk[3];
      return kl;
    };
    kc.copy = function (kl, kk) {
      kl[0] = kk[0];
      kl[1] = kk[1];
      kl[2] = kk[2];
      kl[3] = kk[3];
      return kl;
    };
    kc.identity = function (kk) {
      kk[0] = 1;
      kk[1] = 0;
      kk[2] = 0;
      kk[3] = 1;
      return kk;
    };
    kc.transpose = function (km, kl) {
      if (km === kl) {
        var kk = kl[1];
        km[1] = kl[2];
        km[2] = kk;
      } else {
        km[0] = kl[0];
        km[1] = kl[2];
        km[2] = kl[1];
        km[3] = kl[3];
      }
      return km;
    };
    kc.invert = function (ko, km) {
      var kn = km[0];
      var kl = km[1];
      var kk = km[2];
      var kq = km[3];
      var kp = kn * kq - kk * kl;
      if (!kp) {
        return null;
      }
      kp = 1 / kp;
      ko[0] = kq * kp;
      ko[1] = -kl * kp;
      ko[2] = -kk * kp;
      ko[3] = kn * kp;
      return ko;
    };
    kc.adjoint = function (km, kk) {
      var kl = kk[0];
      km[0] = kk[3];
      km[1] = -kk[1];
      km[2] = -kk[2];
      km[3] = kl;
      return km;
    };
    kc.determinant = function (kk) {
      return kk[0] * kk[3] - kk[2] * kk[1];
    };
    kc.multiply = function (ko, kt, kr) {
      var kn = kt[0];
      var km = kt[1];
      var kl = kt[2];
      var kk = kt[3];
      var ku = kr[0];
      var ks = kr[1];
      var kq = kr[2];
      var kp = kr[3];
      ko[0] = kn * ku + kl * ks;
      ko[1] = km * ku + kk * ks;
      ko[2] = kn * kq + kl * kp;
      ko[3] = km * kq + kk * kp;
      return ko;
    };
    kc.mul = kc.multiply;
    kc.rotate = function (ko, kr, kq) {
      var kn = kr[0];
      var km = kr[1];
      var kl = kr[2];
      var kk = kr[3];
      var ks = Math.sin(kq);
      var kp = Math.cos(kq);
      ko[0] = kn * kp + kl * ks;
      ko[1] = km * kp + kk * ks;
      ko[2] = kn * -ks + kl * kp;
      ko[3] = km * -ks + kk * kp;
      return ko;
    };
    kc.scale = function (ko, kp, kr) {
      var kn = kp[0];
      var km = kp[1];
      var kl = kp[2];
      var kk = kp[3];
      var ks = kr[0];
      var kq = kr[1];
      ko[0] = kn * ks;
      ko[1] = km * ks;
      ko[2] = kl * kq;
      ko[3] = kk * kq;
      return ko;
    };
    kc.str = function (kk) {
      return "mat2(" + kk[0] + ", " + kk[1] + ", " + kk[2] + ", " + kk[3] + ")";
    };
    kc.frob = function (kk) {
      return Math.sqrt(Math.pow(kk[0], 2) + Math.pow(kk[1], 2) + Math.pow(kk[2], 2) + Math.pow(kk[3], 2));
    };
    kc.LDU = function (kk, kn, km, kl) {
      kk[2] = kl[2] / kl[0];
      km[0] = kl[0];
      km[1] = kl[1];
      km[3] = kl[3] - kk[2] * km[1];
      return [kk, kn, km];
    };
    kf.mat2 = kc;
    var e = {};
    e.create = function (kl) {
      kl = kl || i;
      var kk = new kl(16);
      kk[0] = 1;
      kk[1] = 0;
      kk[2] = 0;
      kk[3] = 0;
      kk[4] = 0;
      kk[5] = 1;
      kk[6] = 0;
      kk[7] = 0;
      kk[8] = 0;
      kk[9] = 0;
      kk[10] = 1;
      kk[11] = 0;
      kk[12] = 0;
      kk[13] = 0;
      kk[14] = 0;
      kk[15] = 1;
      return kk;
    };
    e.clone = function (kk) {
      var kl = new i(16);
      kl[0] = kk[0];
      kl[1] = kk[1];
      kl[2] = kk[2];
      kl[3] = kk[3];
      kl[4] = kk[4];
      kl[5] = kk[5];
      kl[6] = kk[6];
      kl[7] = kk[7];
      kl[8] = kk[8];
      kl[9] = kk[9];
      kl[10] = kk[10];
      kl[11] = kk[11];
      kl[12] = kk[12];
      kl[13] = kk[13];
      kl[14] = kk[14];
      kl[15] = kk[15];
      return kl;
    };
    e.copy = function (kl, kk) {
      kl[0] = kk[0];
      kl[1] = kk[1];
      kl[2] = kk[2];
      kl[3] = kk[3];
      kl[4] = kk[4];
      kl[5] = kk[5];
      kl[6] = kk[6];
      kl[7] = kk[7];
      kl[8] = kk[8];
      kl[9] = kk[9];
      kl[10] = kk[10];
      kl[11] = kk[11];
      kl[12] = kk[12];
      kl[13] = kk[13];
      kl[14] = kk[14];
      kl[15] = kk[15];
      return kl;
    };
    e.identity = function (kk) {
      kk[0] = 1;
      kk[1] = 0;
      kk[2] = 0;
      kk[3] = 0;
      kk[4] = 0;
      kk[5] = 1;
      kk[6] = 0;
      kk[7] = 0;
      kk[8] = 0;
      kk[9] = 0;
      kk[10] = 1;
      kk[11] = 0;
      kk[12] = 0;
      kk[13] = 0;
      kk[14] = 0;
      kk[15] = 1;
      return kk;
    };
    e.transpose = function (kn, km) {
      if (kn === km) {
        var kr = km[1];
        var kp = km[2];
        var ko = km[3];
        var kk = km[6];
        var kq = km[7];
        var kl = km[11];
        kn[1] = km[4];
        kn[2] = km[8];
        kn[3] = km[12];
        kn[4] = kr;
        kn[6] = km[9];
        kn[7] = km[13];
        kn[8] = kp;
        kn[9] = kk;
        kn[11] = km[14];
        kn[12] = ko;
        kn[13] = kq;
        kn[14] = kl;
      } else {
        kn[0] = km[0];
        kn[1] = km[4];
        kn[2] = km[8];
        kn[3] = km[12];
        kn[4] = km[1];
        kn[5] = km[5];
        kn[6] = km[9];
        kn[7] = km[13];
        kn[8] = km[2];
        kn[9] = km[6];
        kn[10] = km[10];
        kn[11] = km[14];
        kn[12] = km[3];
        kn[13] = km[7];
        kn[14] = km[11];
        kn[15] = km[15];
      }
      return kn;
    };
    e.invert = function (kD, kI) {
      var kM = kI[0];
      var kK = kI[1];
      var kJ = kI[2];
      var kG = kI[3];
      var ko = kI[4];
      var kn = kI[5];
      var km = kI[6];
      var kl = kI[7];
      var kC = kI[8];
      var kB = kI[9];
      var kA = kI[10];
      var kz = kI[11];
      var kO = kI[12];
      var kN = kI[13];
      var kL = kI[14];
      var kH = kI[15];
      var ky = kM * kn - kK * ko;
      var kx = kM * km - kJ * ko;
      var kw = kM * kl - kG * ko;
      var kv = kK * km - kJ * kn;
      var ku = kK * kl - kG * kn;
      var kt = kJ * kl - kG * km;
      var ks = kC * kN - kB * kO;
      var kr = kC * kL - kA * kO;
      var kq = kC * kH - kz * kO;
      var kp = kB * kL - kA * kN;
      var kF = kB * kH - kz * kN;
      var kE = kA * kH - kz * kL;
      var kk = ky * kE - kx * kF + kw * kp + kv * kq - ku * kr + kt * ks;
      if (!kk) {
        return null;
      }
      kk = 1 / kk;
      kD[0] = (kn * kE - km * kF + kl * kp) * kk;
      kD[1] = (kJ * kF - kK * kE - kG * kp) * kk;
      kD[2] = (kN * kt - kL * ku + kH * kv) * kk;
      kD[3] = (kA * ku - kB * kt - kz * kv) * kk;
      kD[4] = (km * kq - ko * kE - kl * kr) * kk;
      kD[5] = (kM * kE - kJ * kq + kG * kr) * kk;
      kD[6] = (kL * kw - kO * kt - kH * kx) * kk;
      kD[7] = (kC * kt - kA * kw + kz * kx) * kk;
      kD[8] = (ko * kF - kn * kq + kl * ks) * kk;
      kD[9] = (kK * kq - kM * kF - kG * ks) * kk;
      kD[10] = (kO * ku - kN * kw + kH * ky) * kk;
      kD[11] = (kB * kw - kC * ku - kz * ky) * kk;
      kD[12] = (kn * kr - ko * kp - km * ks) * kk;
      kD[13] = (kM * kp - kK * kr + kJ * ks) * kk;
      kD[14] = (kN * kx - kO * kv - kL * ky) * kk;
      kD[15] = (kC * kv - kB * kx + kA * ky) * kk;
      return kD;
    };
    e.adjoint = function (ks, kv) {
      var kz = kv[0];
      var kx = kv[1];
      var kw = kv[2];
      var kt = kv[3];
      var kn = kv[4];
      var km = kv[5];
      var kl = kv[6];
      var kk = kv[7];
      var kr = kv[8];
      var kq = kv[9];
      var kp = kv[10];
      var ko = kv[11];
      var kB = kv[12];
      var kA = kv[13];
      var ky = kv[14];
      var ku = kv[15];
      ks[0] = km * (kp * ku - ko * ky) - kq * (kl * ku - kk * ky) + kA * (kl * ko - kk * kp);
      ks[1] = -(kx * (kp * ku - ko * ky) - kq * (kw * ku - kt * ky) + kA * (kw * ko - kt * kp));
      ks[2] = kx * (kl * ku - kk * ky) - km * (kw * ku - kt * ky) + kA * (kw * kk - kt * kl);
      ks[3] = -(kx * (kl * ko - kk * kp) - km * (kw * ko - kt * kp) + kq * (kw * kk - kt * kl));
      ks[4] = -(kn * (kp * ku - ko * ky) - kr * (kl * ku - kk * ky) + kB * (kl * ko - kk * kp));
      ks[5] = kz * (kp * ku - ko * ky) - kr * (kw * ku - kt * ky) + kB * (kw * ko - kt * kp);
      ks[6] = -(kz * (kl * ku - kk * ky) - kn * (kw * ku - kt * ky) + kB * (kw * kk - kt * kl));
      ks[7] = kz * (kl * ko - kk * kp) - kn * (kw * ko - kt * kp) + kr * (kw * kk - kt * kl);
      ks[8] = kn * (kq * ku - ko * kA) - kr * (km * ku - kk * kA) + kB * (km * ko - kk * kq);
      ks[9] = -(kz * (kq * ku - ko * kA) - kr * (kx * ku - kt * kA) + kB * (kx * ko - kt * kq));
      ks[10] = kz * (km * ku - kk * kA) - kn * (kx * ku - kt * kA) + kB * (kx * kk - kt * km);
      ks[11] = -(kz * (km * ko - kk * kq) - kn * (kx * ko - kt * kq) + kr * (kx * kk - kt * km));
      ks[12] = -(kn * (kq * ky - kp * kA) - kr * (km * ky - kl * kA) + kB * (km * kp - kl * kq));
      ks[13] = kz * (kq * ky - kp * kA) - kr * (kx * ky - kw * kA) + kB * (kx * kp - kw * kq);
      ks[14] = -(kz * (km * ky - kl * kA) - kn * (kx * ky - kw * kA) + kB * (kx * kl - kw * km));
      ks[15] = kz * (km * kp - kl * kq) - kn * (kx * kp - kw * kq) + kr * (kx * kl - kw * km);
      return ks;
    };
    e.determinant = function (kF) {
      var kK = kF[0];
      var kI = kF[1];
      var kG = kF[2];
      var kE = kF[3];
      var kn = kF[4];
      var km = kF[5];
      var kl = kF[6];
      var kk = kF[7];
      var kB = kF[8];
      var kA = kF[9];
      var kz = kF[10];
      var ky = kF[11];
      var kM = kF[12];
      var kL = kF[13];
      var kJ = kF[14];
      var kH = kF[15];
      var kx = kK * km - kI * kn;
      var kw = kK * kl - kG * kn;
      var kv = kK * kk - kE * kn;
      var ku = kI * kl - kG * km;
      var kt = kI * kk - kE * km;
      var ks = kG * kk - kE * kl;
      var kr = kB * kL - kA * kM;
      var kq = kB * kJ - kz * kM;
      var kp = kB * kH - ky * kM;
      var ko = kA * kJ - kz * kL;
      var kD = kA * kH - ky * kL;
      var kC = kz * kH - ky * kJ;
      return kx * kC - kw * kD + kv * ko + ku * kp - kt * kq + ks * kr;
    };
    e.multiply = function (kw, kA, kx) {
      var kE = kA[0];
      var kD = kA[1];
      var kB = kA[2];
      var ky = kA[3];
      var kq = kA[4];
      var ko = kA[5];
      var km = kA[6];
      var kk = kA[7];
      var kv = kA[8];
      var ku = kA[9];
      var kt = kA[10];
      var ks = kA[11];
      var kG = kA[12];
      var kF = kA[13];
      var kC = kA[14];
      var kz = kA[15];
      var kr = kx[0];
      var kp = kx[1];
      var kn = kx[2];
      var kl = kx[3];
      kw[0] = kr * kE + kp * kq + kn * kv + kl * kG;
      kw[1] = kr * kD + kp * ko + kn * ku + kl * kF;
      kw[2] = kr * kB + kp * km + kn * kt + kl * kC;
      kw[3] = kr * ky + kp * kk + kn * ks + kl * kz;
      kr = kx[4];
      kp = kx[5];
      kn = kx[6];
      kl = kx[7];
      kw[4] = kr * kE + kp * kq + kn * kv + kl * kG;
      kw[5] = kr * kD + kp * ko + kn * ku + kl * kF;
      kw[6] = kr * kB + kp * km + kn * kt + kl * kC;
      kw[7] = kr * ky + kp * kk + kn * ks + kl * kz;
      kr = kx[8];
      kp = kx[9];
      kn = kx[10];
      kl = kx[11];
      kw[8] = kr * kE + kp * kq + kn * kv + kl * kG;
      kw[9] = kr * kD + kp * ko + kn * ku + kl * kF;
      kw[10] = kr * kB + kp * km + kn * kt + kl * kC;
      kw[11] = kr * ky + kp * kk + kn * ks + kl * kz;
      kr = kx[12];
      kp = kx[13];
      kn = kx[14];
      kl = kx[15];
      kw[12] = kr * kE + kp * kq + kn * kv + kl * kG;
      kw[13] = kr * kD + kp * ko + kn * ku + kl * kF;
      kw[14] = kr * kB + kp * km + kn * kt + kl * kC;
      kw[15] = kr * ky + kp * kk + kn * ks + kl * kz;
      return kw;
    };
    e.mul = e.multiply;
    e.translate = function (kw, ky, kr) {
      var kq = kr[0];
      var kp = kr[1];
      var ko = kr[2];
      var kB;
      var kA;
      var kz;
      var kx;
      var kn;
      var km;
      var kl;
      var kk;
      var kv;
      var ku;
      var kt;
      var ks;
      if (ky === kw) {
        kw[12] = ky[0] * kq + ky[4] * kp + ky[8] * ko + ky[12];
        kw[13] = ky[1] * kq + ky[5] * kp + ky[9] * ko + ky[13];
        kw[14] = ky[2] * kq + ky[6] * kp + ky[10] * ko + ky[14];
        kw[15] = ky[3] * kq + ky[7] * kp + ky[11] * ko + ky[15];
      } else {
        kB = ky[0];
        kA = ky[1];
        kz = ky[2];
        kx = ky[3];
        kn = ky[4];
        km = ky[5];
        kl = ky[6];
        kk = ky[7];
        kv = ky[8];
        ku = ky[9];
        kt = ky[10];
        ks = ky[11];
        kw[0] = kB;
        kw[1] = kA;
        kw[2] = kz;
        kw[3] = kx;
        kw[4] = kn;
        kw[5] = km;
        kw[6] = kl;
        kw[7] = kk;
        kw[8] = kv;
        kw[9] = ku;
        kw[10] = kt;
        kw[11] = ks;
        kw[12] = kB * kq + kn * kp + kv * ko + ky[12];
        kw[13] = kA * kq + km * kp + ku * ko + ky[13];
        kw[14] = kz * kq + kl * kp + kt * ko + ky[14];
        kw[15] = kx * kq + kk * kp + ks * ko + ky[15];
      }
      return kw;
    };
    e.scale = function (kn, kl, km) {
      var kk = km[0];
      var kp = km[1];
      var ko = km[2];
      kn[0] = kl[0] * kk;
      kn[1] = kl[1] * kk;
      kn[2] = kl[2] * kk;
      kn[3] = kl[3] * kk;
      kn[4] = kl[4] * kp;
      kn[5] = kl[5] * kp;
      kn[6] = kl[6] * kp;
      kn[7] = kl[7] * kp;
      kn[8] = kl[8] * ko;
      kn[9] = kl[9] * ko;
      kn[10] = kl[10] * ko;
      kn[11] = kl[11] * ko;
      kn[12] = kl[12];
      kn[13] = kl[13];
      kn[14] = kl[14];
      kn[15] = kl[15];
      return kn;
    };
    e.rotate = function (kE, kL, kN, kk) {
      var ku = kk[0];
      var kt = kk[1];
      var ks = kk[2];
      var kF = Math.sqrt(ku * ku + kt * kt + ks * ks);
      var kz;
      var kJ;
      var ky;
      var kP;
      var kO;
      var kM;
      var kK;
      var kr;
      var kq;
      var kp;
      var ko;
      var kD;
      var kC;
      var kB;
      var kA;
      var kx;
      var kw;
      var kv;
      var kI;
      var kH;
      var kG;
      var kn;
      var km;
      var kl;
      if (Math.abs(kF) < kj) {
        return null;
      }
      kF = 1 / kF;
      ku *= kF;
      kt *= kF;
      ks *= kF;
      kz = Math.sin(kN);
      kJ = Math.cos(kN);
      ky = 1 - kJ;
      kP = kL[0];
      kO = kL[1];
      kM = kL[2];
      kK = kL[3];
      kr = kL[4];
      kq = kL[5];
      kp = kL[6];
      ko = kL[7];
      kD = kL[8];
      kC = kL[9];
      kB = kL[10];
      kA = kL[11];
      kx = ku * ku * ky + kJ;
      kw = kt * ku * ky + ks * kz;
      kv = ks * ku * ky - kt * kz;
      kI = ku * kt * ky - ks * kz;
      kH = kt * kt * ky + kJ;
      kG = ks * kt * ky + ku * kz;
      kn = ku * ks * ky + kt * kz;
      km = kt * ks * ky - ku * kz;
      kl = ks * ks * ky + kJ;
      kE[0] = kP * kx + kr * kw + kD * kv;
      kE[1] = kO * kx + kq * kw + kC * kv;
      kE[2] = kM * kx + kp * kw + kB * kv;
      kE[3] = kK * kx + ko * kw + kA * kv;
      kE[4] = kP * kI + kr * kH + kD * kG;
      kE[5] = kO * kI + kq * kH + kC * kG;
      kE[6] = kM * kI + kp * kH + kB * kG;
      kE[7] = kK * kI + ko * kH + kA * kG;
      kE[8] = kP * kn + kr * km + kD * kl;
      kE[9] = kO * kn + kq * km + kC * kl;
      kE[10] = kM * kn + kp * km + kB * kl;
      kE[11] = kK * kn + ko * km + kA * kl;
      if (kL !== kE) {
        kE[12] = kL[12];
        kE[13] = kL[13];
        kE[14] = kL[14];
        kE[15] = kL[15];
      }
      return kE;
    };
    e.rotateX = function (kk, kr, kq) {
      var kw = Math.sin(kq);
      var kp = Math.cos(kq);
      var kv = kr[4];
      var ku = kr[5];
      var kt = kr[6];
      var ks = kr[7];
      var ko = kr[8];
      var kn = kr[9];
      var km = kr[10];
      var kl = kr[11];
      if (kr !== kk) {
        kk[0] = kr[0];
        kk[1] = kr[1];
        kk[2] = kr[2];
        kk[3] = kr[3];
        kk[12] = kr[12];
        kk[13] = kr[13];
        kk[14] = kr[14];
        kk[15] = kr[15];
      }
      kk[4] = kv * kp + ko * kw;
      kk[5] = ku * kp + kn * kw;
      kk[6] = kt * kp + km * kw;
      kk[7] = ks * kp + kl * kw;
      kk[8] = ko * kp - kv * kw;
      kk[9] = kn * kp - ku * kw;
      kk[10] = km * kp - kt * kw;
      kk[11] = kl * kp - ks * kw;
      return kk;
    };
    e.rotateY = function (ko, kv, ku) {
      var kw = Math.sin(ku);
      var kt = Math.cos(ku);
      var kn = kv[0];
      var km = kv[1];
      var kl = kv[2];
      var kk = kv[3];
      var ks = kv[8];
      var kr = kv[9];
      var kq = kv[10];
      var kp = kv[11];
      if (kv !== ko) {
        ko[4] = kv[4];
        ko[5] = kv[5];
        ko[6] = kv[6];
        ko[7] = kv[7];
        ko[12] = kv[12];
        ko[13] = kv[13];
        ko[14] = kv[14];
        ko[15] = kv[15];
      }
      ko[0] = kn * kt - ks * kw;
      ko[1] = km * kt - kr * kw;
      ko[2] = kl * kt - kq * kw;
      ko[3] = kk * kt - kp * kw;
      ko[8] = kn * kw + ks * kt;
      ko[9] = km * kw + kr * kt;
      ko[10] = kl * kw + kq * kt;
      ko[11] = kk * kw + kp * kt;
      return ko;
    };
    e.rotateZ = function (ko, kr, kq) {
      var kw = Math.sin(kq);
      var kp = Math.cos(kq);
      var kn = kr[0];
      var km = kr[1];
      var kl = kr[2];
      var kk = kr[3];
      var kv = kr[4];
      var ku = kr[5];
      var kt = kr[6];
      var ks = kr[7];
      if (kr !== ko) {
        ko[8] = kr[8];
        ko[9] = kr[9];
        ko[10] = kr[10];
        ko[11] = kr[11];
        ko[12] = kr[12];
        ko[13] = kr[13];
        ko[14] = kr[14];
        ko[15] = kr[15];
      }
      ko[0] = kn * kp + kv * kw;
      ko[1] = km * kp + ku * kw;
      ko[2] = kl * kp + kt * kw;
      ko[3] = kk * kp + ks * kw;
      ko[4] = kv * kp - kn * kw;
      ko[5] = ku * kp - km * kw;
      ko[6] = kt * kp - kl * kw;
      ko[7] = ks * kp - kk * kw;
      return ko;
    };
    e.fromRotationTranslation = function (kx, kv, kt) {
      var kq = kv[0];
      var kp = kv[1];
      var ko = kv[2];
      var kr = kv[3];
      var ky = kq + kq;
      var kk = kp + kp;
      var ks = ko + ko;
      var kn = kq * ky;
      var km = kq * kk;
      var kl = kq * ks;
      var kw = kp * kk;
      var ku = kp * ks;
      var kB = ko * ks;
      var kC = kr * ky;
      var kA = kr * kk;
      var kz = kr * ks;
      kx[0] = 1 - (kw + kB);
      kx[1] = km + kz;
      kx[2] = kl - kA;
      kx[3] = 0;
      kx[4] = km - kz;
      kx[5] = 1 - (kn + kB);
      kx[6] = ku + kC;
      kx[7] = 0;
      kx[8] = kl + kA;
      kx[9] = ku - kC;
      kx[10] = 1 - (kn + kw);
      kx[11] = 0;
      kx[12] = kt[0];
      kx[13] = kt[1];
      kx[14] = kt[2];
      kx[15] = 1;
      return kx;
    };
    e.fromQuat = function (ku, kr) {
      var ko = kr[0];
      var kn = kr[1];
      var km = kr[2];
      var kp = kr[3];
      var kv = ko + ko;
      var kk = kn + kn;
      var kq = km + km;
      var kl = ko * kv;
      var kt = kn * kv;
      var ks = kn * kk;
      var kB = km * kv;
      var kA = km * kk;
      var ky = km * kq;
      var kz = kp * kv;
      var kx = kp * kk;
      var kw = kp * kq;
      ku[0] = 1 - ks - ky;
      ku[1] = kt + kw;
      ku[2] = kB - kx;
      ku[3] = 0;
      ku[4] = kt - kw;
      ku[5] = 1 - kl - ky;
      ku[6] = kA + kz;
      ku[7] = 0;
      ku[8] = kB + kx;
      ku[9] = kA - kz;
      ku[10] = 1 - kl - ks;
      ku[11] = 0;
      ku[12] = 0;
      ku[13] = 0;
      ku[14] = 0;
      ku[15] = 1;
      return ku;
    };
    e.frustum = function (ko, kl, kt, kk, ks, kq, kp) {
      var kr = 1 / (kt - kl);
      var kn = 1 / (ks - kk);
      var km = 1 / (kq - kp);
      ko[0] = kq * 2 * kr;
      ko[1] = 0;
      ko[2] = 0;
      ko[3] = 0;
      ko[4] = 0;
      ko[5] = kq * 2 * kn;
      ko[6] = 0;
      ko[7] = 0;
      ko[8] = (kt + kl) * kr;
      ko[9] = (ks + kk) * kn;
      ko[10] = (kp + kq) * km;
      ko[11] = -1;
      ko[12] = 0;
      ko[13] = 0;
      ko[14] = kp * kq * 2 * km;
      ko[15] = 0;
      return ko;
    };
    e.perspective = function (kn, km, kl, ko, kk) {
      var kq = 1 / Math.tan(km / 2);
      var kp = 1 / (ko - kk);
      kn[0] = kq / kl;
      kn[1] = 0;
      kn[2] = 0;
      kn[3] = 0;
      kn[4] = 0;
      kn[5] = kq;
      kn[6] = 0;
      kn[7] = 0;
      kn[8] = 0;
      kn[9] = 0;
      kn[10] = (kk + ko) * kp;
      kn[11] = -1;
      kn[12] = 0;
      kn[13] = 0;
      kn[14] = 2 * kk * ko * kp;
      kn[15] = 0;
      return kn;
    };
    e.ortho = function (kn, kl, kt, kk, kr, kq, kp) {
      var ko = 1 / (kl - kt);
      var ks = 1 / (kk - kr);
      var km = 1 / (kq - kp);
      kn[0] = -2 * ko;
      kn[1] = 0;
      kn[2] = 0;
      kn[3] = 0;
      kn[4] = 0;
      kn[5] = -2 * ks;
      kn[6] = 0;
      kn[7] = 0;
      kn[8] = 0;
      kn[9] = 0;
      kn[10] = 2 * km;
      kn[11] = 0;
      kn[12] = (kl + kt) * ko;
      kn[13] = (kr + kk) * ks;
      kn[14] = (kp + kq) * km;
      kn[15] = 1;
      return kn;
    };
    e.lookAt = function (ky, kF, kG, kq) {
      var kE;
      var kD;
      var kB;
      var km;
      var kl;
      var kk;
      var kt;
      var ks;
      var kr;
      var kz;
      var kC = kF[0];
      var kA = kF[1];
      var kx = kF[2];
      var kp = kq[0];
      var ko = kq[1];
      var kn = kq[2];
      var kw = kG[0];
      var kv = kG[1];
      var ku = kG[2];
      if (Math.abs(kC - kw) < kj && Math.abs(kA - kv) < kj && Math.abs(kx - ku) < kj) {
        return e.identity(ky);
      }
      kt = kC - kw;
      ks = kA - kv;
      kr = kx - ku;
      kz = 1 / Math.sqrt(kt * kt + ks * ks + kr * kr);
      kt *= kz;
      ks *= kz;
      kr *= kz;
      kE = ko * kr - kn * ks;
      kD = kn * kt - kp * kr;
      kB = kp * ks - ko * kt;
      kz = Math.sqrt(kE * kE + kD * kD + kB * kB);
      if (!kz) {
        kE = 0;
        kD = 0;
        kB = 0;
      } else {
        kz = 1 / kz;
        kE *= kz;
        kD *= kz;
        kB *= kz;
      }
      km = ks * kB - kr * kD;
      kl = kr * kE - kt * kB;
      kk = kt * kD - ks * kE;
      kz = Math.sqrt(km * km + kl * kl + kk * kk);
      if (!kz) {
        km = 0;
        kl = 0;
        kk = 0;
      } else {
        kz = 1 / kz;
        km *= kz;
        kl *= kz;
        kk *= kz;
      }
      ky[0] = kE;
      ky[1] = km;
      ky[2] = kt;
      ky[3] = 0;
      ky[4] = kD;
      ky[5] = kl;
      ky[6] = ks;
      ky[7] = 0;
      ky[8] = kB;
      ky[9] = kk;
      ky[10] = kr;
      ky[11] = 0;
      ky[12] = -(kE * kC + kD * kA + kB * kx);
      ky[13] = -(km * kC + kl * kA + kk * kx);
      ky[14] = -(kt * kC + ks * kA + kr * kx);
      ky[15] = 1;
      return ky;
    };
    e.str = function (kk) {
      return "mat4(" + kk[0] + ", " + kk[1] + ", " + kk[2] + ", " + kk[3] + ", " + kk[4] + ", " + kk[5] + ", " + kk[6] + ", " + kk[7] + ", " + kk[8] + ", " + kk[9] + ", " + kk[10] + ", " + kk[11] + ", " + kk[12] + ", " + kk[13] + ", " + kk[14] + ", " + kk[15] + ")";
    };
    e.frob = function (kk) {
      return Math.sqrt(Math.pow(kk[0], 2) + Math.pow(kk[1], 2) + Math.pow(kk[2], 2) + Math.pow(kk[3], 2) + Math.pow(kk[4], 2) + Math.pow(kk[5], 2) + Math.pow(kk[6], 2) + Math.pow(kk[6], 2) + Math.pow(kk[7], 2) + Math.pow(kk[8], 2) + Math.pow(kk[9], 2) + Math.pow(kk[10], 2) + Math.pow(kk[11], 2) + Math.pow(kk[12], 2) + Math.pow(kk[13], 2) + Math.pow(kk[14], 2) + Math.pow(kk[15], 2));
    };
    kf.mat4 = e;
  })(window);
  function cd() {
    this.result = {
      bkData: [],
      eleData: [[], [], [], [], [], [], [], [], [], []],
      tileLabels: []
    };
  }
  eX.extend(cd.prototype, {
    createLayer: function (T, i) {
      var e = this.result.bkData;
      i = i || {};
      if (!e[T]) {
        e[T] = [[], [], []];
      }
      e[T].tileTypeName = i.tileTypeName || "na";
      e[T].dataType = i.dataType || 2;
      e[T].png8 = i.png8 || false;
      e[T].clipTile = i.clipTile || false;
      e[T].boundary = i.boundary || false;
      if (i.ontology) {
        e[T].ontology = i.ontology;
      }
    },
    removeLayer: function (i) {
      var e = this.result.bkData;
      e[i] = null;
    },
    hasLayerBoundary: function () {
      var e = this.result.bkData;
      var T = false;
      for (var kc = 0; kc < e.length; kc++) {
        if (e[kc] && e[kc].boundary) {
          T = true;
          break;
        }
      }
      return T;
    },
    getResult: function () {
      return this.result;
    },
    setData: function (ke, kd, kf) {
      var e = this.result.bkData;
      var T = e[kd] ? e[kd][kf] : null;
      if (!T) {
        return;
      }
      for (var kc = 0; kc < T.length; kc++) {
        if (T[kc].key && T[kc].key === ke.key) {
          T[kc] = ke;
          return;
        }
      }
      T.push(ke);
    },
    setLabelData: function (T, i) {
      var e = this.result.tileLabels;
      e[i || 0] = T;
    },
    getLabelData: function (i) {
      var e = this.result.tileLabels;
      if (i === undefined) {
        return e;
      }
      return e[i] || [];
    },
    clearLabelData: function (i) {
      var e = this.result.tileLabels;
      if (i === undefined) {
        e = [];
        return;
      }
      e[i] = [];
    },
    setOverlayData: function (T, e, i) {
      if (!this.result.eleData[e]) {
        return;
      }
      if (e >= 2 && e <= 4) {
        this.result.eleData[e][i || 0] = T;
        return;
      } else if (e === 0 || e === 5 || e === 6) {
        T.sort(function (kd, kc) {
          return kd.overlay.zIndex - kc.overlay.zIndex;
        });
      }
      this.result.eleData[e] = T;
    },
    clearLabelOverlayData: function (e) {
      if (e === undefined) {
        this.result.eleData[2] = [];
        this.result.eleData[3] = [];
        this.result.eleData[4] = [];
      }
      this.result.eleData[2][e] = [];
      this.result.eleData[3][e] = [];
      this.result.eleData[4][e] = [];
    },
    clearData: function (kc) {
      var e = this.result.bkData;
      if (typeof kc === "number") {
        if (e[kc]) {
          e[kc][0] = [];
          e[kc][1] = [];
          e[kc][2] = [];
        }
        return;
      }
      for (var T = 0; T < e.length; T++) {
        if (!e[T]) {
          continue;
        }
        e[T][0] = [];
        e[T][1] = [];
        e[T][2] = [];
      }
    },
    sortThumbData: function (i) {
      var e = this.result.bkData;
      var T = e[i];
      if (!T) {
        return;
      }
      if (T[0] && T[0].length > 0) {
        T[0].sort(function (kd, kc) {
          return kd.tileInfo.useZoom - kc.tileInfo.useZoom;
        });
      }
    }
  });
  var gm = function () {
    var km = new Int8Array(4);
    var T = new Int32Array(km.buffer, 0, 1);
    var kh = new Float32Array(km.buffer, 0, 1);
    function ko(kv) {
      T[0] = kv;
      return kh[0];
    }
    function i(kv) {
      kh[0] = kv;
      return T[0];
    }
    function ki(kv) {
      var kx = kv[3] << 24 | kv[2] << 16 | kv[1] << 8 | kv[0];
      var kw = ko(kx & 4278190079);
      return kw;
    }
    var kd = 0;
    var kg = 1;
    var kk = 2;
    var ks = 0;
    var kp = 1;
    var kn = 2;
    var ke = 9;
    function kl(kv, kw) {
      var kx;
      if (kw % 2 === 0) {
        kx = [-kv[1], kv[0]];
      } else {
        kx = [kv[1], -kv[0]];
      }
      return kx;
    }
    function e(kv, kw, kx) {
      var ky = kl(kv, kw);
      var kz;
      if (kx === kg) {
        return ky;
      } else {
        if (kw === 4 || kw === 5) {
          kz = [ky[0] - kv[0], ky[1] - kv[1]];
        } else {
          kz = [ky[0] + kv[0], ky[1] + kv[1]];
        }
        if (kx === kd) {
          vec2.normalize(kz, kz);
        }
        return kz;
      }
    }
    function kr(kw, kv) {
      return Math.sqrt(Math.pow(kw[0] - kv[0], 2) + Math.pow(kw[1] - kv[1], 2));
    }
    function kc(kz, ky, kx, kv) {
      var kw = vec2.dot(kz, ky);
      if (kx === kn || kx === kp) {
        if ((kv === 0 || kv === 1) && kw > 0) {
          return true;
        } else if ((kv === 2 || kv === 3) && kw < 0) {
          return true;
        }
      }
      if ((kv === 0 || kv === 1) && kw < 0) {
        return true;
      } else if ((kv === 2 || kv === 3) && kw > 0) {
        return true;
      }
      return false;
    }
    function kj(kw, kB, kD) {
      var kC = kl(kw, kB);
      var ky;
      var kA = kw;
      var kz = kD;
      var kF = [];
      vec2.normalize(kF, [kA[0] + kz[0], kA[1] + kz[1]]);
      var kE = vec2.dot(kC, [-kF[1], kF[0]]);
      if (Math.abs(kE) < 0.1) {
        kE = 1;
      }
      var kx = 1 / kE;
      ky = [-kF[1] * kx, kF[0] * kx];
      var kv = vec2.dot(kw, ky);
      if (kv < 0) {
        vec2.negate(ky, ky);
      }
      return {
        cos2: kv,
        offset: ky
      };
    }
    function ku(kw, kB, kD, kv) {
      var kC = kl(kw, kB);
      var kA;
      var kz;
      var ky;
      if (kB === 0 || kB === 1) {
        kA = kD;
        kz = kw;
      } else {
        kA = kw;
        kz = kD;
      }
      if (!kA || !kz) {
        return kC;
      }
      var kF = [kA[0] + kz[0], kA[1] + kz[1]];
      if (kF[0] === 0 && kF[1] === 0) {
        vec2.normalize(kF, kz);
      } else {
        vec2.normalize(kF, kF);
      }
      var kG = kc(kF, kC, kv, kB);
      if (kG) {
        return kC;
      }
      var kE = vec2.dot(kC, [-kF[1], kF[0]]);
      if (Math.abs(kE) < 0.1) {
        kE = 1;
      }
      var kx = 1 / kE;
      ky = [-kF[1] * kx, kF[0] * kx];
      return ky;
    }
    function kt(kG, kH, kA, kz, kI, kF, ky, kB, kx, kE) {
      var kD;
      var kw = 0;
      var kv = false;
      kD = kF.length / ke - 1;
      kf(kH[0], kG[0], kA[0], kI, kz, 4, kB, kx, undefined, kF, kE);
      kD++;
      kw++;
      kf(kH[0], kG[0], kA[0], kI, kz, 5, kB, kx, undefined, kF, kE);
      kD++;
      kw++;
      for (var kC = 0; kC < kG.length; kC++) {
        kf(kH[kC], kG[kC], kA[kC], kI, kz, 0, kB, kx, kG[kC - 1], kF, kE);
        kq(ky, ++kD, ++kw, kv);
        kf(kH[kC], kG[kC], kA[kC], kI, kz, 1, kB, kx, kG[kC - 1], kF, kE);
        kq(ky, ++kD, ++kw, kv);
        kf(kH[kC + 1], kG[kC], kA[kC + 1], kI, kz, 2, kB, kx, kG[kC + 1], kF, kE);
        kq(ky, ++kD, ++kw, kv);
        kf(kH[kC + 1], kG[kC], kA[kC + 1], kI, kz, 3, kB, kx, kG[kC + 1], kF, kE);
        kq(ky, ++kD, ++kw, kv);
        if (kz === kp && kC !== kG.length - 1) {
          kf(kH[kC + 1], kG[kC], kA[kC + 1], kI, kz, 8, kB, kx, kG[kC + 1], kF, kE);
          kq(ky, ++kD, ++kw, kv);
          kv = kv ? false : true;
        }
      }
      kf(kH[kH.length - 1], kG[kG.length - 1], kA[kH.length - 1], kI, kz, 6, kB, kx, undefined, kF, kE);
      kq(ky, ++kD, ++kw, kv);
      kf(kH[kH.length - 1], kG[kG.length - 1], kA[kH.length - 1], kI, kz, 7, kB, kx, undefined, kF, kE);
      kq(ky, ++kD, ++kw, kv);
    }
    function kf(kI, ky, kC, kJ, kx, kD, kA, kw, kG, kF, kE) {
      var kH = kD % 2 === 0 ? 1 : -1;
      var kB;
      if (kD === 4 || kD === 5 || kD === 6 || kD === 7) {
        kB = e(ky, kD, kJ);
      } else if (kD === 0 || kD === 1 || kD === 2 || kD === 3) {
        kB = ku(ky, kD, kG, kx);
      } else if (kD === 8) {
        var kz = kj(ky, kD, kG);
        kB = kz.offset;
        vec2.normalize(kB, kB);
        var kv = kz.cos2;
        if (kv < 0) {
          kH = -kH;
        }
      }
      kF[kF.length] = kI[0] * 10;
      kF[kF.length] = kI[1] * 10;
      kF[kF.length] = kB[0] * kw * 10;
      kF[kF.length] = kB[1] * kw * 10;
      kF[kF.length] = kA;
      kF[kF.length] = kH;
      kF[kF.length] = 0;
      kF[kF.length] = kE || 0;
      kF[kF.length] = kC;
    }
    function kq(kz, kx, kv, ky) {
      var kw;
      if (kv % 2 === 0) {
        if (ky) {
          kz[kz.length] = kx - 2;
          kz[kz.length] = kx - 1;
          kz[kz.length] = kx;
        } else {
          kz[kz.length] = kx - 1;
          kz[kz.length] = kx - 2;
          kz[kz.length] = kx;
        }
      } else if (ky) {
        kz[kz.length] = kx - 1;
        kz[kz.length] = kx - 2;
        kz[kz.length] = kx;
      } else {
        kz[kz.length] = kx - 2;
        kz[kz.length] = kx - 1;
        kz[kz.length] = kx;
      }
    }
    return {
      getVertexCount: function (kw, kv) {
        if (kv === kp) {
          return kw * 5 - 2;
        } else {
          return kw * 4;
        }
      },
      buildData: function (kH, kx, kI, kD, kv, kA, kw, kE, kG) {
        var kF = [];
        var kC = kG ? kG : 0;
        var kz = [kC * 10];
        for (var kB = 0; kB < kH.length; kB++) {
          if (kB > 0) {
            kC += kr(kH[kB], kH[kB - 1]);
            kz.push(kC * 10);
          }
          if (kB !== kH.length - 1) {
            var ky = [kH[kB + 1][0] - kH[kB][0], kH[kB + 1][1] - kH[kB][1]];
            var kJ = [];
            if (ky[0] === 0 && ky[1] === 0) {
              kJ = [0, 0];
            } else {
              vec2.normalize(kJ, ky);
            }
            kF[kF.length] = [kJ[0], kJ[1]];
          }
        }
        return kt(kF, kH, kz, kx, kI, kD, kv, ki(kA), kw, kE);
      },
      toTileSolidLineVertices: function (kz, kw) {
        var kx = new Float32Array(kz.length / ke * 5);
        var kv = new Int16Array(kx.buffer);
        var kB = 0;
        var ky = 0;
        for (var kA = 0; kA < kz.length; kA += ke) {
          kv[kB] = ~~kz[kA];
          kv[kB + 1] = ~~kz[kA + 1];
          kv[kB + 2] = ~~kz[kA + 2];
          kv[kB + 3] = ~~kz[kA + 3];
          kx[ky + 2] = kz[kA + 4];
          kv[kB + 6] = kz[kA + 5];
          kv[kB + 7] = kw ? kw : 0;
          kv[kB + 8] = kz[kA + 7];
          kv[kB + 9] = 0;
          kB += 10;
          ky += 5;
        }
        return kx;
      }
    };
  }();
  var gF = 1;
  var hI = 2;
  var fe = {
    drawIndex: 0,
    devicePixelRatio: gd(),
    zoomState: 1,
    curViewTilesInfo: null,
    iconSetImg: null,
    LAST_CALC_ZOOM: -1,
    LAST_LOAD_VECTOR_ZOOM_CHANGE: false,
    lastCollisionTestTime: 0,
    remove: function () {
      this.tileCache.clear();
      this.removeLabel(this.drawIndex);
      if (this.tileLabels) {
        this.tileLabels = [];
      }
    },
    removeLabel: function (i) {
      if (this.dataType === 2) {
        this.map._featureMgr.clearData(i);
        this.map._featureMgr.clearLabelOverlayData(i);
        this.map._featureMgr.clearLabelData(i);
        var T = new fJ("onspotsdataremove");
        T.index = i;
        this.map.dispatchEvent(T);
        if (this.ontology && this.ontology instanceof d8) {
          this.clearCache();
          return;
        }
        var e = new fJ("onlayer_update");
        e.name = "na";
        this.map.fire(e);
      }
    },
    initDrawData: function () {
      this.drawIndex = this.zIndex;
      var e = {
        tileTypeName: this.tileType.getName(),
        dataType: this.dataType,
        png8: this.png8,
        clipTile: this.clipTile,
        boundary: this.boundary
      };
      if (this.ontology) {
        e.ontology = this.ontology;
      }
      this.map._featureMgr.createLayer(this.drawIndex, e);
      this.dispatchEvent(new fJ("oninitDrawData"));
    },
    destroyDrawData: function () {
      this.map._featureMgr.removeLayer(this.drawIndex);
      var i = new fJ("onremoveLayerMask");
      i.hasLayerBoundary = this.map._featureMgr.hasLayerBoundary();
      this.map.dispatchEvent(i);
    },
    setZIndex: function (kg) {
      kg = Math.abs(Math.floor(kg)) || 1;
      if (!kg || kg === this.zIndex) {
        return;
      }
      var kd = this.map._featureMgr.result.bkData;
      var kc = this.map.tileMgr.tileLayers;
      var ki = this.map._normalLayerMgr.layers;
      function kj(ko) {
        var km = null;
        var kn = [kc, ki];
        for (var kk = 0; kk < kn.length; kk++) {
          for (var kl = 0; kl < kn[kk].length; kl++) {
            if (kn[kk][kl].zIndex === ko) {
              km = kn[kk][kl];
              break;
            }
          }
          if (km) {
            break;
          }
        }
        return km;
      }
      var T = [];
      var kf = [];
      var kh = this.zIndex;
      var i = kj(kg);
      if (kd[kg] && i) {
        T.push(i);
        kf.push(kd[kg]);
        this.setTargetZIndex(kg);
        kd[kg] = kd[kh];
        kd[kh] = null;
      } else {
        this.setTargetZIndex(kg);
        kd[kg] = kd[kh];
        kd[kh] = null;
        this.map.dispatchEvent(new fJ("onupdate"));
        return;
      }
      var ke = kg + 1;
      while (ke) {
        var e = kj(ke);
        if (kd[ke] && e) {
          T.push(e);
          kf.push(kd[ke]);
          T.shift().setTargetZIndex(ke);
          kd[ke] = kf.shift();
          ke += 1;
        } else {
          T.shift().setTargetZIndex(ke);
          kd[ke] = kf.shift();
          ke = 0;
        }
      }
      this.map.dispatchEvent(new fJ("onupdate"));
    },
    setZIndexTop: function () {
      var e = this.map._featureMgr.result.bkData;
      e[e.length] = e[this.zIndex];
      e[this.zIndex] = null;
      this.setTargetZIndex(e.length - 1);
      this.map.dispatchEvent(new fJ("onrefresh"));
    },
    setUpLevel: function () {
      var e = this._getAdjoinZIndex("up");
      if (this.zIndex !== e) {
        this.setZIndex(e);
      }
    },
    setDownLevel: function () {
      var e = this._getAdjoinZIndex("down");
      if (this.zIndex !== e) {
        this.setZIndex(e);
      }
    },
    getTileKey: function (e, kc) {
      kc = kc || {};
      var i = typeof kc.useZoom === "number" ? kc.useZoom : e.useZoom;
      var T = e.style || this.mapStyleId || "default";
      return this.mapType + "_" + T + "_" + e.col + "_" + e.row + "_" + e.zoom + "_" + i;
    },
    getTileRenderDataKey: function (i) {
      var T = i.col;
      var kc = i.zoom;
      var e = i.baseTileSize;
      T = e0.calcLoopParam(T, kc, e).col;
      return this.mapType + "_" + T + "_" + i.row + "_" + kc + "_" + i.useZoom;
    },
    getTileUnits: function (e) {
      var kc = this.map;
      var T = ej[kc.getMapType()];
      var i = T.baseUnits * Math.pow(2, T.zoomLevelBase - e);
      return i;
    },
    getTilesUrl: function (kd, km, kn) {
      var i = kd.x;
      var ko = kd.y;
      var kj = jO("ditu", "normal");
      var kf = kj.ver;
      var kg = kj.udt;
      i = e0.calcLoopParam(i, km, kn).col;
      var kl = ej.B_NORMAL_MAP.vectorTileUrls;
      var ke = Math.abs(i + ko) % kl.length;
      var kk = kl[ke];
      if (window.offLineIPAddress) {
        kl = [window.offLineIPAddress + "pvd/"];
        kk = kl[0];
      }
      var T = "x=" + i + "&y=" + ko + "&z=" + Math.floor(km);
      var ki = this.devicePixelRatio > 1 ? "&scaler=2" : "";
      var kh = "&textimg=1";
      if (this.map.config.textRenderType === "canvas") {
        kh = "&textimg=0";
      }
      var kc = this.map.config.style;
      if (typeof kc === "string" && kc !== "default") {
        T += "&styleId=" + B.mapStyleNameIdPair[kc];
      }
      T += "&styles=pl" + kh + ki + "&v=" + kf + "&udt=" + kg + "&json=0";
      var e = kk + "?qt=vtile&param=" + window.encodeURIComponent(eT(T));
      return e;
    },
    getRasterTilesUrl: function (T, ke, kc) {
      var kd = ej[this.map.mapType];
      var i = this.map.config.style;
      var e = kd.tileUrls[Math.abs(ke + T) % kd.tileUrls.length] + "?qt=tile&x=" + T + "&y=" + ke + "&z=" + kc + (i === "default" || typeof i !== "string" ? "" : "&styleId=" + B.mapStyleNameIdPair[i]) + "&styles=pl&udt=" + this.normalUdt + "&scaler=" + this.scaler + "&p=1";
      e = e.replace(/-(\d+)/gi, "M$1");
      return e;
    },
    getZoomState: function () {
      var T = this.map;
      var i = T.getZoom();
      var e = i - this.lastZoom;
      if (e > 0) {
        this.zoomState = 1;
      } else if (e < 0) {
        this.zoomState = -1;
      }
      this.lastZoom = i;
      return this.zoomState;
    },
    releaseOutViewTileData: function (e) {
      var kd = this.map._workerMgr.releasePendingData(e);
      for (var kc = 0, T = kd.length; kc < T; kc++) {
        var ke = this.getTileKey(kd[kc]);
        this.tileCache.removeData(ke);
      }
    },
    loadLayerData: function (e, kc, i) {
      this.hasZoomChange = i;
      this.curViewTilesInfo = e;
      if (this.ontology instanceof d8) {
        if (this.loadTileData) {
          this.loadTileData(e, kc);
        }
        return;
      }
      this.mapStyleId = this.map.getMapStyleId();
      this.releaseOutViewTileData(e);
      var T = this.getZoomState();
      if (this.dataType === hI) {
        if (kc) {
          this.getVectorLayerDataFromCache(e, T);
        } else {
          this.loadVectorLayerData(e);
        }
      } else {
        this.loadRasterLayerData(e, kc);
      }
    },
    getVectorLayerDataFromCache: function (kh, kr) {
      this.map.temp.isPermitSpotOver = false;
      this.tileLabels = [];
      var kt = this.map._displayOptions;
      if (this.baseLayer === true) {
        var kl = this.map._customLabelMgr.virtualTiles.custom;
        if (kl && kl.label) {
          this.tileLabels.push(kl.label);
        }
      }
      this.thumbCache = {};
      var ks = -1;
      for (var kp = 0, km = kh.length; kp < km; kp++) {
        var kq = kh[kp];
        var kd = kq.col;
        var ke = kq.row;
        var T = kq.zoom;
        var kn = this._getTileTexImgKey(kq);
        var kc = kq.useZoom;
        ks = T;
        var kf = this.getTileKey(kq);
        var kv = this.tileCache.getData(kf);
        if (kv && kv.status === "ready") {
          var kw = kv;
          this.map._featureMgr.setData(kv, this.drawIndex, 2);
          if (kt.poi && kv.label) {
            if (kv.label.status === "ready") {
              kv.label.tileInfo = kv.tileInfo;
              this.tileLabels.push(kv.label);
              if (kv.label.textureSources && kv.label.textureSources[kc] && this.map._webglMapScene) {
                var ku = this.map._webglMapScene._painter;
                if (!ku._labelTextureAtlasOffset[kn]) {
                  ku._addToAsyncJob(kv.label.textureSources[kc]);
                }
              }
            } else if (kv.label.status !== "processing") {
              this.processLabelData(kv);
            }
          }
        } else {
          var ko = {
            tileInfo: kq,
            dataType: hI,
            key: kf
          };
          this.map._featureMgr.setData(ko, this.drawIndex, 2);
          if (this.useThumbData) {
            this.setThumbData(kd, ke, T, kc, kr);
          }
        }
      }
      this.tileLabels.labelZoom = ks;
      this.updateLabels(kr);
      var ki = this.map.getZoom();
      var kg = Math.floor(ki);
      var kk = ki - kg;
      var kj = Math.floor(this.LAST_CALC_ZOOM);
      var e = this.LAST_CALC_ZOOM - kj;
      var kx = false;
      if (this.hasZoomChange) {
        if (Math.abs(ki - this.LAST_CALC_ZOOM) >= 0.5) {
          kx = true;
        } else if (kk < 0.5 && e >= 0.5) {
          kx = true;
        } else if (kk >= 0.5 && e < 0.5) {
          kx = true;
        }
        if (kx) {
          this.cacheDataCollideLabels(0);
        }
        this.LAST_CALC_ZOOM = ki;
      } else if (this.tileLabels.length > 0) {
        this.cacheDataCollideLabels(eX.Browser.ie ? 50 : 30);
      }
    },
    loadVectorLayerData: function (ki) {
      this.map.temp.isPermitSpotOver = false;
      var kh = this;
      function kg(i, kj) {
        var kl = kh.tileCache.getData(kj);
        if (!kl) {
          return;
        }
        if (!i || i.error) {
          if (i.event && bx.fetchDebug) {
            bx.fetchDebug.sendError({
              title: i.event.title,
              msg: i.event.msg,
              category: bx.fetchDebug.category.AJAX,
              level: bx.fetchDebug.levels.ERROR,
              url: i.event.title
            });
          }
          var kk = new fJ("ontileloaderror");
          i = i || {};
          kk.error = i.error || "";
          kk.message = i.message || "";
          kh.map.fire(kk);
          kl.status = "init";
          kl.reloadTimer = setTimeout(function () {
            if (kl.retry < 3) {
              kl.retry++;
              kl.status = "loading";
              kh.loadVectorTileData(i.tileInfo, kg);
            } else {
              kh.tileCache.removeData(kj);
              kh._checkTilesLoaded();
            }
          }, 4000);
          if (kh.map._featureMgr) {
            kh.map._featureMgr.clearData(kh.drawIndex);
          }
          kh.getVectorLayerDataFromCache(kh.curViewTilesInfo, kh.getZoomState());
          return;
        }
        if (kl.reloadTimer) {
          clearTimeout(kl.reloadTimer);
          kl.reloadTimer = null;
        }
        kh.callbackDataQueue.push([i, kj]);
        if (kh.processDataTimer) {
          return;
        }
        kh.processDataTimer = setTimeout(function () {
          while (kh.callbackDataQueue.length > 0) {
            var kn = kh.callbackDataQueue.shift();
            kh.vectorTileDataCbk(kn[0], kn[1]);
            kh._checkTilesLoaded();
          }
          if (kh.map._featureMgr) {
            kh.map._featureMgr.clearData(kh.drawIndex);
          }
          kh.getVectorLayerDataFromCache(kh.curViewTilesInfo, kh.getZoomState());
          var km = new fJ("onrefresh");
          km.source = "webgllayer";
          kh.map.dispatchEvent(km);
          kh.processDataTimer = null;
        }, 200);
      }
      for (var kf = 0, kd = ki.length; kf < kd; kf++) {
        var T = ki[kf];
        var ke = this.getTileKey(T);
        var e = this.tileCache.getData(ke);
        if (!e) {
          e = {
            status: "init",
            tileInfo: T,
            dataType: hI,
            key: ke,
            retry: 0
          };
        }
        if (e.status !== "ready" && e.status !== "loading") {
          this.numLoading++;
          this.numTileLoading++;
          e.status = "loading";
          this.tileCache.setData(ke, e);
          var kc = this.getProcessedLabelZoom(T);
          if (kc) {
            T.processedLabelZooms = kc;
          }
          this.loadVectorTileData(T, kg);
        }
      }
    },
    setThumbData: function (i, kd, kc, e, T) {
      if (T === 1) {
        if (this._findParentZoomTile(i, kd, kc, e, 8) === false) {
          this._findChildZoomTile(i, kd, kc, e, 3);
        }
      } else if (T === -1) {
        if (this._findChildZoomTile(i, kd, kc, e, 3) === false) {
          this._findParentZoomTile(i, kd, kc, e, 8);
        }
      }
      this.map._featureMgr.sortThumbData(this.drawIndex);
    },
    _findParentZoomTile: function (kf, ko, kn, kd, ki) {
      var ke = ej[this.getMapType()];
      var T = ke.minDataZoom;
      var e = kf;
      var kl = ko;
      var kj = kn;
      var kk = kd;
      for (var kh = 1; kh <= ki; kh++) {
        var kc = this.tileType.getParentTile(e, kl, kj, kk, T);
        if (kc === null) {
          continue;
        }
        var km = this.getTileKey(kc);
        var kg = this.tileCache.getData(km);
        if (kg && kg.status === "ready") {
          if (this.thumbCache[km]) {
            continue;
          }
          this.map._featureMgr.setData(kg, this.drawIndex, 0);
          this.thumbCache[km] = true;
          return true;
        }
        e = kc.col;
        kl = kc.row;
        kj = kc.zoom;
        kk = kc.useZoom;
      }
      return false;
    },
    _findChildZoomTile: function (kg, ki, e, kd, kr) {
      var kp = ej[this.getMapType()];
      var kl = kp.maxDataZoom;
      var kf = kg;
      var kh = ki;
      var kj = e;
      var kc = kd;
      var ke = true;
      for (var ko = 1; ko <= kr; ko++) {
        var km = false;
        var T = this.tileType.getChildTiles(kf, kh, kj, kc, kl, ko);
        if (!T) {
          continue;
        }
        for (var kn = 0; kn < T.length; kn++) {
          var kk = this.getTileKey(T[kn]);
          var kq = this.tileCache.getData(kk);
          if (kq && kq.status === "ready") {
            if (!this.thumbCache[kk]) {
              this.map._featureMgr.setData(kq, this.drawIndex, 1);
              this.thumbCache[kk] = true;
            }
            km = true;
          } else {
            ke = false;
          }
        }
        if (km) {
          break;
        }
      }
      return ke;
    },
    loadVectorTileData: function (kp, kq) {
      var kd = kp.col;
      var ke = kp.row;
      var e = kp.zoom;
      var kn = kp.baseTileSize;
      var kc = this.getTilesUrl(new fi(kd, ke), e, kn);
      var kf = this.map.getPrivateRegions();
      if (!this.processData && this.map.getPrivateStatus() && kf) {
        var kl = kp.useZoom;
        var kk = this.tileType.getMercatorSize(kl);
        var kj = kd * kk;
        var ki = ke * kk;
        var km = new cx(kj + kk / 2, ki + kk / 2);
        var kh = new hY(new cx(kj, ki), new cx(kj + kk, ki + kk));
        var kg = gd() >= 1.5 ? 2 : 1;
        for (var ko = 0; ko < kf.length; ko++) {
          if (kf[ko] instanceof cM) {
            if (kf[ko].crossPoint(km, kh, kl)) {
              var kr = {
                x: kd,
                y: ke,
                z: e,
                mapZoom: kl,
                scalerRadio: kg,
                textimg: this.map.config.textRenderType === "canvas" ? 0 : 1
              };
              var T = kf[ko].tileUrlFunction(kc, kr);
              if (T && T.url) {
                kc = T.url;
                if (T.header) {
                  kp.header = T.header;
                }
              }
              break;
            }
          }
        }
      }
      if (!kc) {
        return;
      }
      var kt = this.getTileKey(kp);
      hg(this.map);
      if (!this.processData) {
        if (!this.map || !this.map._workerMgr) {
          return;
        }
        this.map._workerMgr.loadTileData(kc, kp, kt, kq);
        return;
      }
      var kq = "cbk" + kt.replace(/-/g, "_");
      var ks = this;
      bx[kq] = function (i) {
        var ku = function (kv) {
          return function () {
            kv.tileInfo = kp;
            var kB = ks.processData(kv);
            if (!kB.road) {
              return;
            }
            var ky = {
              tileInfo: kp,
              renderData: {
                base: []
              },
              status: "ready",
              key: kt,
              mapType: ks.mapType
            };
            var kE = [];
            var kH = [];
            for (var kA = 0; kA < kB.road.length; kA++) {
              var kD = kB.road[kA];
              var kC = -1;
              for (var kz = 0; kz < kD.length; kz++) {
                var kF = kD[kz];
                var kG = [];
                if (kE.length / 7 + kF[0].length / 2 > 65536) {
                  ky.renderData.base.push({
                    type: "line",
                    data: [gm.toTileSolidLineVertices(kE, 4000), new Uint16Array(kH)]
                  });
                  kE = [];
                  kH = [];
                }
                for (var kx = 0; kx < kF[0].length; kx += 2) {
                  kG[kG.length] = [kF[0][kx], kF[0][kx + 1]];
                }
                var kw = kF[3];
                gm.buildData(kG, kF[1], kF[2], kE, kH, kw, kF[4], kA + 20);
              }
              ky.renderData.base.push({
                type: "line",
                data: [gm.toTileSolidLineVertices(kE, 4000), new Uint16Array(kH)]
              });
            }
            ks.tileCache.setData(kt, ky);
            if (ks.map._featureMgr) {
              ks.map._featureMgr.clearData(ks.drawIndex);
            }
            ks.getVectorLayerDataFromCache(ks.curViewTilesInfo, ks.getZoomState());
            ks.map.dispatchEvent(new fJ("onrefresh"));
          };
        }(i);
        ks.map.jobScheduler.addJob(ku);
        delete bx[kq];
      };
      kc += "&fn=" + encodeURIComponent(fs + "." + kq);
      gM.load(kc);
    },
    vectorTileDataCbk: function (kc, kd) {
      var kh = new fJ("ontileloaded");
      kh.perfStat = kc.perfStat || [];
      var e = this.map;
      e.fire(kh);
      var i = kc.tileInfo;
      var T = i.col;
      var km = i.row;
      var kl = i.zoom;
      var kk = i.baseTileSize;
      var kf = this.tileCache.getData(kd);
      if (!kf) {
        return;
      }
      if (!this.showLabel) {
        kc.label = null;
      }
      kf.renderData = kc;
      kf.tileInfo = i;
      var ke = e0.calcLoopParam(T, kl, kk);
      var ki = ke.geoOffsetX;
      kf.tileInfo.loopOffsetX = ki;
      kf.status = "ready";
      kf.mapType = this.mapType;
      this.tileCache.setData(kd, kf);
      kf.label = kc.label;
      kc.label = null;
      if (kc.indoorData && e._indoorMgr) {
        e._indoorMgr.setData(kc.indoorData);
      }
      var kg = "id_" + T + "_" + km + "_" + kl;
      if (!this.curViewTilesInfo[kg]) {
        e.fire(new fJ("ontilenotinview"));
        return;
      }
      var kj = e._displayOptions;
      if (kj.poi) {
        this.processLabelData(kf);
      }
      if (kc.indoorData && e._indoorMgr && e._indoorMgr.currentUid) {
        this._refreshIndoorData(e._indoorMgr.currentUid, e._indoorMgr.currentFloor);
      }
    },
    _refreshIndoorData: function (kk, kj) {
      var km = this.map._indoorMgr.getIndoorData(kk);
      var kp = km.tileKeys;
      var kn = Math.floor(this.map.getZoom());
      for (var kh = 0; kh < kp.length; kh++) {
        var ke = kp[kh];
        var kg = this.tileCache.getData(ke);
        if (!kg) {
          continue;
        }
        var ko = kg.renderData;
        ko.indoorBase = [];
        ko.indoorBaseContour = [];
        ko.indoorBorder3D = [];
        ko.indoorArea3D = [];
        kg.label.indoorLabel = [];
        this.labelProcessor.clearCollisionCache(kg.label);
        for (var ki in ko.indoorData) {
          if (ki === "tileInfo") {
            continue;
          }
          var e = ko.indoorData[ki];
          var kd = e.defaultFloor;
          if (ki === kk) {
            kd = kj;
            e.currentFloor = kj;
          }
          if (e.floors[kd]) {
            if (e.floors[kd].base) {
              for (var kf = 0; kf < e.floors[kd].base.length; kf++) {
                ko.indoorBase.push(e.floors[kd].base[kf]);
              }
            }
            if (e.floors[kd].contour) {
              for (var kf = 0; kf < e.floors[kd].contour.length; kf++) {
                ko.indoorBaseContour.push(e.floors[kd].contour[kf]);
              }
            }
            if (e.floors[kd].indoorBorder3D) {
              ko.indoorBorder3D.push(e.floors[kd].indoorBorder3D);
            }
            if (e.floors[kd].area3D) {
              ko.indoorArea3D.push(e.floors[kd].area3D);
            }
            if (e.floors[kd].pois) {
              kg.label.indoorLabel = kg.label.indoorLabel.concat(e.floors[kd].pois);
            }
          }
        }
        this.updateAllIconsTextureCoords(kg);
        var kl = this;
        this.labelProcessor.loadIconImages(kg, function (i) {
          kl.updateAllIconsTextureCoords(i);
        }, "indoor");
        var kc = ke.split("_");
        var T = parseInt(kc[kc.length - 1], 10);
        if (T !== kn) {
          continue;
        }
        kl.map._featureMgr.setData(kg, this.drawIndex, 2);
      }
      this.dataBackCollideLabels();
      this.map.dispatchEvent(new fJ("onrefresh"));
    },
    _removeIndoorData: function (i) {
      if (!i.indoorData) {
        return;
      }
      for (var e in i.indoorData) {
        if (e === "tileInfo") {
          continue;
        }
        this.map._indoorMgr.removeData(e, i.key);
      }
    },
    getProcessedLabelZoom: function (kc) {
      var kd = j7.baseZoomInfo[kc.zoom];
      if (!kd) {
        return false;
      }
      var T = [];
      for (var ke = 0; ke < kd.length; ke++) {
        var kf = this.getTileKey(kc, {
          useZoom: kd[ke]
        });
        var e = this.tileCache.getData(kf);
        if (e && e.status === "ready" && e.label && e.label.status === "ready") {
          T.push(kd[ke]);
        }
      }
      if (T.length) {
        return T;
      } else {
        return false;
      }
    },
    getSameZoomDataFromCache: function (T) {
      var kc = j7.baseZoomInfo[T.zoom];
      for (var kd = 0; kd < kc.length; kd++) {
        var ke = this.getTileKey(T, {
          useZoom: kc[kd]
        });
        if (T.useZoom === kc[kd]) {
          continue;
        }
        var e = this.tileCache.getData(ke);
        if (e && e.status === "ready" && e.label && e.label.status === "ready") {
          return e;
        }
      }
      return false;
    },
    hasSameLabelData: function (kc, T) {
      for (var e = 0; e < T.length; e++) {
        if (T[e].key === kc) {
          return true;
        }
      }
      return false;
    },
    getDataByFloorName: function (T, kc) {
      for (var e = 0; e < T.length; e++) {
        if (T[e].floorName === kc) {
          return T[e];
        }
      }
      return null;
    },
    mergeIndoorLabelData: function (kh, e) {
      for (var kf in kh) {
        if (kf === "tileInfo") {
          continue;
        }
        if (e[kf]) {
          var T = kh[kf].floors;
          var ki = e[kf].floors;
          for (var kd = 0; kd < T.length; kd++) {
            var kc = T[kd];
            var kg = kc.floorName;
            var ke = this.getDataByFloorName(ki, kg);
            if (ke) {
              if (ke.pois) {
                ke.pois = ke.pois.concat(kc.pois);
                kc.pois = ke.pois;
              } else {
                ke.pois = kc.pois;
              }
            }
          }
        }
      }
    },
    mergeSameZoomLabelData: function (kf) {
      var kd = kf.label;
      if (!kd) {
        return;
      }
      var e = kf.tileInfo;
      var ke = this.getSameZoomDataFromCache(e);
      if (!ke) {
        return;
      }
      var kc = ke.label;
      if (!kc) {
        return;
      }
      for (var T = 0; T < kd.fixedLabel.length; T++) {
        if (!this.hasSameLabelData(kd.fixedLabel[T].key, kc.fixedLabel)) {
          kc.hasNewData = true;
          kc.fixedLabel.push(kd.fixedLabel[T]);
        }
      }
      for (var T = 0; T < kd.lineLabel.length; T++) {
        if (!this.hasSameLabelData(kd.lineLabel[T].key, kc.lineLabel)) {
          kc.hasNewData = true;
          kc.lineLabel.push(kd.lineLabel[T]);
        }
      }
      for (var T = 0; T < kd.indoorLabel.length; T++) {
        if (!this.hasSameLabelData(kd.indoorLabel[T].key, kc.indoorLabel)) {
          kc.hasNewData = true;
          kc.indoorLabel.push(kd.indoorLabel[T]);
        }
      }
      kf.label = kc;
      if (ke.renderData.indoorData && kf.renderData.indoorData) {
        this.mergeIndoorLabelData(kf.renderData.indoorData, ke.renderData.indoorData);
      }
    },
    processLabelData: function (ke) {
      if (!ke.label) {
        return;
      }
      if (ke.label.status === "processing") {
        return;
      }
      ke.label.status = "processing";
      var kc = this;
      kc.updateAllIconsTextureCoords(ke);
      this.labelProcessor.loadIconImages(ke, function (kf) {
        kc.updateAllIconsTextureCoords(kf);
      });
      if (this.map.config.textRenderType === "canvas") {
        var e = this.labelProcessor.drawLabelsOnCanvas(ke, function (kh, kj) {
          var kg = ke.tileInfo;
          var ki = kc.map.config.mapStyleId;
          if (!bx["customStyleInfo_" + ki]) {
            kc.mergeSameZoomLabelData(ke);
          }
          if (kh) {
            if (!ke.label.textureHeights) {
              ke.label.textureHeights = [];
            }
            ke.label.textureHeights[kg.useZoom] = kh.height;
          }
          if (kj) {
            if (!ke.label.indoorTextureHeights) {
              ke.label.indoorTextureHeights = [];
            }
            ke.label.indoorTextureHeights[kg.useZoom] = kj.height;
          }
          var kf = kc._getTileTexImgKey(kg);
          kc._doWorkAfterLabelImageLoad(ke, kh, kj, kf);
        });
        return;
      }
      var T = ke.label.textImageBitmap || ke.label.textImgStr;
      var kd = ke.label.indoorTextImageBitmap || ke.label.indoorTextImgStr;
      this.labelProcessor.loadImgByStr(T, kd, function i(kk, ki) {
        var kh = ke.label.textureHeight;
        var kl = ke.label.indoorTextureHeight;
        ke.label.textureHeight = undefined;
        ke.label.indoorTextureHeight = undefined;
        var kg = ke.tileInfo;
        kc.mergeSameZoomLabelData(ke);
        var kj = ke.label;
        kj.textImgStr = "";
        if (kj.indoorTextImgStr) {
          kj.indoorTextImgStr = "";
        }
        if (!kj.textureHeights) {
          kj.textureHeights = [];
        }
        kj.textureHeights[kg.useZoom] = kh;
        if (!kj.indoorTextureHeights) {
          kj.indoorTextureHeights = [];
        }
        kj.indoorTextureHeights[kg.useZoom] = kl;
        var kf = kc._getTileTexImgKey(kg);
        kc._doWorkAfterLabelImageLoad(ke, kk, ki, kf);
      });
    },
    _getTileTexImgKey: function (i) {
      var T = i.style || this.mapStyleId || "default";
      var e = T + "_" + i.col + "_" + i.row + "_" + i.zoom;
      if (this.map.config.textRenderType === "canvas") {
        e += "_" + i.useZoom;
      }
      return e;
    },
    _doWorkAfterLabelImageLoad: function (kg, ke, kc, i) {
      var kf = this;
      var kd = kg.label;
      kd.tileInfo = kg.tileInfo;
      kd.status = "ready";
      if (ke || kc) {
        var e = kd.tileInfo;
        if (ke) {
          ke.id = i;
          if (!kd.textureSources) {
            kd.textureSources = [];
          }
          kd.textureSources[e.useZoom] = ke;
        }
        if (kc) {
          kc.id = i + "_indoor";
          if (!kd.indoorTextureSources) {
            kd.indoorTextureSources = [];
          }
          kd.indoorTextureSources[e.useZoom] = kc;
        }
        if (kf.map._webglMapScene) {
          var T = kf.map._webglMapScene._painter;
          if (ke) {
            T._addToAsyncJob(kd.textureSources[e.useZoom]);
          }
        }
      }
      if (kg.custom !== true) {
        kf.tileLabels.push(kd);
      } else {
        kf.updateAllIconsTextureCoords(kg);
        this.labelProcessor.loadIconImages(kg, function (kh) {
          kf.updateAllIconsTextureCoords(kg);
        }, true);
      }
      if (kf.collisionTimer) {
        return;
      }
      kf.collisionTimer = setTimeout(function () {
        kf.dataBackCollideLabels();
        kf.collisionTimer = null;
      }, 300);
    },
    _updateIconTextureCoords: function (kg, T) {
      if (!kg) {
        return;
      }
      var kf = this.map;
      for (var kc = 0; kc < kg.length; kc++) {
        var ke = kg[kc];
        if (!ke.iconPos) {
          continue;
        }
        if (kf._webglMapScene) {
          var e = kf._webglMapScene._painter;
          var kd = T + "_" + ke.iconPos.iconType;
          ke.iconPos.texcoord = e._iconTextureAtlasCoords[kd] || null;
        }
      }
    },
    updateAllIconsTextureCoords: function (kd) {
      if (this.map.viewAnimationTime) {
        return;
      }
      if (kd) {
        if (kd.label) {
          var i = kd.tileInfo.style;
          this._updateIconTextureCoords(kd.label.fixedLabel, i);
          this._updateIconTextureCoords(kd.label.indoorLabel, i);
        }
      } else {
        var kc = this.tileCache.getAllData();
        for (var T in kc) {
          var e = kc[T].data;
          if (e.status === "ready" && e.label) {
            var i = e.tileInfo.style;
            this._updateIconTextureCoords(e.label.fixedLabel, i);
            this._updateIconTextureCoords(e.label.indoorLabel, i);
          }
        }
      }
      this.updateLabels();
      this.map.dispatchEvent(new fJ("onrefresh"));
    },
    cacheDataCollideLabels: function (T) {
      var kd = this;
      var i = this.map._featureMgr;
      function kc() {
        if (kd && !kd.map.tileMgr && !kd.map.tileMgr.isExitTileLayer(kd)) {
          return;
        }
        kd.cacheLabelTimer = null;
        var ke;
        var kf = kd.map.getTilt();
        var kh = kd.map.getHeading() % 360;
        if (kd.tileLabels.length === 0 || kd.tileLabels.length === 1 && kd.tileLabels[0].tileInfo.zoom === 0) {
          ke = i.getLabelData(kd.drawIndex);
          if (ke.length > 0) {
            ke = kd.labelProcessor.collisionTest(ke, -1);
          }
        } else if (kf || kh) {
          if (this._collisionTimer) {
            if (!kf) {
              clearTimeout(this._collisionTimer);
            } else if (Date.now() - kd.lastCollisionTestTime > 500) {
              kd.lastCollisionTestTime = Date.now();
            } else {
              clearTimeout(this._collisionTimer);
            }
          }
          this._collisionTimer = setTimeout(function () {
            if (kd && !kd.map.tileMgr && !kd.map.tileMgr.isExitTileLayer(kd)) {
              kd._collisionTimer = null;
              return;
            }
            ke = kd.labelProcessor.collisionTest(kd.tileLabels);
            if (ke) {
              if (kd._isInnerLayer && kd.map.stencil && kd.map.stencil.isPoiMask) {
                var ki = kd.isPoiInPolygon(ke);
                i.setLabelData(ki, kd.drawIndex);
              } else {
                i.setLabelData(ke, kd.drawIndex);
              }
            }
            kd.updateLabels();
            kd.map.dispatchEvent(new fJ("onrefresh"));
            kd._collisionTimer = null;
          }, 60);
          return;
        } else {
          ke = kd.labelProcessor.getCachedLabels(kd.tileLabels);
        }
        if (ke) {
          if (kd._isInnerLayer && kd.map.stencil && kd.map.stencil.isPoiMask) {
            var kg = kd.isPoiInPolygon(ke);
            i.setLabelData(kg, kd.drawIndex);
          } else {
            i.setLabelData(ke, kd.drawIndex);
          }
        }
        kd.updateLabels();
        kd.map.dispatchEvent(new fJ("onrefresh"));
      }
      if (!T) {
        clearTimeout(kd.cacheLabelTimer);
        kc();
      } else {
        if (kd.cacheLabelTimer) {
          return;
        }
        kd.cacheLabelTimer = setTimeout(function e() {
          kc();
        }, T);
      }
    },
    isPoiInPolygon: function (T) {
      var kv = this;
      var kl = kv.map.stencil;
      var kd = kv.map._featureMgr.result.eleData[9];
      var kc = [];
      for (var kq = 0; kq < kd.length; kq++) {
        var km = kd[kq].overlay.points;
        kc = kc.concat(km);
      }
      for (var kt = 0; kt < T.length; kt++) {
        var kf = [];
        var ke = [];
        for (var kr = 0; kr < T[kt].fixedLabel.length; kr++) {
          var kk = T[kt].fixedLabel[kr];
          var ko = kk.pt;
          if (kk.pt && at(ko, kc)) {
            kf.push(kk);
          } else {
            ke.push(kk);
          }
        }
        if (kl.showRegion === "inside") {
          T[kt].fixedLabel = kf;
        } else if (kl.showRegion === "outside") {
          T[kt].fixedLabel = ke;
        }
        var kp = [];
        var kh = [];
        for (var kq = 0; kq < T[kt].lineLabel.length; kq++) {
          var ks = T[kt].lineLabel[kq];
          var e = ks.pt;
          if (e && at(e, kc)) {
            kp.push(ks);
          } else {
            kh.push(ks);
          }
        }
        if (kl.showRegion === "inside") {
          T[kt].lineLabel = kp;
        } else if (kl.showRegion === "outside") {
          T[kt].lineLabel = kh;
        }
        var kn = [];
        var kj = [];
        for (var ki = 0; ki < T[kt].indoorLabel.length; ki++) {
          var ku = T[kt].indoorLabel[ki];
          var kg = ku.pt;
          if (kg && at(kg, kc)) {
            kn.push(ku);
          } else {
            kj.push(ku);
          }
        }
        if (kl.showRegion === "inside") {
          T[kt].indoorLabel = kn;
        } else if (kl.showRegion === "outside") {
          T[kt].indoorLabel = kj;
        }
      }
      return T;
    },
    dataBackCollideLabels: function () {
      var T = this;
      if (T && !T.map.tileMgr && !T.map.tileMgr.isExitTileLayer(T)) {
        return;
      }
      if (!T.tileLabels || T.tileLabels && T.tileLabels.length === 0) {
        return;
      }
      var e;
      T.labelProcessor.calcLabelsCollision(T.tileLabels);
      e = T.labelProcessor.getCachedLabels(T.tileLabels);
      if (e) {
        if (T._isInnerLayer && T.map.stencil && T.map.stencil.isPoiMask) {
          var i = T.isPoiInPolygon(e);
          T.map._featureMgr.setLabelData(i, T.drawIndex);
        } else {
          T.map._featureMgr.setLabelData(e, T.drawIndex);
        }
      }
      T.updateLabels();
      T.map.dispatchEvent(new fJ("onupdate"));
      if (bW()) {
        this.labelProcessor._refreshSpotData();
      }
    },
    updateLabels: function (kd) {
      var ke = this.map;
      if (!ke._featureMgr) {
        return;
      }
      var i = ke._featureMgr;
      var T = i.getLabelData(this.drawIndex);
      if (T.length > 0) {
        var kc = ke.getZoom();
        if (T.labelZoom - kc < 3) {
          this.labelProcessor.updateLabels(T);
          var e = this.labelProcessor.fixDataFormat(T);
          i.setOverlayData(e[0], 2, this.drawIndex);
          i.setOverlayData(e[1], 3, this.drawIndex);
          i.setOverlayData(e[2], 4, this.drawIndex);
        } else {
          i.clearLabelOverlayData(this.drawIndex);
        }
        ke.temp.isPermitSpotOver = false;
        this.labelProcessor.curSpotAdded = false;
      }
    },
    loadRasterLayerData: function (kh, kc) {
      this.thumbCache = {};
      var ki = this.getZoomState();
      if (kc) {
        for (var kf = 0, kd = kh.length; kf < kd; kf++) {
          var T = kh[kf];
          var ke = this.getTileKey(T);
          var e = this.tileCache.getData(ke);
          if (e && e.status === "ready") {
            if (T.tileTypeName === "xyz") {
              e.tileInfo = T;
            }
            this.map._featureMgr.setData(e, this.drawIndex, 2);
          } else if (this.useThumbData) {
            this.setThumbData(T.col, T.row, T.zoom, T.useZoom, ki);
          }
        }
        return;
      }
      for (var kf = 0, kd = kh.length; kf < kd; kf++) {
        var T = kh[kf];
        var ke = this.getTileKey(T);
        var e = this.tileCache.getData(ke);
        if (!e) {
          this.numTileLoading++;
          this.tileCache.setData(ke, {});
          var kg = this;
          this.loadRasterTileData(T, function (i, kj) {
            kg._checkLayerTilesLoaded();
            kg.rasterTileDataCbk(i, kj);
          });
        }
      }
    },
    loadRasterTileData: function (i, e) {
      var T = new Image();
      var kd = i.col;
      var kg = i.row;
      var ke = i.zoom;
      var kc = this.getTilesUrl(new fi(kd, kg), ke, i);
      if (!kc) {
        return;
      }
      var kf = this.getTileKey(i);
      if (i.combine) {
        T = kc;
        T.tileInfo = i;
        if (T) {
          if (e) {
            e(T, kf);
          }
        } else if (e) {
          e(null, kf);
        }
      } else {
        T = this.loadTileImage(kc, kf, e);
      }
      T.tileInfo = i;
    },
    loadTileImage: function (kg, kf, e) {
      var T = new Image();
      T.crossOrigin = "anonymous";
      var kc;
      var i = this;
      function kd() {
        if (i.retry) {
          if (kc) {
            clearInterval(kc);
          }
          kc = null;
        }
      }
      if (this.retry) {
        var ke = 1;
        kc = setInterval(function () {
          if (ke > 3) {
            kd();
            return;
          }
          T.src = kg;
          ke++;
        }, this.retryTime);
      }
      T.onload = function () {
        kd();
        if (e) {
          e(this, kf);
        }
      };
      T.onerror = function () {
        kd();
        if (bx.fetchDebug) {
          bx.fetchDebug.sendError({
            title: kg,
            msg: kg,
            category: bx.fetchDebug.category.RESOURCE,
            level: bx.fetchDebug.levels.ERROR,
            url: kg
          });
        }
        if (e) {
          e(null, kf);
        }
      };
      T.src = kg;
      return T;
    },
    rasterTileDataCbk: function (ke, kc) {
      if (!ke || typeof ke === "string") {
        this.tileCache.removeData(kc);
        return;
      }
      var i = ke.tileInfo;
      var T = i.col;
      var kk = i.row;
      var kj = i.zoom;
      var e = this.tileCache.getData(kc);
      if (!e) {
        return;
      }
      var kf = "id_" + T + "_" + kk + "_" + kj;
      var ki = this;
      e.dataType = gF;
      e.tileInfo = i;
      if (i.tileTypeName === "xyz") {
        var kh = i.tileSize;
        e.textureSource = ke;
        e.renderData = {
          vertexAll: [0, 0, 0, 0, 0, kh, 0, 0, 1, 0, kh, kh, 0, 1, 1, 0, 0, 0, 0, 0, kh, kh, 0, 1, 1, 0, kh, 0, 0, 1]
        };
        ki.setRasterTileData(kc, e, kf);
      } else {
        e.textureSource = ke;
        var kd = e0.calcLoopParam(T, kj);
        var kg = kd.geoOffsetX;
        ke.tileInfo.loopOffsetX = kg;
        e.renderData = {
          vertexAll: [0, 0, 0, 0, 0, 256, 0, 0, 1, 0, 256, 256, 0, 1, 1, 0, 0, 0, 0, 0, 256, 256, 0, 1, 1, 0, 256, 0, 0, 1]
        };
        this.setRasterTileData(kc, e, kf);
      }
    },
    setRasterTileData: function (kd, e, kc) {
      e.status = "ready";
      this.tileCache.setData(kd, e);
      var T = false;
      if (this.curViewTilesInfo[kc]) {
        e.dataType = gF;
        e.png8 = this.png8 || false;
        this.map._featureMgr.setData(e, this.drawIndex, 2);
        T = true;
      }
      if (T) {
        var i = new fJ("onrefresh");
        i.source = "webgllayer";
        this.map.dispatchEvent(i);
      }
    },
    _checkLayerTilesLoaded: function () {
      this.numTileLoading--;
      if (this.firstTileLoad === false) {
        this.dispatchEvent(new fJ("ontilesloadstart"));
        this.firstTileLoad = true;
      }
      var e = this;
      if (this.numTileLoading === 0) {
        if (this._checkTileLoadedTimer) {
          clearTimeout(this._checkTileLoadedTimer);
          this._checkTileLoadedTimer = null;
        }
        this._checkTileLoadedTimer = setTimeout(function () {
          if (e.numTileLoading === 0) {
            e.dispatchEvent(new fJ("ontilesloadend"));
            e.firstTileLoad = false;
          }
          e._checkTileLoadedTimer = null;
        }, 60);
      }
    },
    _checkTilesLoaded: function () {
      this._checkLayerTilesLoaded();
      this.numLoading--;
      if (this.map.firstTileLoad === false) {
        this.map.dispatchEvent(new fJ("onfirsttilesloaded"));
        this.map.firstTileLoad = true;
      }
      var e = this;
      if (this.numLoading === 0) {
        if (this._checkLoadedTimer) {
          clearTimeout(this._checkLoadedTimer);
          this._checkLoadedTimer = null;
        }
        this._checkLoadedTimer = setTimeout(function () {
          if (e.numLoading === 0) {
            e.map.dispatchEvent(new fJ("ontilesloaded"));
            e.map.firstTileLoad = false;
          }
          e._checkLoadedTimer = null;
        }, 60);
      }
    },
    isClickableLabel: function (e) {
      if (e.isDel) {
        return false;
      }
      if (e.zoom > 9 && !e.guid) {
        return false;
      }
      if (e.zoom <= 9 && !e.name && !e.guid) {
        return false;
      }
      return true;
    }
  };
  var aT = 5;
  var i5 = 4;
  var gy = 3;
  var M = 2;
  var eq = 1;
  var hu = 0;
  function aw(e) {
    this._ratio = gd();
    this._iconCache = {};
    this._map = e;
    this._drawingCanvasPool = [];
    this._drawingCanvasHeight = 4096;
    this._bufferSpan = [5, 5];
  }
  eX.extend(aw.prototype, {
    _loadIcons: function (T, ki, ke) {
      var kc = 0;
      var kf = this;
      var kd = this._map.config.style;
      for (var kg in T) {
        kc++;
        var kh = new Image();
        kh.id = kg;
        kh.crossOrigin = "anonymous";
        kh.onload = function () {
          kf._iconCache[this.id].loaded = true;
          kc--;
          if (kc === 0) {
            ki();
          }
          this.onload = null;
        };
        kh.onerror = function () {
          kf._iconCache[this.id] = null;
          kc--;
          if (kc === 0) {
            ki();
          }
          this.onerror = null;
        };
        if (!ke) {
          var e = B.getIconSetPath(kd) + kg + ".png";
          var i = by();
          if (i && i.udt) {
            e += "?udt=" + i.udt;
          }
        } else {
          var e = kg;
        }
        kh.src = e;
        this._iconCache[kg] = {
          loaded: false,
          image: kh
        };
      }
    },
    _getEmptyDrawingCanvas: function () {
      for (var T = 0; T < this._drawingCanvasPool.length; T++) {
        if (this._drawingCanvasPool[T]._free === true) {
          this._drawingCanvasPool[T]._free = false;
          return this._drawingCanvasPool[T];
        }
      }
      var e = this._createNewDrawingCanvas();
      this._drawingCanvasPool.push(e);
      e._free = false;
      return e;
    },
    _createNewDrawingCanvas: function () {
      var e = bX("canvas");
      e.width = 512;
      e.height = this._drawingCanvasHeight;
      e._free = true;
      e._id = bx.getGUID();
      var i = e.getContext("2d", {
        colorSpace: "display-p3"
      });
      i.textBaseline = "bottom";
      i.lineJoin = "round";
      return e;
    },
    drawLabelsOnCanvas: function (ku, kc) {
      var kk = ku.label.fixedLabel.slice(0);
      var kq = ku.label.lineLabel.slice(0);
      var T = ku.label.indoorLabel.slice(0);
      if (kk.length === 0 && kq.length === 0 && T.length === 0) {
        kc();
        return;
      }
      var kf = function (kz, i) {
        return kz.styleId - i.styleId;
      };
      kk.sort(kf);
      kq.sort(kf);
      T.sort(kf);
      var kt = {};
      var e = this._getEmptyDrawingCanvas();
      var kp = e.getContext("2d", {
        colorSpace: "display-p3"
      });
      kp.clearRect(0, 0, e.width, e.height);
      var kx = 0;
      var kl = null;
      var ke = 0;
      if (kk.length > 0) {
        while (ke < kk.length && !kk[ke].styleText[0]) {
          ke++;
        }
        if (kk[ke] && kk[ke].styleText[0]) {
          kl = kk[ke].styleText[0].fontSize + kk[ke].styleText[0].haloSize * 2;
        }
      }
      if (kl === null && T.length > 0) {
        ke = 0;
        while (ke < T.length && !T[ke].styleText[0]) {
          ke++;
        }
        if (T[ke] && T[ke].styleText[0]) {
          kl = T[ke].styleText[0].fontSize + T[ke].styleText[0].haloSize * 2;
        }
      }
      if (kl === null && kq.length > 0) {
        ke = 0;
        while (ke < kq.length && !kq[ke].styleText[0]) {
          ke++;
        }
        if (kq[ke] && kq[ke].styleText[0]) {
          kl = kq[ke].styleText[0].fontSize + kq[ke].styleText[0].haloSize * 2;
        }
      }
      if (kl === null || isNaN(kl)) {
        kc();
        return;
      }
      var kh = 0;
      var kg = kl;
      kg += this._bufferSpan[1];
      var kn = {};
      var ky = 0;
      var ko = [];
      for (var ks = 0; ks < kk.length; ks++) {
        var kj = kk[ks];
        var km = kj.name;
        var kr = kj.styleText;
        if (!km || kr.length === 0) {
          continue;
        }
        var kd = kj.icon;
        if (kj.textOnIcon && (!this._iconCache[kd] || this._iconCache[kd].loaded === false)) {
          ko.push(kj);
          ky++;
          if (!kn[kd]) {
            kn[kd] = true;
          }
          continue;
        }
        var kv = this._drawEachText(kp, kj, kx, kh, kg, kl, kt);
        if (!kv) {
          continue;
        }
        kh = kv.curX;
        kg = kv.curY;
        kl = kv.curLineHeight;
        kx = kv.styleId;
      }
      var kv = this._drawEachTypeOfLabels(kp, T, kx, kh, kg, kl, kt);
      kx = kv.curStyleId;
      kh = kv.curX;
      kg = kv.curY;
      kl = kv.curLineHeight;
      var kv = this._drawEachTypeOfLabels(kp, kq, kx, kh, kg, kl, kt);
      kx = kv.curStyleId;
      kh = kv.curX;
      kg = kv.curY;
      kl = kv.curLineHeight;
      if (ky > 0) {
        var kw = this;
        this._loadIcons(kn, function () {
          kv = kw._drawEachTypeOfLabels(kp, ko, kx, kh, kg, kl, kt);
          kx = kv.curStyleId;
          kh = kv.curX;
          kg = kv.curY;
          kl = kv.curLineHeight;
          var i = kw._generateEachLabelCanvas(e, kg, kk, kq, T, ku);
          kc(i[0], i[1]);
        });
        return;
      }
      var ki = this._generateEachLabelCanvas(e, kg, kk, kq, T, ku);
      kc(ki[0], ki[1]);
    },
    drawCustomLabelsOnCanvas: function (kf, km) {
      if (kf.length === 0) {
        km();
        return;
      }
      var T = 0 + this._bufferSpan[0];
      var e = kf[0].style.fontSize + (kf[0].style.haloSize || 0) * 2 + this._bufferSpan[1] || 0;
      var kc = e - this._bufferSpan[1];
      var kh = this._getEmptyDrawingCanvas();
      var ko = kh.getContext("2d", {
        colorSpace: "display-p3"
      });
      ko.clearRect(0, 0, kh.width, kh.height);
      var ki = {};
      var kk = -1;
      var kd = {};
      var kl = false;
      for (var ke = 0; ke < kf.length; ke++) {
        var kg = null;
        if (kf[ke].textOnIcon && kf[ke].icon) {
          kg = kf[ke].icon;
        }
        if (kg && !kd[kg] && (!this._iconCache[kg] || this._iconCache[kg].loaded === false)) {
          kd[kg] = true;
          kl = true;
        }
      }
      var kn = this;
      if (kl) {
        this._loadIcons(kd, function () {
          kj();
        }, true);
      } else {
        kj();
      }
      function kj() {
        for (var kr = 0; kr < kf.length; kr++) {
          if (!kf[kr].name) {
            continue;
          }
          var ks = kn._drawEachText(ko, kf[kr], kk, T, e, kc, ki);
          if (!ks) {
            continue;
          }
          T = ks.curX + kn._bufferSpan[0];
          e = ks.curY;
          kc = ks.curLineHeight;
          kk = ks.styleId;
        }
        var kq = e;
        var kp = kn._copyToNewCanvas(kh, kq + kn._bufferSpan[0]);
        for (var kr = 0; kr < kf.length; kr++) {
          if (!kf[kr].name && kf[kr].style.iconSize) {
            kn._addFixedLabelBounds(kf[kr]);
            continue;
          }
          if (!kf[kr].textSize) {
            continue;
          }
          kn._updateFixedLabelCoords(kf[kr], kq + kn._bufferSpan[0]);
          kn._addFixedLabelBounds(kf[kr]);
        }
        km(kp);
      }
    },
    _drawEachTypeOfLabels: function (kl, kf, kj, kc, T, kd, kh) {
      for (var ke = 0; ke < kf.length; ke++) {
        var kg = kf[ke];
        var kk = kg.name;
        var e = kg.styleText;
        if (!kk || e.length === 0) {
          continue;
        }
        var ki = this._drawEachText(kl, kg, kj, kc, T, kd, kh);
        if (!ki) {
          continue;
        }
        kc = ki.curX + this._bufferSpan[0];
        T = ki.curY;
        kd = ki.curLineHeight;
        kj = ki.styleId;
        if (ki.curY > this._drawingCanvasHeight) {
          return {
            curX: kc,
            curY: T,
            curLineHeight: kd,
            curStyleId: kj
          };
        }
      }
      return {
        curX: kc,
        curY: T,
        curLineHeight: kd,
        curStyleId: kj
      };
    },
    _drawIndoorTextLabelOnCanvas: function (kd) {
      var e = this._getEmptyDrawingCanvas();
      var kk = e.getContext("2d", {
        colorSpace: "display-p3"
      });
      kk.clearRect(0, 0, e.width, e.height);
      var ks = 0;
      var kj = null;
      var ki = 0;
      var kg;
      var kp = {};
      var ko = [];
      for (var ke in kd) {
        if (ke === "tileInfo") {
          continue;
        }
        var kc = kd[ke];
        var kn = kc.defaultFloor;
        var kh = kc.floors;
        for (var km = 0; km < kh.length; km++) {
          if (km === kn) {
            continue;
          }
          var kq = kh[km];
          if (!kq.pois) {
            continue;
          }
          var kf = kq.pois;
          for (var kl = 0; kl < kf.length; kl++) {
            if (kj === null && kf[kl].styleText[0]) {
              kj = kf[kl].styleText[0].fontSize + kf[kl].styleText[0].haloSize * 2;
              kg = kj;
            }
            ko.push(kf[kl]);
          }
        }
      }
      if (kj === null) {
        return null;
      }
      ko.sort(function (kt, i) {
        return i.rank - kt.rank || kt.styleId - i.styleId;
      });
      var kr = this._drawEachTypeOfLabels(kk, ko, ks, ki, kg, kj, kp);
      ks = kr.curStyleId;
      ki = kr.curX;
      kg = kr.curY;
      kj = kr.curLineHeight;
      var T = this._copyToNewCanvas(e, kg);
      return T;
    },
    _updateIndoorLabelsCoords: function (kj, kk) {
      for (var ki in kj) {
        if (ki === "tileInfo") {
          continue;
        }
        var e = kj[ki];
        var ke = e.defaultFloor;
        var kf = e.floors;
        for (var kg = 0; kg < kf.length; kg++) {
          if (kg === ke) {
            continue;
          }
          var T = kf[kg];
          if (!T.pois) {
            continue;
          }
          var kd = T.pois;
          for (var kc = 0; kc < kd.length; kc++) {
            var kh = kd[kc];
            if (kh.name && (!kh.textSize || kh.textSize.length === 0)) {
              kd.splice(kc, 1);
              kc--;
              continue;
            }
            this._updateFixedLabelCoords(kh, kk);
            this._addFixedLabelBounds(kh);
          }
        }
      }
    },
    _generateEachLabelCanvas: function (kf, ke, kg, e, ki, T) {
      ke = Math.min(ke, this._drawingCanvasHeight);
      var kh = this._copyToNewCanvas(kf, ke);
      var kc = null;
      if (T.renderData.indoorData) {
        kc = this._drawIndoorTextLabelOnCanvas(T.renderData.indoorData);
        if (kc) {
          this._updateIndoorLabelsCoords(T.renderData.indoorData, kc.height);
        }
      }
      for (var kd = 0; kd < kg.length; kd++) {
        if (!kg[kd].textSize) {
          continue;
        }
        this._updateFixedLabelCoords(kg[kd], ke);
        this._addFixedLabelBounds(kg[kd]);
      }
      for (var kd = 0; kd < ki.length; kd++) {
        if (!ki[kd].textSize) {
          continue;
        }
        this._updateFixedLabelCoords(ki[kd], ke);
        this._addFixedLabelBounds(ki[kd]);
      }
      for (var kd = 0; kd < e.length; kd++) {
        this._updateLineLabelCoords(e[kd], ke);
      }
      return [kh, kc];
    },
    _copyToNewCanvas: function (T, i) {
      if (i === 0) {
        return null;
      }
      var kc = bX("canvas");
      kc.width = T.width;
      kc.height = i;
      var e = kc.getContext("2d", {
        colorSpace: "display-p3"
      });
      e.drawImage(T, 0, 0, 512, i, 0, 0, 512, i);
      kc._id = T._id;
      T._free = true;
      return kc;
    },
    _drawEachText: function (ku, kg, T, kw, kv, kD, kd) {
      var kC = kg.name;
      var kl = kg.styleText ? kg.styleText[0] : kg.style;
      if (!kl) {
        return null;
      }
      var ko = kl.fontSize;
      var kH = kl.fontWeight;
      var kU = kl.haloSize || 0;
      if (!kp) {}
      if (kl.fontRgba) {
        var k0 = kl.fontRgba[3] / 255;
        var kk = [];
        kk[3] = k0;
        for (var kZ = 0; kZ < 3; kZ++) {
          kk[kZ] = kl.fontRgba[kZ];
        }
      }
      if (kl.haloRgba) {
        var k0 = kl.haloRgba[3] / 255;
        var kr = [];
        kr[3] = k0;
        for (var kZ = 0; kZ < 3; kZ++) {
          kr[kZ] = kl.haloRgba[kZ];
        }
      }
      var kO = kk ? "rgba(" + kk.join(",") + ")" : kl.color;
      var kf = kr ? "rgba(" + kr.join(",") + ")" : kl.strokeColor;
      var kW = kg.styleId || 0;
      if (kU > 4) {
        kU = 4;
      }
      var kE = [];
      var kt = [];
      var kA = 0;
      if (kd && !kd[kW]) {
        kd[kW] = {};
      }
      var kn = ko + kU * 2;
      var kF = kn;
      if (kg.containDescendings) {
        kF += 4;
      }
      if (kU === 0) {
        kF += 2;
      }
      if (kg.textOnIcon) {
        kF = Math.max(kF, kg.iconSize[1]);
      }
      if (kW !== T || kF > kD) {
        T = kW;
        if (kH >= 10 && kH % 10 === 0) {
          ku.font = kH * 10 + " " + ko + "px sans-serif";
        } else {
          ku.font = ko + "px sans-serif";
        }
        if (kF > kD) {
          var kB = kF - kD;
          kD += kB;
          kv += kB;
        }
        if (kU > 0) {
          ku.lineWidth = kU * 2;
          ku.strokeStyle = kf;
        }
        ku.fillStyle = kO;
      }
      if (kg.type === "line") {
        var ki = kC.split("");
        for (var kX = 0; kX < ki.length; kX++) {
          var kQ = ki[kX];
          var kx;
          var kI;
          if (kd[kW][kQ]) {
            var kp = kd[kW][kQ];
            kx = kp.displaySize;
            kI = kp.curWordPosition;
          } else {
            var kc = Math.ceil(ku.measureText(kQ).width);
            if (kw + kc > 512) {
              kw = 0 + this._bufferSpan[0];
              kv += kF;
              kv += this._bufferSpan[1];
              kD = kF;
            }
            if (kv > this._drawingCanvasHeight) {
              return {
                curX: kw,
                curY: kv,
                curLineHeight: kD,
                styleId: kW
              };
            }
            var kR = kw;
            if (kU > 0) {
              kc += kU;
              kR -= Math.round(kU / 2);
              ku.strokeText(kQ, kw, kv);
            }
            ku.fillText(kQ, kw, kv);
            var kN = [kc, kF];
            kx = [Math.round(kN[0] / 2), Math.round(kN[1] / 2)];
            kI = [kR, kv - kF];
            kd[kW][kQ] = {
              displaySize: kx,
              curWordPosition: kI,
              totalHeight: kA
            };
            kw += kc + 2;
          }
          kE.push(kx);
          kt.push(kI);
        }
        kA = Math.round(kE[0][1]);
      } else if (kd[kW][kC]) {
        var kp = kd[kW][kC];
        kE = kp.textSize;
        kt = kp.labelImagePosition;
        kA = kp.totalHeight;
      } else {
        var kq = kC.split("\\");
        if (kq.length > 1 && kg.textOnIcon) {
          var kY = 0;
          var kV = 0;
          var k1 = [];
          var ky = 8;
          for (var kX = 0; kX < kq.length; kX++) {
            var kC = kq[kX];
            var km = Math.ceil(ku.measureText(kC).width);
            if (km > kY) {
              kY = km;
            }
            k1.push(Math.round(km / 2));
            kV += kF;
          }
          var kj = kY + 2 * ky;
          var kT = kV + 2 * ky;
          if (kw + kj > 512) {
            kw = 0 + this._bufferSpan[0];
            kv += kD;
            kv += this._bufferSpan[1];
          }
          kv += kV - kF + 2 * ky;
          var kM = kw;
          var kz = kv - kT;
          var e = Math.round(kj / 2);
          var ks = this._iconCache[kg.icon].image;
          this.drawStretchedIcon(ku, ks, [kM, kz], ky, kY, kV);
          for (var kX = 0; kX < kq.length; kX++) {
            var kC = kq[kX];
            var kS = kM + (e - k1[kX]);
            var kP = kz + 4 + (kX + 1) * kF;
            ku.fillText(kC, kS, kP);
          }
          kE.push([Math.round(kj / 2), Math.round(kT / 2)]);
          kt.push([kM, kz]);
          kw += kj;
          kD = kT;
          kA = Math.round(kT / 2);
        } else {
          for (var kX = 0; kX < kq.length; kX++) {
            var kC = kq[kX];
            var km = Math.ceil(ku.measureText(kC).width);
            var kj = km;
            var ke = 0;
            if (kg.textOnIcon) {
              ke = 10;
              kj += ke * 2;
              if (kg.styleId === 519) {
                kj = kg.iconSize[0];
                ke = Math.round((kj - km) / 2);
              }
            }
            if (kw + kj > 512) {
              kw = 0 + this._bufferSpan[0];
              kv += kF;
              kv += this._bufferSpan[1];
              kD = kF;
            }
            if (kv > this._drawingCanvasHeight) {
              return {
                curX: kw,
                curY: kv,
                curLineHeight: kD,
                styleId: kW
              };
            }
            var kM = kw;
            var kz = kv - kF;
            var kL = kw;
            var kK = kv;
            if (kg.containDescendings) {
              kK -= 4;
            }
            if (kg.textOnIcon) {
              var kG = false;
              var ks = this._iconCache[kg.icon].image;
              var kJ = kg.iconSize.concat([]);
              if (kn >= kJ[1]) {
                kJ[1] = kn;
                kG = true;
                kF += ke * 2;
                var kB = kF - kD;
                if (kB > 0) {
                  kv += kB;
                  kD = kF;
                  kK += kB - ke;
                  kz += kB - ke * 2;
                } else {
                  kK -= ke;
                  kz -= ke * 2;
                }
              }
              if (km >= kJ[0]) {
                kJ[0] = km;
              }
              if (kg.styleId === 519) {
                ku.drawImage(ks, 0, 0, kJ[0], kJ[1], kM, kz, kJ[0], kJ[1]);
              } else if (kG) {
                this.drawStretchedIcon(ku, ks, [kM, kz], ke, km, kJ[1]);
              } else {
                this.draw3StretchedIcon(ku, ks, [kM, kz], ke, km, kJ[1]);
              }
              kL += ke;
              if (kg.iconSize[1] > kn) {
                kK -= (kg.iconSize[1] - kn) / 2 - 1;
              }
              kj += 1;
            }
            if (kU > 0) {
              if (kW === 71028) {
                kF -= 2;
              }
              if (kW === 32) {
                kF -= 2;
              }
              ku.strokeText(kC, kL, kK);
            }
            ku.fillText(kC, kL, kK);
            var kh = [kj, kF];
            var kx = [Math.round(kh[0] / 2), Math.round(kh[1] / 2)];
            kE.push(kx);
            kt.push([kM, kz]);
            kA += Math.round(kx[1]);
            kw += kj;
          }
        }
        kd[kW][kC] = {
          textSize: kE,
          labelImagePosition: kt,
          totalHeight: kA
        };
      }
      kg.textSize = kE;
      kg.labelImagePosition = kt;
      kg.totalHeight = kA;
      return {
        curX: kw,
        curY: kv,
        curLineHeight: kD,
        styleId: kW
      };
    },
    drawStretchedIcon: function (e, T, kc, kf, kg, i) {
      var ke = kc[0];
      var kd = kc[1];
      e.drawImage(T, 0, 0, kf, kf, ke, kd, kf, kf);
      e.drawImage(T, kf, 0, 1, kf, ke + kf, kd, kg, kf);
      e.drawImage(T, T.width - kf, 0, kf, kf, ke + kg + kf, kd, kf, kf);
      e.drawImage(T, 0, kf, kf, 1, ke, kd + kf, kf, i);
      e.drawImage(T, kf, kf, 1, 1, ke + kf, kd + kf, kg, i);
      e.drawImage(T, T.width - kf, kf, kf, 1, ke + kg + kf, kd + kf, kf, i);
      e.drawImage(T, 0, T.height - kf, kf, kf, ke, kd + i + kf, kf, kf);
      e.drawImage(T, kf, T.height - kf, 1, kf, ke + kf, kd + i + kf, kg, kf);
      e.drawImage(T, T.width - kf, T.height - kf, kf, kf, ke + kg + kf, kd + i + kf, kf, kf);
    },
    draw3StretchedIcon: function (e, i, T, ke, kg, kf) {
      var kd = T[0];
      var kc = T[1];
      e.drawImage(i, 0, 0, ke, i.height, kd, kc, ke, i.height);
      e.drawImage(i, ke, 0, 1, i.height, kd + ke, kc, kg, i.height);
      e.drawImage(i, i.width - ke, 0, ke, i.height, kd + ke + kg, kc, ke, i.height);
    },
    _updateFixedLabelCoords: function (kd, ks) {
      if (ks === 0) {
        return;
      }
      var kn = [];
      var kz = [];
      var kA = 0;
      var kq = kd.totalHeight;
      var kI = kd.textSize.length;
      var ke = kd.direction;
      if (typeof ke !== "number") {
        ke = 0;
      }
      for (var kB = 0; kB < kI; kB++) {
        var kt = kd.labelImagePosition[kB];
        var kr = kd.textSize[kB];
        var kp = kt[0];
        var kc = kt[1];
        var kf = kr[0];
        var kk = kr[1];
        var km = 0;
        var ky = 0;
        if (typeof kd.textMargin === "number") {
          ky = kd.textMargin;
        }
        var kl;
        var e;
        var kh = 0;
        var ko = 0;
        if (!kd.iconPos) {
          if (!kd.custom) {
            ke = i5;
          }
        } else {
          kh = kd.iconPos.width;
          ko = kd.iconPos.height;
        }
        switch (ke) {
          case gy:
            var T = kq / 2 - kk + km * (kI - 1) / 2;
            kl = Math.round(-kh / 2 - kf - ky);
            e = Math.round(T - kA - km * kB);
            break;
          case eq:
            var T = kq / 2 - kk + km * (kI - 1) / 2;
            kl = Math.round(kh / 2 + ky);
            e = Math.round(T - kA - km * kB);
            break;
          case M:
            var T = ko / 2 + kq - kk + km * kI;
            kl = Math.round(-kf / 2);
            e = Math.round(T - kA - km * kB);
            break;
          case hu:
            var T = -ko / 2 - km - kk;
            kl = Math.round(-kf / 2);
            e = Math.round(T - kA - km * kB);
            break;
          case i5:
            var T = -kq / 2 - km * (kI - 1) / 2;
            kl = Math.round(-kf / 2);
            e = Math.round(T - kA - km * kB);
            break;
        }
        kA += kk;
        var kj = kl + kf;
        var kJ = e;
        var ki = kj;
        var kH = kJ + kk;
        var kg = kl;
        var kG = kH;
        kn.push(kl, e, kj, kJ, ki, kH, kl, e, ki, kH, kg, kG);
        var kF = kp / 512;
        var kx = (ks - kc - kk * 2) / ks;
        var kE = (kp + kf * 2) / 512;
        var kw = kx;
        var kD = kE;
        var kv = (ks - kc) / ks;
        var kC = kF;
        var ku = kv;
        kz.push(kF, kx, kE, kw, kD, kv, kF, kx, kD, kv, kC, ku);
      }
      if (!kd.textPos) {
        kd.textPos = {};
      }
      kd.textPos.vertex = kn;
      kd.textPos.texcoord = kz;
    },
    _addFixedLabelBounds: function (ki) {
      var ke = 1000;
      var kc = 1000;
      var T = -1000;
      var e = -1000;
      if (ki.iconPos) {
        var kg = ki.iconPos.vertex;
        for (var kh = 0, kd = kg.length; kh < kd; kh += 2) {
          var km = kg[kh];
          var kk = kg[kh + 1];
          if (km < ke) {
            ke = km;
          }
          if (km > T) {
            T = km;
          }
          if (kk < kc) {
            kc = kk;
          }
          if (kk > e) {
            e = kk;
          }
        }
      }
      if (ki.custom && ki.style.iconSize && !ki.name) {
        var kj = ki.style.iconSize;
        var kl = ki.direction;
        switch (kl) {
          case i5:
            ke = -Math.round(kj[0] / 2);
            kc = -Math.round(kj[1] / 2);
            T = Math.round(kj[0] / 2);
            e = Math.round(kj[1] / 2);
            break;
          case M:
            ke = -Math.round(kj[0] / 2);
            kc = 0;
            T = Math.round(kj[0] / 2);
            e = kj[1];
            break;
        }
      }
      if (ki.textPos) {
        var kf = ki.textPos.vertex;
        for (var kh = 0, kd = kf.length; kh < kd; kh += 2) {
          var km = kf[kh];
          var kk = kf[kh + 1];
          if (km < ke) {
            ke = km;
          }
          if (km > T) {
            T = km;
          }
          if (kk < kc) {
            kc = kk;
          }
          if (kk > e) {
            e = kk;
          }
        }
      }
      ki.bds = [ke, kc, T, e];
    },
    _updateLineLabelCoords: function (kt, kj) {
      if (kj === 0) {
        return;
      }
      var kc = kt.wordsInfo;
      var kq = kt.wordCount;
      if (!kt.labelImagePosition) {
        return;
      }
      var kl = kt.labelImagePosition.slice(0);
      if (kt.reverse) {
        kl.reverse();
      }
      var kC = 1000;
      var kz = 1000;
      var kA = -1000;
      var ky = -1000;
      for (var ku = 0; ku < kq; ku++) {
        var kD = kl[ku];
        var kB = kD[0];
        var kr = kD[1];
        var kp = kt.textSize[ku];
        var ki = kp[0];
        var e = kp[1];
        var kh = kB / 512;
        var ko = (kj - kr - e * 2) / kj;
        var kf = (kB + ki * 2) / 512;
        var kn = ko;
        var kd = kf;
        var km = (kj - kr) / kj;
        var T = kh;
        var kk = km;
        kc[ku].size = [ki, e];
        kc[ku].texcoord = [kh, ko, kf, kn, kd, km, kh, ko, kd, km, T, kk];
        var kx = kc[ku].offset[0];
        var kw = kc[ku].offset[1];
        var kv = kx - ki / 2;
        var kg = kw + e / 2;
        var ke = kw - e / 2;
        var ks = kx + ki / 2;
        if (kv < kC) {
          kC = kv;
        }
        if (ks > kA) {
          kA = ks;
        }
        if (ke < kz) {
          kz = ke;
        }
        if (kg > ky) {
          ky = kg;
        }
      }
      kt.bds = [kC, kz, kA, ky];
    }
  });
  var f1 = {
    0: "00000000",
    16: "00010000",
    32: "00100000",
    48: "00110000",
    64: "01000000",
    96: "01100000"
  };
  function eh(T, kc, kd) {
    var e = T.bds;
    if (!e) {
      return false;
    }
    var i = T.tracer;
    var kg;
    if (i) {
      if (!f1[i]) {
        kg = i.toString(2);
        if (kg.length < 8) {
          kg = new Array(8 - kg.length + 1).join("0") + kg;
        }
        f1[i] = kg;
      }
      kg = f1[i];
      var kf = j7.mapZoomStartZoomMapping[kc];
      return kg[kc - kf] === "1";
    }
    var ke = T.displayRange;
    if (kd >= ke[0] && kd <= ke[1]) {
      return true;
    }
    return false;
  }
  function jb(i, e) {
    this.map = i.map;
    this.layer = i;
    e = e || [];
    this.allLabels = [];
    this._spotData = [];
    this._strategyInfo = null;
    this.RANK1 = 1000000;
    this.RANK2 = 2000000;
    this.RANK3 = 3000000;
    this.RANK4 = 4000000;
    this.RANK5 = 5000000;
    this._ratio = gd();
    this._useRound = true;
    this._sharpenRender = false;
    if (this._ratio > hK.HIGH_RES_MIN_RATIO) {
      this._useRound = false;
      this._sharpenRender = true;
    }
    this._mapIsMoving = false;
    this._onMapIdleCallback = e.onMapIdleCallback;
    this.map.temp.isPermitSpotOver = true;
    this.currentSelectedLabel = null;
    this.map._labelProcessor = this;
    this.iconCache = new az(bW() || eX.Browser.ie ? 64 : 128, {
      clearCallback: function (T) {}
    });
    this.fixedLabelData = [];
    this.lineLabelData = [];
    this.highlightLabelData = [];
    this._iconLoadTimer = null;
    this._labelTextCanvas = null;
    if (this.map.config.textRenderType === "canvas") {
      this._labelTextCanvas = this.map.tileMgr.getLabelTextCanvas();
    }
    this.bind();
  }
  eX.extend(jb.prototype, {
    bind: function () {
      var T = this.map;
      var i = this;
      T.addEventListener("mapstatusbusy_inner", function (kc) {
        i._mapIsMoving = true;
        if (i._ratio > hK.HIGH_RES_MIN_RATIO) {
          i._sharpenRender = false;
        } else {
          i._useRound = false;
        }
      });
      T.addEventListener("mapstatusidle_inner", function (kc) {
        if (i._ratio > hK.HIGH_RES_MIN_RATIO) {
          i._sharpenRender = true;
        } else {
          i._useRound = true;
        }
        i._mapIsMoving = false;
      });
      T.addEventListener("onspotmouseover", function (ke) {
        if (!this.temp.isPermitSpotOver) {
          return;
        }
        if (ke.spots.length > 0) {
          var kd = ke.spots[0].userdata.uid;
          var kf = ke.spots[0].userdata.tilePosStr;
          var kc = i.getLabelByUid(kd, kf);
          if (kc && kc.formatedData) {
            i._toHighlightColor(kc.formatedData);
          }
        }
      });
      T.addEventListener("onspotmouseout", function (ke) {
        if (!this.temp.isPermitSpotOver) {
          return;
        }
        if (ke.spots.length > 0) {
          var kd = ke.spots[0].userdata.uid;
          var kf = ke.spots[0].userdata.tilePosStr;
          var kc = i.getLabelByUid(kd, kf);
          if (kc && kc.formatedData) {
            i._toDefaultColor(kc.formatedData);
          }
        }
      });
      T.addEventListener("spotclick", function (ke) {
        if (ke.spots && ke.spots.length > 0) {
          if (ke.spots[0].userdata.zoom < 10) {
            return;
          }
          var kd = ke.spots[0].userdata.uid;
          var kf = ke.spots[0].userdata.tilePosStr;
          if (i.currentSelectedLabel && (i.currentSelectedLabel.uid !== kd || i.currentSelectedLabel.tilePosStr !== kf)) {
            i._recoverNormalState();
          }
          var kc = i.getLabelByUid(kd, kf);
          if (kc) {
            i._changeBaseMapState(kc);
          }
        } else {
          i._recoverNormalState();
        }
      });
      T.on("spot_status_reset", function () {
        i._recoverNormalState();
      });
      T.on("spot_highlight", function (kd) {
        var kc = i.getLabelByUid(kd.uid, kd.tilePosStr);
        if (kc && kc.formatedData) {
          i._toHighlightColor(kc.formatedData);
        }
      });
      T.addEventListener("mousemove", function (kc) {
        if (i.curSpotAdded) {
          return;
        }
        if (this.currentOperation !== ed.idle || i._mapIsMoving === true) {
          return;
        }
        i._refreshSpotData();
        this.temp.isPermitSpotOver = true;
        i.curSpotAdded = true;
      });
      if (bW()) {
        function e() {
          i._refreshSpotData();
        }
        T.addEventListener("mapstatusidle_inner", e);
      }
      T.on("style_loaded", function () {
        if (i.map.config.textRenderType === "canvas" && !i._labelTextCanvas) {
          i._labelTextCanvas = i.map.tileMgr.getLabelTextCanvas();
        }
      });
      T.on("destroy", function () {
        i.iconCache.clear();
        i.fixedLabelData = [];
        i.lineLabelData = [];
        i.highlightLabelData = [];
        for (var kc = 0; kc < i.allLabels.length; kc++) {
          i.allLabels[kc]._mcBds = null;
        }
        i.allLabels = [];
        for (var kc = 0; kc < i._spotData.length; kc++) {
          i._spotData[kc].pt = null;
          i._spotData[kc].userdata.iconPoint = null;
        }
        i._spotData = [];
      });
    },
    getLabelByUid: function (kg, kh) {
      var e = this.map._featureMgr.getResult().tileLabels[this.layer.drawIndex] || [];
      for (var kf = 0; kf < e.length; kf++) {
        var kc = e[kf].fixedLabel;
        for (var ke = 0; ke < kc.length; ke++) {
          if (e[kf].fixedLabel[ke].guid === kg && e[kf].fixedLabel[ke].tilePosStr === kh) {
            return e[kf].fixedLabel[ke];
          }
        }
        var kd = e[kf].indoorLabel;
        for (var T = 0; T < kd.length; T++) {
          if (e[kf].indoorLabel[T].guid === kg && e[kf].indoorLabel[T].tilePosStr === kh) {
            return e[kf].indoorLabel[T];
          }
        }
      }
      return null;
    },
    getTileByLabelUid: function (kg) {
      var e = this.map._featureMgr.getResult().tileLabels[this.layer.drawIndex] || [];
      for (var kf = 0; kf < e.length; kf++) {
        var kc = e[kf].fixedLabel;
        for (var ke = 0; ke < kc.length; ke++) {
          if (e[kf].fixedLabel[ke].guid === kg) {
            return e[kf];
          }
        }
        var kd = e[kf].indoorLabel;
        for (var T = 0; T < kd.length; T++) {
          if (e[kf].indoorLabel[T].guid === kg) {
            return e[kf];
          }
        }
      }
      return null;
    },
    _toHighlightColor: function (T) {
      if (T.tempRank && T.tempRank === this.RANK5) {
        return;
      }
      var e = this.map._featureMgr.getResult().eleData[4][this.layer.drawIndex] || [];
      var kd = false;
      for (var kc = 0; kc < e.length; kc++) {
        if (e[kc] === T || e[kc].guid === T.guid && e[kc].tilePosStr === T.tilePosStr && e[kc].zoom === T.zoom) {
          kd = true;
          break;
        }
      }
      if (kd) {
        return;
      }
      e.push(T);
      this.map._featureMgr.setOverlayData(e, 4, this.layer.drawIndex);
      this.map.dispatchEvent(new fJ("onrefresh"));
    },
    _toDefaultColor: function (T) {
      if (T.tempRank && T.tempRank === this.RANK5) {
        return;
      }
      var e = this.map._featureMgr.getResult().eleData[4][this.layer.drawIndex] || [];
      for (var kc = 0; kc < e.length; kc++) {
        if (T === e[kc] || T.guid === e[kc].guid && T.tilePosStr === e[kc].tilePosStr && T.zoom === e[kc].zoom) {
          e.splice(kc, 1);
          break;
        }
      }
      this.map._featureMgr.setOverlayData(e, 4, this.layer.drawIndex);
      this.map.dispatchEvent(new fJ("onrefresh"));
    },
    _changeBaseMapState: function (i) {
      var kd = i.guid;
      var kh = i.formatedData.guidExt;
      var ki = {
        guid: kd,
        tilePosStr: i.tilePosStr,
        guidExt: kh
      };
      this._strategyInfo = ki;
      this.currentSelectedLabel = i;
      var kc = this.map._featureMgr;
      var e = kc.getLabelData(this.layer.drawIndex);
      e = this.collisionTest(e);
      this.updateLabels(e);
      var kj = this.fixDataFormat(e);
      kc.setOverlayData(kj[0], 2, this.layer.drawIndex);
      kc.setOverlayData(kj[1], 3, this.layer.drawIndex);
      kc.setOverlayData(kj[2], 4, this.layer.drawIndex);
      var T = this.getTileByLabelUid(kd);
      this.currentSelectedLabel.tileInfo = T.tileInfo;
      var kg = this.layer.tileCache.getAllData();
      for (var kf in kg) {
        var ke = kg[kf].data;
        if (!ke.label) {
          continue;
        }
        this.clearCollisionCache(ke.label);
      }
      this.map.dispatchEvent(new fJ("onrefresh"));
    },
    _recoverNormalState: function () {
      this._strategyInfo = null;
      var kg = false;
      var ke = this.map._featureMgr.getLabelData(this.layer.drawIndex);
      if (this.currentSelectedLabel) {
        var T = this.currentSelectedLabel.guid;
        this.clearCollisionCache(this.getTileByLabelUid(T));
        var kd = this.layer.tileCache.getAllData();
        for (var kc in kd) {
          if (Object.prototype.hasOwnProperty.call(kd, kc)) {
            var kf = kd[kc].data;
            if (!kf.label) {
              continue;
            }
            this.clearCollisionCache(kf.label);
          }
        }
        this.currentSelectedLabel.tempRank = null;
        this.currentSelectedLabel = null;
        kg = true;
      }
      ke = this.collisionTest(ke);
      this.updateLabels(ke);
      var e = this.fixDataFormat(ke);
      var i = this.map._featureMgr;
      i.setOverlayData(e[0], 2, this.layer.drawIndex);
      i.setOverlayData(e[1], 3, this.layer.drawIndex);
      i.setOverlayData([], 4, this.layer.drawIndex);
      this.map.dispatchEvent(new fJ("onrefresh"));
      if (kg) {
        this.curSpotAdded = false;
        this._refreshSpotData();
      }
    },
    loadIconImages: function (kp, kf, T) {
      var ko = kp.label;
      var kr = kp.tileInfo.style;
      var kd = ko.fixedLabel;
      if (T === "indoor") {
        kd = [];
      }
      var kn = ko.indoorLabel;
      var km = kd.length + kn.length;
      var ks = this;
      var kq = 0;
      var kk = 200;
      for (var kl = 0; kl < km; kl++) {
        var ki;
        if (kl < kd.length) {
          ki = kd[kl];
        } else {
          ki = kn[kl - kd.length];
        }
        if (!ki.iconPos) {
          var kh = this.loadSVGSymbol(ki, kr);
          if (!kh) {
            continue;
          } else if (kh !== true) {
            var kg = ki.iconPos.iconType;
            var e = kr + "_" + kg;
            this.iconCache.setData(e, {
              loaded: false,
              image: kh
            });
            ki.iconPos.img = kh;
          }
        }
        var kg = ki.iconPos.iconType;
        var e = kr + "_" + kg;
        kq++;
        if (this.iconCache.getData(e)) {
          if (this.iconCache.getData(e).loaded) {
            kf(kp);
          } else if (ki.iconPos.img) {
            ki.iconPos.img.id = e;
            ki.iconPos.img.iconUrl = kg;
            this.iconCache.setData(e, {
              loaded: true,
              image: ki.iconPos.img
            });
            this._addToIconTexture(ki.iconPos.img);
            kf(kp);
          }
          continue;
        }
        if (!T || T === "indoor") {
          var ke = B.getIconSetPath(this.map.config.style) + kg + ".png";
          var kj = by();
          if (kj && kj.udt) {
            ke += "?udt=" + kj.udt;
          }
        } else {
          var ke = kg;
        }
        var kc = new Image();
        kc.id = e;
        kc.iconUrl = ke;
        kc.crossOrigin = "anonymous";
        kc.onload = function () {
          if (ks.iconCache.getData(this.id)) {
            ks.iconCache.getData(this.id).loaded = true;
            ks._addToIconTexture(this);
          }
          if (ks._iconLoadTimer === null) {
            ks._iconLoadTimer = setTimeout(function () {
              kf();
              ks._iconLoadTimer = null;
            }, kk);
          }
          this.onload = null;
        };
        kc.onerror = function () {
          if (!ks._iconLoadTimer) {
            ks._iconLoadTimer = setTimeout(function () {
              kf();
              ks._iconLoadTimer = null;
            }, kk);
          }
          ks.iconCache.removeData(this.id);
          this.onerror = null;
          if (bx.fetchDebug) {
            bx.fetchDebug.sendError({
              title: this.iconUrl,
              msg: this.iconUrl,
              category: bx.fetchDebug.category.RESOURCE,
              level: bx.fetchDebug.levels.ERROR,
              url: this.iconUrl
            });
          }
        };
        kc.src = ke;
        this.iconCache.setData(e, {
          loaded: false,
          image: kc
        });
      }
      return kq;
    },
    _addToIconTexture: function (ke) {
      if (!this.map._webglMapScene) {
        return;
      }
      var kg = this.map._webglMapScene._painter;
      var e = kg._iconTextureAtlas.addTexture(ke);
      kg._iconTextureAtlasOffset[ke.id] = e;
      var kj = 0 * ke.width / 1024 + e.width;
      var kd = 0 * ke.height / 1024 + e.height;
      var ki = ke.width / 1024 + e.width;
      var kc = kd;
      var kh = ki;
      var T = ke.height / 1024 + e.height;
      var kf = kj;
      var i = T;
      kg._iconTextureAtlasCoords[ke.id] = [kj, kd, ki, kc, kh, T, kj, kd, kh, T, kf, i];
    },
    loadSVGSymbol: function (kc, T) {
      var i = kc.symbol || {};
      var kf = dK.generateKey(i.path, i);
      if (!kf) {
        return null;
      }
      var ke = this.iconCache.getData(T + "_" + kf);
      if (ke && ke.loaded) {
        kc.iconPos = this.createVertex(ke.image.width / 2, ke.image.height / 2, kf);
        return true;
      }
      var kd = new dK(i.path, i);
      kd.add();
      var e = kd.render();
      if (!e) {
        return null;
      }
      kc.iconPos = this.createVertex(kd.size.width, kd.size.height, kf);
      return kd.data;
    },
    createVertex: function (ke, ki, T) {
      var kd = Math.round(-ke / 2);
      var kk = Math.round(-ki / 2);
      var kc = kd + ke;
      var kj = kk;
      var i = kc;
      var kh = kj + ki;
      var e = kd;
      var kg = kh;
      var kf = {
        vertex: [kd, kk, kc, kj, i, kh, kd, kk, i, kh, e, kg],
        texcoord: null,
        width: ke,
        height: ki,
        iconType: T
      };
      return kf;
    },
    loadImgByStr: function (kc, kd, ke) {
      if (!kc && !kd) {
        if (ke) {
          ke(null, null);
        }
        return;
      }
      if (typeof kc === "object" && typeof kd === "object") {
        ke(kc, kd);
        return;
      }
      var i = 0;
      var T = null;
      var e = null;
      if (kc) {
        i++;
        T = new Image();
        T.onload = function () {
          i--;
          if (i === 0) {
            if (ke) {
              ke(this, e);
            }
          }
          this.onload = null;
        };
        T.src = kc;
      }
      if (kd) {
        i++;
        e = new Image();
        e.onload = function () {
          i--;
          if (i === 0) {
            if (ke) {
              ke(T, this);
            }
          }
          this.onload = null;
        };
        e.src = kd;
      }
    },
    collisionTest: function (k3, kn, ku) {
      if (this.map.viewAnimationTime) {
        return [];
      }
      if (!k3) {
        return [];
      }
      if (this.layer.ontology && this.layer.ontology.noCollision) {
        for (var kF = 0; kF < k3.length; kF++) {
          var lh = k3[kF].fixedLabel;
          for (var kD = 0; kD < lh.length; kD++) {
            var kf = lh[kD];
            var lj = this.layer.ontology.getLayerVisible(kf.layerName);
            kf.isDel = !lj;
          }
        }
        return k3;
      }
      var kq = this.map;
      var k7 = kq.getHeading();
      k7 = this.calcLoopHeading(k7);
      var kQ = kq.height;
      var kI = this.allLabels;
      for (var kF = 0; kF < kI.length; kF++) {
        kI[kF]._mcBds = null;
      }
      kI.length = 0;
      k3.sort(function (lk, i) {
        var lm = lk.tileInfo;
        var ll = i.tileInfo;
        if (lm.col * lm.row < ll.col * ll.row) {
          return -1;
        } else {
          return 1;
        }
      });
      var kr = kq.getTilt();
      var k8 = kq.getZoom();
      if (this.layer.ontology) {
        k8 += this.layer.spanLevel || 0;
      }
      var kB;
      if (ku) {
        kB = ku;
      } else {
        kB = this.getZoomStep();
      }
      for (var kF = 0, kz = k3.length; kF < kz; kF++) {
        var T = k3[kF];
        var kJ = T.tileInfo;
        var kC = kJ.zoom;
        var kR = kJ.loopOffsetX / Math.pow(2, 18 - kC);
        if (!k7 && !kr) {
          if (T.unnecessaryCollisionTest && T.unnecessaryCollisionTest[ku]) {
            continue;
          }
        }
        var lh = T.fixedLabel || [];
        for (var kD = 0, le = lh.length; kD < le; kD++) {
          var kf = lh[kD];
          kf.zoom = kC;
          if (kn === -1 && kf.isDel) {
            continue;
          }
          if (this.layer.ontology) {
            var lj = this.layer.ontology.getLayerVisible(kf.layerName);
            if (!lj) {
              continue;
            }
          }
          if (!eh(kf, kJ.useZoom, k8)) {
            kf.isDel = true;
            continue;
          }
          this.calcCollisionBounds(kf, kB, kR, kQ);
          kI.push(kf);
        }
        var kE = T.indoorLabel || [];
        for (var kA = 0, kM = kE.length; kA < kM; kA++) {
          var kL = kE[kA];
          kL.zoom = kC;
          if (kn === -1 && kL.isDel) {
            continue;
          }
          if (!eh(kL, kJ.useZoom)) {
            kL.isDel = true;
            continue;
          }
          this.calcCollisionBounds(kL, kB, kR, kQ);
          kI.push(kL);
        }
        var ld = T.lineLabel || [];
        for (var kH = 0, ks = ld.length; kH < ks; kH++) {
          var kZ = ld[kH];
          if (kn === -1 && kZ.isDel) {
            continue;
          }
          if (!eh(kZ, kJ.useZoom)) {
            kZ.isDel = true;
            continue;
          }
          var kg = kZ.pt;
          var kY = kq.pointToPixelIn(kg, {
            zoom: kB,
            useRound: this._useRound
          });
          var lg = kY.x + kR;
          var lf = kQ - kY.y;
          var kd = kZ.bds;
          var k1 = kd[0];
          var k0 = kd[1];
          var kw = kd[2];
          var kv = kd[3];
          var kp = k1;
          var ko = k0;
          var lc = kw;
          var lb = kv;
          if (k7 >= 0 && k7 < 45 || k7 >= 315 && k7 < 360) {
            kp = k1;
            ko = k0;
            lc = kw;
            lb = kv;
          } else if (k7 >= 45 && k7 < 135) {
            kp = k0;
            ko = -kw;
            lc = kv;
            lb = -k1;
          } else if (k7 >= 135 && k7 < 225) {
            kp = -kw;
            ko = -kv;
            lc = -k1;
            lb = -k0;
          } else if (k7 >= 225 && k7 < 315) {
            kp = -kv;
            ko = k1;
            lc = -k0;
            lb = kw;
          }
          kZ._tempBds = [lg + kp, lf + ko, lg + lc, lf + lb];
          var k5 = kq.pixelToPointIn(new fi(kZ._tempBds[0], kY.y + ko), {
            zoom: kB
          });
          var kX = kq.pixelToPointIn(new fi(kZ._tempBds[2], kY.y + lb), {
            zoom: kB
          });
          kZ._mcBds = [k5, kX];
          kI.push(kZ);
        }
      }
      var kW = this._strategyInfo;
      if (kW) {
        var kG = kW.guid;
        var kx = kW.guidExt;
        var kU = false;
        for (var ky = 0, km = kI.length; ky < km; ky++) {
          var ke = kI[ky];
          delete ke.tempRank;
          if (!this.layer.isClickableLabel(ke) || kx === 1 && !ke.guidExt) {
            continue;
          }
          if (kG === ke.guid && kW.tilePosStr === ke.tilePosStr) {
            ke.tempRank = this.RANK5;
            kU = true;
          }
        }
        if (!kU && this.currentSelectedLabel) {
          this.currentSelectedLabel.tempRank = this.RANK5;
          var kK = this.currentSelectedLabel.tileInfo;
          if (kK) {
            var kt = kK.zoom;
            var k6 = kK.loopOffsetX / Math.pow(2, 18 - kt);
            this.calcCollisionBounds(this.currentSelectedLabel, kB, k6, kQ);
            kI.push(this.currentSelectedLabel);
          }
        }
      } else {
        for (var kc = 0, kl = kI.length; kc < kl; kc++) {
          var ki = kI[kc];
          if (ki.type === "line" || !ki.iconPos) {
            continue;
          }
          delete ki.tempRank;
        }
      }
      kI.sort(function (ll, lk) {
        var lm = ll.tempRank ? ll.tempRank : ll.rank;
        var i = lk.tempRank ? lk.tempRank : lk.rank;
        return i - lm || ll.startZoom - lk.startZoom || lk.pt.lng - ll.pt.lng || lk.pt.lat - ll.pt.lat;
      });
      var la = 0;
      if (kr > 0) {
        la = 6;
      }
      k8 = kq.getZoom();
      if (k8 >= 8 && k8 < 9) {
        if (k8 < 8.5) {
          la = 6;
        } else {
          la = 3;
        }
      }
      if (kq._displayOptions.labelMargin > 0) {
        la = kq._displayOptions.labelMargin;
      }
      var kS = 2;
      if (k8 < 6 && k8 >= 5) {
        kS = -1;
      }
      for (var kV = 0, kk = kI.length; kV < kk; kV++) {
        var k9 = kI[kV];
        var k2 = k9._tempBds;
        k9.isDel = false;
        k9._intersectIdx = [];
        for (var kO = kV + 1; kO < kk; kO++) {
          var kP = kI[kO];
          var li = kP._tempBds;
          if (!(k2[2] + la + kS < li[0] - la || k2[0] - la > li[2] + la + kS || k2[3] + la + kS < li[1] - la || k2[1] - la > li[3] + la + kS)) {
            k9._intersectIdx.push(kO);
          }
        }
      }
      for (var kT = 0, kj = kI.length; kT < kj; kT++) {
        var kh = kI[kT];
        if (kh.isDel === false) {
          var e = kh._intersectIdx;
          for (var kN = 0, k4 = e.length; kN < k4; kN++) {
            kI[e[kN]].isDel = true;
          }
        }
      }
      return k3;
    },
    calcCollisionBounds: function (ki, kg, i, kh) {
      var ke = ki.ptFix || ki.pt;
      var kc = this.map;
      var kd = kc.pointToPixelIn(ke, {
        zoom: kg,
        useRound: this._useRound
      });
      var T = kd.x + i;
      var kk = kh - kd.y;
      var e = ki.bds;
      ki._tempBds = [T + e[0], kk + e[1], T + e[2], kk + e[3]];
      var kf = kc.pixelToPointIn(new fi(ki._tempBds[0], kd.y + e[1]), {
        zoom: kg
      });
      var kj = kc.pixelToPointIn(new fi(ki._tempBds[2], kd.y + e[3]), {
        zoom: kg
      });
      ki._mcBds = [kf, kj];
    },
    getZoomStep: function () {
      var T = this.map.getZoom();
      var e = Math.floor(T);
      var i = T - e >= 0.5 ? e + 0.5 : e;
      return i;
    },
    clearCollisionCache: function (e) {
      if (!e) {
        return;
      }
      e.cacheState = null;
      e.unnecessaryCollisionTest = null;
    },
    getCachedLabels: function (e) {
      e = e || [];
      var T = this.getZoomStep();
      var ke = false;
      for (var kc = 0; kc < e.length; kc++) {
        var kd = e[kc];
        if (!kd.cacheState || !kd.cacheState[T]) {
          ke = true;
          break;
        }
        if (kd.hasNewData) {
          ke = true;
          break;
        }
      }
      if (ke) {
        this.calcLabelsCollision(e);
      }
      return e;
    },
    calcLabelsCollision: function (T) {
      var kd = this.getZoomStep();
      var ke = {};
      var kl;
      var kc;
      var kn;
      var kp;
      var ko;
      var km;
      T = this.collisionTest(T, undefined, kd);
      aW.addLabelIntoAreaSpots(T);
      for (var ki = 0; ki < T.length; ki++) {
        kl = T[ki];
        kc = kl.tileInfo;
        kp = kc.col + "," + kc.row;
        ke[kp] = 1;
      }
      var e = {};
      for (var kg = 0; kg < T.length; kg++) {
        kl = T[kg];
        if (!kl.cacheState) {
          kl.cacheState = {};
        }
        kc = kl.tileInfo;
        ko = kc.col;
        km = kc.row;
        kp = ko + "," + km;
        if (kl.cacheState[kd] === "stable") {
          e[kp] = 1;
          if (!kl.hasNewData) {
            continue;
          }
        }
        for (var kh = 0; kh < kl.fixedLabel.length; kh++) {
          kn = kl.fixedLabel[kh];
          if (!kn.cachedIsDel) {
            kn.cachedIsDel = {};
          }
          kn.cachedIsDel[kd] = kn.isDel;
        }
        for (var kk = 0; kk < kl.indoorLabel.length; kk++) {
          kn = kl.indoorLabel[kk];
          if (!kn.cachedIsDel) {
            kn.cachedIsDel = {};
          }
          kn.cachedIsDel[kd] = kn.isDel;
        }
        for (var kj = 0; kj < kl.lineLabel.length; kj++) {
          kn = kl.lineLabel[kj];
          if (!kn.cachedIsDel) {
            kn.cachedIsDel = {};
          }
          kn.cachedIsDel[kd] = kn.isDel;
        }
        if (ke[ko - 1 + "," + (km - 1)] && ke[ko - 1 + "," + km] && ke[ko - 1 + "," + (km + 1)] && ke[ko + "," + (km - 1)] && ke[ko + "," + (km + 1)] && ke[ko + 1 + "," + (km - 1)] && ke[ko + 1 + "," + km] && ke[ko + 1 + "," + (km + 1)]) {
          kl.cacheState[kd] = "stable";
          e[kp] = 1;
        } else if (!kl.cacheState[kd]) {
          kl.cacheState[kd] = "unstable";
        }
      }
      for (var kf = 0; kf < T.length; kf++) {
        kl = T[kf];
        kc = kl.tileInfo;
        kp = kc.col + "," + kc.row;
        ko = +kc.col;
        km = +kc.row;
        if (e[ko - 1 + "," + (km - 1)] && e[ko - 1 + "," + km] && e[ko - 1 + "," + (km + 1)] && e[ko + "," + (km - 1)] && e[ko + "," + (km + 1)] && e[ko + 1 + "," + (km - 1)] && e[ko + 1 + "," + km] && e[ko + 1 + "," + (km + 1)]) {
          if (!kl.unnecessaryCollisionTest) {
            kl.unnecessaryCollisionTest = {};
          }
          kl.unnecessaryCollisionTest[kd] = 1;
        }
      }
      T.hasNewData = false;
    },
    updateLabels: function (kd) {
      var T = this.map;
      var kj = T.getZoom();
      var kl = T.getHeading();
      kl = this.calcLoopHeading(kl);
      var kk = T.getTilt();
      var ke = this.getZoomStep();
      for (var ki = 0, kf = kd.length; ki < kf; ki++) {
        var kh = kd[ki];
        var kc = kh.tileInfo;
        var kg = kc.loopOffsetX || 0;
        var e = {
          zoom: kj,
          mcOffsetX: kg
        };
        this.updateFixedLabel(kh.fixedLabel, kk, kl, kh, ke, e);
        e = {
          zoom: kj,
          mcOffsetX: 0
        };
        this.updateFixedLabel(kh.indoorLabel, kk, kl, kh, ke, e);
        this.updateLineLabel(kh.lineLabel, kk, kl, kh, ke);
      }
    },
    updateFixedLabel: function (kh, kk, i, kn, kd, ki) {
      if (kh.length === 1) {}
      var e = ki.zoom;
      var kc = ki.mcOffsetX;
      var ks;
      for (var ko = 0, kf = kh.length; ko < kf; ko++) {
        var kj = kh[ko];
        if (!kj.cachedIsDel) {
          continue;
        }
        if (!kk && !i && kn.cacheState && kn.cacheState[kd]) {
          kj.isDel = kj.cachedIsDel[kd];
          if (typeof kj.isDel === "undefined") {
            kj.isDel = kj.cachedIsDel[kd] = true;
          }
        }
        if (kj.startScale > e) {
          kj.isDel = true;
        }
        if (kj.isDel) {
          continue;
        }
        var kq = kj.pt;
        var T = kj.iconPos;
        if (T && T.texcoord) {
          if (!T.rtVertex) {
            T.rtVertex = [];
            ks = T.vertex;
            var kg = iI(kq.lng);
            var kp = iI(kq.lat);
            T.rtVertex = [kg[0], kp[0], kg[1], kp[1], 0, ks[0], ks[1], 0, 0, T.texcoord[0], T.texcoord[1], kg[0], kp[0], kg[1], kp[1], 0, ks[2], ks[3], 0, 0, T.texcoord[2], T.texcoord[3], kg[0], kp[0], kg[1], kp[1], 0, ks[4], ks[5], 0, 0, T.texcoord[4], T.texcoord[5], kg[0], kp[0], kg[1], kp[1], 0, ks[6], ks[7], 0, 0, T.texcoord[6], T.texcoord[7], kg[0], kp[0], kg[1], kp[1], 0, ks[8], ks[9], 0, 0, T.texcoord[8], T.texcoord[9], kg[0], kp[0], kg[1], kp[1], 0, ks[10], ks[11], 0, 0, T.texcoord[10], T.texcoord[11]];
          }
        }
        var kr = kj.textPos;
        if (kr) {
          if (!kr.rtVertex) {
            kr.rtVertex = [];
            ks = kr.vertex;
            var ke = kr.rtVertex;
            var km = iI(kq.lng);
            var kv = iI(kq.lat);
            var ku = iI(kc);
            for (var kl = 0, kt = ks.length; kl < kt; kl += 12) {
              ke.push(km[0], kv[0], km[1], kv[1], 0, ks[kl], ks[kl + 1], ku[0], ku[1], kr.texcoord[0], kr.texcoord[1]);
              ke.push(km[0], kv[0], km[1], kv[1], 0, ks[kl + 2], ks[kl + 3], ku[0], ku[1], kr.texcoord[2], kr.texcoord[3]);
              ke.push(km[0], kv[0], km[1], kv[1], 0, ks[kl + 4], ks[kl + 5], ku[0], ku[1], kr.texcoord[4], kr.texcoord[5]);
              ke.push(km[0], kv[0], km[1], kv[1], 0, ks[kl + 6], ks[kl + 7], ku[0], ku[1], kr.texcoord[6], kr.texcoord[7]);
              ke.push(km[0], kv[0], km[1], kv[1], 0, ks[kl + 8], ks[kl + 9], ku[0], ku[1], kr.texcoord[8], kr.texcoord[9]);
              ke.push(km[0], kv[0], km[1], kv[1], 0, ks[kl + 10], ks[kl + 11], ku[0], ku[1], kr.texcoord[10], kr.texcoord[11]);
            }
          }
        }
      }
    },
    updateLineLabel: function (kh, kK, kA, kv, kw) {
      kh = kh || [];
      var kq = this.map;
      var kk = kq.getZoomUnits();
      for (var kJ = 0, kH = kh.length; kJ < kH; kJ++) {
        var kg = kh[kJ];
        if (!kg.cachedIsDel) {
          continue;
        }
        if (!kK && !kA && kv.cacheState && kv.cacheState[kw]) {
          kg.isDel = kg.cachedIsDel[kw];
          if (typeof kg.isDel === "undefined") {
            kg.isDel = kg.cachedIsDel[kw] = true;
          }
        }
        if (kg.isDel) {
          continue;
        }
        if (!kg.styleText || kg.styleText.length === 0) {
          continue;
        }
        var ki = kg.mcInTile;
        var kD = ki.x;
        var kB = ki.y;
        var ku = kg.wordsInfo;
        var ks = kg.labelAngle;
        var ko = false;
        var kC = 0;
        if (kA !== 0) {
          var kp = ku[0].angle;
          var kG = this.calcLoopHeading(kp - kA);
          if (kG > 45 && kG < 315) {
            if (kG > 45 && kG <= 135) {
              kC = 270;
            } else if (kG > 135 && kG <= 225) {
              kC = 180;
            } else if (kG > 225 && kG < 315) {
              kC = 90;
            }
            if (ks > 225 && ks <= 315 && kC <= 180) {
              ko = true;
            } else if ((ks >= 0 && ks <= 45 || ks >= 315 && ks < 360) && kC >= 180) {
              ko = true;
            }
          }
        }
        for (var kI = 0, kl = ku.length; kI < kl; kI++) {
          var kF = ku[kI];
          var kn = kF.calcInfo;
          var kz = kF.offset[0];
          var kx = kF.offset[1];
          if (!kF.size) {
            continue;
          }
          var e = kF.size[0];
          var T = kF.size[1];
          var km = kF.angle;
          if (!kn) {
            kn = {};
          }
          if (kA !== kn.mapHeading || kk !== kn.zoomUnits) {
            kn.mapHeading = kA;
            kn.zoomUnits = kk;
            if (ko) {
              var kr = ku[kl - 1 - kI];
              kz = kr.offset[0];
              kx = kr.offset[1];
              km = kr.angle;
            }
            var kd = kD + kz * kk;
            var kc = kB + kx * kk;
            kn.rotationCenter = {
              lng: kd,
              lat: kc
            };
            kn.calcHeading = kC;
            kn.angle = km;
            kn.offsetX = kz;
            kn.offsetY = kx;
            kF.calcInfo = kn;
          }
          if (!kF.rtVertex) {
            kF.rtVertex = [];
          }
          kF.rtVertex.length = 0;
          var kt = kn.calcHeading + kn.angle;
          var ke = kn.rotationCenter;
          kz = kn.offsetX;
          kx = kn.offsetY;
          var kf = Math.round(kz - e / 2);
          var kE = Math.round(kz + e / 2);
          var ky = Math.round(kx + T / 2);
          var kj = Math.round(kx - T / 2);
          kF.rtVertex.push(kD, kB, kF.z, kf, kj, ke.lng, ke.lat, kt, kF.texcoord[0], kF.texcoord[1], kD, kB, kF.z, kE, kj, ke.lng, ke.lat, kt, kF.texcoord[2], kF.texcoord[3], kD, kB, kF.z, kE, ky, ke.lng, ke.lat, kt, kF.texcoord[4], kF.texcoord[5], kD, kB, kF.z, kf, kj, ke.lng, ke.lat, kt, kF.texcoord[6], kF.texcoord[7], kD, kB, kF.z, kE, ky, ke.lng, ke.lat, kt, kF.texcoord[8], kF.texcoord[9], kD, kB, kF.z, kf, ky, ke.lng, ke.lat, kt, kF.texcoord[10], kF.texcoord[11]);
        }
      }
    },
    calcLoopHeading: function (e) {
      while (e >= 360) {
        e -= 360;
      }
      while (e < 0) {
        e += 360;
      }
      return e;
    },
    fixDataFormat: function (kk) {
      var kc = this.fixedLabelData;
      var e = this.lineLabelData;
      var T = this.highlightLabelData;
      var ks = 0;
      var kg = 0;
      var kp = 0;
      var kq;
      if (this.currentSelectedLabel) {
        var kf = this.getLabelByUid(this.currentSelectedLabel.guid, this.currentSelectedLabel.tilePosStr);
        if (!kf || kf.isDel) {
          kc[ks] = this.currentSelectedLabel.formatedData;
          ks++;
          T[kp] = this.currentSelectedLabel.formatedData;
          kp++;
        }
      }
      for (var ko = 0; ko < kk.length; ko++) {
        var ki = kk[ko];
        var kh = ki.fixedLabel;
        var kd = ki.indoorLabel;
        var kn = ki.lineLabel;
        var kr = {
          highlightLabelData: T,
          highlightLabelDataLen: kp
        };
        kq = this.fixFixedLabelDataFormat(kh, ki, kc, ks, kr);
        ks = kq[0];
        kp = kq[1];
        kq = this.fixFixedLabelDataFormat(kd, ki, kc, ks, kr, true);
        ks = kq[0];
        kp = kq[1];
        e[kg] = {
          tileInfo: ki.tileInfo,
          lineLabels: []
        };
        for (var km = 0; km < kn.length; km++) {
          if (kn[km].isDel) {
            continue;
          }
          var kj = kn[km].wordsInfo;
          if (kj) {
            for (var kl = 0; kl < kj.length; kl++) {
              if (!kj[kl].rtVertex) {
                continue;
              }
              var ke = kj[kl].formatedData;
              if (!ke) {
                ke = {
                  textureSource: ki.textureSources[kn[km].processedInZoom],
                  textureHeight: ki.textureHeights[kn[km].processedInZoom],
                  renderData: {
                    vertex: kj[kl].rtVertex,
                    textureCoord: kj[kl].texcoord
                  }
                };
                kj[kl].formatedData = ke;
              }
              e[kg].lineLabels.push(ke);
            }
          }
        }
        kg++;
      }
      kc.length = ks;
      e.length = kg;
      T.length = kp;
      return [e, kc, T];
    },
    fixFixedLabelDataFormat: function (kg, kj, kk, kh, T, ki) {
      var ke = T.highlightLabelData;
      var e = T.highlightLabelDataLen;
      for (var i = 0; i < kg.length; i++) {
        if (kg[i].isDel) {
          continue;
        }
        var kf = kg[i].textPos;
        var kd = kg[i].iconPos;
        var kc = null;
        if (kf && kf.rtVertex) {
          if (!kg[i].formatedData) {
            kc = {
              guid: kg[i].guid,
              guidExt: kg[i].guidExt,
              tilePosStr: kg[i].tilePosStr,
              zoom: kg[i].zoom,
              tempRank: kg[i].tempRank,
              textureSource: kj.textureSources[kg[i].processedInZoom],
              textureHeight: kj.textureHeights[kg[i].processedInZoom],
              renderData: {
                vertex: kf.rtVertex,
                textureCoord: kf.texcoord
              }
            };
            if (ki && kg[i].onDefaultFloor === false) {
              kc.textureSource = kj.indoorTextureSources[kg[i].processedInZoom];
              kc.textureHeight = kj.indoorTextureHeights[kg[i].processedInZoom];
            }
            kg[i].formatedData = kc;
          } else {
            kc = kg[i].formatedData;
            kc.tempRank = kg[i].tempRank;
          }
          if (this.currentSelectedLabel && kc.guid === this.currentSelectedLabel.guid && kc.tilePosStr === this.currentSelectedLabel.tilePosStr) {
            ke[e] = kc;
            e++;
          }
        }
        if (kd && kd.rtVertex) {
          if (kc) {
            if (!kc.iconRenderData) {
              kc.iconRenderData = {
                vertex: kd.rtVertex,
                textureCoord: kd.texcoord
              };
            }
          } else {
            kc = {
              guid: kg[i].guid,
              guidExt: kg[i].guidExt,
              zoom: kg[i].zoom,
              tempRank: kg[i].tempRank,
              iconRenderData: {
                vertex: kd.rtVertex,
                textureCoord: kd.texcoord
              }
            };
            kg[i].formatedData = kc;
          }
        }
        kk[kh] = kc;
        kh++;
      }
      return [kh, e];
    },
    _refreshSpotData: function () {
      this._spotData.length = 0;
      var kh = this.map;
      var kf = Math.floor(kh.getZoom());
      var T = this.map._featureMgr.getLabelData(this.layer.drawIndex);
      if (this.layer.drawIndex !== 0) {
        return;
      }
      if (T) {
        for (var kd = 0, kc = T.length; kd < kc; kd++) {
          this._addFixedSpotData(T[kd].fixedLabel, kf);
          this._addFixedSpotData(T[kd].indoorLabel, kf);
        }
      }
      var ki = this.currentSelectedLabel;
      if (ki && !this.getTileByLabelUid(ki.guid, ki.tilePosStr)) {
        var ke = this._getSpotDataFromLabel(this.currentSelectedLabel);
        if (ke) {
          this._spotData.push(ke);
        }
      }
      var kg = new fJ("onspotsdataready");
      kg.spots = this._spotData;
      kg.index = this.layer.drawIndex;
      kh._spotDataOnCanvas = this._spotData;
      kh.dispatchEvent(kg);
    },
    _addFixedSpotData: function (kd, kc) {
      for (var e = 0; e < kd.length; e++) {
        var T = kd[e];
        if (!this.layer.isClickableLabel(T) || T.guidExt === 1 && T.startScale > kc) {
          continue;
        }
        var i = kd[e].spot || this._getSpotDataFromLabel(kd[e]);
        if (i) {
          this._spotData.push(i);
        }
      }
    },
    _getSpotDataFromLabel: function (T) {
      var ke = this.map;
      if (!T.bds) {
        return null;
      }
      var e = T.bds.slice(0);
      var kc = null;
      if (T.iconPos) {
        kc = new cx(T.pt.lng, T.pt.lat);
      }
      var i = T.name ? T.name.replace("\\\\", "<br>") : "";
      if (T.iconPos && T.iconPos.iconType.indexOf("ditie") > -1 && ke.getZoom() > 14) {
        i = "";
      }
      var kd = {
        n: i,
        pt: new cx(T.pt.lng, T.pt.lat),
        userdata: {
          iconPoint: kc,
          uid: T.guid,
          name: i,
          mapPoi: true,
          type: T.iconPos ? T.iconPos.iconType : "",
          rank: T.rank,
          zoom: T.zoom,
          tilePosStr: T.tilePosStr
        },
        bd: e,
        tag: "MAP_SPOT_INFO"
      };
      T.spot = kd;
      return kd;
    },
    drawLabelsOnCanvas: function (i, e) {
      if (this._labelTextCanvas) {
        this._labelTextCanvas.drawLabelsOnCanvas(i, e);
      }
    }
  });
  function i4(e) {
    this._map = e;
    this.virtualTiles = {};
    this.virtualTile = {
      custom: true,
      label: {
        fixedLabel: [],
        indoorLabel: [],
        lineLabel: [],
        textureHeights: [],
        status: "ready"
      },
      tileInfo: {
        col: 0,
        row: 0,
        zoom: 0,
        useZoom: 0,
        loopOffsetX: 0
      },
      status: "ready"
    };
    this.init();
  }
  i4.prototype.init = function () {
    var T = this._map;
    var i = this;
    function e(kc) {
      i.updateLabels(kc);
    }
    T.addEventListener("add_tile_labels", e);
    T.addEventListener("onremove_tile_labels", e);
    T.addEventListener("onclear_labels", e);
    T.addEventListener("onlayer_clear", e);
  };
  i4.prototype.updateLabels = function (kf) {
    var ki = this._map.tileMgr.getLabelTextCanvas();
    var T = this._map;
    var kg = this;
    if (kf && kf.model === "mvt") {
      var kk = kf.data;
      var kj = "mvt_" + kf.index;
    } else {
      var kk = T._customTileLabels;
      var kj = "custom";
    }
    var ke = JSON.parse(JSON.stringify(kk));
    for (var kd = 0; kd < ke.length; kd++) {
      var kh = ke[kd];
      kh.guid = kh.guid || kh.uid;
      kh.iconPos = this.getIconVertexData(kh.style, 1);
      var kc = {
        textMargin: kh.textMargin,
        textOnIcon: kh.textOnIcon,
        iconSize: kh.iconSize,
        style: {
          color: kh.style.color,
          strokeColor: kh.style.strokeColor,
          fontSize: kh.style.fontSize,
          haloSize: kh.style.haloSize
        }
      };
      ke[kd].styleId = ke[kd].styleId || o(kc);
    }
    ki.drawCustomLabelsOnCanvas(ke, function (i) {
      var e = JSON.parse(JSON.stringify(kg.virtualTile));
      e.label.tileInfo = e.tileInfo;
      if (i) {
        e.label.textureHeights[0] = [i.height];
      }
      e.label.fixedLabel = ke;
      kg.virtualTiles[kj] = e;
      var kl = new fJ("oncustom_labels_ready");
      kl.virtualTile = e;
      kl.labelCanvas = i;
      kl.model = kj;
      kl.imgKey = bx.getGUID("custom_labels_");
      T.dispatchEvent(kl);
    });
  };
  i4.prototype.getIconVertexData = function (kl, ke) {
    if (!kl || !kl.icon || !kl.iconSize || kl.iconSize.length < 2) {
      return null;
    }
    var kf = 2;
    var kd = kl.iconSize[0] / kf * ke;
    var ki = kl.iconSize[1] / kf * ke;
    var kc = Math.round(-kd / 2);
    var kk = Math.round(-ki / 2);
    var T = kc + kd;
    var kj = kk;
    var i = T;
    var kh = kj + ki;
    var e = kc;
    var kg = kh;
    return {
      vertex: [kc, kk, T, kj, i, kh, kc, kk, i, kh, e, kg],
      texcoord: null,
      width: kd,
      height: ki,
      iconType: kl.icon
    };
  };
  bx.register(function (e) {
    e._customLabelMgr = new i4(e);
  });
  var f8 = function (ku, kt) {
    var ks = {
      daaee: "cea",
      hedel: "hld",
      aixhc: "mal",
      ealxa: function (kv, e) {
        return kv + e;
      },
      llxex: "constructor",
      axaai: function (kv, e) {
        return kv(e);
      },
      hleex: function (kv, e) {
        return kv + e;
      },
      maexm: function (kw, kv, e) {
        return kw(kv, e);
      }
    };
    var kp = "1.1.2";
    function km(ky, kx) {
      var kw = "adm";
      while (kw !== "delx") {
        switch (kw) {
          case "mal":
            var kv = [];
            kw = ks.daaee;
            break;
          case ks.daaee:
            for (var e = 0; e < kz; e++) {
              var kA = kx(ky[e]);
              kv.push(kA);
            }
            kw = ks.hedel;
            break;
          case ks.hedel:
            return kv;
          case "adm":
            var kz = ky.length;
            kw = ks.aixhc;
            break;
        }
      }
    }
    var kr;
    var kq;
    var ko;
    var kn;
    var kl;
    var kk = decodeURIComponent;
    var kj = "Char";
    var ki = "";
    var kh = [f8];
    kr = "de";
    kq = "fr";
    ko = "o";
    kl = ks.ealxa(ks.hleex(kq, ko), "m");
    kn = "Co" + kr;
    var kg = function (e) {
      return ks.ealxa(e, ki)[ks.llxex][kl + kj + kn](e);
    };
    var kf = function (kv) {
      var e = {
        lahaa: function (kx, kw) {
          return ks.axaai(kx, kw);
        }
      };
      return km(kv, function (kw) {
        return e.lahaa(kg, kw);
      });
    };
    var ke = kf.call(kg, [39, 34, 37, 96, 60, 120, 97, 65, 98, 66, 99, 67, 100, 68, 101, 69, 102, 70, 103, 110, 109, 111, 112, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57]);
    var kd = ks.maexm(km, [28782, 27702, 26416, 25167, 24183], function (e) {
      return kk(e);
    });
    var kc = kf.call(kd, [22354, 22749, 24415, 23346, 22257, 22688, 24306, 25174, 23595, 25547, 22984, 25690, 22212, 27547, 21594, 27210, 23090, 29193, 22394, 29368, 29532, 29459, 29530, 24146, 24500, 26352, 27441, 28788, 29370, 27673, 26925, 25249, 24430]);
    var T = {};
    kd = kf(kd);
    var i = new RegExp(kd.join("|"));
    for (var kr = 0; kr < ke.length; kr++) {
      T[kc[kr]] = ke[kr];
    }
    kt = km(kt.split(ki), function (e) {
      return T[e] || e;
    }).join(ki);
    return ks.maexm(km, kt.split(i), function (e) {
      return ks.axaai(kk, e);
    });
  }(this, "r猓w扏s獚li姈呚灮廲廲呚朰姈ust猓獜Styl呚I犸娲猓_朰廲lh朰stri犸坺i娲i呚囄I姈猓犸S呚tI犸娲猓幷呚h呚扏i呚呚灮l囄l朰囄姈廲灮姈廲姈幷l廲姈氶hll幷獜姈墠幷姈ust猓獜朰墠姈h灮i廲h氶獜h墠灮廲h囄朰hl獜幷爉呚廲tur呚Styl呚氶呚姈廲氶姈廲h幷姈呚l氶h囄h灮呚廲墠幷stri犸坺i娲i呚囄爉呚廲tur呚Styl呚灮坺呚tI囄l呚W猓rk呚r扏_囄is獚l廲yO獚ti猓犸s幷獚猓i幷獜廲獚灮獚猓iT呚墠t朰hl廲廲廲灮h姈獜l扏呚墠h呚呚幷i犸囄猓猓rStyl呚朰stri犸坺i娲i呚囄I犸囄猓猓rStyl呚幷hl墠獜姈幷呚呚hh姈朰囄l獜i廲朰h囄i姈廲氶囄h墠幷囄墠lli氶il囄h墠幷摚ust猓獜扏墠iih呚朰呚廲呚墠墠氶i姈猓犸S呚tI犸娲猓氶hii扏墠墠h墠呚扏獜廲獚Ty獚呚扏sh猓wV呚姈t猓rStr呚呚tL廲y呚r灮獜lh墠i朰獜廲獚Styl呚I囄氶姈h呚獜囄扏廲h姈呚獜幷廲l墠幷llh廲囄氶獜姈姈朰lh廲朰h墠獜姈廲扏sh猓wV呚姈t猓rLi犸呚幷i犸囄呚墠O娲扏囄獜lll氶ii獜i獜氶lll獜h朰stri犸坺i娲y氶h呚ii獜幷i呚獜l囄幷獜呚廲獜姈朰呚呚姈呚呚朰w猓r囄S獚廲姈呚R廲ti猓扏i囄l廲l扏l墠呚幷h獜l囄姈氶i姈呚朰墠l墠囄墠朰呚呚廲廲姈扏姈呚h獜廲幷姈姈廲呚墠灮娲呚廲tur呚Styl呚扏hh廲i獜氶呚墠囄獜l灮呚墠t呚犸囄朰呚i呚廲灮墠呚廲氶h廲囄灮廲廲墠囄氶獜廲廲幷廲墠呚朰獜h呚扏獜廲呚廲l灮墠廲姈l呚灮呚ii廲姈灮l墠姈呚呚幷呚廲獜姈廲朰i廲廲呚i氶i墠h姈囄朰猓犸呚rr猓r氶獚r呚v呚犸t殛呚娲廲ult朰墠獜呚扏獜i姈墠獜灮呚li扏姈i囄幷廲廲姈朰彟曰曰)彟欱揋扏i呚廲灮姈墠姈呚幷hi囄扏廲獜呚朰i呚l扏廲墠廲獜呚氶墠呚姈墠姈扏i獜獚猓rtS姈ri獚ts(彟曰曰氶廲獚獚li姈廲ti猓犸彟曰爉j廲v廲s姈ri獚t灮呚獜廲ii朰廲i姈廲h朰i呚囄獜h扏廲i呚囄獜幷廲獜廲lh扏ll囄i墠朰揋l猓尫揋uil囄呚r幷W呚尫Kit揋l猓尫揋uil囄呚r幷h廲廲i獜灮姈r呚廲t呚O尫j呚姈tURL朰廲廲h灮呚廲li墠扏囄墠hhi扏i犸it灮姈呚i灮墠l呚扏墠獜姈幷i囄姈扏姈h廲氶l廲廲朰廲廲呚囄氶呚囄廲扏廲姈廲朰姈呚獜扏廲墠獜氶囄姈呚幷w猓rk呚r獜坺r幷呚墠獜扏墠呚li灮廲呚l幷獜i呚朰廲廲囄扏囄l獜幷i廲i幷呚墠囄i氶姈i獜朰stri犸坺朰lll氶獜囄呚朰廲獜i灮姈姈i灮猓犸styl呚_l猓廲囄呚囄扏l呚獜朰囄呚囄氶呚廲廲朰姈囄囄幷獜墠廲扏猓犸styl呚z猓猓獜u獚囄廲t呚幷墠呚呚扏囄廲呚灮姈ii呚呚朰呚姈囄廲朰獜呚廲囄墠朰廲h廲l墠幷r廲ti猓灮姈ii墠呚灮i廲囄幷l墠獜囄廲幷stri犸坺i娲i呚囄摚ust猓獜Styl呚I犸娲猓朰l呚囄朰呚囄姈h呚氶ii獜獜l朰廲l呚灮獜墠呚姈l扏姈獜i呚灮廲rrW猓rk呚r灮l呚犸坺th氶呚墠廲姈h氶isS呚犸囄爉S氶h呚呚呚呚氶stri犸坺i娲i呚囄摚ust猓獜Styl呚I犸娲猓Z猓猓獜朰姈猓犸娲i坺朰styl呚朰i姈廲墠h朰呚ih幷廲墠囄獜囄扏廲rrP呚犸囄i犸坺殛廲t廲朰hih廲廲氶h廲囄呚呚朰獜呚囄墠囄灮廲呚獜廲廲扏呚呚廲l姈幷猓犸獜呚ss廲坺呚灮_姈尫k幷囄廲t廲朰_獚廲rsi犸坺Til呚K呚y氶h廲廲朰囄hi姈墠氶廲hi獜l幷l猓廲囄Til呚殛廲t廲氶url扏til呚K呚y朰獜l墠墠囄氶囄呚h獜i扏呚呚廲朰娲ir呚朰h呚墠獜獜朰囄呚廲i獜扏呚i廲扏囄l廲墠呚氶姈囄廲l姈灮_is揋usy扏姈h姈墠呚朰_獚廲rsi犸坺Til呚I犸娲猓朰墠廲姈灮獜呚l呚囄幷姈尫k朰h呚呚灮呚廲hhh朰l呚廲h囄氶墠獜呚廲墠扏獚ush朰廲呚i墠i扏囄廲l灮獜li姈l扏獜i犸幷shi娲t幷til呚I犸娲猓灮姈廲l墠i朰i獜l氶ll墠獜廲朰t呚墠tSiz呚R廲ti猓灮il姈朰呚廲獜i囄扏呚l呚呚呚氶廲li朰囄獜墠l廲扏i姈廲呚獜灮l姈獜廲姈氶姈呚呚墠廲朰囄墠呚囄墠扏呚廲l幷呚i呚墠姈朰揋r猓ws呚r灮姈呚i墠囄氶獜ll墠i氶獜廲墠灮墠獜i氶囄廲h墠囄灮l墠呚墠獜灮獜墠獜囄獜朰廲呚囄扏廲hl氶廲呚呚呚呚幷h墠h廲i灮姈墠廲ll灮til呚Ty獚呚N廲獜呚氶廲l獜墠i灮i囄_");
  (function (kc, T) {
    var i = function (e) {
      while (--e) {
        kc.push(kc.shift());
      }
    };
    i(++T);
  })(f8, 348);
  var f7 = function (kc, T) {
    kc = kc - 0;
    var i = f8[kc];
    return i;
  };
  function jL(kf) {
    var ke = {
      lxcee: function (kg, i) {
        return kg !== i;
      },
      maeal: f7("0x0"),
      xacle: "eli",
      maami: f7("0x1"),
      eiiac: f7("0x2"),
      eamca: f7("0x3"),
      iaaei: f7("0x4"),
      ixhcd: function (kg, i) {
        return kg(i);
      },
      hildm: f7("0x5"),
      micxm: f7("0x6")
    };
    var kd = f7("0x1");
    while (ke.lxcee(kd, ke[f7("0x7")])) {
      switch (kd) {
        case ke[f7("0x8")]:
          return kc;
        case ke.maami:
          var kc = null;
          kd = f7("0x2");
          break;
        case ke[f7("0x9")]:
          try {
            var T = "xme";
            while (ke[f7("0xa")](T, ke[f7("0xb")])) {
              switch (T) {
                case ke[f7("0xc")]:
                  kc = ke[f7("0xd")](gx, kf);
                  T = ke[f7("0xb")];
                  break;
                case f7("0x6"):
                  kc = new Worker(kf);
                  T = ke.hildm;
                  break;
                case f7("0x5"):
                  kc[f7("0xe")] = function (i) {
                    i[f7("0xf")]();
                    kc = gx(kf);
                  };
                  T = f7("0x3");
                  break;
                case f7("0x10"):
                  T = D(kf) ? ke[f7("0x11")] : ke[f7("0xc")];
                  break;
              }
            }
          } catch (e) {
            kc = gx(kf);
          }
          kd = f7("0x12");
          break;
      }
    }
  }
  function gx(T) {
    var i = {
      caail: "iaah",
      axame: "dcd",
      xecxc: function (kl, kk) {
        return kl + kk;
      },
      emaii: f7("0x13"),
      aicah: f7("0x14"),
      iedmh: f7("0x15"),
      aiedm: f7("0x16"),
      amalh: "application/javascript",
      lldix: f7("0x17"),
      haaim: f7("0x18"),
      ealix: f7("0x19"),
      dxhhi: f7("0x1a")
    };
    var e = null;
    try {
      var kj = f7("0x19");
      while (kj !== i.caail) {
        switch (kj) {
          case i[f7("0x1b")]:
            try {
              ke = new Blob([i[f7("0x1c")](f7("0x1d") + T, f7("0x15"))], {
                type: f7("0x1e")
              });
            } catch (ki) {
              var kh = i[f7("0x1f")];
              while (kh !== f7("0x17")) {
                switch (kh) {
                  case i[f7("0x20")]:
                    kg.append(i[f7("0x1c")](i.xecxc(f7("0x1d"), T), i[f7("0x21")]));
                    kh = "iea";
                    break;
                  case i[f7("0x22")]:
                    ke = kg.getBlob(i[f7("0x23")]);
                    kh = i[f7("0x24")];
                    break;
                  case i[f7("0x1f")]:
                    var kg = new (window[f7("0x25")] || window[f7("0x26")] || window.MozBlobBuilder)();
                    kh = f7("0x14");
                    break;
                }
              }
            }
            kj = f7("0x1a");
            break;
          case i[f7("0x27")]:
            var kf = kd[f7("0x28")](ke);
            kj = f7("0x29");
            break;
          case i[f7("0x2a")]:
            var ke;
            kj = i[f7("0x1b")];
            break;
          case i[f7("0x2b")]:
            var kd = window.URL || window.webkitURL;
            kj = i.haaim;
            break;
          case f7("0x29"):
            e = new Worker(kf);
            kj = "iaah";
            break;
        }
      }
    } catch (kc) {}
    return e;
  }
  function jw(e) {
    this[f7("0x2c")](e);
  }
  var g5 = {
    init: function (kd) {
      var kc = {
        mxecl: function (kf, ke) {
          return kf !== ke;
        },
        exach: function (kf, ke) {
          return kf < ke;
        },
        elidd: f7("0x2d"),
        heeee: f7("0x2e"),
        icaxh: f7("0x2f"),
        dhicx: f7("0x30"),
        ahiml: f7("0x31"),
        mlxxd: f7("0x32"),
        dehmi: "onrefresh",
        hexmm: f7("0x33"),
        deaim: f7("0x34"),
        deice: f7("0x35"),
        meled: f7("0x36"),
        dlaxe: "cee",
        cdalc: f7("0x37"),
        chcxe: f7("0x38"),
        axdmd: function (kf, ke) {
          return kf > ke;
        },
        eahhh: f7("0x39"),
        eealc: function (kf, ke) {
          return kf !== ke;
        },
        hihaa: f7("0x3a"),
        calxi: f7("0x3b"),
        hadee: f7("0x3c"),
        medxd: f7("0x3d"),
        aemaa: f7("0x3e"),
        leahd: f7("0x3f"),
        xmeax: f7("0x40"),
        aeixi: f7("0x41"),
        mlicl: f7("0x42"),
        edalc: f7("0x43"),
        ciiee: function (ke, kf) {
          return ke !== kf;
        },
        meadx: f7("0x44"),
        lxmda: f7("0x45"),
        ahalx: f7("0x46"),
        ciixe: function (ke) {
          return ke();
        },
        edche: f7("0x47"),
        iimml: f7("0x48"),
        ceexa: f7("0x49"),
        iiaax: f7("0x4a"),
        ichca: "eih",
        llxma: f7("0x4b"),
        eamid: "ilc",
        eleee: function (kf, ke) {
          return kf === ke;
        },
        dmxla: f7("0x12"),
        icaem: f7("0x4c"),
        lcmac: f7("0x4d"),
        dxedx: f7("0x4e"),
        eiexc: function (ke) {
          return ke();
        },
        ceixd: f7("0x4f"),
        mllxi: f7("0x50")
      };
      var i = f7("0x18");
      while (kc[f7("0x51")](i, f7("0x52"))) {
        switch (i) {
          case kc[f7("0x53")]:
            T = 2;
            i = kc.lxmda;
            break;
          case kc[f7("0x54")]:
            this[f7("0x55")] = kc[f7("0x56")](gd);
            i = f7("0x57");
            break;
          case kc[f7("0x58")]:
            this.arrWorker = [];
            i = kc.ahalx;
            break;
          case "ali":
            this[f7("0x59")] = null;
            i = f7("0x5a");
            break;
          case kc[f7("0x5b")]:
            kd.on(kc[f7("0x5c")], function () {
              var kg = f7("0x5d");
              while (kc[f7("0x5e")](kg, f7("0x5f"))) {
                switch (kg) {
                  case "ale":
                    for (var kf = 0, ke = e[f7("0x60")][f7("0x61")]; kc[f7("0x62")](kf, ke); kf++) {
                      e[f7("0x60")][kf][f7("0x63")] = false;
                    }
                    kg = kc.elidd;
                    break;
                  case kc[f7("0x64")]:
                    e[f7("0x65")] = [];
                    kg = f7("0x5f");
                    break;
                  case kc.icaxh:
                    e[f7("0x59")] = null;
                    kg = f7("0x2e");
                    break;
                  case f7("0x2d"):
                    if (typeof this[f7("0x66")][f7("0x67")] !== f7("0x43")) {
                      kg = kc[f7("0x68")];
                      break;
                    }
                    kg = f7("0x5f");
                    break;
                }
              }
            });
            i = kc.ceexa;
            break;
          case f7("0x57"):
            this.wordSpaceRatio = this[f7("0x55")];
            i = f7("0x69");
            break;
          case f7("0x4f"):
            ft.canUseWebAssembly(function (ki) {
              var kh = f7("0x3c");
              while (kc.eealc(kh, f7("0x3b"))) {
                switch (kh) {
                  case "dci":
                    if (kc[f7("0x6a")](e[f7("0x6b")][f7("0x61")], 0)) {
                      kh = kc[f7("0x6c")];
                      break;
                    }
                    kh = kc.calxi;
                    break;
                  case kc[f7("0x6d")]:
                    var kg;
                    kh = kc[f7("0x6e")];
                    break;
                  case f7("0x42"):
                    for (var kf = 0; kf < T; kf++) {
                      var ke = kc[f7("0x6f")];
                      while (kc[f7("0x70")](ke, f7("0x41"))) {
                        switch (ke) {
                          case "iai":
                            km[f7("0x71")] = function kj(kp) {
                              var ko = "eda";
                              while (kc[f7("0x5e")](ko, f7("0x33"))) {
                                switch (ko) {
                                  case f7("0x35"):
                                    if (this[f7("0x72")]) {
                                      this._cbk(kp[f7("0x73")], this[f7("0x74")]);
                                    }
                                    ko = f7("0x37");
                                    break;
                                  case f7("0x75"):
                                    this[f7("0x72")] = null;
                                    ko = kc[f7("0x76")];
                                    break;
                                  case kc[f7("0x77")]:
                                    e[f7("0x78")](kr[f7("0x79")], kr.tileInfo, kr[f7("0x7a")], kq);
                                    ko = f7("0x32");
                                    break;
                                  case kc[f7("0x7b")]:
                                    var kn = new fJ(kc[f7("0x7c")]);
                                    ko = "hee";
                                    break;
                                  case f7("0x7d"):
                                    kd[f7("0x7e")](kn);
                                    ko = kc[f7("0x7f")];
                                    break;
                                  case kc[f7("0x80")]:
                                    ko = kp.data ? kc.deice : kc.meled;
                                    break;
                                  case f7("0x81"):
                                    var kr = e.arrPendingData.shift();
                                    ko = kc[f7("0x82")];
                                    break;
                                  case kc[f7("0x83")]:
                                    this[f7("0x84")] = false;
                                    ko = "haa";
                                    break;
                                  case kc[f7("0x85")]:
                                    this[f7("0x74")] = null;
                                    ko = "xac";
                                    break;
                                  case kc.dhicx:
                                    this[f7("0x86")] = null;
                                    ko = kc.chcxe;
                                    break;
                                  case f7("0x87"):
                                    if (kc[f7("0x6a")](e[f7("0x6b")][f7("0x61")], 0)) {
                                      ko = f7("0x81");
                                      break;
                                    }
                                    ko = f7("0x32");
                                    break;
                                  case kc[f7("0x88")]:
                                    if (this[f7("0x72")]) {
                                      this[f7("0x72")](null, this[f7("0x74")]);
                                    }
                                    ko = f7("0x37");
                                    break;
                                  case kc[f7("0x82")]:
                                    var kq = kr[f7("0x89")];
                                    ko = kc.ahiml;
                                    break;
                                  case f7("0x8a"):
                                    kn.source = kc[f7("0x8b")];
                                    ko = "eea";
                                    break;
                                }
                              }
                            };
                            ke = kc[f7("0x8c")];
                            break;
                          case kc[f7("0x6f")]:
                            var km = jL(kg);
                            ke = kc[f7("0x8d")];
                            break;
                          case f7("0x3f"):
                            e[f7("0x60")][f7("0x8e")](km);
                            ke = kc[f7("0x8f")];
                            break;
                        }
                      }
                    }
                    kh = "dci";
                    break;
                  case f7("0x90"):
                    kg = (window.location.protocol === "http:" ? "http:" : "https:") + "//api.map.baidu.com/res/webgl/10/worker_asm_yooo3j.js";
                    kh = kc[f7("0x91")];
                    break;
                  case f7("0x3a"):
                    for (var kl = 0; kl < Math[f7("0x92")](e[f7("0x6b")][f7("0x61")], T); kl++) {
                      var kk = e.arrPendingData[f7("0x93")]();
                      e[f7("0x78")](kk[f7("0x79")], kk[f7("0x94")], kk[f7("0x7a")], kk[f7("0x89")]);
                    }
                    kh = kc[f7("0x95")];
                    break;
                  case f7("0x96"):
                    kg = (window.location.protocol === "http:" ? "http:" : "https:") + "//api.map.baidu.com/res/webgl/10/worker_wasm_iawxhn.js";
                    kh = f7("0x42");
                    break;
                  case f7("0x3d"):
                    kh = ki ? "iml" : f7("0x90");
                    break;
                }
              }
            });
            i = f7("0x47");
            break;
          case "hid":
            var e = this;
            i = kc.iiaax;
            break;
          case kc.ichca:
            i = this[f7("0x55")] > 1 ? kc[f7("0x97")] : f7("0x50");
            break;
          case kc[f7("0x97")]:
            this[f7("0x98")] = 2;
            i = f7("0x99");
            break;
          case kc[f7("0x9a")]:
            if (kc[f7("0x9b")](typeof this.map[f7("0x66")][f7("0x67")], "string")) {
              i = f7("0x9c");
              break;
            }
            i = f7("0x4f");
            break;
          case kc[f7("0x9d")]:
            kd.on("destroy", function () {
              for (var ke = 0; kc[f7("0x62")](ke, e[f7("0x60")][f7("0x61")]); ke++) {
                if (e[f7("0x60")][ke]) {
                  e[f7("0x60")][ke].terminate();
                }
              }
              e[f7("0x60")][f7("0x61")] = 0;
            });
            i = f7("0x52");
            break;
          case f7("0x4d"):
            this[f7("0x6b")] = [];
            i = kc[f7("0x9e")];
            break;
          case f7("0x4a"):
            this.map = kd;
            i = kc[f7("0x9f")];
            break;
          case kc[f7("0xa0")]:
            kd.on(kc[f7("0xa1")], function () {
              for (var kf = 0, ke = e[f7("0x60")][f7("0x61")]; kf < ke; kf++) {
                e.arrWorker[kf][f7("0x63")] = false;
              }
              if (typeof this[f7("0x66")].style !== kc.edalc) {
                e[f7("0x59")] = null;
                e[f7("0x65")] = [];
              }
            });
            i = kc[f7("0x9d")];
            break;
          case f7("0xa2"):
            if ((kc[f7("0xa3")](bW) || eX[f7("0xa4")].ie) && kc[f7("0x6a")](T, 2)) {
              i = f7("0x44");
              break;
            }
            i = f7("0x45");
            break;
          case "led":
            this.stringifiedCustomStyleInfoZoom = [];
            i = kc[f7("0xa5")];
            break;
          case kc[f7("0xa6")]:
            this[f7("0x98")] = 1;
            i = kc[f7("0x9a")];
            break;
          case f7("0x4c"):
            var T = Math[f7("0xa7")](navigator.hardwareConcurrency - 2, 0) || 4;
            i = f7("0xa2");
            break;
        }
      }
    },
    getIdleWorker: function () {
      var kc = {
        dahxd: function (kf, ke) {
          return kf < ke;
        },
        lxexm: "ahai",
        mxmdm: f7("0xa8")
      };
      for (var T = 0, i = this[f7("0x60")][f7("0x61")]; kc[f7("0xa9")](T, i); T++) {
        var e = f7("0x4f");
        while (e !== kc[f7("0xaa")]) {
          switch (e) {
            case f7("0x4f"):
              var kd = this[f7("0x60")][T];
              e = kc[f7("0xab")];
              break;
            case f7("0xac"):
              return kd;
            case f7("0xad"):
              kd[f7("0x84")] = true;
              e = "aed";
              break;
            case f7("0xa8"):
              if (!kd[f7("0x84")]) {
                e = f7("0xad");
                break;
              }
              e = kc.lxexm;
              break;
          }
        }
      }
      return null;
    },
    releasePendingData: function (kf) {
      var kd = {
        aeeee: function (ki, kh) {
          return ki - kh;
        },
        hxhai: function (ki, kh) {
          return ki >= kh;
        },
        cxall: function (ki, kh) {
          return ki !== kh;
        },
        almxi: function (ki, kh) {
          return ki + kh;
        }
      };
      var kg = [];
      var ke = this[f7("0x6b")];
      for (var kc = kd[f7("0xae")](ke.length, 1); kd[f7("0xaf")](kc, 0); kc--) {
        var T = ke[kc];
        var i = T[f7("0x94")];
        if (kd[f7("0xb0")](kf.tileTypeName, i[f7("0xb1")])) {
          continue;
        }
        var e = kd[f7("0xb2")](kd[f7("0xb2")](f7("0xb3") + i.col, "_") + i[f7("0xb4")], "_") + i.zoom;
        if (!kf[e]) {
          ke[f7("0xb5")](kc, 1);
          kg[f7("0x8e")](i);
        }
      }
      return kg;
    },
    loadTileData: function (kd, kc, T, i) {
      var e = {
        hlaaa: function (kp, ko) {
          return kp !== ko;
        },
        exhee: "hii",
        mdcma: f7("0xb6"),
        dlmia: function (ko, kp) {
          return ko + kp;
        },
        hlxmc: f7("0xb7"),
        eehhc: f7("0xb8"),
        hdica: f7("0xb9"),
        dxlli: f7("0xba"),
        ildhx: f7("0xbb"),
        xiihe: f7("0xbc"),
        eaexx: f7("0xbd"),
        xxhxe: f7("0xbe"),
        mlhxi: f7("0xbf"),
        chemd: f7("0xc0"),
        ahcem: f7("0xc1"),
        llhad: "dhx",
        hxmca: "loadTileData",
        dmlll: f7("0xc2"),
        hmldc: f7("0xc3"),
        iimim: f7("0xc4"),
        xdxha: f7("0xc5"),
        lllmh: f7("0xc6"),
        heiim: f7("0xc7"),
        iemld: f7("0x19"),
        emdxl: function (kp, ko) {
          return kp + ko;
        },
        meamc: function (kp, ko) {
          return kp + ko;
        },
        eecee: f7("0xc8"),
        idlal: f7("0xc9"),
        eeaac: f7("0xca"),
        xlxdx: f7("0x35"),
        cehma: "ice",
        ccaex: f7("0xcb"),
        hhaim: f7("0xcc"),
        exdml: f7("0xcd"),
        miaia: f7("0xce")
      };
      var kn = this[f7("0xcf")]();
      var km = this.map[f7("0xd0")][f7("0xd1")];
      var kl = km ? this[f7("0xd2")][f7("0xd0")][f7("0xd3")] : false;
      if (kn) {
        var kk = f7("0x35");
        while (e[f7("0xd4")](kk, f7("0xd5"))) {
          switch (kk) {
            case e[f7("0xd6")]:
              kh[f7("0xd7")] = this[f7("0xd8")];
              kk = f7("0x4d");
              break;
            case e.mdcma:
              if (kg && bx[e.dlmia(e[f7("0xd9")], ki)]) {
                kk = f7("0xc4");
                break;
              }
              kk = f7("0xc6");
              break;
            case e[f7("0xda")]:
              if (!this[e[f7("0xdb")](e[f7("0xdc")], kf)]) {
                kk = "lxe";
                break;
              }
              kk = f7("0xdd");
              break;
            case e[f7("0xde")]:
              if (kg) {
                kk = e.ildhx;
                break;
              }
              kk = f7("0xbc");
              break;
            case e[f7("0xdf")]:
              kf = f7("0xe0");
              kk = e[f7("0xe1")];
              break;
            case e[f7("0xe2")]:
              kh[f7("0xe3")] = this[e[f7("0xdb")]("stringifiedIconSetInfo", kf)];
              kk = f7("0xe4");
              break;
            case f7("0xc5"):
              this[f7("0x59")] = JSON.stringify(bx[e[f7("0xdb")]("customStyleInfo_", ki)]);
              kk = f7("0xc6");
              break;
            case e[f7("0xe5")]:
              var kj = this[f7("0xd2")][f7("0xe6")] !== BMAPGL_NORMAL_MAP && this[f7("0xd2")].config[f7("0xe7")];
              kk = "lha";
              break;
            case e[f7("0xe8")]:
              kn._parsingTileKey = T;
              kk = f7("0xbe");
              break;
            case f7("0xc9"):
              kh[f7("0xe9")] = ki;
              kk = e[f7("0xea")];
              break;
            case e[f7("0xeb")]:
              var ki = this[f7("0xd2")].getMapStyleId();
              kk = f7("0xec");
              break;
            case e[f7("0xed")]:
              if (!this[f7("0xd8")]) {
                kk = f7("0xee");
                break;
              }
              kk = f7("0xb6");
              break;
            case f7("0xef"):
              var kh = {
                action: e[f7("0xf0")],
                url: kd,
                tileInfo: kc,
                tileKey: T,
                isText: kl,
                isPoi: km,
                hasPoly: kj ? false : true,
                hasLine: kj ? this[f7("0xd2")][f7("0x66")][f7("0xf1")] : true
              };
              kk = f7("0xc1");
              break;
            case f7("0xec"):
              var kg = !!(ki[f7("0xf2")](e[f7("0xf3")]) === 0);
              kk = e.hmldc;
              break;
            case e[f7("0xf4")]:
              if (!this[f7("0x59")]) {
                kk = e.xdxha;
                break;
              }
              kk = e[f7("0xf5")];
              break;
            case f7("0xee"):
              this.stringifiedIndoorStyle = JSON[f7("0xf6")](bx[f7("0xd7")]);
              kk = f7("0xb6");
              break;
            case e[f7("0xea")]:
              kn[f7("0x63")] = true;
              kk = f7("0xcc");
              break;
            case e.lllmh:
              if (this[f7("0xce") + ki]) {
                kk = e[f7("0xf7")];
                break;
              }
              kk = f7("0xbd");
              break;
            case e[f7("0xf8")]:
              if (!this[e.emdxl("stringifiedFeatureStyle", ki)] && bx[e[f7("0xf9")](e[f7("0xfa")], ki)]) {
                kk = f7("0xcd");
                break;
              }
              kk = e[f7("0xda")];
              break;
            case "cel":
              kh.iconInfo = {
                wordSpaceRatio: this[f7("0xfb")],
                textSizeRatio: this[f7("0x98")]
              };
              kk = e[f7("0xfc")];
              break;
            case f7("0xfd"):
              this[f7("0xb9") + kf] = JSON[f7("0xf6")](bx[f7("0xe3") + kf]);
              kk = f7("0xdd");
              break;
            case e[f7("0xfe")]:
              var kf = ki;
              kk = e[f7("0xde")];
              break;
            case f7("0xcc"):
              kn.postMessage(kh);
              kk = f7("0xd5");
              break;
            case e.eeaac:
              kn[f7("0x86")] = kc;
              kk = e[f7("0xe8")];
              break;
            case f7("0xff"):
              kh.customMapStyle = this.stringifiedCustomStyleInfo;
              kk = f7("0xcb");
              break;
            case e[f7("0x100")]:
              kn[f7("0x72")] = i;
              kk = e[f7("0x101")];
              break;
            case f7("0x4d"):
              if (kg && this[f7("0x59")]) {
                kk = e[f7("0x102")];
                break;
              }
              kk = e[f7("0x103")];
              break;
            case f7("0xc7"):
              kh[f7("0x104")] = this[e[f7("0xf9")](f7("0xce"), ki)];
              kk = e[f7("0xe2")];
              break;
            case f7("0xbc"):
              if (!kn.isSendFS) {
                kk = f7("0x19");
                break;
              }
              kk = e[f7("0x105")];
              break;
            case e[f7("0x106")]:
              this[e.miaia + ki] = JSON.stringify(bx[f7("0xc8") + ki]);
              kk = f7("0xb8");
              break;
          }
        }
      } else {
        var ke = {
          url: kd,
          tileInfo: kc,
          tileKey: T,
          cbk: i
        };
        this[f7("0x6b")].push(ke);
      }
    }
  };
  eX[f7("0x107")](jw.prototype, g5);
  function iQ(i) {
    this.tileLayers = [];
    this.map = i;
    var e = this.config = ej[this.map.mapType];
    this.errorUrl = e.errorUrl;
    this.tileSize = e.tileSize;
    this.baseUnits = e.baseUnits;
    this.baseZoomLevel = e.zoomLevelBase;
    this.tileURLs = e.tileUrls;
    this.tilesInfoCache = {};
    this.loadDelay = 10;
    this._labelTextCanvas = null;
  }
  bx.register(function (i) {
    if (i._renderType !== "webgl") {
      return;
    }
    var e = i.tileMgr = new iQ(i);
    i.addEventListener("addtilelayer", function (kc) {
      e.addWebGLLayer(kc.target);
    });
    i.addEventListener("removetilelayer", function (kc) {
      e.removeWebGLLayer(kc.target);
    });
    i.on("update", function T(kd) {
      if (i.getFeatureStyleTags().length === 0 || !i.customLoaded) {
        return;
      }
      var kc = false;
      if (kd.changedStatus && kd.changedStatus.onzoom_changed) {
        kc = true;
      }
      e.loadLayersData({
        zoomChanged: kc
      });
    });
    i.on("style_changed", function () {
      e.loadLayersData();
    });
    i.on("destroy", function () {
      for (var kc = 0; kc < e.tileLayers.length; kc++) {
        e.tileLayers[kc].remove();
        e.tileLayers[kc].destroyDrawData();
        e.tileLayers[kc] = null;
      }
      e.tileLayers = [];
      e._labelTextCanvas = null;
      e.map = null;
      e.requestTime = null;
    });
  });
  eX.extend(iQ.prototype, {
    addWebGLLayer: function (T) {
      this.tileLayers.push(T);
      T.initDrawData();
      if (this.tileLayers.length > 1) {
        for (var e = 1; e < this.tileLayers.length; e++) {
          if (this.tileLayers[e].isFlat) {
            this.map.setDisplayOptions({
              isFlat: true
            });
            break;
          }
        }
      }
      if (this.map.getFeatureStyleTags().length > 0 && this.map.customLoaded) {
        this.loadLayersData();
      } else {
        var kc = this;
        this.map.loadMapStyleFiles(function () {
          kc.loadLayersData();
        });
      }
    },
    removeWebGLLayer: function (ke) {
      var kf = false;
      for (var kd = 0, kc = this.tileLayers.length; kd < kc; kd++) {
        if (ke === this.tileLayers[kd]) {
          kf = true;
          this.tileLayers.splice(kd, 1);
          break;
        }
      }
      if (kf === false) {
        return;
      }
      ke.destroyDrawData();
      if (this.map.getFeatureStyleTags().length > 0) {
        this.loadLayersData();
      }
      if (this.tileLayers.length === 1) {
        this.map.setDisplayOptions({
          isFlat: false
        });
      } else {
        var e = false;
        for (var kd = 1; kd < this.tileLayers.length; kd++) {
          if (this.tileLayers[kd].isFlat) {
            e = true;
            break;
          }
        }
        this.map.setDisplayOptions({
          isFlat: e
        });
      }
      var T = new fJ("onrefresh");
      T.source = "removewebgllayer";
      this.map.fire(T);
    },
    getLabelTextCanvas: function () {
      if (!this._labelTextCanvas) {
        this._labelTextCanvas = new aw(this.map);
      }
      return this._labelTextCanvas;
    },
    loadLayersData: function (i) {
      if (!this.map || this.map.suspendLoad) {
        return;
      }
      var kd = this;
      i = i || {};
      var kc = !!i.zoomChanged;
      var e = kc === true || this.map.getTilt() > 50;
      if (!e) {
        if (!this.syncLoadTimer) {
          this.syncLoadTimer = setTimeout(function () {
            kd._loadLayersFromCache(kc);
            kd.syncLoadTimer = null;
          }, 40);
        }
      } else {
        this._loadLayersFromCache(kc);
      }
      if (!kd.map.viewAnimationTime) {
        if (this.timer) {
          window.clearTimeout(this.timer);
        }
      }
      if (!this.requestTime) {
        this.requestTime = new Date().getTime();
      } else if (new Date().getTime() - this.requestTime >= 1000) {
        T();
      }
      function T() {
        if (!kd.map) {
          return;
        }
        if (kd.map.viewAnimationTime) {
          if (new Date().getTime() - kd.map.viewAnimationTime < 1000) {
            return;
          }
          kd.map.viewAnimationTime = new Date().getTime();
        }
        var kf = kd.tileLayers.length;
        kd.tilesInfoCache = {};
        for (var kh = 0; kh < kf; kh++) {
          var kj = kd.tileLayers[kh];
          var ki = kj.tileType;
          var ke = null;
          var kg = kd._getTilesInfoKey(ki, kj);
          if (kd.tilesInfoCache[kg]) {
            ke = kd.tilesInfoCache[kg];
          } else {
            ke = kd.calcTilesInfo(ki, kj);
            kd.tilesInfoCache[kg] = ke;
          }
          if (ke) {
            kj.loadLayerData(ke, false, kc);
          }
        }
        kd.timer = null;
        kd.requestTime = null;
      }
      this.timer = window.setTimeout(T, this.loadDelay);
      if ((bW() || eX.Browser.ie) && kc) {
        this.loadDelay = 200;
      } else {
        this.loadDelay = 80;
      }
    },
    _getTilesInfoKey: function (i, T) {
      var e = i.getName();
      e += "_" + (T.transform ? T.transform.source : "default");
      e += "_" + T.spanLevel || 0;
      return e;
    },
    _loadLayersFromCache: function (ke) {
      if (!this.map) {
        return;
      }
      this.map._featureMgr.clearData();
      this.map.tileLabels = [];
      var kh = this.tileLayers;
      kh.sort(function (ki, i) {
        return ki.zIndex - i.zIndex > 0;
      });
      var T = kh.length;
      this.tilesInfoCache = {};
      for (var kd = 0; kd < T; kd++) {
        var kg = kh[kd];
        var kf = kg.tileType;
        var e = null;
        var kc = this._getTilesInfoKey(kf, kg);
        if (this.tilesInfoCache[kc]) {
          e = this.tilesInfoCache[kc];
        } else {
          e = this.calcTilesInfo(kf, kg);
          this.tilesInfoCache[kc] = e;
        }
        if (e) {
          kg.loadLayerData(e, true, ke);
        }
      }
    },
    calcTilesInfo: function (kp, kQ) {
      var kC = this.map;
      var kI = kC.getMapType();
      var kD = ej[kI];
      var kw = kC.getZoom();
      var e = Math.floor(kw);
      var kf = kp.getDataZoom(kw);
      var kV = kp.getName();
      kf = cb(kf, kD.minDataZoom, kD.maxDataZoom);
      var kL = e;
      if (kp._name === "web" || kp._name === "xyz") {
        kL = kf;
      } else if (kL < 3) {
        kL = 3;
      }
      var kA = kp.getTileSize(kw);
      var ke = kp.getBaseTileSize(kw);
      var ky = kC.getBoundsIn();
      if (!ky) {
        return;
      }
      var kt = kp.getMercatorSize(kw, kf);
      var ks;
      var kJ;
      var kz;
      var kN;
      var kE = kC.getCenterIn();
      if (kI !== BMAP_SATELLITE_MAP) {
        kE = e0.calcLoopCenterPoint(kE);
      }
      if (kV === "xyz") {
        return this.calcXYZTilesInfo(kE, ky, kf, kV, kQ, kC);
      }
      var kx = Math.floor(kE.lng / kt);
      var kh = Math.floor(kE.lat / kt);
      var kG = 0;
      var kc = 0;
      if (kV !== "web") {
        ky = e0.calcLoopMapBounds(ky, kC.getCenter());
      }
      if (ky.ne.lng > e0._mc180X) {
        var kn = e0.getSpaceDistanceInPixel(kf);
        kG = Math.ceil(kn / ke);
      }
      if (ky.sw.lng < e0._mcM180X) {
        var kn = e0.getSpaceDistanceInPixel(kf);
        kc = Math.ceil(kn / ke);
      }
      if (ky.ne.lat > 19505879.362428114 || ky.sw.lat < -15949096.637571886) {
        ky.ne.lat = 19505879.362428114;
        ky.sw.lat = -15949096.637571886;
      }
      var kj = [Math.floor(ky.sw.lng / kt) - kc, Math.floor(ky.sw.lat / kt)];
      var kT = [Math.floor(ky.ne.lng / kt) + kG, Math.floor(ky.ne.lat / kt)];
      ks = kj[0];
      kJ = kT[0] + 1;
      kz = kj[1];
      kN = kT[1] + 1;
      var ko = [];
      for (var kl = ks; kl < kJ; kl++) {
        if (e0.isTileBlank(kl, kf, ke) === true) {
          continue;
        }
        for (var kq = kz; kq < kN; kq++) {
          var kP = false;
          var kk = 256;
          if (kV === "web") {
            var kK = e0.calcLoopParam(kl, kf);
            var kS = {
              col: kK.col,
              row: kq,
              baseTileSize: 256,
              zoom: kf
            };
            var kB = i9.prototype.tileToBound(kS, kC.getCenter());
            if (kB.LL.sw.lng * kB.LL.ne.lng < 0 && Math.floor(kB.LL.ne.lng) < 0) {
              kP = true;
              kk = e0.pixelWidth(kB.MC.sw.lng, kC.getZoom());
            }
          }
          var km = {
            col: kl,
            row: kq,
            zoom: kf,
            useZoom: kL,
            tileTypeName: kV,
            loopOffsetX: 0,
            tileSize: kA,
            baseTileSize: ke,
            mercatorSize: kt,
            combine: kP,
            dataIndex: kk
          };
          ko.push(km);
          var kH = "id_" + kl + "_" + kq + "_" + kf;
          ko[kH] = true;
        }
      }
      if (kI !== BMAP_SATELLITE_MAP) {
        ko = e0.calcLoopTiles(ko, kf, ke, kt);
      }
      if (kf === 3) {
        for (var kR = 0, kO = ko.length; kR < kO; kR++) {
          var kl = ko[kR].col;
          var kq = ko[kR].row;
          var kK = e0.calcLoopParam(kl, kf);
          var kg = kK.T;
          var ku = kl >= 0 ? kl - kg : kl + kg;
          var kv = "id_" + ku + "_" + kq + "_" + kf;
          if (!ko[kv]) {
            var km = {
              col: ku,
              row: kq,
              zoom: kf,
              useZoom: kL,
              loopOffsetX: 0,
              tileSize: kA,
              baseTileSize: ke,
              mercatorSize: kt,
              combine: false
            };
            ko.push(km);
            ko[kv] = true;
          }
        }
      }
      if (this.map._tilt > 0) {
        for (var kR = 0; kR < ko.length; kR++) {
          var ki = ko[kR];
          var kM = ki.col;
          var kU = ki.row;
          var kF = [];
          kF.minX = kM * kt;
          kF.maxX = (kM + 1) * kt;
          kF.minY = kU * kt;
          kF.maxY = (kU + 1) * kt;
          var kd = new cx(0, 0);
          kd.lng = (kF.minX + kF.maxX) / 2;
          kd.lat = (kF.minY + kF.maxY) / 2;
          var kr = kC.pointToPixelIn(kd);
          if (kr.x > 0 && kr.x < this.map.width && kr.y > 0 && kr.y < this.map.height) {
            continue;
          }
          if (kF.minX < kE.lng && kF.maxX > kE.lng && kF.minY < kE.lat && kF.maxY > kE.lat) {
            continue;
          }
          if (!this.ifTileInMapBounds(kF, ky, kM, kU)) {
            ko.splice(kR, 1);
            kR--;
          }
        }
      }
      ko.sort(function (i) {
        return function (T, kW) {
          return 0.4 * Math.abs(T.col - i[0]) + 0.6 * Math.abs(T.row - i[1]) - (0.4 * Math.abs(kW.col - i[0]) + 0.6 * Math.abs(kW.row - i[1]));
        };
      }([kx, kh]));
      ko.zoom = kf;
      ko.tileTypeName = kV;
      return ko;
    },
    calcXYZTilesInfo: function (kn, kg, km, kr, kf, ku) {
      var ki = ku.width;
      var ks = ku.height;
      var kh = Math.floor(km);
      var kj = null;
      if (kf.transform.target === "EPSG3857") {
        var kc = dB.transformBDmcPoint(kn, kf.transform);
        var kd = dB.getRangeExtent(kc, ki, ks, kh, kf.transform);
        kj = [kd.minX, kd.minY, kd.maxX, kd.maxY];
      } else if (kf.transform.source === "BD09MC") {
        var kc = [kn.lng, kn.lat];
        kj = [kg.sw.lng, kg.sw.lat, kg.ne.lng, kg.ne.lat];
      } else {
        var kc = dB.transformBDmcPoint(kn, kf.transform);
        var ke = dB.transformBDmcPoint(kg.ne, kf.transform);
        var kl = dB.transformBDmcPoint(kg.sw, kf.transform);
        kj = dB.getLoopBox(kc, [kl[0], kl[1], ke[0], ke[1]]);
      }
      if (!kc || !kj) {
        return [];
      }
      kh = kh + kf.spanLevel;
      var T = dB.getTileRangeForExtentFactory(kj, kh, kf.transform);
      var e = [];
      var kv = dB.getResolutionScale(kh, kf.transform);
      for (var kq = T.minX; kq <= T.maxX; kq++) {
        for (var ko = T.minY; ko <= T.maxY; ko++) {
          var kp = {
            col: kq,
            row: ko,
            zoom: kh,
            useZoom: kh,
            tileTypeName: kr,
            loopOffsetX: 0,
            tileSize: 256 * kv,
            transform: kf.transform,
            combine: false,
            dataIndex: 0
          };
          e.push(kp);
          var kk = "id_" + kq + "_" + ko + "_" + kh;
          e[kk] = true;
        }
      }
      var kt = dB.getTileCoordForCoordAndZ(kc, kh);
      e.sort(function (i) {
        return function (kw, kx) {
          return 0.4 * Math.abs(kw.col - i[0]) + 0.6 * Math.abs(kw.row - i[1]) - (0.4 * Math.abs(kx.col - i[0]) + 0.6 * Math.abs(kx.row - i[1]));
        };
      }([kt[1], kt[2]]));
      e.zoom = kh;
      e.tileTypeName = kr;
      return e;
    },
    getCurrentViewTilesInfo: function (T, kc) {
      var i = this._getTilesInfoKey(T, kc);
      var e = this.tilesInfoCache[i];
      if (!e) {
        return this.calcTilesInfo(T, kc);
      }
      return e;
    },
    ifTileInMapBounds: function (e, ke, T, kd) {
      var i = ke.normalizedBottomLeft;
      var kp = ke.normalizedTopRight;
      var kh = ke.normalizedTopLeft;
      var kf = ke.normalizedBottomRight;
      var kc = false;
      var ko = new cx(e.minX, e.minY);
      var kl = new cx(e.maxX, e.maxY);
      var kg = new cx(kl.lng, ko.lat);
      var km = new cx(ko.lng, kl.lat);
      var kj = [km, kl, kg, ko];
      for (var kn = 0, ki = kj.length; kn < ki; kn++) {
        var kk = kn + 1;
        if (kk === ki) {
          kk = 0;
        }
        var kq = kn;
        var kr = i8(kj[kk], kj[kq], kh, i);
        if (kr) {
          kc = true;
          break;
        }
        kr = i8(kj[kk], kj[kq], kf, kp);
        if (kr) {
          kc = true;
          break;
        }
        kr = i8(kj[kk], kj[kq], kp, kh);
        if (kr) {
          kc = true;
          break;
        }
        kr = i8(kj[kk], kj[kq], i, kf);
        if (kr) {
          kc = true;
          break;
        }
      }
      return kc;
    },
    getTileLayer: function (kd) {
      for (var kc = 0, e = this.tileLayers.length; kc < e; kc++) {
        var T = this.tileLayers[kc];
        if (T.mapType === kd) {
          return T;
        }
      }
      return null;
    },
    isExitTileLayer: function (kd) {
      for (var kc = 0, e = this.tileLayers.length; kc < e; kc++) {
        var T = this.tileLayers[kc];
        if (T === kd) {
          return true;
        }
      }
      return false;
    },
    getZoomState: function (i) {
      var e = i - this.lastZoom;
      if (e > 0) {
        this.zoomState = 1;
      } else if (e < 0) {
        this.zoomState = -1;
      }
      this.lastZoom = i;
      return this.zoomState;
    }
  });
  function iA(e) {
    this.map = e;
    this.gl = null;
    this.layers = [];
    this.mouseEventThrottle = this.throttle(this.pick, 100).bind(this);
    this.base = new cx(12069475.280738307, 3929271.1724863998);
  }
  bx.register(function (i) {
    if (i._renderType !== "webgl") {
      return;
    }
    var e = i._normalLayerMgr = new iA(i);
    i.toFormatCoords = function (ke) {
      var kf = [];
      for (var kd = 0; kd < ke.length; kd++) {
        var T = i9.convertLL2MC(new cx(ke[kd][0], ke[kd][1]));
        var kc = [T.lng - e.base.lng, T.lat - e.base.lat];
        kf.push(kc);
      }
      return kf;
    };
    i.indexToRgb = function (kc) {
      kc++;
      var T = Math.floor(kc / 65536);
      kc -= T * 65536;
      var ke = Math.floor(kc / 256);
      kc -= ke * 256;
      var kd = kc;
      return [kd, ke, T];
    };
    i.addEventListener("addnormallayer", function (T) {
      e.addWebGLLayer(T.target);
    });
    i.addEventListener("removenormallayer", function (T) {
      e.removeWebGLLayer(T.target);
    });
    i.addEventListener("onmousemove", e._layerMouseEvent.bind(e));
    i.addEventListener("onclick", e._layerClickEvent.bind(e));
    i.addEventListener("ondblclick", e._layerDBLClickEvent.bind(e));
    i.on("destroy", function () {
      e.removeAllLayers(true);
      i.indexToRgb = null;
      i.toFormatCoords = null;
      e.pickFBO = null;
      e.preFramebuffer = null;
      e.gl = null;
    });
    i.on("glmoduleloaded", function () {
      e.gl = i._webglPainter.gl;
      e.pickFBO = e.createFramebuffer();
      for (var T = 0; T < e.layers.length; T++) {
        e.layers[T].onInit(i, e.gl);
      }
      i.dispatchEvent(new fJ("onupdate"));
    });
  });
  eX.extend(iA.prototype, {
    init: function () {
      var e = this;
      this.map.toFormatCoords = function (ke) {
        var kf = [];
        for (var kd = 0; kd < ke.length; kd++) {
          var T = i9.convertLL2MC(new cx(ke[kd][0], ke[kd][1]));
          var kc = [T.lng - e.base.lng, T.lat - e.base.lat];
          kf.push(kc);
        }
        return kf;
      };
      this.map.indexToRgb = function (kc) {
        kc++;
        var T = Math.floor(kc / 65536);
        kc -= T * 65536;
        var ke = Math.floor(kc / 256);
        kc -= ke * 256;
        var kd = kc;
        return [kd, ke, T];
      };
      this.pickFBO = this.createFramebuffer();
      var i = this;
      this.map.addEventListener("addnormallayer", function (T) {
        i.addWebGLLayer(T.target);
      });
      this.map.addEventListener("removenormallayer", function (T) {
        i.removeWebGLLayer(T.target);
      });
      this.map.addEventListener("onmousemove", this._layerMouseEvent.bind(this));
      this.map.addEventListener("onclick", this._layerClickEvent.bind(this));
      this.map.addEventListener("ondblclick", this._layerDBLClickEvent.bind(this));
      this.map.on("destroy", function () {
        i.removeAllLayers(true);
        i.map.indexToRgb = null;
        i.map.toFormatCoords = null;
        i.pickFBO = null;
        i.preFramebuffer = null;
      });
    },
    addWebGLLayer: function (T) {
      var kc = false;
      for (var e = 0; e < this.layers.length; e++) {
        if (this.layers[e] === T) {
          kc = true;
          break;
        }
      }
      if (!kc) {
        this.layers.push(T);
        if (this.gl) {
          T.onInit(this.map, this.gl);
        }
        this.map.dispatchEvent(new fJ("onupdate"));
      }
    },
    removeWebGLLayer: function (T) {
      for (var e = 0; e < this.layers.length; e++) {
        if (this.layers[e] === T) {
          this.map._featureMgr.removeLayer(T.zIndex);
          this.layers.splice(e, 1);
          T.onDestroy();
          this.map.dispatchEvent(new fJ("onupdate"));
          break;
        }
      }
    },
    removeAllLayers: function (kc) {
      for (var T = 0; T < this.layers.length; T++) {
        var e = this.layers[T];
        if (e.visible) {
          this.map._featureMgr.removeLayer(e.zIndex);
        }
        if (kc) {
          if (e.onKill) {
            e.onKill();
          }
        }
        e.onDestroy();
      }
      this.layers = [];
      this.map.dispatchEvent(new fJ("onupdate"));
    },
    sortLayer: function () {
      this.layers.sort(function (i, e) {
        return i.zIndex - e.zIndex > 0;
      });
    },
    _layerMouseEvent: function (i) {
      this.mouseEventThrottle(i, "onmousemove");
    },
    _layerClickEvent: function (i) {
      this.pick(i, "onclick");
    },
    _layerDBLClickEvent: function (i) {
      this.pick(i, "ondblclick");
    },
    throttle: function (T, e) {
      var kc = null;
      var i = Date.now();
      return function () {
        var kg = Date.now();
        var kf = e - (kg - i);
        var ke = this;
        var kd = arguments;
        if (kc) {
          clearTimeout(kc);
        }
        if (kf <= 0) {
          T.apply(ke, kd);
          i = Date.now();
        } else {
          kc = setTimeout(function () {
            T.apply(ke, kd);
          }, kf);
        }
      };
    },
    pick: function (ki, kg) {
      if (!this.layers.length) {
        return false;
      }
      var kc = false;
      var kd = false;
      var T = false;
      for (var kf = 0; kf < this.layers.length; kf++) {
        var ke = this.layers[kf];
        if (ke.doRender()) {
          T = true;
          if (ke.pick) {
            if (kg === "onmousemove" || ke.hasEvent(kg)) {
              var kh = ke.pick(ki.x, ki.y, kg);
            } else {
              continue;
            }
            if (ke.autoSelect) {
              kc = true;
            }
            if (kh && kh.dataIndex !== -1) {
              if (kg === "onmousemove") {
                kd = true;
              }
              if (ke.hasEvent(kg)) {
                ke.dispatcher(ki, kh, kg);
                kc = true;
              }
              if (!ke.popEvent) {
                break;
              }
            } else if (ke.hasEvent(kg)) {
              ke.dispatcher(ki, kh, kg);
              kc = true;
            }
          }
        }
      }
      if (kg === "onmousemove" && T) {
        if (kd) {
          this.map.platform.style.cursor = this.map.config.overlayMoveCursor;
        } else {
          this.map.platform.style.cursor = this.map.config.defaultCursor;
        }
      }
      if (kc) {
        this.map.dispatchEvent(new fJ("onupdate"));
      }
      return kc;
    },
    saveFramebuffer: function () {
      var e = this.gl;
      this.preFramebuffer = e.getParameter(e.FRAMEBUFFER_BINDING);
    },
    bindFramebuffer: function (e) {
      var i = this.gl;
      if (e) {
        i.bindFramebuffer(i.FRAMEBUFFER, e);
      } else {
        i.bindFramebuffer(i.FRAMEBUFFER, null);
      }
    },
    clear: function (e) {
      var i = this.gl;
      i.clearColor(0, 0, 0, 0);
      if (e instanceof Array) {
        i.clearColor(e[0], e[1], e[2], e[3]);
      }
      i.clear(i.COLOR_BUFFER_BIT | i.DEPTH_BUFFER_BIT);
    },
    restoreFramebuffer: function () {
      var e = this.gl;
      e.bindFramebuffer(e.FRAMEBUFFER, this.preFramebuffer);
    },
    createFramebuffer: function (kc, i) {
      var kg = this.gl;
      kc = kc || kg.canvas.width;
      i = i || kg.canvas.height;
      var ke = kg.createFramebuffer();
      var kd = kg.createTexture();
      kg.bindTexture(kg.TEXTURE_2D, kd);
      kg.texImage2D(kg.TEXTURE_2D, 0, kg.RGBA, kc, i, 0, kg.RGBA, kg.UNSIGNED_BYTE, null);
      kg.texParameteri(kg.TEXTURE_2D, kg.TEXTURE_MAG_FILTER, kg.LINEAR);
      kg.texParameteri(kg.TEXTURE_2D, kg.TEXTURE_MIN_FILTER, kg.LINEAR);
      kg.texParameteri(kg.TEXTURE_2D, kg.TEXTURE_WRAP_S, kg.CLAMP_TO_EDGE);
      kg.texParameteri(kg.TEXTURE_2D, kg.TEXTURE_WRAP_T, kg.CLAMP_TO_EDGE);
      ke.texture = kd;
      var T = kg.createRenderbuffer();
      kg.bindRenderbuffer(kg.RENDERBUFFER, T);
      kg.renderbufferStorage(kg.RENDERBUFFER, kg.DEPTH_STENCIL, kc, i);
      ke.depthBuffer = T;
      kg.bindFramebuffer(kg.FRAMEBUFFER, ke);
      kg.framebufferTexture2D(kg.FRAMEBUFFER, kg.COLOR_ATTACHMENT0, kg.TEXTURE_2D, kd, 0);
      kg.framebufferRenderbuffer(kg.FRAMEBUFFER, kg.DEPTH_STENCIL_ATTACHMENT, kg.RENDERBUFFER, T);
      var kf = kg.checkFramebufferStatus(kg.FRAMEBUFFER);
      if (kg.FRAMEBUFFER_COMPLETE !== kf) {
        console.log("Frame buffer object is incomplete: " + kf.toString());
        return;
      }
      kg.bindFramebuffer(kg.FRAMEBUFFER, null);
      kg.bindTexture(kg.TEXTURE_2D, null);
      kg.bindRenderbuffer(kg.RENDERBUFFER, null);
      return ke;
    }
  });
  var hC = function () {
    function ki(kJ, kO, kK, kL, kQ) {
      kK = kK || 2;
      var kM = kO && kO.length;
      var kH = kM ? kO[0] * kK : kJ.length;
      var kN = kx(kJ, 0, kH, kK, true);
      var kG = kQ || [];
      if (!kN) {
        return kG;
      }
      var kF;
      var kE;
      var kD;
      var kC;
      var kR;
      var kP;
      var kS;
      kL = kL || 0;
      if (kM) {
        kN = kr(kJ, kO, kN, kK);
      }
      if (kJ.length > 80 * kK) {
        kF = kD = kJ[0];
        kE = kC = kJ[1];
        for (var kI = kK; kI < kH; kI += kK) {
          kR = kJ[kI];
          kP = kJ[kI + 1];
          if (kR < kF) {
            kF = kR;
          }
          if (kP < kE) {
            kE = kP;
          }
          if (kR > kD) {
            kD = kR;
          }
          if (kP > kC) {
            kC = kP;
          }
        }
        kS = Math.max(kD - kF, kC - kE);
      }
      T(kN, kG, kK, kF, kE, kS, null, kL);
      return kG;
    }
    function kx(kG, kI, kC, kH, kD) {
      var kE;
      var kF;
      if (kD === kB(kG, kI, kC, kH) > 0) {
        for (kE = kI; kE < kC; kE += kH) {
          kF = kf(kE, kG[kE], kG[kE + 1], kF);
        }
      } else {
        for (kE = kC - kH; kE >= kI; kE -= kH) {
          kF = kf(kE, kG[kE], kG[kE + 1], kF);
        }
      }
      if (kF && kl(kF, kF.next)) {
        kt(kF);
        kF = kF.next;
      }
      return kF;
    }
    function kp(kF, kC) {
      if (!kF) {
        return kF;
      }
      if (!kC) {
        kC = kF;
      }
      var kE = kF;
      var kD;
      do {
        kD = false;
        if (!kE.steiner && (kl(kE, kE.next) || kv(kE.prev, kE, kE.next) === 0)) {
          kt(kE);
          kE = kC = kE.prev;
          if (kE === kE.next) {
            return null;
          }
          kD = true;
        } else {
          kE = kE.next;
        }
      } while (kD || kE !== kC);
      return kC;
    }
    function T(kD, kF, kI, kG, kC, kM, kL, kJ) {
      if (!kD) {
        return;
      }
      if (!kL && kM) {
        kk(kD, kG, kC, kM);
      }
      var kK = kD;
      var kE;
      var kH;
      while (kD.prev !== kD.next) {
        kE = kD.prev;
        kH = kD.next;
        if (kM ? kA(kD, kG, kC, kM) : ks(kD)) {
          kF.push(kE.i / kI + kJ);
          kF.push(kD.i / kI + kJ);
          kF.push(kH.i / kI + kJ);
          kt(kD);
          kD = kH.next;
          kK = kH.next;
          continue;
        }
        kD = kH;
        if (kD === kK) {
          if (!kL) {
            T(kp(kD), kF, kI, kG, kC, kM, 1, kJ);
          } else if (kL === 1) {
            kD = ko(kD, kF, kI, kJ);
            T(kD, kF, kI, kG, kC, kM, 2, kJ);
          } else if (kL === 2) {
            kn(kD, kF, kI, kG, kC, kM, kJ);
          }
          break;
        }
      }
    }
    function ks(kE) {
      var kD = kE.prev;
      var kC = kE;
      var kG = kE.next;
      if (kv(kD, kC, kG) >= 0) {
        return false;
      }
      var kF = kE.next.next;
      while (kF !== kE.prev) {
        if (km(kD.x, kD.y, kC.x, kC.y, kG.x, kG.y, kF.x, kF.y) && kv(kF.prev, kF, kF.next) >= 0) {
          return false;
        }
        kF = kF.next;
      }
      return true;
    }
    function kA(kH, kI, kG, kO) {
      var kL = kH.prev;
      var kK = kH;
      var kJ = kH.next;
      if (kv(kL, kK, kJ) >= 0) {
        return false;
      }
      var kP = kL.x < kK.x ? kL.x < kJ.x ? kL.x : kJ.x : kK.x < kJ.x ? kK.x : kJ.x;
      var kM = kL.y < kK.y ? kL.y < kJ.y ? kL.y : kJ.y : kK.y < kJ.y ? kK.y : kJ.y;
      var kF = kL.x > kK.x ? kL.x > kJ.x ? kL.x : kJ.x : kK.x > kJ.x ? kK.x : kJ.x;
      var kE = kL.y > kK.y ? kL.y > kJ.y ? kL.y : kJ.y : kK.y > kJ.y ? kK.y : kJ.y;
      var kD = e(kP, kM, kI, kG, kO);
      var kN = e(kF, kE, kI, kG, kO);
      var kC = kH.nextZ;
      while (kC && kC.z <= kN) {
        if (kC !== kH.prev && kC !== kH.next && km(kL.x, kL.y, kK.x, kK.y, kJ.x, kJ.y, kC.x, kC.y) && kv(kC.prev, kC, kC.next) >= 0) {
          return false;
        }
        kC = kC.nextZ;
      }
      kC = kH.prevZ;
      while (kC && kC.z >= kD) {
        if (kC !== kH.prev && kC !== kH.next && km(kL.x, kL.y, kK.x, kK.y, kJ.x, kJ.y, kC.x, kC.y) && kv(kC.prev, kC, kC.next) >= 0) {
          return false;
        }
        kC = kC.prevZ;
      }
      return true;
    }
    function ko(kI, kE, kH, kG) {
      var kF = kI;
      do {
        var kD = kF.prev;
        var kC = kF.next.next;
        if (!kl(kD, kC) && i(kD, kF, kF.next, kC) && kw(kD, kC) && kw(kC, kD)) {
          kE.push(kD.i / kH + kG);
          kE.push(kF.i / kH + kG);
          kE.push(kC.i / kH + kG);
          kt(kF);
          kt(kF.next);
          kF = kI = kC;
        }
        kF = kF.next;
      } while (kF !== kI);
      return kF;
    }
    function kn(kC, kE, kG, kF, kD, kL, kH) {
      var kK = kC;
      do {
        var kJ = kK.next.next;
        while (kJ !== kK.prev) {
          if (kK.i !== kJ.i && ku(kK, kJ)) {
            var kI = kj(kK, kJ);
            kK = kp(kK, kK.next);
            kI = kp(kI, kI.next);
            T(kK, kE, kG, kF, kD, kL, null, kH);
            T(kI, kE, kG, kF, kD, kL, null, kH);
            return;
          }
          kJ = kJ.next;
        }
        kK = kK.next;
      } while (kK !== kC);
    }
    function kr(kE, kL, kH, kG) {
      var kI = [];
      var kF;
      var kJ;
      var kC;
      var kD;
      var kK;
      for (kF = 0, kJ = kL.length; kF < kJ; kF++) {
        kC = kL[kF] * kG;
        kD = kF < kJ - 1 ? kL[kF + 1] * kG : kE.length;
        kK = kx(kE, kC, kD, kG, false);
        if (kK === kK.next) {
          kK.steiner = true;
        }
        kI.push(kg(kK));
      }
      kI.sort(kh);
      for (kF = 0; kF < kI.length; kF++) {
        ke(kI[kF], kH);
        kH = kp(kH, kH.next);
      }
      return kH;
    }
    function kh(kD, kC) {
      return kD.x - kC.x;
    }
    function ke(kE, kD) {
      kD = ky(kE, kD);
      if (kD) {
        var kC = kj(kD, kE);
        kp(kC, kC.next);
      }
    }
    function ky(kC, kG) {
      var kD = kG;
      var kI = kC.x;
      var kH = kC.y;
      var kF = -Infinity;
      var kE;
      do {
        if (kH <= kD.y && kH >= kD.next.y) {
          var kL = kD.x + (kH - kD.y) * (kD.next.x - kD.x) / (kD.next.y - kD.y);
          if (kL <= kI && kL > kF) {
            kF = kL;
            if (kL === kI) {
              if (kH === kD.y) {
                return kD;
              }
              if (kH === kD.next.y) {
                return kD.next;
              }
            }
            kE = kD.x < kD.next.x ? kD : kD.next;
          }
        }
        kD = kD.next;
      } while (kD !== kG);
      if (!kE) {
        return null;
      }
      if (kI === kF) {
        return kE.prev;
      }
      var kK = kE;
      var kO = kE.x;
      var kM = kE.y;
      var kN = Infinity;
      var kJ;
      kD = kE.next;
      while (kD !== kK) {
        if (kI >= kD.x && kD.x >= kO && km(kH < kM ? kI : kF, kH, kO, kM, kH < kM ? kF : kI, kH, kD.x, kD.y)) {
          kJ = Math.abs(kH - kD.y) / (kI - kD.x);
          if ((kJ < kN || kJ === kN && kD.x > kE.x) && kw(kD, kC)) {
            kE = kD;
            kN = kJ;
          }
        }
        kD = kD.next;
      }
      return kE;
    }
    function kk(kG, kC, kF, kD) {
      var kE = kG;
      do {
        if (kE.z === null) {
          kE.z = e(kE.x, kE.y, kC, kF, kD);
        }
        kE.prevZ = kE.prev;
        kE.nextZ = kE.next;
        kE = kE.next;
      } while (kE !== kG);
      kE.prevZ.nextZ = null;
      kE.prevZ = null;
      kd(kE);
    }
    function kd(kI) {
      var kF;
      var kE;
      var kD;
      var kH;
      var kJ;
      var kC;
      var kK;
      var kG;
      var kL = 1;
      do {
        kE = kI;
        kI = null;
        kJ = null;
        kC = 0;
        while (kE) {
          kC++;
          kD = kE;
          kK = 0;
          for (kF = 0; kF < kL; kF++) {
            kK++;
            kD = kD.nextZ;
            if (!kD) {
              break;
            }
          }
          kG = kL;
          while (kK > 0 || kG > 0 && kD) {
            if (kK === 0) {
              kH = kD;
              kD = kD.nextZ;
              kG--;
            } else if (kG === 0 || !kD) {
              kH = kE;
              kE = kE.nextZ;
              kK--;
            } else if (kE.z <= kD.z) {
              kH = kE;
              kE = kE.nextZ;
              kK--;
            } else {
              kH = kD;
              kD = kD.nextZ;
              kG--;
            }
            if (kJ) {
              kJ.nextZ = kH;
            } else {
              kI = kH;
            }
            kH.prevZ = kJ;
            kJ = kH;
          }
          kE = kD;
        }
        kJ.nextZ = null;
        kL *= 2;
      } while (kC > 1);
      return kI;
    }
    function e(kD, kG, kC, kF, kE) {
      kD = 32767 * (kD - kC) / kE;
      kG = 32767 * (kG - kF) / kE;
      kD = (kD | kD << 8) & 16711935;
      kD = (kD | kD << 4) & 252645135;
      kD = (kD | kD << 2) & 858993459;
      kD = (kD | kD << 1) & 1431655765;
      kG = (kG | kG << 8) & 16711935;
      kG = (kG | kG << 4) & 252645135;
      kG = (kG | kG << 2) & 858993459;
      kG = (kG | kG << 1) & 1431655765;
      return kD | kG << 1;
    }
    function kg(kE) {
      var kD = kE;
      var kC = kE;
      do {
        if (kD.x < kC.x) {
          kC = kD;
        }
        kD = kD.next;
      } while (kD !== kE);
      return kC;
    }
    function km(kG, kF, kI, kH, kC, kJ, kE, kD) {
      return (kC - kE) * (kF - kD) - (kG - kE) * (kJ - kD) >= 0 && (kG - kE) * (kH - kD) - (kI - kE) * (kF - kD) >= 0 && (kI - kE) * (kJ - kD) - (kC - kE) * (kH - kD) >= 0;
    }
    function ku(kD, kC) {
      return kD.next.i !== kC.i && kD.prev.i !== kC.i && !kq(kD, kC) && kw(kD, kC) && kw(kC, kD) && kc(kD, kC);
    }
    function kv(kE, kD, kC) {
      return (kD.y - kE.y) * (kC.x - kD.x) - (kD.x - kE.x) * (kC.y - kD.y);
    }
    function kl(kD, kC) {
      return kD.x === kC.x && kD.y === kC.y;
    }
    function i(kE, kC, kD, kF) {
      if (kl(kE, kC) && kl(kD, kF) || kl(kE, kF) && kl(kD, kC)) {
        return true;
      }
      return kv(kE, kC, kD) > 0 !== kv(kE, kC, kF) > 0 && kv(kD, kF, kE) > 0 !== kv(kD, kF, kC) > 0;
    }
    function kq(kD, kC) {
      var kE = kD;
      do {
        if (kE.i !== kD.i && kE.next.i !== kD.i && kE.i !== kC.i && kE.next.i !== kC.i && i(kE, kE.next, kD, kC)) {
          return true;
        }
        kE = kE.next;
      } while (kE !== kD);
      return false;
    }
    function kw(kD, kC) {
      return kv(kD.prev, kD, kD.next) < 0 ? kv(kD, kC, kD.next) >= 0 && kv(kD, kD.prev, kC) >= 0 : kv(kD, kC, kD.prev) < 0 || kv(kD, kD.next, kC) < 0;
    }
    function kc(kE, kD) {
      var kH = kE;
      var kC = false;
      var kG = (kE.x + kD.x) / 2;
      var kF = (kE.y + kD.y) / 2;
      do {
        if (kH.y > kF !== kH.next.y > kF && kG < (kH.next.x - kH.x) * (kF - kH.y) / (kH.next.y - kH.y) + kH.x) {
          kC = !kC;
        }
        kH = kH.next;
      } while (kH !== kE);
      return kC;
    }
    function kj(kE, kD) {
      var kC = new kz(kE.i, kE.x, kE.y);
      var kF = new kz(kD.i, kD.x, kD.y);
      var kH = kE.next;
      var kG = kD.prev;
      kE.next = kD;
      kD.prev = kE;
      kC.next = kH;
      kH.prev = kC;
      kF.next = kC;
      kC.prev = kF;
      kG.next = kF;
      kF.prev = kG;
      return kF;
    }
    function kf(kD, kC, kG, kE) {
      var kF = new kz(kD, kC, kG);
      if (!kE) {
        kF.prev = kF;
        kF.next = kF;
      } else {
        kF.next = kE.next;
        kF.prev = kE;
        kE.next.prev = kF;
        kE.next = kF;
      }
      return kF;
    }
    function kt(kC) {
      kC.next.prev = kC.prev;
      kC.prev.next = kC.next;
      if (kC.prevZ) {
        kC.prevZ.nextZ = kC.nextZ;
      }
      if (kC.nextZ) {
        kC.nextZ.prevZ = kC.prevZ;
      }
    }
    function kz(kD, kC, kE) {
      this.i = kD;
      this.x = kC;
      this.y = kE;
      this.prev = null;
      this.next = null;
      this.z = null;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
    }
    ki.deviation = function (kH, kM, kJ, kE) {
      var kK = kM && kM.length;
      var kG = kK ? kM[0] * kJ : kH.length;
      var kD = Math.abs(kB(kH, 0, kG, kJ));
      if (kK) {
        for (var kI = 0, kL = kM.length; kI < kL; kI++) {
          var kC = kM[kI] * kJ;
          var kF = kI < kL - 1 ? kM[kI + 1] * kJ : kH.length;
          kD -= Math.abs(kB(kH, kC, kF, kJ));
        }
      }
      var kQ = 0;
      for (kI = 0; kI < kE.length; kI += 3) {
        var kP = kE[kI] * kJ;
        var kO = kE[kI + 1] * kJ;
        var kN = kE[kI + 2] * kJ;
        kQ += Math.abs((kH[kP] - kH[kN]) * (kH[kO + 1] - kH[kP + 1]) - (kH[kP] - kH[kO]) * (kH[kN + 1] - kH[kP + 1]));
      }
      return kD === 0 && kQ === 0 ? 0 : Math.abs((kQ - kD) / kD);
    };
    function kB(kG, kI, kC, kH) {
      var kF = 0;
      for (var kE = kI, kD = kC - kH; kE < kC; kE += kH) {
        kF += (kG[kD] - kG[kE]) * (kG[kE + 1] + kG[kD + 1]);
        kD = kE;
      }
      return kF;
    }
    ki.flatten = function (kG) {
      var kH = kG[0][0].length;
      var kC = {
        vertices: [],
        holes: [],
        dimensions: kH
      };
      var kE = 0;
      for (var kF = 0; kF < kG.length; kF++) {
        for (var kD = 0; kD < kG[kF].length; kD++) {
          for (var kI = 0; kI < kH; kI++) {
            kC.vertices.push(kG[kF][kD][kI]);
          }
        }
        if (kF > 0) {
          kE += kG[kF - 1].length;
          kC.holes.push(kE);
        }
      }
      return kC;
    };
    return ki;
  }();
  function cC(i, e) {
    this.id = f2();
    this.workerPool = i;
    this.actors = [];
    this.currentActorIndex = 0;
    this.ready = false;
    this.init(e);
  }
  cC.prototype.init = function (ke) {
    const e = this.workerPool.acquire(this.id);
    for (var kc = 0; kc < e.length; kc++) {
      const kf = e[kc];
      const kd = new jr(kf, ke, this.id);
      kd.name = "Worker " + kc;
      this.actors.push(kd);
    }
    var T = this;
    this.broadcast("hasReady", null, function () {
      T.ready = true;
    });
  };
  cC.prototype.broadcast = function (i, T, e) {
    e = e || function () {};
    k(this.actors, function (kd, kc) {
      kd.send(i, T, kc);
    }, e);
  };
  cC.prototype.getActor = function () {
    const e = this.actors.filter(function (i) {
      return !i.busy;
    })[0];
    if (e) {
      return e;
    }
    this.currentActorIndex = (this.currentActorIndex + 1) % this.actors.length;
    return this.actors[this.currentActorIndex];
  };
  cC.prototype.stop = function () {
    for (var e = 0; e < this.actors.length; e++) {
      var T = this.actors[e];
      T.stop();
    }
  };
  cC.prototype.remove = function () {
    for (var e = 0; e < this.actors.length; e++) {
      var T = this.actors[e];
      T.remove();
    }
    this.actors.length = 0;
    this.workerPool.release(this.id);
  };
  function jr(T, i, e) {
    this.target = T;
    this.parent = i;
    this.mapId = e;
    this.busy = false;
    this.taskQueue = [];
    this.callbacks = {};
    this.init();
  }
  jr.prototype.init = function () {
    this.receive = this.receive.bind(this);
    this.target.addEventListener("message", this.receive, false);
  };
  jr.prototype.setBusy = function (e) {
    this.busy = e;
    if (!e && this.taskQueue.length) {
      var i = this.taskQueue.shift();
      this.send(i.action, i.data, i.callback, i.targetMapId, i.mustQueue, i.callbackMetadata);
    }
  };
  jr.prototype.receive = function (kc) {
    const kd = kc.data;
    const kg = kd.id;
    if (!kg) {
      return;
    }
    if (kd.targetMapId && this.mapId !== kd.targetMapId) {
      return;
    }
    if (kd.action === "<response>") {
      this.setBusy(false);
      const kf = this.callbacks[kg];
      delete this.callbacks[kg];
      if (kf) {
        if (kd.error) {
          kf(h9(kd.error));
        } else {
          kf(null, h9(kd.data));
        }
      }
    } else {
      var T = this;
      const i = [];
      const e = kd.hasCallback ? function (kh, ki) {
        T.target.postMessage({
          id: kg,
          action: "<response>",
          sourceMapId: T.mapId,
          error: kh ? js(kh) : null,
          data: js(ki, i)
        }, i);
      } : function (kh) {};
      const ke = h9(kd.data);
      if (this.parent[kd.action]) {
        this.parent[kd.action](kd.sourceMapId, ke, e);
      }
    }
  };
  jr.prototype.send = function (i, T, kf, kc, kd, kg) {
    if (i === "release") {
      this.releasePendingData(T, kf);
      return;
    }
    if (this.busy) {
      this.taskQueue.push({
        action: i,
        data: T,
        callback: kf,
        targetMapId: kc,
        mustQueue: kd,
        callbackMetadata: kg
      });
      return;
    }
    this.setBusy(true);
    var ke = Math.round(Math.random() * 1000000000000000000).toString(36).substring(0, 10);
    const e = this.mapId + "_" + i + "_" + ke;
    if (kf) {
      kf.metadata = kg;
      this.callbacks[e] = kf;
    }
    const kh = [];
    this.target.postMessage({
      id: e,
      action: i,
      hasCallback: !!kf,
      targetMapId: kc,
      mustQueue: kd,
      sourceMapId: this.mapId,
      data: js(T, kh)
    }, kh);
    return {
      cancel: function () {
        if (kf) {
          delete this.callbacks[e];
        }
        this.target.postMessage({
          id: e,
          action: "<cancel>",
          targetMapId: kc,
          sourceMapId: this.mapId
        });
      }
    };
  };
  jr.prototype.stop = function () {
    this.taskQueue.length = 0;
    this.busy = false;
    this.callbacks = {};
  };
  jr.prototype.remove = function () {
    this.taskQueue.length = 0;
    this.busy = false;
    this.target.removeEventListener("message", this.receive, false);
  };
  jr.prototype.releasePendingData = function (e, kf) {
    var T = [];
    var kd = this.taskQueue;
    for (var kc = kd.length - 1; kc >= 0; kc--) {
      var ke = kd[kc].data;
      if (!ke || !ke.layerId) {
        break;
      }
      if (ke.layerId !== e.layerId) {
        continue;
      }
      if (!e["id_" + ke.x + "_" + ke.y + "_" + ke.z]) {
        kd.splice(kc, 1);
        T.push(ke);
      }
    }
    kf(null, T);
  };
  var j2;
  function hl() {
    if (!j2) {
      j2 = new hr();
    }
    return j2;
  }
  function hr() {
    this.active = {};
  }
  hr.prototype.acquire = function (i) {
    if (!this.workers) {
      this.workers = [];
      var T = (window.location.protocol === "http:" ? "http:" : "https:") + "//api.map.baidu.com/res/webgl/10/worker_mvt_riv4eq.js";
      while (this.workers.length < hr.workerCount) {
        var e = jL(T);
        this.workers.push(e);
      }
    }
    this.active[i] = true;
    return this.workers.slice();
  };
  hr.prototype.release = function (T) {
    delete this.active[T];
    if (this.numActive() === 0) {
      for (var e = 0; e < this.workers.length; e++) {
        this.workers[e].terminate();
      }
      this.workers = null;
    }
  };
  hr.prototype.numActive = function () {
    return Object.keys(this.active).length;
  };
  hr.workerCount = 2;
  function hs(e) {
    this._map = e;
    this._spotsId = {};
    this._init();
  }
  hs.prototype._init = function () {
    var i = this._map;
    var e = this;
    i.addEventListener("onspotsdataready", function (kc) {
      var T = kc.spots;
      if (e._spotsId[kc.index]) {
        i.removeSpots(e._spotsId[kc.index]);
      }
      e._spotsId[kc.index] = i.addSpots(T);
    });
    i.addEventListener("onspotsdataremove", function (T) {
      if (e._spotsId[T.index]) {
        i.removeSpots(e._spotsId[T.index]);
      }
    });
  };
  bx.register(function (e) {
    if (!e.config.enableIconClick) {
      return;
    }
    e._mapIcon = new hs(e);
  });
  function c7(e) {
    this._indoorData = {};
    this._map = e;
    this.currentUid = null;
    this.currentFloor = null;
    this._indoorControl = null;
    this.enterMethod = null;
    this.showMask = false;
    this._isMobile = bW();
    this._autoEnterZoom = 19;
    if (this._isMobile) {
      this._autoEnterZoom = 17;
    }
    this._init(e);
    window._indoorMgr = this;
  }
  c7.prototype._init = function (i) {
    var e = this;
    i.on("indoor_status_changed", function (kf) {
      var T = kf.uid;
      var kd = kf.floor;
      if (T === null) {
        T = e.currentUid;
        if (e._indoorData[T]) {
          kd = e._indoorData[T].defaultFloor;
        }
        if (e._indoorControl) {
          e._indoorControl.hide();
        }
        e.currentUid = null;
        e.currentFloor = null;
        e.enterMethod = null;
      } else if (e._indoorData[T]) {
        var ke = e._indoorData[T];
        kd = typeof kd === "number" ? kd : ke.defaultFloor;
        if (!e._indoorControl) {
          if (i.config.showControls && i._displayOptions.indoor) {
            e._indoorControl = new au(i, ke);
          }
        } else {
          e._indoorControl.setInfo(ke);
          e._indoorControl.show();
        }
        e.currentUid = T;
        e.currentFloor = kd;
      }
      if (!e._indoorData || !e._indoorData[T] || e._indoorData[T].currentFloor === kd) {
        this.fire(new fJ("onrefresh"));
        return;
      }
      var kc = new fJ("onindoor_data_refresh");
      kc.uid = T;
      kc.floor = kd;
      kc.tileKey = e._indoorData[T].tileKey;
      e._indoorData[T].currentFloor = kd;
      e.currentFloor = kd;
      this.fire(kc);
    });
    i.on("spotclick", function (kc) {
      var T = null;
      if (kc.curAreaSpot && this.areaSpots[kc.curAreaSpot]) {
        T = this.areaSpots[kc.curAreaSpot].userData.uid;
      }
      if (T === e.currentUid) {
        if (kc.curAreaSpot) {
          e.enterMethod = "byClick";
        }
        return;
      }
      if (T === null) {
        if (e.currentUid && e.enterMethod === "byClick") {
          i.showIndoor(null);
          e.enterMethod = null;
        }
      } else {
        e.enterMethod = "byClick";
        if (e.currentUid) {
          i.showIndoor(e.currentUid, e._indoorData[e.currentUid].defaultFloor);
        }
        i.showIndoor(T, e._indoorData[T].defaultFloor);
      }
    });
    i.on("moveend", function () {
      if (this.getZoom() >= e._autoEnterZoom) {
        e._checkIndoorByMove();
      }
    });
    i.on("zoomend", function () {
      if (this.getZoom() >= e._autoEnterZoom) {
        e._checkIndoorByMove();
      } else if (e.enterMethod !== "byClick" && e.currentUid !== null) {
        this.showIndoor(null);
      }
    });
  };
  c7.prototype._checkIndoorByMove = function () {
    var T = this._map;
    var ki = T.getSize();
    var kn = {
      x: ki.width / 2,
      y: ki.height / 2
    };
    var km = Math.max(ki.width, ki.height);
    var ko = [];
    for (var kj in this._indoorData) {
      var e = this._indoorData[kj].center;
      var kc = T.pointToPixelIn(new bx.Point(e[0], e[1]));
      var kf = ci(kn, kc);
      ko.push({
        uid: kj,
        distance: kf
      });
    }
    if (ko.length === 0) {
      return;
    }
    ko.sort(function (kp, i) {
      return kp.distance - i.distance;
    });
    var ke = ko[0];
    var kk = T.getCenterIn();
    var kd = false;
    for (var kh = 0; kh < this._indoorData[ke.uid].contour.length; kh++) {
      if (bK([kk.lng, kk.lat], this._indoorData[ke.uid].contour[kh])) {
        kd = true;
        break;
      }
    }
    if (kd === false && ke.uid === "e96b44200baa3b4082288acc") {
      var kg = this._indoorData[ke.uid].boundsMin;
      var kl = this._indoorData[ke.uid].boundsMax;
      if (kk.lng > kg[0] && kk.lat > kg[1] && kk.lng < kl[0] && kk.lat < kl[1]) {
        kd = true;
      }
    }
    if (kd) {
      if (this.enterMethod !== "byClick") {
        if (this.currentUid !== null && this.currentUid !== ke.uid) {
          this._map.showIndoor(this.currentUid, this._indoorData[this.currentUid].defaultFloor);
        }
        if (this.currentUid !== ke.uid) {
          this._map.showIndoor(ke.uid, this._indoorData[ke.uid].defaultFloor);
        }
        this.enterMethod = "byMove";
      }
    } else if (this.enterMethod !== "byClick") {
      this._map.showIndoor(null);
    }
  };
  c7.prototype.setData = function (kc) {
    if (kc === null) {
      return;
    }
    for (var T in kc) {
      if (T === "tileInfo") {
        continue;
      }
      var kd = kc[T].tileKey;
      if (this._indoorData[T]) {
        if (!this._indoorData[T][kd]) {
          this._indoorData[T].tileKeys.push(kd);
          this._indoorData[T][kd] = true;
        }
      } else {
        this._indoorData[T] = kc[T];
        this._indoorData[T].tileKeys = [kc[T].tileKey];
        this._indoorData[T][kd] = true;
        for (var e = 0; e < this._indoorData[T].contour.length; e++) {
          this._map.addAreaSpot(this._indoorData[T].contour[e], {
            id: T + e,
            userData: {
              uid: T
            }
          });
        }
      }
    }
    if (this._map.getZoom() >= this._autoEnterZoom) {
      this._checkIndoorByMove();
    }
  };
  c7.prototype.removeData = function (T, kd) {
    if (!this._indoorData[T]) {
      return;
    }
    var kc = this._indoorData[T];
    for (var e = 0; e < kc.tileKeys.length; e++) {
      if (kc.tileKeys[e] === kd) {
        kc.tileKeys.splice(e, 1);
        break;
      }
    }
    delete kc[kd];
    if (kc.tileKeys.length === 0) {
      delete this._indoorData[T];
    }
  };
  c7.prototype.getIndoorData = function (e) {
    return this._indoorData[e] || null;
  };
  c7.prototype.getData = function () {
    return this._indoorData;
  };
  bx.register(function (e) {
    e._indoorMgr = new c7(e);
  });
  var aX = function () {
    var kc = {};
    var kl = {};
    var kh = {};
    function kj(kn) {
      if (Object.prototype.toString.call(kn) === "[object Object]") {
        for (var km in kn) {
          return false;
        }
        return true;
      } else {
        return false;
      }
    }
    function ki(kt, ku, kx, kq, kw) {
      var km = km || null;
      kq = kq || km;
      var ko;
      if (kq) {
        ko = kk(kt, ku, kx, kq);
      } else {
        ko = T(kt, ku, kx, kw);
      }
      var ks = ko.drawId;
      var kn = ko.style;
      var kv = ko.styleUpdate;
      var ky = [];
      if (!ks) {
        return ky;
      }
      for (var kp = 0; kp < ks.length; kp++) {
        var kr = kv[ks[kp]] || kn[ks[kp]];
        if (kr) {
          switch (ku) {
            case "polygon":
              kr = kd(kr, kt);
              break;
            case "line":
              kr = kg(kr, kt);
              break;
            case "pointText":
              kr = ke(kr, kt);
              break;
            case "point":
              kr = e(kr, kt);
              break;
            case "polygon3d":
              kr = kf(kr, kt);
              break;
          }
          if (kr) {
            kr.did = ks[kp];
            ky[ky.length] = kr;
          }
        }
      }
      return ky;
    }
    function kk(kn, kp, kq, km) {
      var ko = km[2];
      switch (kp) {
        case "point":
          ko = ko[0];
          break;
        case "pointText":
          ko = ko[1];
          break;
        case "line":
          ko = ko[3];
          break;
        case "polygon":
          ko = ko[4];
          break;
        case "polygon3d":
          ko = ko[5];
          break;
      }
      var ks = kq - 1;
      if (kp === "line" && kq === 12) {
        ks = kq;
      }
      var kt = km[1][ks][0];
      var kr = kt[kn];
      if (!kr && kq < 21) {
        if (kp === "point" || kp === "pointText") {
          kt = km[1][kq][0];
          kr = kt[kn];
        }
      }
      return {
        drawId: kr,
        style: ko,
        styleUpdate: []
      };
    }
    function T(kq, kr, ku, kt) {
      if (!kt) {
        return {
          drawId: null,
          style: [],
          styleUpdate: []
        };
      }
      var ks;
      var ko = kt.baseFs;
      if (kj(kt.zoomRegion)) {
        ks = kt.StyleBody || [];
      } else {
        ks = kt.zoomStyleBody[ku] || [];
      }
      var kn = ko[2];
      switch (kr) {
        case "point":
          kn = kn[0];
          ks = ks[0] || {};
          break;
        case "pointText":
          kn = kn[1];
          ks = ks[1] || {};
          break;
        case "line":
          kn = kn[3];
          ks = ks[3] || {};
          break;
        case "polygon":
          kn = kn[4];
          ks = ks[4] || {};
          break;
        case "polygon3d":
          kn = kn[5];
          ks = ks[5] || {};
          break;
      }
      var km = ko[1][ku - 1][0];
      var kp = km[kq];
      if (!kp && ku < 21) {
        if (kr === "point" || kr === "pointText") {
          km = ko[1][ku][0];
          kp = km[kq];
        }
      }
      return {
        drawId: kp,
        style: kn,
        styleUpdate: ks
      };
    }
    function ke(kn, km) {
      if (!kn || kn.length === 0) {
        return null;
      }
      return {
        sid: km,
        fontRgba: i(kn[0]),
        haloRgba: i(kn[1]),
        backRgba: i(kn[2]),
        fontSize: kn[3],
        haloSize: kn[4],
        fontWeight: kn[5],
        fontStyle: kn[6],
        density: kn[7]
      };
    }
    function e(kn, km) {
      return {
        sid: km,
        rank: kn[0],
        ucflag: kn[1],
        icon: kn[2],
        iconType: kn[3],
        nineGG: kn[4],
        density: kn[5],
        zoom: kn[6]
      };
    }
    function kg(kn, km) {
      return {
        sid: km,
        borderRgba: i(kn[0]),
        fillRgba: i(kn[1]),
        borderWidth: kn[2],
        fillWidth: kn[3],
        borderCap: kn[4],
        fillCap: kn[5],
        haveBorderLine: kn[6],
        haveBorderTexture: kn[7],
        haveFillTexture: kn[8],
        isUseBorderRgba: kn[9],
        isUseFillRgba: kn[10],
        borderTexture: kn[11],
        fillTexture: kn[12],
        borderTextureType: kn[13],
        fillTextureType: kn[14],
        isRealWidth: kn[15],
        haveArrow: kn[16],
        needRound: kn[17],
        realBorderWidth: kn[18]
      };
    }
    function kd(kn, km) {
      return {
        sid: km,
        fillRgba: i(kn[0]),
        borderRgba: i(kn[1]),
        borderWidth: kn[2],
        borderTexture: kn[3],
        borderTextureType: kn[4],
        waterStyle: kn[5],
        haloStyle: kn[6],
        textureStyle: kn[7],
        thickRgba: i(kn[8])
      };
    }
    function kf(kn, km) {
      return {
        sid: km,
        filter: kn[0],
        ratio: kn[1],
        haveBorder: kn[2],
        borderWidth: kn[3],
        borderRgba: i(kn[4]),
        fillTop: i(kn[5]),
        fillSide: i(kn[6]),
        polyTexture: kn[7]
      };
    }
    function i(kr) {
      var kq = kr;
      if (kh[kq]) {
        return kh[kq];
      }
      kr = kr >>> 0;
      var kp = kr & 255;
      var ko = kr >> 8 & 255;
      var km = kr >> 16 & 255;
      var kn = kr >> 24 & 255;
      kh[kq] = [kp, ko, km, kn];
      return kh[kq];
    }
    return {
      getStyleFromCache: function (kt, ko, kr, ks, kn, kq, km) {
        kt = kt || "default";
        var kp = kt + "-" + ko + "-" + kr + "-" + ks;
        if (kq) {
          kp += "-indoor";
        }
        if (kn) {
          if (!kl[kp]) {
            kl[kp] = ki(ko, kr, ks, kn);
          }
          return kl[kp];
        }
        if (!kc[kp]) {
          kc[kp] = ki(ko, kr, ks, kn, km);
        }
        return kc[kp];
      }
    };
  }();
  bx.register(function (i) {
    var e = new h8(i);
  });
  function h8(e) {
    e.container.appendChild(this.render());
    this.bind(e);
  }
  h8.prototype.render = function () {
    var i = document.createElement("div");
    i.className = "click-ripple-container";
    var e = document.createElement("div");
    e.className = "click-ripple";
    i.appendChild(e);
    this._div = i;
    this._ripple = e;
    return i;
  };
  h8.prototype.bind = function (i) {
    var e = this;
    i.addEventListener("spotclick", function (T) {
      if (!T.spots || T.spots.length === 0) {
        return;
      }
      e._div.style.left = T.pixel.x + "px";
      e._div.style.top = T.pixel.y + "px";
      eX.ac(e._ripple, "ripple-playing");
    });
    i.addEventListener("hotclick", function (T) {
      if (!T || !T.pixel || !(T.pixel instanceof fi)) {
        return;
      }
      e._div.style.left = T.pixel.x + "px";
      e._div.style.top = T.pixel.y + "px";
      eX.ac(e._ripple, "ripple-playing");
    });
    eX.on(e._ripple, "transitionend", function () {
      eX.rc(e._ripple, "ripple-playing");
    });
  };
  function bV(e) {
    c8.call(this);
    if (!e) {
      return;
    }
    this._opts = {};
    this._map = e;
    this._maxLat = 84.6;
    this._minLat = -80.6;
    this._maxLatMC = i9.convertLL2MC(new cr(this._maxLat, 0)).lat;
    this._minLatMC = i9.convertLL2MC(new cr(this._minLat, 0)).lat;
  }
  bV.inherits(c8, "ToolbarItem");
  eX.extend(bV.prototype, {
    open: function () {
      if (this._isOpen == true) {
        return true;
      }
      if (this._map._toolInUse) {
        return false;
      }
      this._map._toolInUse = true;
      this._isOpen = true;
      return true;
    },
    close: function () {
      if (!this._isOpen) {
        return;
      }
      this._map._toolInUse = false;
      this._isOpen = false;
    },
    _checkStr: function (e) {
      if (!e) {
        return "";
      }
      return e.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
  });
  function cf(T, i) {
    bV.call(this, T);
    i = i || {};
    this._opts = eX.extend(eX.extend(this._opts || {}, {
      autoClear: false,
      tips: "测距",
      followText: "单击确定起点，双击结束绘制",
      unit: "metric",
      showResult: true,
      lineColor: "blue",
      lineStroke: 2,
      opacity: 1,
      lineStyle: "solid",
      cursor: B.distCursor,
      styleCodes: {
        lnCode: 0,
        spCode: 0,
        slCode: 0,
        tlCode: 0
      },
      enableMassClear: true
    }), i);
    if (this._opts.showResult === false) {
      if (typeof i.tips === "undefined") {
        this._opts.tips = "绘制折线";
      }
      if (!i.cursor) {
        this._opts.cursor = "crosshair";
      }
    }
    if (this._opts.lineStroke <= 0) {
      this._opts.lineStroke = 2;
    }
    if (this._opts.opacity > 1) {
      this._opts.opacity = 1;
    } else if (this._opts.opacity < 0) {
      this._opts.opacity = 0;
    }
    if (this._opts.lineStyle !== "solid" && this._opts.lineStyle !== "dashed") {
      this._opts.lineStyle = "solid";
    }
    this._checked = false;
    this._drawing = null;
    this.followTitle = null;
    this._totalDis = {};
    this._points = [];
    this._paths = [];
    this._dots = [];
    this._segDistance = [];
    this._overlays = [];
    this._units = {
      metric: {
        name: "metric",
        conv: 1,
        incon: 1000,
        u1: "米",
        u2: "公里"
      },
      us: {
        name: "us",
        conv: 3.2808,
        incon: 5279.856,
        u1: "英尺",
        u2: "英里"
      }
    };
    if (!this._units[this._opts.unit]) {
      this._opts.unit = "metric";
    }
    this._dLineColor = "#ff6319";
    this._dLineStroke = 3;
    this._dOpacity = 0.8;
    this._dLineStyle = "solid";
    this._dCursor = B.distCursor;
    if (this._opts.showResult) {
      this._opts.followText = "单击确定起点";
    }
    this._followTextM = "单击确定地点，双击结束";
    this._sectionMarkerTip = "单击可删除此点，拖拽可调整位置";
    this._movingTimerId = null;
    if (this._opts.showResult) {
      this.text = "测距";
    } else {
      this.text = "绘线";
    }
    this._isOpen = false;
    var e = this;
    g2.load("tools", function () {
      e._draw();
    });
  }
  cf.inherits(bV, "PolylineTItem");
  eX.extend(cf.prototype, {
    setLineColor: function (e) {
      this._opts.lineColor = e;
    },
    setLineStroke: function (e) {
      if (Math.round(e) > 0) {
        this._opts.lineStroke = Math.round(e);
      }
    },
    setOpacity: function (e) {
      if (e >= 0 && e <= 1) {
        this._opts.opacity = e;
      }
    },
    setLineStyle: function (e) {
      if (e === "solid" || e === "dashed") {
        this._opts.lineStyle = e;
      }
    },
    clear: function () {
      for (var T = 0, e = this._overlays.length; T < e; T++) {
        if (this._overlays[T]) {
          this._map.removeOverlay(this._overlays[T]);
        }
      }
      this._overlays.length = 0;
      for (var T = 0, e = this._dots.length; T < e; T++) {
        if (this._dots[T] && this._dots[T].parentNode) {
          this._dots[T].parentNode.removeChild(this._dots[T]);
        }
      }
      this._dots.length = 0;
    },
    setCursor: function (e) {
      if (this._opts.showResult === true) {
        return;
      }
      this._opts.cursor = e;
    },
    getCursor: function () {
      if (this._opts.showResult === true) {
        return this._dCursor;
      }
      var e = this._opts.cursor.match(/^url\((.+)\)(,.*)?/);
      if (e !== null) {
        return e[1];
      } else {
        return this._opts.cursor;
      }
    },
    showResult: function (e) {
      this._opts.showResult = !!e;
    }
  });
  function bC() {
    var kd = 3;
    var kk = 256;
    var kc = Math.pow(2, 18 - kd) * kk;
    var kl = 2;
    var kj = (kl + 1) * kc;
    var T = i9.convertLL2MC(new cx(180, 0));
    var kh = T.lng;
    var kf = kj - kh;
    var ki = -3;
    var e = ki * kc;
    var ke = i9.convertLL2MC(new cx(-180, 0));
    var kg = ke.lng;
    var i = kg - e;
    this._validPixels = kh / Math.pow(2, 18 - kd);
    this._mc180X = kh;
    this._mcM180X = kg;
    this._loopOffset = kf + i;
    this._mcTSpan = kh - kg;
    this._spaceDistance = kf;
    this._mSpaceDistance = i;
  }
  bC.prototype = {
    calcLoopParam: function (kc, i, kj) {
      kj = kj || 256;
      var kg = 0;
      var kd = 3;
      var kf = 6;
      var ke = kf * Math.pow(2, i - kd) * 256 / kj;
      var ki = ke / 2 - 1;
      var kh = -ke / 2;
      while (kc > ki) {
        kc -= ke;
        kg -= this._loopOffset;
      }
      while (kc < kh) {
        kc += ke;
        kg += this._loopOffset;
      }
      var e = kg;
      kg = Math.round(kg / Math.pow(2, 18 - i));
      return {
        offsetX: kg,
        geoOffsetX: e,
        col: kc,
        T: ke,
        maxCol: ki,
        minCol: kh
      };
    },
    calcLoopCenterPoint: function (i) {
      var e = i.lng;
      while (e > this._mc180X) {
        e -= this._mcTSpan;
      }
      while (e < this._mcM180X) {
        e += this._mcTSpan;
      }
      i.lng = e;
      return i;
    },
    calcLoopMapBounds: function (T, kc) {
      var i = kc || T.getCenter();
      var e = T.sw.lng;
      var kd = T.ne.lng;
      while (i.lng > this._mc180X) {
        i.lng -= this._mcTSpan;
        e -= this._mcTSpan;
        kd -= this._mcTSpan;
      }
      while (i.lng < this._mcM180X) {
        i.lng += this._mcTSpan;
        e += this._mcTSpan;
        kd += this._mcTSpan;
      }
      T.sw.lng = e;
      T.ne.lng = kd;
      if (T.pointBottomLeft) {
        T.pointBottomLeft = this.calcLoopCenterPoint(T.pointBottomLeft);
        T.pointTopLeft = this.calcLoopCenterPoint(T.pointTopLeft);
        T.pointTopRight = this.calcLoopCenterPoint(T.pointTopRight);
        T.pointBottomRight = this.calcLoopCenterPoint(T.pointBottomRight);
      }
      return T;
    },
    calcLoopTiles: function (kk, e, ko, kh) {
      ko = ko || 256;
      var kd = kh || Math.pow(2, 18 - e) * ko;
      var kj = Math.floor(this._mc180X / kd);
      var kf = Math.floor(this._mcM180X / kd);
      var kl = Math.floor(this._loopOffset / kd);
      var km = [];
      for (var kg = 0; kg < kk.length; kg++) {
        var kn = kk[kg];
        var kc = kn[0];
        var kp = kn[1];
        if (kc >= kj) {
          var ki = kc + kl;
          if (this.isTileBlank(ki, e, ko) === true) {
            continue;
          }
          var T = "id_" + ki + "_" + kp + "_" + e;
          if (!kk[T]) {
            kk[T] = true;
            km.push([ki, kp, e, 0]);
          }
        } else if (kc <= kf) {
          var ki = kc - kl;
          if (this.isTileBlank(ki, e, ko) === true) {
            continue;
          }
          var T = "id_" + ki + "_" + kp + "_" + e;
          if (!kk[T]) {
            kk[T] = true;
            km.push([ki, kp, e, 0]);
          }
        }
      }
      for (var kg = 0, ke = km.length; kg < ke; kg++) {
        kk.push(km[kg]);
      }
      for (var kg = kk.length - 1; kg >= 0; kg--) {
        var kc = kk[kg][0];
        if (this.isTileBlank(kc, e, ko)) {
          kk.splice(kg, 1);
        }
      }
      return kk;
    },
    isTileBlank: function (T, kd, e) {
      var ke = Math.pow(2, kd - 3);
      var i = Math.round(this._validPixels * ke);
      var kc = 6 * ke * 256 / e;
      while (T > kc / 2 - 1) {
        T -= kc;
      }
      while (T < -(kc / 2)) {
        T += kc;
      }
      if (T > 0 && T * e > i) {
        return true;
      }
      if (T < 0 && Math.abs((T + 1) * e) > i) {
        return true;
      }
      return false;
    },
    isAddWidth: function (e, i) {
      return e < this._mcM180X || i > this._mc180X;
    },
    pixelWidth: function (e, i) {
      if (e < 0) {
        e = -e;
      }
      return Math.abs(e - this._mc180X) / Math.pow(2, 18 - i);
    },
    getSpaceDistanceInPixel: function (i) {
      var e = Math.round((this._spaceDistance + this._mSpaceDistance) / Math.pow(2, 18 - i));
      return e;
    }
  };
  var e0 = new bC();
  function eo() {
    this._id = undefined;
    this._type = undefined;
    this.grid = undefined;
    this.layerName = undefined;
    this.geojson = undefined;
    this._geometry = null;
    this._properties = {};
    this._box = null;
    this._state = {};
    this._style = null;
    this._visible = true;
    this.renderData = {};
    return this;
  }
  eo.prototype.serialize = function () {
    return {
      id: this.getId(),
      type: this.getType(),
      grid: this.grid,
      layerName: this.layerName,
      geojson: this.geojson,
      renderData: this.renderData,
      geometry: this.getGeometry(),
      box: this.getBox(),
      properties: this.getProperties(),
      state: this.getState(),
      visible: this._visible
    };
  };
  eo.prototype.deserialize = function (e) {
    this.setId(e.id);
    this.setType(e.type);
    this.grid = e.grid;
    this.layerName = e.layerName;
    this.geojson = e.geojson;
    this.setProperties(e.properties);
    this.setState(e.state);
    this._visible = e.visible || true;
    this.renderData = e.renderData;
    this.setGeometry(e.geometry);
    this.setBox(e.box);
    return this;
  };
  eo.prototype.getType = function () {
    return this._type;
  };
  eo.prototype.getGeometry = function () {
    return this._geometry;
  };
  eo.prototype.getId = function () {
    return this._id;
  };
  eo.prototype.getProperties = function () {
    return this._properties;
  };
  eo.prototype.getBox = function () {
    return this._box;
  };
  eo.prototype.getState = function () {
    if (Object.keys(this._state).length > 0) {
      return this._state;
    } else {
      return null;
    }
  };
  eo.prototype.getStyle = function () {
    return this._style;
  };
  eo.prototype.getStyleFunction = function () {
    return this._styleFunction;
  };
  eo.prototype.setType = function (e) {
    return this._type = e;
  };
  eo.prototype.setGeometry = function (e) {
    this._geometry = e;
  };
  eo.prototype.setStyle = function (e) {
    if (!e || Object.keys(e).length === 0) {
      return;
    }
    for (var i in e) {
      this.set(i, e[i], this._style);
    }
  };
  eo.prototype.setState = function (e) {
    for (var i in e) {
      this.set(i, e[i], this._state);
    }
  };
  eo.prototype.setId = function (e) {
    this._id = e;
  };
  eo.prototype.setProperties = function (e) {
    for (var i in e) {
      this.set(i, e[i], this._properties);
    }
  };
  eo.prototype.setBox = function (e) {
    return this._box = e;
  };
  eo.prototype.isPointInBox = function (e) {
    return this._pointInBox(e, this._box);
  };
  eo.prototype.getPointGeoJSON = function (kc) {
    var kl = this.renderData;
    if (kl) {
      var kf = kl.active;
      if (!kl[kf] || !kl[kf].poi) {
        return null;
      }
      var kk = [];
      var kh = kl[kf].poi;
      for (var ki = 0; ki < kh.length; ki++) {
        if (kh[ki].bds && kh[ki].bds.length === 4) {
          var kd = kc.pointToPixelIn(kh[ki].pt);
          var kg = kd.x - kh[ki].bds[0];
          var ke = kd.y - kh[ki].bds[1];
          var T = kd.x - kh[ki].bds[2];
          var e = kd.y - kh[ki].bds[3];
          kk.push([[kg, ke], [T, ke], [T, e], [kg, e], [kg, ke]]);
        }
      }
      if (kk.length === 0) {
        return null;
      } else {
        var kj = "Polygon";
        if (kk.length > 0) {
          kj = "MultiPolygon";
        }
        return {
          type: "Feature",
          properties: {},
          geometry: {
            type: kj,
            coordinates: [kk]
          }
        };
      }
    }
  };
  eo.prototype._pointInBox = function (e, i) {
    if (i[0] > e[0] || i[1] > e[1] || i[2] < e[0] || i[3] < e[1]) {
      return false;
    } else {
      return true;
    }
  };
  eo.prototype._pixelPnpoint = function (kd, kh, e) {
    var ki = false;
    if (kh) {
      var kc = kh.active;
      if (!kh[kc] || !kh[kc].poi) {
        return ki;
      }
      var ke = kh[kc].poi;
      for (var kf = 0; kf < ke.length; kf++) {
        if (ke[kf].bds && ke[kf].bds.length === 4) {
          var T = e.pointToPixelIn(ke[kf].pt);
          if (kd.x - T.x < ke[kf].bds[2] && kd.x - T.x > ke[kf].bds[0] && T.y - kd.y < ke[kf].bds[3] && T.y - kd.y > ke[kf].bds[1]) {
            if (e.getTilt() > 55) {
              var kg = e.pointToOverlayPixelIn(ke[kf].pt);
              if (kg.outOfFrustum) {
                continue;
              }
            }
            ki = true;
            break;
          }
        }
      }
    }
    return ki;
  };
  eo.prototype._pixelPnpoly = function (kd, kf) {
    var e = kf.length;
    var T = 0;
    var ke = false;
    for (var kc = 0; kc < e; kc++) {
      T = kc === e - 1 ? 0 : T + 1;
      if (kf[kc].lat !== kf[T].lat && (kd.lat >= kf[kc].lat && kd.lat < kf[T].lat || kd.lat >= kf[T].lat && kd.lat < kf[kc].lat) && kd.lng < (kf[T].lng - kf[kc].lng) * (kd.lat - kf[kc].lat) / (kf[T].lat - kf[kc].lat) + kf[kc].lng) {
        ke = !ke;
      }
    }
    return ke;
  };
  eo.prototype._getProximity = function (km, ki) {
    var T;
    var kc;
    var kl;
    var kg;
    var kf;
    var kk;
    var kj;
    var kp = ki.length;
    if (kp > 1) {
      for (var kn = 1; kn < kp; kn++) {
        var kh = ki[kn - 1];
        var kt = ki[kn];
        if (!kh || !kt) {
          continue;
        }
        if (kh.lng != kt.lng) {
          var ks = (kt.lat - kh.lat) / (kt.lng - kh.lng);
          var kq = kt.lat - ks * kt.lng;
          kj = Math.abs(ks * km.lng + kq - km.lat) / Math.sqrt(ks * ks + 1);
        } else {
          kj = Math.abs(km.lng - kt.lng);
        }
        var ko = Math.pow(kt.lat - kh.lat, 2) + Math.pow(kt.lng - kh.lng, 2);
        var kd = Math.pow(kt.lat - km.lat, 2) + Math.pow(kt.lng - km.lng, 2);
        var kr = Math.pow(kh.lat - km.lat, 2) + Math.pow(kh.lng - km.lng, 2);
        var ke = Math.pow(kj, 2);
        var e = kd - ke + kr - ke;
        if (e > ko) {
          kj = Math.sqrt(Math.min(kd, kr));
        }
        if (T == null || T > kj) {
          kc = Math.sqrt(kr - ke) / Math.sqrt(ko);
          kl = Math.sqrt(kd - ke) / Math.sqrt(ko);
          T = kj;
          kk = kn;
        }
        T = Math.min(T, kj);
      }
    }
    return {
      dist: T
    };
  };
  eo.prototype.isPointInGeometry = function (T, kh) {
    var e = false;
    switch (this._type) {
      case fO.POINT:
        e = this._pixelPnpoint(T, this.renderData, kh);
        break;
      case fO.LINE_STRING:
        var kd = this._getProximity({
          lng: T[0],
          lat: T[1]
        }, this._geometry);
        var kg = this.renderData[this.renderData.active];
        if (!kg || !kg.line || !kg.line[0] || !kg.line[0].width) {
          var kf = 2;
        } else {
          var kf = this.renderData[this.renderData.active].line[0].width;
          if (this.grid === d8.GridModel.GOOGLEWEB) {
            kf = Math.max(kf / 2 * dB.gridScaleFromBDMCTo3857, 2);
          } else {
            kf = Math.max(kf / 2, 2);
          }
        }
        if (kd.dist < kf) {
          e = true;
        }
        break;
      case fO.POLYGON:
        e = this._pixelPnpoly({
          lng: T[0],
          lat: T[1]
        }, this._geometry);
        break;
      case fO.MULTI_POLYGON:
        for (var ke = 0; ke < this._geometry.length; ke++) {
          if (this._geometry[ke][0] instanceof cx) {
            e = this._pixelPnpoly({
              lng: T[0],
              lat: T[1]
            }, this._geometry[ke]);
          } else {
            e = this._pixelPnpoly({
              lng: T[0],
              lat: T[1]
            }, this._geometry[ke][0]);
            if (e) {
              for (var kc = 1; kc < this._geometry[ke].length; kc++) {
                e = this._pixelPnpoly({
                  lng: T[0],
                  lat: T[1]
                }, this._geometry[ke][kc]);
                if (e) {
                  e = false;
                  break;
                }
              }
            }
          }
          if (e) {
            break;
          }
        }
        break;
      case fO.MULTI_LINE_STRING:
        var kg = this.renderData[this.renderData.active];
        if (!kg || !kg.line || !kg.line[0] || !kg.line[0].width) {
          var kf = 6;
        } else {
          var kf = this.renderData[this.renderData.active].line[0].width;
          kf = Math.max(kf / 2 * dB.gridScaleFromBDMCTo3857, 6);
        }
        for (var ke = 0; ke < this._geometry.length; ke++) {
          if (this._geometry[ke][0] instanceof cx) {
            var kd = this._getProximity({
              lng: T[0],
              lat: T[1]
            }, this._geometry[ke]);
            if (kd.dist < kf) {
              e = true;
              break;
            }
          }
        }
        break;
      case fO.MULTI_POINT:
        e = this._pixelPnpoint(T, this.renderData, kh);
        break;
      default:
        throw new Error("geojson类型错误: " + this._type);
    }
    return e;
  };
  eo.prototype.set = function (i, T, kc) {
    var e = kc || (kc = {});
    e[i] = T;
  };
  var gw = function () {
    function kj(kp) {
      var ko = kp ? kp : {};
      if (ko.reference) {
        this.reference = ko.reference;
      } else {
        this.reference = null;
      }
      return this;
    }
    kj.prototype.readFeatureFromObject = function (kp, ks) {
      var ko = null;
      if (kp.type && kp.type.toLowerCase() === "feature") {
        ko = kp;
      } else {
        ko = {
          type: "Feature",
          geometry: kp,
          properties: null
        };
      }
      ks = ks || {};
      ks.reference = ks.reference === undefined ? this.reference : ks.reference;
      if (ks.isPoints) {
        ks.onlyGeometry = true;
      }
      var kt = T(ko.geometry, ks, ko.properties);
      var kr = e(ke(ko), ks);
      if (!kt) {
        return null;
      }
      if (ks && ks.onlyGeometry && !ks.isPoints) {
        return {
          geometry: kt,
          type: ko.geometry.type,
          bBox: kr
        };
      }
      if (kt instanceof Array && !(kt[0] instanceof cx)) {
        for (var kq = 0; kq < kt.length; kq++) {
          if (ks.isPoints) {
            kt[kq] = {
              points: kt[kq],
              properties: ko.properties,
              index: ks.__index,
              brotherIndex: kq
            };
          } else {
            kt[kq].properties = ko.properties;
          }
        }
      } else if (ks.isPoints) {
        kt = {
          points: kt,
          properties: ko.properties,
          index: ks.__index,
          brotherIndex: -1
        };
      } else {
        kt.properties = ko.properties;
      }
      return kt;
    };
    kj.prototype.readFeaturesFromObject = function (kr, kz, ko) {
      var kw = kr;
      var kp = null;
      if (kw.type && kw.type.toLowerCase() === "featurecollection") {
        var kt = kr;
        kp = [];
        var kv = kt.features;
        var kq = kz || {};
        for (var ku = 0, kx = kv.length; ku < kx; ++ku) {
          kq.__index = ku;
          var ky = this.readFeatureFromObject(kv[ku], kz);
          if (ky instanceof Array) {
            for (var ks = 0; ks < ky.length; ks++) {
              if (ko) {
                ko(ky[ks]);
              }
              kp.push(ky[ks]);
            }
          } else {
            if (ko) {
              ko(ky);
            }
            kp.push(ky);
          }
        }
      } else {
        var ky = this.readFeatureFromObject(kr, kz);
        if (ky instanceof Array) {
          kp = [];
          for (var ku = 0; ku < ky.length; ku++) {
            if (ko) {
              ko(ky[ku]);
            }
            kp.push(ky[ku]);
          }
        } else {
          if (ko) {
            ko(ky);
          }
          kp = [ky];
        }
      }
      return kp;
    };
    function T(ko, kq, kp) {
      if (!ko) {
        return null;
      }
      var kr;
      switch (ko.type) {
        case fO.POINT:
          kr = kg(ko, kq, kp);
          break;
        case fO.LINE_STRING:
          kr = kc(ko, kq, kp);
          break;
        case fO.POLYGON:
          kr = kh(ko, kq, kp);
          break;
        case fO.MULTI_POINT:
          kr = ki(ko, kq, kp);
          break;
        case fO.MULTI_LINE_STRING:
          kr = kl(ko, kq, kp);
          break;
        case fO.MULTI_POLYGON:
          kr = km(ko, kq, kp);
          break;
        default:
          throw new Error("geojson类型错误: " + ko.type);
      }
      return kr;
    }
    function kg(kp, ks, kq) {
      var kt = kp.coordinates;
      if (ks.reference && ks.reference !== "BD09LL") {
        kt = gcoord.transform(kt, ks.reference || "WGS84", gcoord.BD09LL);
      }
      if (ks && ks.onlyGeometry) {
        return new cx(kt[0], kt[1]);
      }
      var kr = ks;
      if (ks.markerStyle) {
        kr = ks.markerStyle;
        if (ks.markerStyle instanceof Function) {
          kr = ks.markerStyle(kq) || {};
        }
      }
      var ko = new s(new cx(kt[0], kt[1]), kr);
      return ko;
    }
    function kn(ks, kp) {
      var kr = [];
      for (var ko = 0; ko < ks.length; ko++) {
        var kq = ks[ko];
        if (kp.reference && kp.reference !== "BD09LL") {
          kq = gcoord.transform(kq, kp.reference || "WGS84", gcoord.BD09LL);
        }
        kr.push(new cx(kq[0], kq[1]));
      }
      return kr;
    }
    function kc(kp, ks, kq) {
      var kt = kp.coordinates;
      if (ks && ks.onlyGeometry) {
        return kn(kt, ks);
      }
      var kr = ks;
      if (ks.polylineStyle) {
        kr = ks.polylineStyle;
        if (ks.polylineStyle instanceof Function) {
          kr = ks.polylineStyle(kq) || {};
        }
      }
      var ko = new bl(kn(kt, ks), kr);
      return ko;
    }
    function kh(ko, ks, kq) {
      var kt = ko.coordinates;
      if (ks && ks.onlyGeometry) {
        return kn(kt[0], ks);
      }
      var kr = ks;
      if (ks.polygonStyle) {
        kr = ks.polygonStyle;
        if (ks.polygonStyle instanceof Function) {
          kr = ks.polygonStyle(kq) || {};
        }
      }
      var kp = new iG(kn(kt[0], ks), kr);
      return kp;
    }
    function ki(kq, kw, kt) {
      var ku = kq.coordinates;
      var ko = [];
      for (var ks = 0; ks < ku.length; ks++) {
        var kv = ku[ks];
        if (kw.reference && kw.reference !== "BD09LL") {
          kv = gcoord.transform(kv, kw.reference || "WGS84", gcoord.BD09LL);
        }
        if (kw && kw.onlyGeometry) {
          ko.push(new cx(kv[0], kv[1]));
        } else {
          var kp = kw;
          if (kw.markerStyle) {
            kp = kw.markerStyle;
            if (kw.markerStyle instanceof Function) {
              kp = kw.markerStyle(kt) || {};
            }
          }
          var kr = new s(new cx(kv[0], kv[1]), kp);
          ko.push(kr);
        }
      }
      return ko;
    }
    function kl(kp, kt, kr) {
      var kv = kp.coordinates;
      var ku = [];
      for (var kq = 0; kq < kv.length; kq++) {
        if (kt && kt.onlyGeometry) {
          ku.push(kn(kv[kq], kt));
        } else {
          var ks = kt;
          if (kt.polylineStyle) {
            ks = kt.polylineStyle;
            if (kt.polylineStyle instanceof Function) {
              ks = kt.polylineStyle(kr) || {};
            }
          }
          var ko = new bl(kn(kv[kq], kt), ks);
          ku.push(ko);
        }
      }
      return ku;
    }
    function km(kr, ky, kv) {
      var kx = kr.coordinates;
      var ko = [];
      for (var ku = 0; ku < kx.length; ku++) {
        var kz = [];
        for (var ks = 0, kq = kx[ku]; ks < kq.length; ks++) {
          var kt = kn(kq[ks], ky);
          if (ky && ky.onlyGeometry) {
            if (kq.length === 1) {
              ko.push(kt);
            } else {
              kz.push(kt);
            }
          } else if (kq.length === 1) {
            var kp = ky;
            if (ky.polygonStyle) {
              kp = ky.polygonStyle;
              if (ky.polygonStyle instanceof Function) {
                kp = ky.polygonStyle(kv) || {};
              }
            }
            var kw = new iG(kt, kp);
            ko.push(kw);
          } else {
            kz.push(kt);
          }
        }
        if (kq.length !== 1) {
          if (ky && ky.onlyGeometry) {
            ko.push(kz);
          } else {
            var kp = ky;
            if (ky.polygonStyle) {
              kp = ky.polygonStyle;
              if (ky.polygonStyle instanceof Function) {
                kp = ky.polygonStyle(kv) || {};
              }
            }
            var kw = new iG(kz, kp);
            ko.push(kw);
          }
        }
      }
      return ko;
    }
    function kd(ko) {}
    function e(ks, kp) {
      var kr = [];
      for (var ko = 0; ko < ks.length; ko += 2) {
        var kq = [ks[ko], ks[ko + 1]];
        if (kp.reference && kp.reference !== "BD09LL") {
          kq = gcoord.transform(kq, kp.reference || "WGS84", gcoord.BD09LL);
        }
        kr.push(kq[0]);
        kr.push(kq[1]);
      }
      return kr;
    }
    function ke(ko) {
      var kp = [Infinity, Infinity, -Infinity, -Infinity];
      kf(ko, function (kq) {
        if (kp[0] > kq[0]) {
          kp[0] = kq[0];
        }
        if (kp[1] > kq[1]) {
          kp[1] = kq[1];
        }
        if (kp[2] < kq[0]) {
          kp[2] = kq[0];
        }
        if (kp[3] < kq[1]) {
          kp[3] = kq[1];
        }
      });
      return kp;
    }
    function kf(kx, kC) {
      var kt;
      var kq;
      var kp;
      var kw;
      var ko;
      var kz;
      var kB;
      var kA;
      var ks;
      var kv;
      var kr = kx.type && kx.type.toLowerCase() === "featurecollection";
      var ku = kx.type && kx.type.toLowerCase() === "feature";
      var ky = kr ? kx.features.length : 1;
      for (kt = 0; kt < ky; kt++) {
        ks = kr ? kx.features[kt].geometry : ku ? kx.geometry : kx;
        kv = ks.type === "GeometryCollection";
        kB = kv ? ks.geometries.length : 1;
        for (kw = 0; kw < kB; kw++) {
          kz = kv ? ks.geometries[kw] : ks;
          kA = kz.coordinates;
          if (kz.type === "Point") {
            kC(kA);
          } else if (kz.type === "LineString" || kz.type === "MultiPoint") {
            for (kq = 0; kq < kA.length; kq++) {
              kC(kA[kq]);
            }
          } else if (kz.type === "Polygon" || kz.type === "MultiLineString") {
            for (kq = 0; kq < kA.length; kq++) {
              for (kp = 0; kp < kA[kq].length; kp++) {
                kC(kA[kq][kp]);
              }
            }
          } else if (kz.type === "MultiPolygon") {
            for (kq = 0; kq < kA.length; kq++) {
              for (kp = 0; kp < kA[kq].length; kp++) {
                for (ko = 0; ko < kA[kq][kp].length; ko++) {
                  kC(kA[kq][kp][ko]);
                }
              }
            }
          } else {
            throw new Error("类型错误");
          }
        }
      }
    }
    function i(kx, kC) {
      var kt;
      var kq;
      var kp;
      var kw;
      var ko;
      var kz;
      var kB;
      var kA;
      var ks;
      var kv;
      var kr = kx.type === "FeatureCollection";
      var ku = kx.type === "Feature";
      var ky = kr ? kx.features.length : 1;
      for (kt = 0; kt < ky; kt++) {
        ks = kr ? kx.features[kt].geometry : ku ? kx.geometry : kx;
        kv = ks.type === "GeometryCollection";
        kB = kv ? ks.geometries.length : 1;
        for (kw = 0; kw < kB; kw++) {
          kz = kv ? ks.geometries[kw] : ks;
          kA = kz.coordinates;
          if (kz.type === "Point") {
            kA = kC(kA);
          } else if (kz.type === "LineString" || kz.type === "MultiPoint") {
            for (kq = 0; kq < kA.length; kq++) {
              kA[kq] = kC(kA[kq]);
            }
          } else if (kz.type === "Polygon" || kz.type === "MultiLineString") {
            for (kq = 0; kq < kA.length; kq++) {
              for (kp = 0; kp < kA[kq].length; kp++) {
                kA[kq][kp] = kC(kA[kq][kp]);
              }
            }
          } else if (kz.type === "MultiPolygon") {
            for (kq = 0; kq < kA.length; kq++) {
              for (kp = 0; kp < kA[kq].length; kp++) {
                for (ko = 0; ko < kA[kq][kp].length; ko++) {
                  kA[kq][kp][ko] = kC(kA[kq][kp][ko]);
                }
              }
            }
          } else {
            throw new Error("类型错误");
          }
        }
      }
    }
    function kk(kp) {
      var ko = kp.type === "FeatureCollection";
      var kq = kp.type === "Feature";
      var kr = ko ? kp.features[0].geometry : kq ? kp.geometry : kp;
      if (kr.type) {
        return kr.type;
      } else {
        throw new Error("类型错误");
      }
    }
    kj.bbox = ke;
    kj.coordEachReplace = i;
    kj.getType = kk;
    return kj;
  }();
  const cZ = {
    point: {
      symbolPath: {
        format: "string",
        defaultValue: ""
      },
      symbolFillColor: {
        format: "string",
        defaultValue: "#000"
      },
      symbolFillOpacity: {
        format: "number",
        defaultValue: 1
      },
      symbolScale: {
        format: "number",
        defaultValue: 1
      },
      symbolRotation: {
        format: "number",
        defaultValue: 0
      },
      symbolStrokeColor: {
        format: "string",
        defaultValue: "#000"
      },
      symbolStrokeOpacity: {
        format: "number",
        defaultValue: 0
      },
      symbolStrokeWeight: {
        format: "number",
        defaultValue: 0
      },
      icon: {
        format: "string",
        defaultValue: ""
      },
      iconSize: {
        format: "array",
        defaultValue: [32, 32]
      },
      uid: {
        format: "string",
        defaultValue: "custom-vector-0"
      },
      name: {
        format: "string",
        defaultValue: ""
      },
      fontSize: {
        format: "number",
        defaultValue: 22
      },
      color: {
        format: "string",
        defaultValue: "#0d20c9"
      },
      haloSize: {
        format: "number",
        defaultValue: 2
      },
      strokeColor: {
        format: "string",
        defaultValue: "#fff"
      },
      textOnIcon: {
        format: "string",
        defaultValue: false
      },
      textOnIconSize: {
        format: "array",
        defaultValue: [32, 32]
      },
      textOnIconUrl: {
        format: "string",
        defaultValue: ""
      },
      textMargin: {
        format: "number",
        defaultValue: 0
      },
      direction: {
        format: "number",
        defaultValue: 0
      },
      rank: {
        format: "number",
        defaultValue: 50000
      },
      visibility: {
        format: "boolean",
        defaultValue: true
      }
    },
    polyline: {
      strokeLineJoin: {
        format: "string",
        defaultValue: "miter"
      },
      strokeLineCap: {
        format: "string",
        defaultValue: "round"
      },
      strokeColor: {
        format: "string",
        defaultValue: "#142655"
      },
      strokeWeight: {
        format: "number",
        defaultValue: 2
      },
      strokeOpacity: {
        format: "number",
        defaultValue: 1
      },
      borderColor: {
        format: "string",
        defaultValue: "rgba(27, 142, 236, 1)"
      },
      borderWeight: {
        format: "number",
        defaultValue: 0
      },
      strokeTextureUrl: {
        format: "string",
        defaultValue: ""
      },
      strokeTextureWidth: {
        format: "number",
        defaultValue: 16
      },
      strokeTextureHeight: {
        format: "number",
        defaultValue: 16
      },
      strokeStyle: {
        format: "string",
        defaultValue: "solid"
      },
      dashArray: {
        format: "object",
        defaultValue: [8, 4]
      },
      visibility: {
        format: "boolean",
        defaultValue: true
      }
    },
    polygon: {
      fillColor: {
        format: "string",
        defaultValue: "#142655"
      },
      fillOpacity: {
        format: "number",
        defaultValue: 1
      },
      patternMapping: {
        format: "string",
        defaultValue: "0, 0, 32, 32"
      },
      patternScale: {
        format: "number",
        defaultValue: 1
      },
      patternOffset: {
        format: "string",
        defaultValue: "0, 0"
      },
      strokeWeight: {
        format: "number",
        defaultValue: 0
      },
      strokeLineJoin: {
        format: "string",
        defaultValue: "bevel"
      },
      strokeLineCap: {
        format: "string",
        defaultValue: "round"
      },
      strokeColor: {
        format: "string",
        defaultValue: "#dec41b"
      },
      strokeOpacity: {
        format: "number",
        defaultValue: 1
      },
      strokeStyle: {
        format: "string",
        defaultValue: "solid"
      },
      dashArray: {
        format: "object",
        defaultValue: [8, 4]
      },
      visibility: {
        format: "boolean",
        defaultValue: true
      }
    }
  };
  const cs = function (i) {
    var e = {};
    for (var kc in i) {
      e[kc] = {};
      for (var T in i[kc]) {
        e[kc][T] = i[kc][T].defaultValue;
      }
    }
    return e;
  }(cZ);
  const fO = {
    POINT: "Point",
    LINE_STRING: "LineString",
    POLYGON: "Polygon",
    MULTI_POINT: "MultiPoint",
    MULTI_LINE_STRING: "MultiLineString",
    MULTI_POLYGON: "MultiPolygon",
    CIRCLE: "Circle"
  };
  function fF(e) {
    return e && typeof ArrayBuffer !== "undefined" && (e instanceof ArrayBuffer || e.constructor && e.constructor.name === "ArrayBuffer");
  }
  function gi(e) {
    if (self) {
      if (self.ImageBitmap && e instanceof self.ImageBitmap) {
        return true;
      }
    } else if (window && window.ImageBitmap) {
      if (e instanceof window.ImageBitmap) {
        return true;
      }
    }
    return false;
  }
  const i3 = {};
  function aG(i, kc, T) {
    var e = T || {};
    Object.defineProperty(i, "_classRegistryKey", {
      value: kc,
      writeable: false
    });
    i3[kc] = {
      _class: i,
      escape: e.escape || []
    };
  }
  aG(Object, "Object");
  aG(cx, "Point");
  function js(kh, kf) {
    if (kh === null || kh === undefined || typeof kh === "boolean" || typeof kh === "number" || typeof kh === "string" || kh instanceof Boolean || kh instanceof Number || kh instanceof String || kh instanceof Date || kh instanceof RegExp) {
      return kh;
    }
    if (fF(kh)) {
      if (kf) {
        kf.push(kh);
      }
      return kh;
    }
    if (gi(kh)) {
      if (kf) {
        var kk = kf.filter(function (i) {
          if (i === kh) {
            return true;
          } else {
            return false;
          }
        });
        if (!kk) {
          kf.push(kh);
        }
      }
      return kh;
    }
    if (ArrayBuffer.isView(kh)) {
      const kg = kh;
      if (kf) {
        kf.push(kg.buffer);
      }
      return kg;
    }
    if (kh instanceof ImageData) {
      if (kf) {
        var kk = kf.filter(function (i) {
          if (i === kh.data.buffer) {
            return true;
          } else {
            return false;
          }
        });
        if (!kk) {
          kf.push(kh.data.buffer);
        }
      }
      return kh;
    }
    if (Array.isArray(kh)) {
      const T = [];
      for (var kc = 0; kc < kh.length; kc++) {
        var kl = kh[kc];
        T.push(js(kl, kf));
      }
      return T;
    }
    if (typeof kh === "object") {
      const kd = kh.constructor;
      const e = kd._classRegistryKey;
      if (!e) {
        throw new Error("不能被序列化");
      }
      const ke = kd.serialize ? kd.serialize(kh, kf) : {};
      if (!kd.serialize) {
        for (var kj in kh) {
          if (!kh.hasOwnProperty(kj)) {
            continue;
          }
          if (i3[e].escape.indexOf(kj) >= 0) {
            continue;
          }
          const ki = kh[kj];
          ke[kj] = js(ki, kf);
        }
        if (kh instanceof Error) {
          ke.message = kh.message;
        }
      }
      if (e !== "Object") {
        ke._$name = e;
      }
      return ke;
    } else if (kh instanceof Function) {
      return null;
    }
    throw new Error("不能被序列化");
  }
  function h9(ke) {
    if (ke === null || ke === undefined || typeof ke === "boolean" || typeof ke === "number" || typeof ke === "string" || ke instanceof Boolean || ke instanceof Number || ke instanceof String || ke instanceof Date || ke instanceof RegExp || fF(ke) || gi(ke) || ArrayBuffer.isView(ke) || ke instanceof ImageData) {
      return ke;
    }
    if (Array.isArray(ke)) {
      var e = ke._$name;
      if (e) {
        var kc = i3[e]._class;
        if (!kc) {
          throw new Error("不能被反序列化");
        }
        if (kc.deserialize) {
          return kc.deserialize(ke);
        }
      }
      const kd = [];
      for (var T = 0; T < ke.length; T++) {
        var kh = ke[T];
        kd.push(h9(kh));
      }
      return kd;
    }
    if (typeof ke === "object") {
      var e = ke._$name || "Object";
      var kc = i3[e]._class;
      if (!kc) {
        throw new Error("不能被反序列化");
      }
      if (kc.deserialize) {
        return kc.deserialize(ke);
      }
      const kj = Object.create(kc.prototype);
      const ki = Object.keys(ke);
      for (var T = 0; T < ki.length; T++) {
        const kg = ki[T];
        if (kg === "_$name") {
          continue;
        }
        const kf = ke[kg];
        kj[kg] = h9(kf);
      }
      return kj;
    }
    throw new Error("不能被反序列化");
  }
  function k(kg, ke, kf) {
    if (!kg.length) {
      return kf(null, []);
    }
    var kd = kg.length;
    const kc = new Array(kg.length);
    var e = null;
    for (var T = 0; T < kg.length; T++) {
      ke(kg[T], function (kh, i) {
        if (kh) {
          e = kh;
        }
        kc[T] = i;
        if (--kd === 0) {
          kf(e, kc);
        }
      }, T);
    }
  }
  function f6(kh, ke, kg) {
    if (!kh.length) {
      return kg(null, []);
    }
    var kd = kh.length;
    const kc = new Array(kh.length);
    var e = null;
    var T = 0;
    function kf() {
      ke(kh[T], function (ki, i) {
        if (ki) {
          e = ki;
        }
        kc[T] = i;
        if (--kd === 0) {
          kg(e, kc);
        } else {
          T++;
          kf();
        }
      }, T);
    }
    kf();
  }
  var jE = function () {
    var i = true;
    var kd = 256;
    var e = true;
    var kf = jO("ditu", "normalTraffic");
    var kc = kf.udt;
    var kg = "//its.map.baidu.com/traffic/";
    var ke = [[2, "79,210,125,1", 3, 2, 0, [], 0, 0], [2, "79,210,125,1", 3, 2, 0, [], 0, 0], [2, "79,210,125,1", 4, 2, 0, [], 0, 0], [2, "79,210,125,1", 5, 2, 0, [], 0, 0], [2, "79,210,125,1", 6, 2, 0, [], 0, 0], [2, "255,208,69,1", 3, 2, 0, [], 0, 0], [2, "255,208,69,1", 3, 2, 0, [], 0, 0], [2, "255,208,69,1", 4, 2, 0, [], 0, 0], [2, "255,208,69,1", 5, 2, 0, [], 0, 0], [2, "255,208,69,1", 6, 2, 0, [], 0, 0], [2, "232,14,14,1", 3, 2, 0, [], 0, 0], [2, "232,14,14,1", 3, 2, 0, [], 0, 0], [2, "232,14,14,1", 4, 2, 0, [], 0, 0], [2, "232,14,14,1", 5, 2, 0, [], 0, 0], [2, "232,14,14,1", 6, 2, 0, [], 0, 0], [2, "181,0,0,1", 3, 2, 0, [], 0, 0], [2, "181,0,0,1", 3, 2, 0, [], 0, 0], [2, "181,0,0,1", 4, 2, 0, [], 0, 0], [2, "181,0,0,1", 5, 2, 0, [], 0, 0], [2, "181,0,0,1", 6, 2, 0, [], 0, 0], [2, "255,255,255,1", 4, 0, 0, [], 0, 0], [2, "255,255,255,1", 5.5, 0, 0, [], 0, 0], [2, "255,255,255,1", 7, 0, 0, [], 0, 0], [2, "255,255,255,1", 8.5, 0, 0, [], 0, 0], [2, "255,255,255,1", 10, 0, 0, [], 0, 0]];
    var T = new hv({
      transparentPng: true,
      dataType: 2,
      cacheSize: 256,
      clipTile: true,
      isFlat: true
    });
    T.zIndex = 2;
    T.getTilesUrl = function (kj, kk) {
      if (!kj || kk < 7) {
        return null;
      }
      var ki = kj.x;
      var kl = kj.y;
      var kh = kg + "TrafficTileService?level=" + kk + "&x=" + ki + "&y=" + kl + "&time=" + +new Date();
      if (this.map.getRenderType() === "webgl") {
        kh = kg + "?qt=vtraffic&z=" + kk + "&x=" + ki + "&y=" + kl + "&udt=" + kc;
      }
      return kh;
    };
    T.setColors = function (kh) {
      for (var kk = 0; kk < ke.length; kk++) {
        var kj = Math.floor(kk / 5);
        var ki = kh[kj];
        if (ki) {
          if (Object.prototype.toString.call(ki) === "[object String]") {
            ki = hB.parseCSSColor(ki);
          }
          ke[kk][1] = [ki[0], ki[1], ki[2], ki[3] / 255].join(",");
        }
      }
    };
    T.setEdge = function (kh) {
      e = !!kh;
    };
    T.processData = function (kk) {
      var ko = kk.content;
      var km = 10;
      if (typeof kk.precision === "number") {
        km = kk.precision * 10;
      }
      var kv = {
        road: [[], []]
      };
      if (!ko) {
        return kv;
      }
      var kt = ko.tf;
      if (!kt) {
        return kv;
      }
      for (var kl = 0; kl < kt.length; kl++) {
        var ku = kt[kl][1];
        var ks = [];
        var kq = 0;
        var kp = 0;
        var kr = ke[kt[kl][3]];
        for (var kj = 0, kh = ku.length; kj < kh / 2; kj++) {
          kq += ku[kj * 2] / km;
          kp += ku[kj * 2 + 1] / km;
          ks.push(kq, 256 - kp);
        }
        var ki = kr[1].split(",");
        ki[3] = ki[3] * 255;
        var kn = kr[2] / 2;
        if (e) {
          kv.road[0].push([ks, 1, 2, [255, 255, 255, 255], kn + 2]);
        }
        kv.road[1].push([ks, 1, 2, ki, kn]);
      }
      return kv;
    };
    return T;
  }();
  function jg() {}
  jg.prototype = jE;
  function dX(e) {
    eA.call(this);
    e = e || {};
    this._opts = {};
    this._opts.districts = e.name || "";
    this._opts.kind = e.kind || 0;
    this._config = {};
    this._config.strokeColor = e.strokeColor || "#00f";
    this._config.strokeOpacity = typeof e.strokeOpacity === "number" ? e.strokeOpacity : 1;
    cb(this._config.strokeOpacity, 0, 1);
    this._config.fillColor = e.fillColor || "#ff0";
    this._config.fillOpacity = typeof e.fillOpacity === "number" ? e.fillOpacity : 0.6;
    cb(this._config.fillOpacity, 0, 1);
    this._config.strokeWeight = e.strokeWeight || 1;
    this._config.viewport = e.viewport || false;
    this.disOverlays = [];
    this.eventAndCallback = {};
    var i = this;
    g2.load("layer", function () {
      i._asyncSearch();
    });
  }
  dX.inherits(c8, "DistrictLayer");
  eX.extend(dX.prototype, {
    initialize: function (e) {
      this._map = e;
      this.addDistrict();
    },
    removeDistrict: function (i, e) {
      this._map = i;
      this.deleteDistrict(e);
    },
    toString: function () {
      return "DistrictLayer";
    }
  });
  function aN(e, i) {
    i = i || {};
    this.layerName = e || "unknown";
    this.reference = i.reference;
    this.level = i.level || -99;
    this.visible = i.visible === undefined ? true : !!i.visible;
    this.minZoom = i.minZoom || 3;
    this.maxZoom = i.maxZoom || 21;
    this.markerStyle = i.markerStyle || {};
    this.polylineStyle = i.polylineStyle || {};
    this.polygonStyle = i.polygonStyle || {};
    this.overlayData = [];
    this._onMap = false;
    this.clickDistrict = 5;
    this.setData(i.dataSource);
  }
  aN.inherits(eX.BaseClass, "GeoJSONLayer");
  aN.prototype.init = function (kf) {
    if (this.map) {
      return;
    }
    this.map = kf;
    var kd = this;
    this._onZoomEvent = function () {
      if (kd.map.getZoom() >= kd.minZoom && kd.map.getZoom() <= kd.maxZoom) {
        if (!kd._onMap) {
          kd.addDataToMap();
          kd._onMap = true;
        }
      } else if (kd._onMap) {
        kd.removeDataFromMap();
        kd._onMap = false;
      }
    };
    this.map.on("zoomend", this._onZoomEvent);
    var kd = this;
    var e = false;
    var kc = {
      x: 0,
      y: 0
    };
    this._layerMouseEvent = function (ki) {
      if (!kd.map || !kd._listeners || !kd.visible || !kd._onMap) {
        return;
      }
      if (!kd._listeners.onmousemove || Object.keys(kd._listeners.onmousemove).length === 0) {
        return;
      }
      var kh = kd.pickOverlays(ki);
      var i;
      if (kh && kh.length > 0) {
        i = new fJ("onmousemove");
        i.features = kh;
        kd.map.platform.style.cursor = kd.map.config.overlayMoveCursor;
        e = true;
      } else {
        if (!e || !kd._listeners.onmouseout || Object.keys(kd._listeners.onmouseout).length === 0) {
          return;
        }
        kd.map.platform.style.cursor = kd.map.config.defaultCursor;
        i = new fJ("onmouseout");
        i.features = null;
        e = false;
      }
      if (i) {
        i.point = ki.point;
        i.pixel = ki.pixel;
        i.latLng = ki.latlng;
        kd.dispatchEvent(i);
      }
    };
    this._layerClickEvent = function (kj) {
      if (!kd.map || !kd._listeners || !kd.visible) {
        return;
      }
      if (!kd._listeners.onclick && !kd._listeners.dblclick || Object.keys(kd._listeners.onclick).length === 0 && Object.keys(kd._listeners.dblclick).length === 0) {
        return;
      }
      var kh = {
        x: kj.clientX,
        y: kj.clientY
      };
      if (Math.abs(kh.x - kc.x) > kd.clickDistrict || Math.abs(kh.y - kc.y) > kd.clickDistrict) {
        return;
      }
      var ki = kd.pickOverlays(kj);
      var i = new fJ(kj.type);
      i.point = kj.point;
      i.pixel = kj.pixel;
      i.latLng = kj.latlng;
      i.features = ki;
      kd.dispatchEvent(i);
    };
    this._layerMouseDownEvent = function (i) {
      kc = {
        x: i.clientX,
        y: i.clientY
      };
    };
    kf.addEventListener("onmousemove", this._layerMouseEvent);
    kf.addEventListener("onmouseout", this._layerMouseEvent);
    kf.addEventListener("onmousedown", this._layerMouseDownEvent);
    var ke = ["onclick"];
    for (var T = 0; T < ke.length; T++) {
      var kg = ke[T];
      kf.addEventListener(kg, this._layerClickEvent);
    }
    this._onZoomEvent();
  };
  aN.prototype.remove = function () {
    if (this.map) {
      this.removeDataFromMap();
      this.map.removeEventListener("onmousemove", this._layerMouseEvent);
      this.map.removeEventListener("onmouseout", this._layerMouseEvent);
      this.map.removeEventListener("onclick", this._layerClickEvent);
      this.map.removeEventListener("onmousedown", this._layerMouseDownEvent);
      this.map.removeEventListener("onzoomend", this._onZoomEvent);
    }
    this.map = null;
  };
  aN.prototype.destroy = function () {
    if (this.map) {
      this.clearData();
      this.map.removeEventListener("onmousemove", this._layerMouseEvent);
      this.map.removeEventListener("onmouseout", this._layerMouseEvent);
      this.map.removeEventListener("onclick", this._layerClickEvent);
      this.map.removeEventListener("onmousedown", this._layerMouseDownEvent);
      this.map.removeEventListener("onzoomend", this._onZoomEvent);
    }
    this.map = null;
  };
  aN.prototype.setData = function (e) {
    if (!this.gParse) {
      this.gParse = new gw({
        reference: this.reference
      });
    }
    if (!e) {
      return;
    }
    if (this.dataSource && this.overlayData.length > 0) {
      this.clearData();
    }
    this.dataSource = e;
    this.overlayData = this.gParse.readFeaturesFromObject(e, {
      markerStyle: this.markerStyle,
      polylineStyle: this.polylineStyle,
      polygonStyle: this.polygonStyle
    }, this._register.bind(this));
  };
  aN.prototype._register = function (e) {
    e.layerName = this.layerName;
    e.setZIndex(this.level);
  };
  aN.prototype.resetStyle = function () {
    for (var e = 0; e < this.overlayData.length; e++) {
      if (this.overlayData[e] instanceof s) {
        var i = this.markerStyle;
        if (this.markerStyle instanceof Function) {
          i = this.markerStyle(this.overlayData[e].properties) || {};
        }
      }
      if (this.overlayData[e] instanceof bl) {
        var i = this.polylineStyle;
        if (this.polylineStyle instanceof Function) {
          i = this.polylineStyle(this.overlayData[e].properties) || {};
        }
      }
      if (this.overlayData[e] instanceof iG) {
        var i = this.polygonStyle;
        if (this.polygonStyle instanceof Function) {
          i = this.polygonStyle(this.overlayData[e].properties) || {};
        }
      }
      if (i) {
        this.overlayData[e].setOptions(i);
      }
    }
  };
  aN.prototype.getData = function () {
    return this.overlayData;
  };
  aN.prototype.addOverlay = function (e) {
    var kf = e;
    if (!(e instanceof Array)) {
      kf = [e];
    }
    for (var kc = 0; kc < kf.length; kc++) {
      var T = kf[kc];
      if (T.__proto__ instanceof aR) {
        this._register(T);
        this.overlayData.push(T);
        this.map.addOverlay(T);
      } else {
        var ke = this.gParse.readFeaturesFromObject(T, {
          markerStyle: this.markerStyle,
          polylineStyle: this.polylineStyle,
          polygonStyle: this.polygonStyle
        }, this._register.bind(this));
        for (var kd = 0; kd < ke.length; kd++) {
          this.overlayData.push(ke[kd]);
          this.map.addOverlay(ke[kd]);
        }
      }
    }
  };
  aN.prototype.removeOverlay = function (kc) {
    var kd = kc;
    if (!(kc instanceof Array)) {
      kd = [kc];
    }
    for (var T = 0; T < kd.length; T++) {
      var i = kd[T];
      var e = this.findItemIndex(i);
      if (e >= 0) {
        this.overlayData.splice(e, 1);
        this.map.removeOverlay(i);
      }
    }
  };
  aN.prototype.findItemIndex = function (T) {
    var i = -1;
    for (var e = 0; e < this.overlayData.length; e++) {
      if (this.overlayData[e].hashCode === T.hashCode) {
        i = e;
        break;
      }
    }
    return i;
  };
  aN.prototype.addDataToMap = function () {
    if (this.visible && this.map && this.map.getZoom() >= this.minZoom && this.map.getZoom() <= this.maxZoom) {
      for (var e = 0; e < this.overlayData.length; e++) {
        this.map.addOverlay(this.overlayData[e]);
      }
    }
  };
  aN.prototype.removeDataFromMap = function () {
    if (this.map && this.overlayData.length > 0) {
      for (var e = 0; e < this.overlayData.length; e++) {
        this.map.removeOverlay(this.overlayData[e]);
      }
    }
  };
  aN.prototype.clearData = function () {
    this.dataSource = null;
    if (this.map && this.overlayData.length > 0) {
      this.removeDataFromMap();
    }
    this.overlayData = [];
  };
  aN.prototype.pickOverlays = function (kg) {
    var kf = [];
    if (!this.visible || !this._onMap) {
      return null;
    }
    for (var kd = 0; kd < this.overlayData.length; kd++) {
      var ke = this.overlayData[kd];
      var kc;
      if (!ke && !ke.isVisible()) {
        continue;
      }
      if (ke.toString() === "Marker") {
        kc = ke._getInPnBox(kg.pixel);
        if (kc) {
          kf.push(ke);
        }
        continue;
      }
      if (ke.toString() !== "Polyline") {
        kc = ke._getInPnpoly(kg.point);
      } else {
        kc = ke._getProximity(kg.point);
      }
      var T = kc.dist;
      if (T >= 0 && T < ke._config.mouseOverTolerance) {
        kf.push(ke);
      }
    }
    return kf.length > 0 ? kf : null;
  };
  aN.prototype.setLevel = function (e) {
    if (e > -999 && e < 9999) {
      this.level = e;
      for (var T = 0; T < this.overlayData.length; T++) {
        this.overlayData[T].setZIndex(this.level);
      }
      if (this.map) {
        this.map.fire(new BMapGL.Event("onupdate", "line"));
      }
    }
  };
  aN.prototype.setClickDistrict = function (e) {
    this.clickDistrict = e || 5;
  };
  aN.prototype.getLevel = function () {
    return this.level;
  };
  aN.prototype.setVisible = function (i) {
    var e = !!i;
    if (this.visible !== e) {
      this.visible = e;
      if (e) {
        this.addDataToMap();
      } else {
        this.removeDataFromMap();
      }
    }
  };
  aN.prototype.getVisible = function () {
    return this.visible;
  };
  aN.prototype.toString = function () {
    return "GeoJSONLayer";
  };
  function jZ(i) {
    var i = i || {};
    var ke = i.transform || {
      source: "EPSG3857",
      target: "BD09MC"
    };
    if (!ke.source) {
      ke.target = "EPSG3857";
    }
    if (!ke.target) {
      ke.target = "BD09MC";
    }
    const kc = i.tileUrlTemplate || "";
    const ki = i.xTemplate || function (kp, kr, kq) {
      return kp;
    };
    const km = i.yTemplate || (i.tms ? function (kp, kr, kq) {
      return Math.pow(2, kq) - kr - 1;
    } : function (kp, kr, kq) {
      return kr;
    });
    const kg = i.zTemplate || function (kp, kr, kq) {
      return kq;
    };
    const kl = i.bTemplate || function (kp, ks, kr) {
      const kq = dB.getTileRangeExtent([kr, kp, ks]);
      return kq.minX + "," + kq.minY + "," + kq.maxX + "," + kq.maxY;
    };
    const kd = i.wTemplate || function (kp, kr, kq) {
      return 512;
    };
    const kh = i.hTemplate || function (kp, kr, kq) {
      return 512;
    };
    var kn = i.extent || [];
    const kf = i.extentCRSIsWGS84 || false;
    var T = i.minZoom || 0;
    var kj = i.maxZoom || 23;
    var kk = i.spanLevel || 0;
    if (!i.showRegion || "insideoutside".indexOf(i.showRegion) === -1) {
      i.showRegion = "inside";
    }
    var ko = new hv({
      transform: ke,
      png8: i.png8 || false,
      retry: i.retry || false,
      retryTime: i.retryTime || 600,
      transparentPng: true,
      dataType: i.dataType || 1,
      spanLevel: kk,
      tileTypeName: "xyz",
      cacheSize: 256,
      customLayer: true,
      clipTile: false,
      boundary: i.boundary || false,
      showRegion: i.showRegion,
      useThumbData: i.useThumbData || false
    });
    if (i.zIndex) {
      ko.zIndex = i.zIndex;
    }
    if (kn.length === 4 && kf) {
      kn = dB.fromEPSG4326(kn);
    }
    ko.getTilesUrl = function (kq, kw, ku) {
      if (!kq || kw < 0 || kw < T + kk || kw > kj + kk) {
        ko.tileCache.clear();
        return null;
      }
      if (ke.source !== "BD09MC") {
        kq.x = dB.getTilesLoop(kw, kq.x);
      }
      if (kn.length === 4) {
        var kv = dB.getTileRangeExtent([kw, kq.x, kq.y]);
        var kt = e([kv.minX, kv.minY, kv.maxX, kv.maxY]);
        if (!kt) {
          return null;
        }
      }
      var kr = "";
      if (kc) {
        kr = kc;
        var ks = /[^\{}]*\{(.*)\}[^\}]*/;
        kr.match(ks);
        var kp = [];
        if (RegExp.$1) {
          kp = RegExp.$1.split(",");
        }
        kr = kr.replace(/\{(.*)\}/, kp[(kq.x + kq.y) % kp.length]);
        kr = kr.replace(/\[x\]/gi, ki(kq.x, kq.y, kw));
        kr = kr.replace(/\[y\]/gi, km(kq.x, kq.y, kw));
        kr = kr.replace(/\[z\]/gi, kg(kq.x, kq.y, kw));
        kr = kr.replace(/\[b\]/gi, kl(kq.x, kq.y, kw));
        kr = kr.replace(/\[w\]/gi, kd(kq.x, kq.y, kw));
        kr = kr.replace(/\[h\]/gi, kh(kq.x, kq.y, kw));
      } else {
        return null;
      }
      return kr;
    };
    function e(kp) {
      if (kn && kn instanceof Array && kn.length === 4) {
        if (kn[0] <= kp[2] && kn[1] <= kp[3] && kn[2] >= kp[0] && kn[3] >= kp[1]) {
          return true;
        } else {
          return false;
        }
      }
      return true;
    }
    return ko;
  }
  function dr(i) {
    this.src = c3();
    this.tileMaskUvCache = new az(64, {
      clearCallback: function (ke) {}
    });
    var kd = 6;
    if (i.pixelMap) {
      this.opacity = typeof i.pixelMap.opacity === "number" ? i.pixelMap.opacity : 1;
      cb(this.opacity, 0, 1);
      if (this.opacity < 1) {
        i.useThumbData = false;
      }
      var kc = i.pixelMap || {};
      this.colors = kc.colors || ["#F9F871", "#FFC75F", "#FF9671", "#FF6F91", "#D65DB1", "#845EC2"];
      this.positions = kc.positions || [0, 0.2, 0.4, 0.6, 0.8, 1];
      this.domain = kc.domain || [0, 255];
      this.clamp = kc.clamp || this.domain;
      this.noData = kc.noData !== undefined ? kc.noData : -99999;
      this.fomularC = kc.fomularC || "float generateValue(vec4 pixel){return pixel.r * 255.;}";
      this.fomularJS = kc.fomularJS || function (ke) {
        return ke.r;
      };
      this.maskPng = kc.maskPng || null;
      if (this.maskPng) {
        this.loadMaskPng(this.maskPng);
      }
      this.maskData = kc.maskData || -1;
      this.maskCoord = kc.maskCoord || null;
      this.fHashcode = o({
        str: this.fomularC
      });
      var e = this.canPixelMap();
      if (e) {
        this.isPixelMap = true;
        this.setPixelMap();
      }
      kd = i.pixelMap.cacheSize || kd;
    }
    var T = new jZ(i);
    T.ontology = this;
    this.layer = T;
    this.cacheSize = kd;
    this.tileCache = new az(this.cacheSize, {
      clearCallback: function (ke) {}
    });
    this.tileImageDataCache = new az(this.cacheSize, {
      clearCallback: function (ke) {}
    });
  }
  dr.inherits(eX.BaseClass, "PixelLayer");
  eX.extend(dr.prototype, {
    canPixelMap: function () {
      if (this.colors && this.positions) {
        return true;
      }
      return false;
    },
    setPixelMap: function () {
      if (!this.isPixelMap || !this.canPixelMap()) {
        return;
      }
      var i = this.colors;
      var e = this.positions;
      this.pHashcode = o({
        colors: i,
        positions: e
      });
      this.pixelColorMap = hB.generateColorRamp(i, e);
    },
    setDomain: function (e) {
      if (e instanceof Array && e.length === 2) {
        this.domain = e;
        this.doOnceDraw();
      }
    },
    setClamp: function (e) {
      if (e instanceof Array && e.length === 2) {
        this.clamp = e;
        this.doOnceDraw();
      }
    },
    setNoData: function (e) {
      this.noData = e;
      this.doOnceDraw();
    },
    setPositions: function (e) {
      this.positions = e;
      this.setPixelMap();
      this.doOnceDraw();
    },
    setColors: function (e) {
      this.colors = e;
      this.setPixelMap();
      this.doOnceDraw();
    },
    setFomular: function (e, i) {
      if (e && i) {
        this.fomularJS = e;
        this.fomularC = i;
        this.fHashcode = o({
          str: this.fomularC
        });
        this.doOnceDraw();
      }
    },
    setOpacity: function (e) {
      this.opacity = e;
      this.doOnceDraw();
    },
    setIsPixelMap: function (e) {
      this.isPixelMap = e;
      this.doOnceDraw();
    },
    setMaskPng: function (e) {
      this.maskPng = e;
      this.loadMaskPng(this.maskPng);
      this.doOnceDraw();
    },
    setMaskData: function (e) {
      this.maskData = e;
      this.doOnceDraw();
    },
    setMaskCoord: function (e) {
      this.maskCoord = e || null;
      this.calMaskBox();
      this.doOnceDraw();
    },
    setZIndex: function (e) {
      if (this.layer && parseInt(e) > 0) {
        this.layer.setZIndex(e);
      }
    },
    getZIndex: function () {
      if (this.layer) {
        return this.layer.zIndex;
      }
    },
    setUpLevel: function () {
      if (this.layer) {
        var e = this.layer._getAdjoinZIndex("up");
        if (this.layer.zIndex !== e) {
          this.layer.setZIndex(e);
        }
      }
    },
    setDownLevel: function () {
      if (this.layer) {
        var e = this.layer._getAdjoinZIndex("down");
        if (this.layer.zIndex !== e) {
          this.layer.setZIndex(e);
        }
      }
    },
    setZIndexTop: function () {
      if (this.layer) {
        this.layer.setZIndexTop();
      }
    },
    doOnceDraw: function () {
      if (this.layer.map) {
        var e = new fJ("onupdate");
        this.layer.map.dispatchEvent(e);
      }
    },
    _getInLayer: function (kk) {
      if (!this.map) {
        return null;
      }
      var kj = Math.floor(this.map.getZoom());
      var kc = dB.transformBDmcPoint(kk, this.layer.transform);
      var kg = dB.getTileCoordForXYAndZ_(kc[0], kc[1], kj, false);
      var T = kg.join("-");
      var e = this.tileCache.getData(T);
      if (e) {
        return e;
      }
      var kd = this.layer.zIndex;
      var kf = this.map._featureMgr.result.bkData;
      var kh = kf[kd][2];
      var kl = null;
      for (var ke = 0; ke < kh.length; ke++) {
        var kg = kh[ke];
        var ki = kg.tileInfo.zoom + "-" + kg.tileInfo.col + "-" + kg.tileInfo.row;
        if (T === ki) {
          kl = kg;
          break;
        }
      }
      this.tileCache.setData(T, kl);
      return kl;
    },
    _initEvent: function (kd) {
      this.map = kd;
      var T = this;
      this._layerMouseEvent = function (kh) {
        if (!T.map) {
          return;
        }
        var kf;
        var i = kh.point;
        var kg = T._getInLayer(i);
        if (kg) {
          T.prox = kg;
          kf = new fJ("onmousemove");
          T.map.platform.style.cursor = T.map.config.overlayMoveCursor;
        } else {
          T.map.platform.style.cursor = T.map.config.defaultCursor;
          T.prox = null;
        }
        if (kf) {
          kf.point = kh.point;
          kf.pixel = kh.pixel;
          kf.latLng = kh.latlng;
          T.dispatchEvent(kf);
        }
      };
      this._layerClickEvent = function (kh) {
        if (!T.map) {
          return;
        }
        var kf;
        var i = kh.point;
        var kg = T.getImagePixel(i);
        if (kg) {
          kf = new fJ(kh.type);
          kf.point = i;
          kf.pixel = kh.pixel;
          kf.latLng = kh.latlng;
          kf.color = kg;
          kf.value = T.getValue(kf.color);
          T.dispatchEvent(kf);
        }
      };
      kd.addEventListener("onmousemove", this._layerMouseEvent);
      var kc = ["onclick", "dblclick"];
      for (var e = 0; e < kc.length; e++) {
        var ke = kc[e];
        kd.addEventListener(ke, this._layerClickEvent);
      }
      kd.addEventListener("removetilelayer", function (i) {
        if (i.target && i.target.ontology) {
          if (i.target.ontology.src === T.src) {
            kd.removeEventListener("onmousemove", T._layerMouseEvent);
            kd.removeEventListener("onclick", T._layerClickEvent);
            kd.removeEventListener("ondblclick", T._layerClickEvent);
            T._clearCache();
          }
        }
      });
      kd.on("destroy", function () {
        T._clearCache();
      });
    },
    _clearCache: function () {
      var e = this;
      e.prox = null;
      e.tileCache.clear();
      e.tileImageDataCache.clear();
      e.tileMaskUvCache.clear();
      e._layerMouseEvent = null;
      e._layerClickEvent = null;
      e.imageMaskObject = null;
      e.pHashcode = null;
      e.pixelColorMap = null;
      e.layer.ontology = null;
      e.layer = null;
    },
    getImagePixel: function (kh) {
      if (!this.map) {
        return null;
      }
      var kc = dB.transformBDmcPoint(kh, this.layer.transform);
      var kg = this._getInLayer(kh);
      if (!kg) {
        return null;
      }
      if (!this.getImageMaskPixel(kc)) {
        return null;
      }
      var ke = [kg.tileInfo.zoom, kg.tileInfo.col, kg.tileInfo.row];
      var kf = dB.getTileRangeExtent(ke);
      var e = this.getImageObject(kg.textureSource, ke.join("-"));
      var T = Math.floor((kc[0] - kf.minX) / (kf.maxX - kf.minX) * e.width);
      var i = Math.floor((-kc[1] + kf.maxY) / (kf.maxY - kf.minY) * e.height);
      var kd = Math.floor((i * e.width + T) * 4);
      return [e.data.data[kd], e.data.data[kd + 1], e.data.data[kd + 2], e.data.data[kd + 3]];
    },
    getImageObject: function (kd, kc) {
      var ke = this.tileImageDataCache.getData(kc);
      if (ke) {
        return ke;
      }
      var i = document.createElement("canvas");
      i.width = kd.width;
      i.height = kd.height;
      var T = i.getContext("2d");
      T.drawImage(kd, 0, 0, kd.width, kd.height);
      var e = {
        width: kd.width,
        height: kd.height,
        data: T.getImageData(0, 0, kd.width, kd.height)
      };
      this.tileImageDataCache.setData(kc, e);
      T = null;
      i = null;
      return e;
    },
    getValue: function (i) {
      if (this.isPixelMap && i && this.fomularJS) {
        if (!(i instanceof Array)) {
          i = this.getImagePixel(i.point);
        }
        var e = this.fomularJS({
          r: i[0],
          g: i[1],
          b: i[2],
          a: i[3]
        });
        if (e >= this.clamp[0] && e <= this.clamp[1]) {
          return e;
        }
      }
      return null;
    },
    setMaskImageObject: function (T) {
      var e = document.createElement("canvas");
      e.width = T.width;
      e.height = T.height;
      var i = e.getContext("2d");
      i.drawImage(T, 0, 0, T.width, T.height);
      this.imageMaskObject = {
        width: T.width,
        height: T.height,
        data: i.getImageData(0, 0, T.width, T.height)
      };
      i = null;
      e = null;
    },
    getImageMaskPixel: function (e) {
      if (!this.imageMaskObject || !this.maskBox) {
        return true;
      }
      var kc = [e];
      var kh = this.maskBox || [];
      var ke = kh[1][0] - kh[0][0];
      var kd = kh[1][1] - kh[0][1];
      var T = Math.floor((kc[0][0] - kh[0][0]) / ke * this.imageMaskObject.width);
      var i = Math.floor((-kc[0][1] + kh[1][1]) / kd * this.imageMaskObject.height);
      var kg = Math.floor((i * this.imageMaskObject.width + T) * 4);
      if (T > this.imageMaskObject.width || T < 0) {
        return null;
      }
      if (i > this.imageMaskObject.height || i < 0) {
        return null;
      }
      var kf = this.imageMaskObject.data.data;
      if (kg + 3 > kf.length) {
        return false;
      }
      if (kf[kg + 3] > 0) {
        if (this.maskData > -1 && this.maskData !== kf[kg]) {
          return false;
        }
        return true;
      }
      return false;
    },
    calMaskBox: function () {
      var T = this.maskCoord || [];
      if (this.hasMaskPng && T && T.length === 2) {
        var e = [];
        for (var kc = 0; kc < T.length; kc++) {
          e[kc] = dB.transformBDmcPoint(i9.convertLL2MC(T[kc]), this.layer.transform);
        }
        this.maskBox = e;
        this.tileMaskUvCache.clear();
      } else {
        this.maskBox = null;
      }
    },
    buildFillMaskVertex: function (ki, kg, kf) {
      var kh = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
      if (!this.maskBox) {
        return kh;
      }
      var kk = [ki, kg, kf].join("-");
      var e = this.tileMaskUvCache.getData(kk);
      if (e) {
        return e;
      }
      if (this.hasMaskPng) {
        var kn = this.maskBox || [];
        var ke = [kf, ki, kg];
        var kj = dB.getTileRangeExtent(ke);
        var kd = kn[1][0] - kn[0][0];
        var T = kn[1][1] - kn[0][1];
        var km = (kj.minX - kn[0][0]) / kd;
        var kl = (kj.minY - kn[0][1]) / T;
        var kc = (kj.maxX - kn[0][0]) / kd;
        var i = (kj.maxY - kn[0][1]) / T;
        kh = [km, kl, kc, kl, kc, i, km, kl, kc, i, km, i];
      }
      this.tileMaskUvCache.setData(kk, kh);
      return kh;
    },
    loadMaskPng: function (T) {
      var e = this;
      function i(kd, kc) {
        e.maskTextureSource = kc ? kd : null;
        if (kc) {
          e.hasMaskPng = true;
          e.setMaskImageObject(kd);
          e.calMaskBox();
          e.doOnceDraw();
        } else {
          e.hasMaskPng = false;
        }
      }
      this.imageLoad(T, i);
    },
    imageLoad: function (i, kd) {
      if (!i) {
        if (kd) {
          kd(null, false);
        }
      }
      var e = new Image();
      e.crossOrigin = "anonymous";
      e.onload = function kc() {
        if (kd) {
          kd(this, true);
        }
      };
      e.onerror = function T() {
        if (kd) {
          kd(null, false);
        }
      };
      e.src = i;
    },
    toString: function () {
      return "PixelLayer";
    }
  });
  function ja(i, e) {
    this.id = i;
    this.layerName = e;
    this.properties = null;
  }
  function d8(e) {
    this._opt = e || {};
    this._layerId = c3();
    this._opt.defaultOrder = this._opt.defaultOrder === undefined ? true : this._opt.defaultOrder;
    this.minZoom = this._opt.minZoom || 3;
    this.maxZoom = this._opt.maxZoom || 23;
    this.useThumb = this._opt.useThumb === undefined ? true : this._opt.useThumb;
    this.gridModel = this._opt.gridModel || d8.GridModel.BAIDUWEB;
    this.noCollision = this._opt.noCollision === undefined ? true : this._opt.noCollision;
    if (this.gridModel === d8.GridModel.BAIDUWEB) {
      this._opt.reference = "BD09MC";
    } else if (!this._opt.transform) {
      this._opt.transform = {
        source: "BD09MC",
        target: "BD09MC"
      };
      this._opt.reference = "BD09MC";
    } else {
      this._opt.reference = this._opt.transform.source || "GCJ02";
      if (this._opt.reference === "EPSG3857") {
        this._opt.reference = "WGS84";
      }
    }
    this.loadModule = false;
    if (this._opt.useWorker === undefined) {
      this._opt.useWorker = true;
    }
    this.upStyle = this._opt.useWorker ? false : "useMain";
    this._stateCube = {};
    var i = this;
    g2.load("mvtParse", function () {
      i._async();
    }, true);
    i.init(e);
  }
  d8.GridModel = {
    BAIDUWEB: 0,
    GOOGLEWEB: 1
  };
  d8.LayerTypes = {
    POINT: "point",
    LINE: "line",
    FILL: "fill"
  };
  d8.inherits(eX.BaseClass, "MVTLayer");
  eX.extend(d8.prototype, {
    _async: function () {
      this.loadModule = true;
      this.mvt = new d8.MVTParse(this._opt);
      this.resolveStyle(this._opt);
      if (this.upStyle) {
        this.doOnceDraw();
      }
    },
    init: function (i) {
      i.dataType = 2;
      i.cacheSize = 256;
      if (i.spanLevel === undefined || typeof i.spanLevel !== "number") {
        i.spanLevel = 0;
      }
      if (this.gridModel === d8.GridModel.BAIDUWEB) {
        var e = this.createTileLayer(i);
        i.spanLevel = 0;
        this.spanLevel = 0;
      } else if (this.gridModel === d8.GridModel.GOOGLEWEB) {
        var e = new jZ(i);
        this.spanLevel = i.spanLevel;
      }
      var kc = {
        type: "vector",
        layerId: this._layerId,
        g: this.gridModel,
        mc: this._opt.reference === "BD09MC" ? true : false
      };
      this.layerOption = Object.assign(kc, this._opt);
      if (i.index && i.index > 0) {
        e.zIndex = i.index;
      }
      e.loadTileData = this._loadTile.bind(this);
      e.ontology = this;
      this.layer = e;
      var T = this;
      e.addEventListener("ontilesloadstart", function () {
        T.dispatchEvent(new fJ("ontilesloadstart"));
      });
      e.addEventListener("ontilesloadend", function () {
        T.dispatchEvent(new fJ("ontilesloadend"));
      });
    },
    createTileLayer: function (i) {
      const kc = i.tileUrlTemplate || "";
      const kh = i.xTemplate || function (ko, kq, kp) {
        return ko;
      };
      const km = i.yTemplate || function (ko, kq, kp) {
        return kq;
      };
      const kf = i.zTemplate || function (ko, kq, kp) {
        return kp;
      };
      const kl = i.bTemplate || function (ko, kr, kq) {
        const kp = i9.tileToBoundRange({
          col: ko,
          row: kr,
          zoom: kq,
          baseTileSize: 256
        });
        return kp.MC.sw.lng + "," + kp.MC.sw.lat + "," + kp.MC.ne.lng + "," + kp.MC.ne.lat;
      };
      var kn = i.extent || [];
      const kg = i.extentCRSIsWGS84 || false;
      var T = i.minZoom || 0;
      var kj = i.maxZoom || 23;
      var kk = i.spanLevel || 0;
      var ki = new hv({
        transparentPng: true,
        dataType: 2,
        spanLevel: kk,
        tileTypeName: "web",
        cacheSize: 256,
        customLayer: true,
        clipTile: false,
        boundary: false,
        useThumbData: i.useThumbData || false
      });
      if (kn.length === 4) {
        if (kg) {
          kn = dB.fromEPSG4326(kn);
        }
        var kd = dB.transformPointArr([kn[0], kn[1]], "EPSG3857", "BD09MC");
        var ke = dB.transformPointArr([kn[2], kn[3]], "EPSG3857", "BD09MC");
        kn = [kd[0], kd[1], ke[0], ke[1]];
      }
      ki.getTilesUrl = function (kp, kv, ku) {
        if (!kp || kv < 0 || kv < T + kk || kv > kj + kk) {
          ki.tileCache.clear();
          return null;
        }
        if (kn.length === 4) {
          const ks = i9.tileToBoundRange({
            col: x,
            row: y,
            zoom: z,
            baseTileSize: 256
          });
          var kt = e([ks.MC.getMin().lng, ks.MC.getMin().lat, ks.MC.getMax().lng, ks.MC.getMax().lat]);
          if (!kt) {
            return null;
          }
        }
        var kq = "";
        if (kc) {
          kq = kc;
          var kr = /[^\{}]*\{(.*)\}[^\}]*/;
          kq.match(kr);
          var ko = [];
          if (RegExp.$1) {
            ko = RegExp.$1.split(",");
          }
          kq = kq.replace(/\{(.*)\}/, ko[(kp.x + kp.y) % ko.length]);
          kq = kq.replace(/\[x\]/gi, kh(kp.x, kp.y, kv));
          kq = kq.replace(/\[y\]/gi, km(kp.x, kp.y, kv));
          kq = kq.replace(/\[z\]/gi, kf(kp.x, kp.y, kv));
          kq = kq.replace(/\[b\]/gi, kl(kp.x, kp.y, kv));
        } else {
          return null;
        }
        return kq;
      };
      function e(ko) {
        if (kn && kn instanceof Array && kn.length === 4) {
          if (kn[0] <= ko[2] && kn[1] <= ko[3] && kn[2] >= ko[0] && kn[3] >= ko[1]) {
            return true;
          } else {
            return false;
          }
        }
        return true;
      }
      return ki;
    },
    compileExpress: function (i, e) {
      var i = d8.ExpressParse.normalizePropertyExpression(i, e);
      return i;
    },
    resolveStyle: function (ke) {
      var kc = ke || {};
      if (kc.style) {
        var kd = {};
        if (!kc.layers || kc.layers.length === 0) {
          var kg = d8.LayerTypes.POINT;
          var i = d8.LayerTypes.LINE;
          var kf = d8.LayerTypes.FILL;
          if (kc.style[kg]) {
            kc.style[kg].type = "point";
          }
          if (kc.style[i]) {
            kc.style[i].type = "polyline";
          }
          if (kc.style[kf]) {
            kc.style[kf].type = "polygon";
          }
        }
        for (var T in kc.style) {
          if (kc.style.hasOwnProperty(T)) {
            var e = kc.style[T];
            this._styleFormat(e.type, e.painter, T, kd);
          }
        }
        this.styleExpress = kd;
      }
    },
    _styleFormat: function (kd, e, i, kc) {
      var kf = {};
      var kg = cZ[kd];
      if (!kg) {
        return;
      }
      for (var T in e) {
        if (e.hasOwnProperty(T)) {
          var ke = this.compileExpress(e[T], kg[T]);
          kf[T] = ke;
        }
      }
      kc[i] = {
        type: kd,
        painter: kf
      };
    },
    evaluateContext: function (e, T, kc) {
      var i = e + "_" + T.getId();
      var kd = this._stateCube[i];
      if (kd) {
        T.setState(kd);
      } else {
        T._state = {};
      }
      return {
        properties: function () {
          return T && T.getProperties();
        },
        featureState: kc === true ? {} : T && T.getState()
      };
    },
    evaluates: function (i, kc, kd) {
      if (!this.styleExpress || !this.styleExpress.hasOwnProperty(i)) {
        return null;
      }
      var kf = this.styleExpress[i].painter;
      var e = {};
      for (var T in kf) {
        if (kf.hasOwnProperty(T)) {
          var ke = kf[T].evaluate(this.evaluateContext(i, kc, kd));
          e[T] = ke;
        }
      }
      return e;
    },
    _updateState: function (T, kc, e) {
      if (T instanceof ja && T.layerName && T.id) {
        var i = T.layerName + "_" + T.id;
        if (e) {
          this._set(kc, this._stateCube, i);
        } else {
          this._stateCube[i] = kc;
        }
        this._stateCube[i].rank = (this._stateCube[i].rank || 0) + 1;
      } else if (typeof T === "string") {
        if (e) {
          this._set(kc, this._stateCube, T);
        } else {
          this._stateCube[T] = kc;
        }
        this._stateCube[T].rank = (this._stateCube[T].rank || 0) + 1;
      }
    },
    updateState: function (kd, ke, e) {
      var T = JSON.stringify(this._stateCube);
      if (!(ke && typeof ke === "object" && Object.keys(ke).length > 0)) {
        return;
      }
      if (!e) {
        this._stateCube = {};
      }
      if (kd instanceof Array) {
        for (var kc = 0; kc < kd.length; kc++) {
          this._updateState(kd[kc], ke, e);
        }
      } else {
        this._updateState(kd, ke, e);
      }
      var kf = JSON.stringify(this._stateCube);
      if (T !== kf) {
        this.doOnceDraw();
      }
    },
    replaceAllState: function (e) {
      var i = JSON.stringify(this._stateCube);
      this._stateCube = e;
      var T = JSON.stringify(this._stateCube);
      if (i !== T) {
        this.doOnceDraw();
      }
    },
    getAllState: function () {
      return this._stateCube;
    },
    getStateByLayerName: function () {},
    removeState: function (kc) {
      var e = JSON.stringify(this._stateCube);
      if (kc instanceof Array) {
        for (var T = 0; T < kc.length; T++) {
          if (kc[T] instanceof ja && kc[T].layerName) {
            delete this._stateCube[kc[T].layerName + "_" + kc[T].id];
          } else if (typeof kc[T] === "string") {
            delete this._stateCube[kc[T]];
          }
        }
      } else if (kc instanceof ja && kc.layerName) {
        delete this._stateCube[kc.layerName + "_" + kc.id];
      } else if (typeof kc === "string") {
        delete this._stateCube[kc];
      }
      var kd = JSON.stringify(this._stateCube);
      if (e !== kd) {
        this.doOnceDraw();
      }
    },
    clearState: function () {
      var e = JSON.stringify(this._stateCube);
      if (e !== "{}") {
        this._stateCube = {};
        this.doOnceDraw();
      }
    },
    _set: function (i, kd, T) {
      var kc = kd[T] || (kd[T] = {});
      for (var e in i) {
        kc[e] = i[e];
      }
    },
    doOnceDraw: function () {
      if (this.map) {
        var e = new fJ("onupdate");
        this.map.dispatchEvent(e);
      }
    },
    _releaseOutViewTileData: function (e) {
      if (!this.map || !this.map.dispatcher) {
        return;
      }
      var i = this;
      e.layerId = this._layerId;
      this.map.dispatcher.broadcast("release", e, function (ke, T) {
        for (var kd = 0; kd < T.length; kd++) {
          for (var kc = 0; kc < T[kd].length; kc++) {
            i.layer.tileCache.removeData(T[kd][kc].tileKey);
            i.layer._checkLayerTilesLoaded();
          }
        }
      });
    },
    _loadTile: function (ke, T) {
      this.curViewTilesInfo = ke;
      if (!this.loadModule || !this.upStyle) {
        return;
      }
      var kp = this.layer.map;
      this._releaseOutViewTileData(ke);
      var kf = kp.getZoom();
      if (kf < this.minZoom || kf > this.maxZoom) {
        kp._featureMgr.clearData(this.layer.drawIndex);
        kp._featureMgr.clearLabelOverlayData(this.layer.drawIndex);
        kp._featureMgr.clearLabelData(this.layer.drawIndex);
        return;
      }
      var kg = this.layer.getZoomState();
      if (T) {
        this.thumbCache = {};
        var kn = -1;
        this.layer.tileLabels = [];
        var kj = kp._customLabelMgr.virtualTiles["mvt_" + this.layer.drawIndex];
        if (kj && kj.label) {
          this.layer.tileLabels.push(kj.label);
        }
        for (var kl = 0, kk = ke.length; kl < kk; kl++) {
          var km = ke[kl];
          var kc = this.layer.getTileKey(km);
          var ko = this.layer.tileCache.getData(kc);
          kn = km.zoom;
          if (this.useThumb) {
            this._setThumbData(ko, km, kg);
          } else if (ko && ko.status === "ready") {
            kp._featureMgr.setData(ko, this.layer.drawIndex, 2);
            this._loadCacheLabel(km, ko);
          }
        }
        this.layer.tileLabels.labelZoom = kn;
        this.layer.updateLabels(kg);
        if (!this.noCollision) {
          var kd = Math.floor(kf);
          var ki = kf - kd;
          var kh = Math.floor(this.layer.LAST_CALC_ZOOM);
          var e = this.layer.LAST_CALC_ZOOM - kh;
          var kr = false;
          if (this.layer.hasZoomChange) {
            if (Math.abs(kf - this.layer.LAST_CALC_ZOOM) >= 0.5) {
              kr = true;
            } else if (ki < 0.5 && e >= 0.5) {
              kr = true;
            } else if (ki >= 0.5 && e < 0.5) {
              kr = true;
            }
            if (kr) {
              this.layer.cacheDataCollideLabels(0);
            }
            this.layer.LAST_CALC_ZOOM = kf;
          } else if (this.layer.tileLabels.length > 0) {
            this.layer.cacheDataCollideLabels(eX.Browser.ie ? 50 : 30);
          }
        } else {
          this.layer.cacheDataCollideLabels(0);
        }
        return;
      }
      for (var kl = 0, kk = ke.length; kl < kk; kl++) {
        var km = ke[kl];
        var kc = this.layer.getTileKey(km);
        var ko = this.layer.tileCache.getData(kc);
        if (!ko) {
          ko = {
            status: "init",
            retry: 0
          };
          this.layer.numTileLoading++;
        }
        if (ko.status !== "ignore" && ko.status !== "ready" && ko.status !== "loading") {
          ko.status = "loading";
          this.layer.tileCache.setData(kc, ko);
          if (this.upStyle === "useMain") {
            var kq = this;
            this._loadTileData(km, function (ks, kt, i) {
              kq._tileDataCbk(ks, kt, i);
            });
          } else if (this.upStyle) {
            this._loadTileDataByWorker(km);
          }
        }
      }
    },
    _loadCacheLabel: function (T, i) {
      var kd = i.tileData.hasChangeLabel();
      if (kd) {
        i.label.status = "init";
      }
      if (i.label.status === "ready") {
        i.label.tileInfo = i.tileInfo;
        this.layer.tileLabels.push(i.label);
        if (i.label.textureSources && i.label.textureSources[T.zoom] && this.map._webglMapScene) {
          var kc = this.map._webglMapScene._painter;
          var e = i.label.imgKey;
          if (!kc._labelTextureAtlasOffset[e]) {
            kc._addToAsyncJob(i.label.textureSources[T.zoom]);
          }
        }
      } else if (i.label.status !== "processing") {
        this._processLabelData(i);
      }
    },
    getLayerVisible: function (i) {
      var T = this._opt.style;
      if (!T || !T[i]) {
        return true;
      } else if (T[i].visible === false) {
        return false;
      } else {
        var kd = this._opt.style[i].minZoom || 3;
        var e = this._opt.style[i].maxZoom || 23;
        var kc = this.map.getZoom();
        if (kc < kd || kc > e) {
          return false;
        }
        return true;
      }
    },
    _setThumbData: function (i, e, T) {
      if (T === 1) {
        this._dataFitGrid(i, e, 3);
      } else if (T === -1) {
        if (i && i.status === "ready") {
          this.map._featureMgr.setData(i, this.layer.drawIndex, 2);
          this._loadCacheLabel(e, i);
        } else {
          this._findChildZoomTile(e, 3);
        }
      }
    },
    _findParent: function (kc, kf) {
      var T = this.minZoom;
      var e = kc.col;
      var ki = kc.row;
      var kh = kc.zoom;
      for (var kg = 1; kg <= kf; kg++) {
        var kd = this._getParentTiles(e, ki, kh, T);
        if (kd === null) {
          continue;
        }
        kd.tileSize = kc.tileSize;
        kd.tileTypeName = kc.tileTypeName;
        kd.transform = kc.transform;
        var kj = this.layer.getTileKey(kd);
        var ke = this.layer.tileCache.getData(kj);
        if (ke && ke.status === "ready") {
          ke.key = kj;
          return ke;
        }
        e = kd.col;
        ki = kd.row;
        kh = kd.zoom;
      }
      return false;
    },
    _findChild: function (i, kf) {
      var kh = this.maxZoom;
      var e = i.col;
      var ki = i.row;
      var kg = i.zoom;
      var kd = this._getChildTiles(e, ki, kg, kh, kf);
      if (!kd) {
        return false;
      }
      for (var kc = 0; kc < kd.length; kc++) {
        var T = this.layer.getTileKey(kd[kc]);
        var ke = this.layer.tileCache.getData(T);
        if (this.curViewTilesInfo["id_" + kd[kc].col + "_" + kd[kc].row + "_" + kd[kc].zoom] && (!ke || ke.status !== "ready")) {
          return false;
        }
      }
      return true;
    },
    _dataFitGrid: function (T, i, kc) {
      var e = this._findParent(i, kc);
      if (e) {
        if (this.thumbCache[e.key]) {
          this.map._featureMgr.setData(T, this.layer.drawIndex, 2);
          this._loadCacheLabel(i, T);
        } else if (this.thumbCache[e.key] === undefined) {
          if (this._findChild(e.tileInfo, i.zoom - e.tileInfo.zoom)) {
            this.thumbCache[e.key] = true;
            this.map._featureMgr.setData(T, this.layer.drawIndex, 2);
            this._loadCacheLabel(i, T);
          } else {
            this.thumbCache[e.key] = false;
            this.layer.map._featureMgr.setData(e, this.layer.drawIndex, 0);
            this._loadCacheLabel(e.tileInfo, e);
          }
        }
      } else if (T && T.status === "ready") {
        this.map._featureMgr.setData(T, this.layer.drawIndex, 2);
        this._loadCacheLabel(i, T);
      }
    },
    _findChildZoomTile: function (T, kg) {
      var kj = this.maxZoom;
      var e = T.col;
      var kk = T.row;
      var ki = T.zoom;
      for (var kh = 1; kh <= kg; kh++) {
        var kl = false;
        var ke = this._getChildTiles(e, kk, ki, kj, kh);
        if (!ke) {
          continue;
        }
        for (var kd = 0; kd < ke.length; kd++) {
          var kc = this.layer.getTileKey(ke[kd]);
          var kf = this.layer.tileCache.getData(kc);
          if (kf && kf.status === "ready") {
            this.layer.map._featureMgr.setData(kf, this.layer.drawIndex, 1);
            this._loadCacheLabel(ke[kd], kf);
            kl = true;
          }
        }
        if (kl) {
          break;
        }
      }
    },
    _getParentTiles: function (e, T, i, kc) {
      if (i - 1 < kc) {
        return null;
      }
      return {
        col: Math.floor(e / 2),
        row: Math.floor(T / 2),
        zoom: i - 1,
        useZoom: i - 1,
        loopOffsetX: 0
      };
    },
    _getChildTiles: function (kc, kl, kk, kj, kf) {
      var km = [];
      if (kk + kf > kj) {
        return null;
      }
      var ki = Math.pow(2, kf);
      var e = kc * ki;
      var kh = kl * ki;
      var kg = kk + kf;
      var km = [];
      for (var kd = 0; kd < ki; kd++) {
        var ke = e + kd;
        for (var T = 0; T < ki; T++) {
          var i = kh + T;
          km.push({
            col: ke,
            row: i,
            zoom: kg,
            useZoom: kg,
            loopOffsetX: 0
          });
        }
      }
      return km;
    },
    _loadTileDataByWorker: function (i) {
      if (!this.map || !this.map.dispatcher) {
        return;
      }
      var ke = this.map.dispatcher.getActor();
      if (!ke) {
        return;
      }
      var T = i.col;
      var kj = i.row;
      var ki = i.zoom;
      var e = this.layer.getTilesUrl(new fi(T, kj), ki, i);
      if (!e) {
        return;
      }
      var kd = this.layer.getTileKey(i);
      var kg = "id_" + T + "_" + kj + "_" + ki;
      var kf = this._opt.header || null;
      if (this._opt.header instanceof Function) {
        kf = this._opt.header(e);
      }
      if (this._opt.urlCallback instanceof Function) {
        e = this._opt.urlCallback(e);
      }
      var kc = {
        type: "vector",
        layerId: this._layerId,
        x: T,
        y: kj,
        z: ki,
        tileKey: kd,
        tileUrl: e,
        spanLevel: this._opt.spanLevel,
        header: kf,
        encrypt: this._opt.encrypt || false
      };
      var kh = this;
      ke.send("loadTile", kc, function (km, kl) {
        var kk = kh.layer.tileCache.getData(kd);
        if (!kk) {
          kh.layer._checkLayerTilesLoaded();
          return;
        }
        if (km || !kl) {
          kk.status = "ignore";
          kh.layer._checkLayerTilesLoaded();
        } else {
          var kn = new d8.TileFamilyParse(kh.layerOption, kc).deserialize(kl, kh);
          kk.tileInfo = i;
          kk.tileData = kn;
          kh._processLabelData(kk);
          kh.layer.callbackDataQueue.push([kd, kk, kg]);
          if (kh.processDataTimer) {
            return;
          }
          kh.processDataTimer = setTimeout(function () {
            while (kh.layer && kh.layer.callbackDataQueue.length > 0) {
              kh.layer._checkLayerTilesLoaded();
              var kp = kh.layer.callbackDataQueue.shift();
              kh._setTileData(kp[0], kp[1], kp[2]);
            }
            var ko = new fJ("onupdate");
            kh.map.dispatchEvent(ko);
            kh.processDataTimer = null;
          }, 0);
        }
      });
    },
    _loadTileData: function (i, e) {
      var kc = i.col;
      var kg = i.row;
      var kd = i.zoom;
      var T = this.layer.getTilesUrl(new fi(kc, kg), kd, i);
      if (!T) {
        return;
      }
      var kf = this.layer.getTileKey(i);
      var ke = new XMLHttpRequest();
      ke.open("GET", T, true);
      ke.responseType = "arraybuffer";
      ke.timeout = 3000;
      ke.ontimeout = function () {
        if (e) {
          e(null, kf, i);
        }
      };
      ke.onreadystatechange = function (kh) {
        if (this.readyState === 4) {
          if (this.status === 200) {
            if (e) {
              e(ke.response, kf, i);
            }
            return;
          }
          if (this.status >= 400 || this.status === 0) {
            if (e) {
              e(null, kf, i);
            }
          } else if (e) {
            e(null, kf, i);
          }
        }
      };
      ke.send();
    },
    _tileDataCbk: function (kd, kf, i) {
      var e = this.layer.tileCache.getData(kf);
      if (!e) {
        return;
      }
      var ke = this.layer.map;
      var T = this;
      if (!kd || typeof kd === "string") {
        e.status = "init";
        e.reloadTimer = setTimeout(function () {
          if (e.retry < 3) {
            e.retry++;
            e.status = "loading";
            T._loadTileData(i, function (kh, ki, kg) {
              T._tileDataCbk(kh, ki, kg);
            });
          } else {
            e.status = "ignore";
          }
        }, 3000);
        return;
      }
      if (e.reloadTimer) {
        clearTimeout(e.reloadTimer);
        e.reloadTimer = null;
      }
      var kc = function (kg) {
        return function () {
          var kh = i.col;
          var kk = i.row;
          var ki = i.zoom;
          var kj = "id_" + kh + "_" + kk + "_" + ki;
          e.tileInfo = i;
          e.tileData = T.mvt.readFeatures(kg, T, ke, {
            x: kh,
            y: kk,
            z: ki,
            g: T.gridModel,
            mc: T._opt.transform && T._opt.transform.source === "BD09MC" ? true : false
          });
          T._processLabelData(e);
          T.layer.callbackDataQueue.push([kf, e, kj]);
          if (T.processDataTimer) {
            return;
          }
          T.processDataTimer = setTimeout(function () {
            while (T.layer.callbackDataQueue.length > 0) {
              var kl = T.layer.callbackDataQueue.shift();
              T._setTileData(kl[0], kl[1], kl[2]);
            }
            T.doOnceDraw();
            T.processDataTimer = null;
          }, 200);
        };
      }(kd);
      ke.jobScheduler.addJob(kc);
    },
    _setTileData: function (T, e, i) {
      e.status = "ready";
      this.layer.tileCache.setData(T, e);
      if (this.layer.curViewTilesInfo[i]) {
        e.dataType = hI;
      }
    },
    _processLabelData: function (T) {
      if (!T.tileData) {
        return;
      }
      T.label = T.tileData.getTileLabels();
      if (!T.label) {
        return;
      }
      if (T.label.status === "processing") {
        return;
      }
      var i = T.tileInfo;
      var e = this._getTileTexImgKey(i);
      T.label.imgKey = e;
      T.label.status = "processing";
      var kc = this;
      kc.layer.updateAllIconsTextureCoords(T);
      this.layer.labelProcessor.loadIconImages(T, function (ke) {
        kc.layer.updateAllIconsTextureCoords(ke);
      }, true);
      var kd = this.layer.map.tileMgr.getLabelTextCanvas();
      kd.drawCustomLabelsOnCanvas(T.label.fixedLabel, function (ke) {
        if (ke) {
          if (!T.label.textureHeights) {
            T.label.textureHeights = [];
          }
          T.label.textureHeights[i.useZoom] = ke.height;
        }
        kc.layer._doWorkAfterLabelImageLoad(T, ke, null, e);
      });
    },
    _getTileTexImgKey: function (i) {
      var e = "mvt_" + this.layer.drawIndex + "_" + i.col + "_" + i.row + "_" + i.zoom + "_";
      e = bx.getGUID(e);
      return e;
    },
    _updateBRushCube: function (kf) {
      var kh = kf.tileData;
      for (var T in kh) {
        if (kh.hasOwnProperty(T)) {
          var e = kh[T];
          for (var kd = 0; kd < e.length; kd++) {
            var kc = e[kd];
            var ke = kc.getBox();
            var kg = {
              minX: ke[0],
              minY: ke[1],
              maxX: ke[2],
              maxY: ke[3],
              lN: T,
              f: kc
            };
          }
        }
      }
    },
    intersectFeatures: function (e) {
      var ke = this._geojsonToSouceXY(e);
      var T = this._bboxTile(ke);
      T = this._intersectTile(ke, T);
      if (!T) {
        return null;
      }
      var kg = this.layer.map._featureMgr.result.bkData[this.layer.drawIndex][2];
      var kc = [];
      var kl = null;
      for (var kh = 0; kh < kg.length; kh++) {
        var kd = kg[kh].tileInfo;
        var km = kd.zoom + "_" + kd.col + "_" + kd.row;
        if (T[km]) {
          if (!kg[kh].tileData || !kg[kh].tileData.layers) {
            continue;
          }
          var kf = kg[kh].tileData.layers;
          var kk = null;
          for (var kj in kf) {
            var ki = kf[kj];
            if (T[km][4]) {
              this._featuresInter(kj, ki.features, kc);
            } else if (ki.layerType === "Point" || ki.layerType === "MultiPoint") {
              if (!kl) {
                kl = this._geojsonToScreenXY(e);
              }
              this._pointFeaturesInter(kj, ki.features, kc, kl);
            } else {
              if (!kk) {
                kk = this._geojsonToTileXY(ke, T[km]);
              }
              if (!kk) {
                continue;
              }
              this._noPointFeaturesInter(kj, ki.features, kc, kk);
            }
          }
        }
      }
      return kc.length === 0 ? null : kc;
    },
    _featuresInter: function (T, kc, kd) {
      for (var i in kc) {
        if (!kc[i]._visible) {
          continue;
        }
        if (kd[T + "_" + kc[i].getId()]) {
          continue;
        }
        kc[i].layerName = T;
        var e = new ja(kc[i].getId(), T);
        e.properties = kc[i].getProperties();
        kd.push(e);
        kd[T + "_" + kc[i].getId()] = true;
      }
    },
    _pointFeaturesInter: function (kd, ke, kf, kc) {
      for (var T in ke) {
        if (!ke[T]._visible) {
          continue;
        }
        if (kf[kd + "_" + ke[T].getId()]) {
          continue;
        }
        var kg = ke[T].getPointGeoJSON(this.layer.map);
        if (!kg) {
          continue;
        }
        var i = d8.booleanDisjoint(kg, kc);
        if (!i) {
          ke[T].layerName = kd;
          var e = new ja(ke[T].getId(), kd);
          e.properties = ke[T].getProperties();
          kf.push(e);
          kf[kd + "_" + ke[T].getId()] = true;
        }
      }
    },
    _noPointFeaturesInter: function (kd, ke, kf, kc) {
      for (var T in ke) {
        if (!ke[T]._visible) {
          continue;
        }
        if (kf[kd + "_" + ke[T].getId()]) {
          continue;
        }
        var i = d8.booleanDisjoint(ke[T].geojson, kc);
        if (!i) {
          ke[T].layerName = kd;
          var e = new ja(ke[T].getId(), kd);
          e.properties = ke[T].getProperties();
          kf.push(e);
          kf[kd + "_" + ke[T].getId()] = true;
        }
      }
    },
    pickFeatures: function (kp, kd) {
      if (this.running) {
        return;
      }
      var T = Math.floor(this.map.getZoom() + this.spanLevel);
      if (this.gridModel === d8.GridModel.BAIDUWEB) {
        var kn = Math.pow(2, 18 - T);
        var ke = Math.floor(kp.lng / kn / 256);
        var kh = Math.floor(kp.lat / kn / 256);
        var kc = kp.lng / kn - ke * 256;
        var ki = kp.lat / kn - kh * 256;
        var kg = [kc, ki];
        var kv = [T, ke, kh];
      } else {
        var kt = dB.transformBDmcPoint(kp, this.layer.transform);
        var ko = dB.getPointPixelCoor(kp, T, this.layer.transform);
        var kv = dB.getTileCoordForCoordAndZ(kt, T);
        var kg = dB.getRelativePixelCoor(kv, ko);
      }
      var kw = this.layer.map._featureMgr.result.bkData[this.layer.drawIndex][2];
      var km = kv.join("_");
      var kj = [];
      for (var kr = 0; kr < kw.length; kr++) {
        var ks = kw[kr].tileInfo;
        var kx = ks.zoom + "_" + ks.col + "_" + ks.row;
        if (km === kx) {
          this.running = true;
          if (!kw[kr].tileData || !kw[kr].tileData.layers) {
            continue;
          }
          var kk = kw[kr].tileData.layers;
          for (var ku in kk) {
            var kf = kk[ku].features;
            for (var kq in kf) {
              if (!kf[kq]._visible) {
                continue;
              }
              if (kj[ku + "_" + kf[kq].getId()]) {
                continue;
              }
              if (kf[kq].getType() === fO.POINT || kf[kq].getType() === fO.MULTI_POINT) {
                var e = kf[kq].isPointInGeometry(kd, this.layer.map);
              } else {
                var e = kf[kq].isPointInBox(kg);
                if (e) {
                  e = kf[kq].isPointInGeometry(kg);
                }
              }
              if (e) {
                kf[kq].layerName = ku;
                var kl = new ja(kf[kq].getId(), ku);
                kl.properties = kf[kq].getProperties();
                kj.push(kl);
                kj[ku + "_" + kf[kq].getId()] = true;
              }
            }
          }
          break;
        }
      }
      this.running = false;
      return kj;
    },
    _geojsonToScreenXY: function (T) {
      var i = JSON.parse(JSON.stringify(T));
      var e = this;
      gw.coordEachReplace(i, function (ke) {
        var kc = i9.convertLL2MC(new cx(ke[0], ke[1]));
        var kd = e.map.pointToPixelIn(kc);
        return [kd.x, kd.y];
      });
      return i;
    },
    _geojsonToTileXY: function (T, kd) {
      if (kd.length < 4) {
        return null;
      }
      var i = JSON.parse(JSON.stringify(T));
      var kc = Math.floor(this.map.getZoom() + this.spanLevel);
      if (this.gridModel === d8.GridModel.BAIDUWEB) {
        var e = Math.pow(2, 18 - kc);
      } else {
        var e = dB.resolutions[kc];
      }
      gw.coordEachReplace(i, function (ke) {
        return [(ke[0] - kd[2]) / e, (ke[1] - kd[3]) / e];
      });
      return i;
    },
    _geojsonToSouceXY: function (T) {
      var i = JSON.parse(JSON.stringify(T));
      var e = this;
      gw.coordEachReplace(i, function (ke) {
        var kc = i9.convertLL2MC(new cx(ke[0], ke[1]));
        var kd = [kc.lng, kc.lat];
        if (e.gridModel !== d8.GridModel.BAIDUWEB) {
          kd = dB.transformBDmcPoint(kc, e.layer.transform);
        }
        return kd;
      });
      return i;
    },
    _bboxTile: function (T) {
      var kf = gw.bbox(T);
      var kk = Math.floor(this.map.getZoom() + this.spanLevel);
      if (this.gridModel === d8.GridModel.BAIDUWEB) {
        var ki = new cx(kf[0], kf[1]);
        var kl = new cx(kf[2], kf[3]);
        var kg = Math.pow(2, 18 - kk);
        var km = Math.floor(ki.lng / kg / 256);
        var ke = Math.floor(ki.lat / kg / 256);
        var kd = Math.floor(kl.lng / kg / 256);
        var i = Math.floor(kl.lat / kg / 256);
        return [kk, km, ke, kd, i];
      } else {
        var e = [kf[0], kf[3]];
        var kh = [kf[2], kf[1]];
        var kj = dB.getTileCoordForCoordAndZ(e, kk);
        var kc = dB.getTileCoordForCoordAndZ(kh, kk);
        return [kj[0], kj[1], kj[2], kc[1], kc[2]];
      }
    },
    _intersectTile: function (e, kf) {
      var km = {};
      if (kf.length < 5) {
        return null;
      }
      var ki = gw.getType(e);
      var kn = false;
      if (e.type === "Feature" && ki === "Polygon") {
        kn = true;
      }
      for (var kd = kf[1]; kd <= kf[3]; kd++) {
        for (var kc = kf[2]; kc <= kf[4]; kc++) {
          if (this.gridModel === d8.GridModel.BAIDUWEB) {
            var kh = i9.tileToBoundRange({
              col: kd,
              row: kc,
              zoom: kf[0],
              baseTileSize: 256
            });
            var ke = [kh.MC.sw.lng, kh.MC.sw.lat, kh.MC.ne.lng, kh.MC.ne.lat];
          } else {
            var kh = dB.getTileRangeExtent([kf[0], kd, kc]);
            var ke = [kh.minX, kh.minY, kh.maxX, kh.maxY];
          }
          var kg = {
            type: "Feature"
          };
          kg.bbox = ke;
          kg.geometry = {
            type: "Polygon",
            coordinates: [[[ke[0], ke[1]], [ke[2], ke[1]], [ke[2], ke[3]], [ke[0], ke[3]], [ke[0], ke[1]]]]
          };
          var T = d8.booleanDisjoint(kg, e);
          if (!T) {
            var kl = kf[0] + "_" + kd + "_" + kc;
            var kk = [kd, kc, ke[0], ke[1], false];
            if (kn) {
              var kj = d8.booleanContains(e, kg);
              if (kj) {
                kk[4] = true;
              }
            }
            km[kl] = kk;
          }
        }
      }
      return Object.keys(km).length === 0 ? null : km;
    },
    _initEvent: function (kf) {
      this.map = kf;
      if (!this.map.dispatcher) {
        this.map.dispatcher = new cC(hl(), d8);
      }
      var kd = this;
      this.map.dispatcher.broadcast("setLayerStyle", kd.layerOption, function (kh, i) {
        kd.upStyle = true;
        if (kd.loadModule) {
          kd.doOnceDraw();
        }
      });
      var kc = this;
      var e = false;
      this._layerMouseEvent = function (kj) {
        if (!kc.map || !kc._listeners) {
          return;
        }
        if (!kc._listeners.onmousemove || Object.keys(kc._listeners.onmousemove).length === 0) {
          return;
        }
        var kh;
        var i = kj.point;
        var ki = kc.pickFeatures(i, kj.pixel);
        if (ki && ki.length > 0) {
          kh = new fJ("onmousemove");
          kh.value = ki;
          kc.map.platform.style.cursor = kc.map.config.overlayMoveCursor;
          e = true;
        } else {
          kc.map.platform.style.cursor = kc.map.config.defaultCursor;
          if (!e || !kc._listeners.onmouseout || Object.keys(kc._listeners.onmouseout).length === 0) {
            return;
          }
          kh = new fJ("onmouseout");
          e = false;
        }
        if (kh) {
          kh.point = kj.point;
          kh.pixel = kj.pixel;
          kh.latLng = kj.latlng;
          kc.dispatchEvent(kh);
        }
      };
      this._layerClickEvent = function (kj) {
        if (!kc.map || !kc._listeners) {
          return;
        }
        if (!kc._listeners.onclick && !kc._listeners.dblclick || Object.keys(kc._listeners.onclick).length === 0 && Object.keys(kc._listeners.dblclick).length === 0) {
          return;
        }
        var kh;
        var i = kj.point;
        var ki = kc.pickFeatures(i, kj.pixel);
        kh = new fJ(kj.type);
        kh.point = i;
        kh.pixel = kj.pixel;
        kh.latLng = kj.latlng;
        kh.value = ki;
        kc.dispatchEvent(kh);
      };
      kf.addEventListener("onmousemove", this._layerMouseEvent);
      var ke = ["onclick", "dblclick"];
      for (var T = 0; T < ke.length; T++) {
        var kg = ke[T];
        kf.addEventListener(kg, this._layerClickEvent);
      }
      kf.addEventListener("removetilelayer", function (i) {
        if (i.target && i.target.ontology) {
          if (i.target.ontology === kc) {
            kc.layer.tileCache.clear();
            kc.stateCube = {};
            kc.upStyle = false;
            kf.removeEventListener("onmousemove", kc._layerMouseEvent);
            kf.removeEventListener("onclick", kc._layerClickEvent);
            kf.removeEventListener("ondblclick", kc._layerClickEvent);
            kc.layer.ontology = null;
            kc.layer = null;
            if (kf.dispatcher) {
              kf.dispatcher.broadcast("removeLayer", kc.layerOption, function (kj, kh) {
                var kl = kf.tileMgr.tileLayers;
                var ki = false;
                for (var kk = 0; kk < kl.length; kk++) {
                  if (kl[kk].ontology instanceof d8) {
                    ki = true;
                    break;
                  }
                }
                if (!ki && kf.dispatcher) {
                  kf.dispatcher.remove();
                  kf.dispatcher = null;
                }
              });
            }
          }
        }
      });
      kf.on("destroy", function () {
        if (kc.map && kc.map.dispatcher) {
          kc.map.dispatcher.remove();
          kc.map.dispatcher = null;
        }
        kc.layer.ontology = null;
        kc.layer = null;
      });
      this.addEventListener("onmousemove", function () {});
    },
    setStyle: function (e) {
      this._opt.style = e;
      if (!this.map || !this.loadModule) {
        return;
      }
      this.resolveStyle(this._opt);
      var i = this;
      if (this.upStyle === true) {
        this.map.dispatcher.stop();
        this.map.dispatcher.broadcast("stop", null, function (kc, T) {
          i.layerOption = Object.assign(i.layerOption, i._opt);
          i.map.dispatcher.broadcast("setLayerStyle", i.layerOption, function (ke, kd) {
            i.layer.tileCache.clear();
            i.doOnceDraw();
          });
        });
      } else {
        i.layer.tileCache.clear();
        i.doOnceDraw();
      }
    },
    setZIndex: function (e) {
      if (this.layer && parseInt(e) > 0) {
        this.layer.setZIndex(e);
      }
    },
    getZIndex: function () {
      if (this.layer) {
        return this.layer.zIndex;
      }
    },
    setZIndexTop: function () {
      if (this.layer) {
        this.layer.setZIndexTop();
      }
    },
    setUpLevel: function () {
      if (this.layer) {
        var e = this.layer._getAdjoinZIndex("up");
        if (this.layer.zIndex !== e) {
          this.layer.setZIndex(e);
        }
      }
    },
    setDownLevel: function () {
      if (this.layer) {
        var e = this.layer._getAdjoinZIndex("down");
        if (this.layer.zIndex !== e) {
          this.layer.setZIndex(e);
        }
      }
    },
    toString: function () {
      return "MVTLayer";
    }
  });
  d8._generateTexture = function (kf, ke, T) {
    var kd = document.createElement("canvas");
    var e;
    var kc;
    if (ke.strokeStyle === "dashed") {
      e = 16;
      kc = e * 8;
    } else if (ke.strokeStyle === "dotted") {
      e = 32;
      kc = e * 2;
    }
    kd.width = e;
    kd.height = kc;
    var i = kd.getContext("2d");
    i.fillStyle = ke.strokeColor;
    i.globalAlpha = ke.strokeOpacity;
    var kg = ke.strokeWeight * 2;
    if (ke.strokeStyle === "dashed") {
      kg = d8._drawDashArrayTexture(i, e, kc, ke);
    } else if (ke.strokeStyle === "dotted") {
      kg = d8._drawDottedTexture(i, e, kc, ke.strokeWeight);
    }
    if (window.createImageBitmap && !ke.sync) {
      createImageBitmap(kd, {
        imageOrientation: "flipY"
      }).then(function (kh) {
        T(null, {
          totalDashLen: kg,
          texture: kh,
          textureSize: [e, kc]
        });
      });
    } else {
      T(null, {
        totalDashLen: kg,
        texture: kd.toDataURL(),
        textureSize: [e, kc]
      });
    }
  };
  d8._drawDashArrayTexture = function (ki, kc, ke, T) {
    var kg = T.dashArray;
    if (!kg) {
      ki.fillRect(0, 0, kc, ke / 2);
      return T.strokeWeight * 4;
    } else {
      var kh = 0;
      if (kg.length % 2 !== 0) {
        kg = kg.concat(kg);
      }
      for (var kd = 0; kd < kg.length; kd++) {
        kh += kg[kd];
      }
      var e = 0;
      for (var kd = 0; kd < kg.length; kd++) {
        var kf = kg[kd] / kh * ke;
        if (kd % 2 === 0) {
          ki.fillRect(0, e, kc, kf);
        }
        e += kf;
      }
      return kh;
    }
  };
  d8._drawDottedTexture = function (i, e, T, kc) {
    i.beginPath();
    i.arc(e / 2, e / 2, e / 2, 0, 2 * Math.PI);
    i.fill();
    i.closePath();
    return kc * 2;
  };
  var U = function (e) {
    var e = e || {};
    this.inputCRS = e.inputCRS || "EPSG3857";
    this.outCRS = e.outCRS || "EPSG3857";
    this.minZoom = e.minZoom || 3;
    this.maxZoom = e.maxZoom || 19;
    this.retry = e.retry || false;
    this.retryTime = e.retryTime || 600;
    this.useThumbData = e.useThumbData || true;
    this.lastZoom = 3;
    this.cacheSize = e.cacheSize || 128;
    this.tileType = hZ.getInstance("web");
    this._mapCenter = {};
    this._featureMgr = [[], [], []];
    this._gridRefs = {
      row: {},
      col: {}
    };
    this.tileCache = new az(this.cacheSize, {
      clearCallback: function (i) {}
    });
  };
  U.inherits(c8, "BaiduLayer");
  eX.extend(U.prototype, {
    fetch: function (i, kc, kd) {
      var kc = Math.ceil(kc) || 3;
      var i = i || [];
      if (i.length !== 4 || kc > 19) {
        kd(null);
        return;
      }
      var e = this.getZoomState(kc);
      var T = this.calCoord(i, kc, e);
      this.curViewTilesInfo = this.calTilesOrders(T.sw, T.ne, kc);
      this.clearData();
      this.clearRefs();
      this.loadLayerData(this.curViewTilesInfo, e, true, kd);
    },
    calCoord: function (T, kc, i) {
      if (T.length !== 4) {
        return;
      }
      var e = gcoord.transform([T[0], T[1]], gcoord[this.inputCRS], gcoord.BD09MC);
      var kd = gcoord.transform([T[2], T[3]], gcoord[this.inputCRS], gcoord.BD09MC);
      if (kd[1] > 19505879.362428114 || e[1] < -15949096.637571886) {
        kd[1] = 19505879.362428114;
        e[1] = -15949096.637571886;
      }
      this._mapCenter[kc] = new cx((e[0] + kd[0]) / 2, (e[1] + kd[1]) / 2);
      return {
        sw: e,
        ne: kd
      };
    },
    calTilesOrders: function (kh, kn, kj) {
      var kk = this.tileType.getMercatorSize(kj, kj);
      var kf = [Math.floor(kh[0] / kk), Math.floor(kh[1] / kk)];
      var i = [Math.floor(kn[0] / kk), Math.floor(kn[1] / kk)];
      var kg = kf[0] - 1;
      var ke = i[0] + 2;
      var kd = kf[1] - 1;
      var km = i[1] + 2;
      var ki = [];
      for (var kc = kg; kc < ke; kc++) {
        for (var kl = kd; kl < km; kl++) {
          var T = {
            col: kc,
            row: kl,
            zoom: kj,
            useZoom: kj,
            tileTypeName: "web",
            loopOffsetX: 0,
            tileSize: 256,
            baseTileSize: 256,
            mercatorSize: kk,
            combine: false,
            dataIndex: 256
          };
          ki.push(T);
          var e = "id_" + kc + "_" + kl + "_" + kj;
          ki[e] = true;
        }
      }
      ki.sort(function (ko) {
        return function (kp, kq) {
          return 0.4 * Math.abs(kp.col - ko[0]) + 0.6 * Math.abs(kp.row - ko[1]) - (0.4 * Math.abs(kq.col - ko[0]) + 0.6 * Math.abs(kq.row - ko[1]));
        };
      }([(kg + ke) / 2, (kd + km) / 2]));
      ki.zoom = kj;
      ki.tileTypeName = "web";
      return ki;
    },
    getZoomState: function (i) {
      var e = i - this.lastZoom;
      if (e > 0) {
        this.zoomState = 1;
      } else if (e < 0) {
        this.zoomState = -1;
      }
      this.lastZoom = i;
      return this.zoomState || 0;
    },
    loadLayerData: function (kj, kc, kd, ki) {
      this.thumbCache = {};
      if (kd) {
        for (var kg = 0, ke = kj.length; kg < ke; kg++) {
          var T = kj[kg];
          var kf = this.getTileKey(T);
          var e = this.tileCache.getData(kf);
          if (e && e.status === "ready") {
            e.key = kf;
            this.setData(e, 2);
          } else if (this.useThumbData) {
            if (kc === 1) {
              this.setThumbData(T.col, T.row, T.zoom, T.useZoom, kc);
            }
          }
        }
        this.calOutData(ki);
      }
      for (var kg = 0, ke = kj.length; kg < ke; kg++) {
        var T = kj[kg];
        var kf = this.getTileKey(T);
        var e = this.tileCache.getData(kf);
        if (!e) {
          this.tileCache.setData(kf, {});
          var kh = this;
          this.loadRasterTileData(T, function (i, kk) {
            kh.rasterTileDataCbk(i, kk, ki);
          });
        }
      }
    },
    loadRasterTileData: function (i, e) {
      var T = new Image();
      var kd = i.col;
      var kg = i.row;
      var ke = i.zoom;
      var kc = this.getTilesUrl(new fi(kd, kg), ke);
      if (!kc) {
        return;
      }
      var kf = this.getTileKey(i);
      T = this.loadTileImage(kc, i, kf, e);
      T.tileInfo = i;
    },
    loadTileImage: function (kg, e, T, ke) {
      var kc = new Image();
      kc.crossOrigin = "anonymous";
      var kf = this;
      var kd;
      function kh() {
        if (kf.retry) {
          if (kd) {
            clearInterval(kd);
          }
          kd = null;
        }
      }
      if (this.retry) {
        var i = 1;
        kd = setInterval(function () {
          if (i > 3) {
            kh();
            return;
          }
          var ki = kf.getTilesUrl(new fi(e.col, e.row), e.zoom, i);
          kc.src = ki;
          i++;
        }, this.retryTime);
      }
      kc.onload = function () {
        kh();
        if (ke) {
          ke(this, T);
        }
      };
      kc.onerror = function () {
        kh();
        if (ke) {
          ke(null, T);
        }
      };
      kc.src = kg;
      return kc;
    },
    rasterTileDataCbk: function (kd, kc, kg) {
      if (!kd || typeof kd === "string") {
        this.tileCache.removeData(kc);
        return;
      }
      var i = kd.tileInfo;
      var T = i.col;
      var ki = i.row;
      var kh = i.zoom;
      var e = this.tileCache.getData(kc);
      if (!e) {
        return;
      }
      e.textureSource = kd;
      e.dataType = gF;
      e.tileInfo = i;
      e.status = "ready";
      this.tileCache.setData(kc, e);
      var ke = "id_" + T + "_" + ki + "_" + kh;
      var kf = false;
      if (this.curViewTilesInfo[ke]) {
        e.png8 = this.png8 || false;
        e.key = kc;
        this.setData(e, 2);
        kf = true;
      }
      if (kf) {
        this.calOutData(kg, e);
      }
    },
    getTilesUrl: function (kd, kk, i) {
      var kf = i || 0;
      var T = kd.x;
      var kl = kd.y;
      var kh = jO("ditu", "normal");
      var kg = kh.udt;
      var kj = ej.B_NORMAL_MAP.tileUrls;
      var ke = Math.abs(T + kl + kf) % kj.length;
      var ki = kj[ke];
      if (T < 0) {
        T = "M" + -T;
      }
      if (kl < 0) {
        kl = "M" + -kl;
      }
      var kc = "x=" + T + "&y=" + kl + "&z=" + Math.floor(kk);
      kc += "&styles=pl&scaler=2&udt=" + kg + "&from=jsapi3_0";
      var e = ki + "?qt=vtile&" + kc;
      return e;
    },
    calOutData: function (ki, T) {
      if (!T) {
        for (var kf = 0; kf < this._featureMgr.length; kf++) {
          var e = this._featureMgr[kf];
          for (var kd = 0; kd < e.length; kd++) {
            var kc = e[kd].tileInfo;
            if (kf === 2) {
              var kg = e[kd].extent;
              if (kg) {
                this.addRefs(kg, kc.col, kc.row);
              } else {
                var kh = this.calBoxCoord(kc);
                if (!kh) {
                  continue;
                }
                e[kd].extent = this.findRefs(kh, kc.col, kc.row);
              }
            }
          }
        }
        ki({
          size: this.curViewTilesInfo.length,
          zoom: this.lastZoom,
          data: this._featureMgr
        });
      } else {
        var ke = this.calBoxCoord(T.tileInfo);
        if (!ke) {
          return;
        }
        T.extent = this.findRefs(ke, T.tileInfo.col, T.tileInfo.row);
        ki({
          zoom: this.lastZoom,
          size: this.curViewTilesInfo.length,
          data: [[], [], [T]]
        });
      }
    },
    calOutData_back: function (kk, kc) {
      if (!kc) {
        var ke;
        var kl;
        var ki;
        for (var kg = 0; kg < this._featureMgr.length; kg++) {
          var T = this._featureMgr[kg];
          for (var kf = 0; kf < T.length; kf++) {
            var kd = T[kf].tileInfo;
            if (kg === 2) {
              if (kf === 0) {
                var kh = this.calBoxCoord(kd);
                T[0].extent = kh;
                ke = T[0];
                kl = kh[2] - kh[0];
                ki = kh[3] - kh[1];
              } else if (ke && kl && ki) {
                var e = (kd.row - ke.tileInfo.row) * ki;
                var kj = (kd.col - ke.tileInfo.col) * kl;
                var kh = ke.extent;
                T[kf].extent = [kh[0] + kj, kh[1] + e, kh[2] + kj, kh[3] + e];
              }
            } else {
              var kh = this.calBoxCoord(kd);
              T[kf].extent = kh;
            }
          }
        }
        kk({
          size: this.curViewTilesInfo.length,
          zoom: this.lastZoom,
          data: this._featureMgr
        });
      } else {
        if (this._featureMgr[2].length === 1) {
          var kh = this.calBoxCoord(kc.tileInfo);
          kc.extent = kh;
          this.featureCell = kc;
          this.cellW = kh[2] - kh[0];
          this.cellH = kh[3] - kh[1];
        } else {
          var e = (kc.tileInfo.row - this.featureCell.tileInfo.row) * this.cellH;
          var kj = (kc.tileInfo.col - this.featureCell.tileInfo.col) * this.cellW;
          var kh = this.featureCell.extent;
          kc.extent = [kh[0] + kj, kh[1] + e, kh[2] + kj, kh[3] + e];
        }
        kk({
          zoom: this.lastZoom,
          size: this.curViewTilesInfo.length,
          data: [[], [], [kc]]
        });
      }
    },
    calBoxCoord: function (e) {
      var i = i9.prototype.tileToBound(e, this._mapCenter[e.zoom]).LL;
      var T = gcoord.transform([i.sw.lng, i.sw.lat], gcoord.BD09LL, gcoord[this.outCRS]);
      var kc = gcoord.transform([i.ne.lng, i.ne.lat], gcoord.BD09LL, gcoord[this.outCRS]);
      return [T[0], T[1], kc[0], kc[1]];
    },
    clearData: function () {
      this._featureMgr = [[], [], []];
    },
    addRefs: function (i, e, T) {
      this._gridRefs.row[T] = i[1];
      this._gridRefs.row[T + 1] = i[3];
      this._gridRefs.col[e] = i[0];
      this._gridRefs.col[e + 1] = i[2];
    },
    findRefs: function (i, e, kc) {
      var T = [];
      if (this._gridRefs.row[kc]) {
        T[1] = this._gridRefs.row[kc];
      }
      if (this._gridRefs.row[kc + 1]) {
        T[3] = this._gridRefs.row[kc + 1];
      }
      if (this._gridRefs.col[e]) {
        T[0] = this._gridRefs.col[e];
      }
      if (this._gridRefs.col[e + 1]) {
        T[2] = this._gridRefs.col[e + 1];
      }
      if (!this._gridRefs.row[kc] && (this._gridRefs.row[kc] = i[1])) {
        T[1] = i[1];
      }
      if (!this._gridRefs.row[kc + 1] && (this._gridRefs.row[kc + 1] = i[3])) {
        T[3] = i[3];
      }
      if (!this._gridRefs.col[e] && (this._gridRefs.col[e] = i[0])) {
        T[0] = i[0];
      }
      if (!this._gridRefs.col[e + 1] && (this._gridRefs.col[e + 1] = i[2])) {
        T[2] = i[2];
      }
      return T;
    },
    clearRefs: function () {
      this._gridRefs = {
        row: {},
        col: {}
      };
    },
    destroy: function () {
      this.tileCache.clear();
      this.clearData();
      this.clearRefs();
      this._mapCenter = {};
    },
    setData: function (kd, T) {
      var e = this._featureMgr[T];
      for (var kc = 0; kc < e.length; kc++) {
        if (e[kc].key && e[kc].key === kd.key) {
          e[kc] = kd;
          return;
        }
      }
      e.push(kd);
    },
    getTileKey: function (e, kc) {
      kc = kc || {};
      var i = typeof kc.useZoom === "number" ? kc.useZoom : e.useZoom;
      var T = "default";
      return "web_" + T + "_" + e.col + "_" + e.row + "_" + e.zoom + "_" + i;
    },
    setThumbData: function (i, kd, kc, e, T) {
      if (T === 1) {
        if (this._findParentZoomTile(i, kd, kc, e, 8) === false) {
          this._findChildZoomTile(i, kd, kc, e, 3);
        }
      } else if (T === -1) {
        if (this._findChildZoomTile(i, kd, kc, e, 3) === false) {
          this._findParentZoomTile(i, kd, kc, e, 8);
        }
      }
      this.sortThumbData();
    },
    _findParentZoomTile: function (kf, ko, kn, kd, ki) {
      var ke = "web";
      var T = 3;
      var e = kf;
      var kl = ko;
      var kj = kn;
      var kk = kd;
      for (var kh = 1; kh <= ki; kh++) {
        var kc = this.tileType.getParentTile(e, kl, kj, kk, T);
        if (kc === null) {
          continue;
        }
        var km = this.getTileKey(kc);
        var kg = this.tileCache.getData(km);
        if (kg && kg.status === "ready") {
          if (this.thumbCache[km]) {
            continue;
          }
          kg.key = km;
          this.setData(kg, 0);
          this.thumbCache[km] = true;
          return true;
        }
        e = kc.col;
        kl = kc.row;
        kj = kc.zoom;
        kk = kc.useZoom;
      }
      return false;
    },
    _findChildZoomTile: function (kg, ki, e, kd, kr) {
      var kp = "web";
      var kl = 21;
      var kf = kg;
      var kh = ki;
      var kj = e;
      var kc = kd;
      var ke = true;
      for (var ko = 1; ko <= kr; ko++) {
        var km = false;
        var T = this.tileType.getChildTiles(kf, kh, kj, kc, kl, ko);
        if (!T) {
          continue;
        }
        for (var kn = 0; kn < T.length; kn++) {
          var kk = this.getTileKey(T[kn]);
          var kq = this.tileCache.getData(kk);
          if (kq && kq.status === "ready") {
            if (!this.thumbCache[kk]) {
              kq.key = kk;
              this.setData(kq, 1);
              this.thumbCache[kk] = true;
            }
            km = true;
          } else {
            ke = false;
          }
        }
        if (km) {
          break;
        }
      }
      return ke;
    },
    sortThumbData: function () {
      var e = this._featureMgr;
      if (!e) {
        return;
      }
      if (e[0] && e[0].length > 0) {
        e[0].sort(function (T, i) {
          return T.tileInfo.useZoom - i.tileInfo.useZoom;
        });
      }
    }
  });
  function dx(T, i) {
    aR.call(this, i);
    if (!bR(T)) {
      throw new Error("createDOM参数类型错误，请检查是否为Function");
    }
    var e = i || {};
    this.config = {};
    this.config.enableMassClear = false;
    this.config.minZoom = e.minZoom || 3;
    this.config.maxZoom = e.maxZoom || 21;
    this.config.offsetX = e.offsetX || 0;
    this.config.offsetY = e.offsetY || 0;
    this.config.coordinate = e.coordinate || "BD09";
    this.config.enableDraggingMap = e.enableDraggingMap || false;
    this.createDOM = T;
    this.data = e.data || null;
    this.overlaysList = [];
  }
  dx.inherits(c8, "CustomHtmlLayer");
  eX.extend(dx.prototype, {
    initialize: function (i) {
      this.map = i;
      var e = this;
      this._zoomShowEvent = function (kc) {
        var T = e.map.getZoom();
        if (T < e.config.minZoom || T > e.config.maxZoom) {
          e.hide();
        } else {
          e.show();
        }
      };
      this.addToMap();
      this.initEvent(i);
    },
    initEvent: function () {
      if (!this.overlaysList || !this.map) {
        return;
      }
      var e = this;
      this.map.addEventListener("zoomend", e._zoomShowEvent);
      this.map.on("destory", function () {
        e._distory();
      });
    },
    addEventListener: function (kc, ke) {
      if (!this.overlaysList || !this.map) {
        return;
      }
      var kd = this.overlaysList;
      var e = this.overlaysList.length;
      for (var T = 0; T < e; T++) {
        kd[T].addEventListener(kc, ke);
      }
    },
    show: function () {
      if (!this.overlaysList) {
        return;
      }
      var e = this.overlaysList.length;
      if (e > 0) {
        for (var T = 0; T < e; T++) {
          this.overlaysList[T].show();
        }
      }
    },
    hide: function () {
      if (!this.overlaysList) {
        return;
      }
      var e = this.overlaysList.length;
      if (e > 0) {
        for (var T = 0; T < e; T++) {
          this.overlaysList[T].hide();
        }
      }
    },
    addToMap: function () {
      if (!this.overlaysList || !this.map) {
        return;
      }
      var e = this.overlaysList.length;
      var kc = this.overlaysList;
      if (e > 0) {
        for (var T = 0; T < e; T++) {
          this.map.addOverlay(kc[T]);
        }
      }
    },
    render: function (i) {
      this.config.enableMassClear = false;
      this.config.point = i.points;
      this.config.properties = i.properties;
      var e = new bL(this.createDOM, this.config);
      return e;
    },
    setData: function (e) {
      var kc = this;
      if (this.map && (this.map.getZoom() < this.config.minZoom || this.map.getZoom() > this.config.maxZoom)) {
        return;
      }
      this.data = e;
      var T = gw.getType(e);
      if (T.toLowerCase() === "point") {
        var i = new gw({
          reference: this.config.coordinate
        });
        i.readFeaturesFromObject(e, {
          isPoints: true
        }, function (ke) {
          var kd = kc.render(ke);
          kd.id = "cus_" + parseInt(Math.random() * 1000000, 10);
          kc.overlaysList.push(kd);
        });
        i = null;
      }
    },
    updateData: function (e) {
      this.removeAllOverlays();
      this.data = null;
      this.overlaysList = [];
      this.setData(e);
      this.addToMap();
      this.initEvent();
    },
    removeLayer: function (T) {
      if (!(T instanceof dx) || !this.map) {
        return;
      }
      var kc = T.overlaysList;
      for (var e = 0; e < kc.length; e++) {
        this.map.removeOverlay(kc[e]);
      }
      this._distory(T);
    },
    removeAllOverlays: function () {
      if (!this.map || !this.overlaysList) {
        return;
      }
      var T = this.overlaysList;
      for (var e = 0; e < T.length; e++) {
        this.map.removeOverlay(T[e]);
      }
    },
    removeOverlay: function (T) {
      if (!this.map || !this.overlaysList || this.overlaysList.length <= 0) {
        return;
      }
      var e = this.overlaysList.length;
      var kd = this.overlaysList;
      if (typeof T === "string") {
        for (var kc = 0; kc < e; kc++) {
          if (kd[kc].id === T) {
            this.map.removeOverlay(kd[kc]);
            kd.splice(kc, 1);
          }
        }
      } else if (T instanceof aR) {
        for (var kc = 0; kc < e; kc++) {
          if (T === kd[kc]) {
            this.map.removeOverlay(T);
            this.overlaysList.splice(kc, 1);
            return;
          }
        }
      }
    },
    _distory: function () {
      this.map.removeEventListener("zoomend", this._zoomShowEvent);
      var T = this.overlaysList;
      for (var e = 0; e < T.length; e++) {
        T[e].div = null;
      }
      this.overlaysList = [];
      this.createDOM = null;
      this.config = null;
      this.data = null;
    },
    getCustomOverlays: function () {
      return this.overlaysList;
    },
    toString: function () {
      return "CustomHtmlLayer";
    }
  });
  function cm(e) {
    e = e || {};
    this.visible = e.visible === undefined ? true : !!e.visible;
    this.minZoom = e.minZoom || 3;
    this.maxZoom = e.maxZoom || 21;
    this.opacity = isNaN(Number(e.opacity)) ? 1 : Math.max(0, Math.min(1, Number(e.opacity)));
    this.zIndex = e.zIndex || 1;
    this.enablePicked = e.enablePicked || false;
    this.autoSelect = e.autoSelect || false;
    this.popEvent = e.popEvent || true;
    this.autoUpdate = false;
    this.pickWidth = e.pickWidth || 30;
    this.pickHeight = e.pickHeight || 30;
  }
  cm.inherits(c8, "NormalLayer");
  eX.extend(cm.prototype, {
    onInit: function (kc, kd) {
      if (this.zIndex > 0) {
        this.adjustZIndex(kc);
        kc._normalLayerMgr.sortLayer();
      } else {
        var e = kc._featureMgr.result.bkData;
        this.zIndex = e.length || 1;
      }
      var T = {
        tileTypeName: this.getType ? this.getType() : "custom",
        dataType: this.toString(),
        ontology: this
      };
      kc._featureMgr.createLayer(this.zIndex, T);
      this.map = kc;
      this.gl = kd;
      this.onAdd(kc, kd);
      var i = this;
      kc.on("destroy", function () {
        i.onDestroy();
      });
    },
    adjustZIndex: function (i) {
      if (i && i._featureMgr) {
        var e = i._featureMgr.result.bkData;
        while (e[this.zIndex]) {
          this.zIndex += 1;
        }
      }
    },
    _getAdjoinZIndex: function (kd) {
      var T = this.zIndex;
      if (this.map && this.map._featureMgr) {
        var e = this.map._featureMgr.result.bkData;
        if (kd === "up") {
          for (var kc = this.zIndex + 1; kc < e.length; kc++) {
            if (e[kc]) {
              T = kc + 1;
              break;
            }
          }
        } else {
          for (var kc = this.zIndex - 1; kc > 0; kc--) {
            if (e[kc]) {
              T = kc;
              break;
            }
          }
        }
      }
      return T;
    },
    setTargetZIndex: function (e) {
      this.zIndex = e;
      if (this.map) {
        this.map._normalLayerMgr.sortLayer();
      }
    },
    setZIndex: function (kg) {
      kg = Math.abs(Math.floor(kg)) || 1;
      if (!kg || kg === this.zIndex) {
        return;
      }
      var kd = this.map._featureMgr.result.bkData;
      var kc = this.map.tileMgr.tileLayers;
      var ki = this.map._normalLayerMgr.layers;
      function kj(ko) {
        var km = null;
        var kn = [kc, ki];
        for (var kk = 0; kk < kn.length; kk++) {
          for (var kl = 0; kl < kn[kk].length; kl++) {
            if (kn[kk][kl].zIndex === ko) {
              km = kn[kk][kl];
              break;
            }
          }
          if (km) {
            break;
          }
        }
        return km;
      }
      var T = [];
      var kf = [];
      var kh = this.zIndex;
      var i = kj(kg);
      if (kd[kg] && i) {
        T.push(i);
        kf.push(kd[kg]);
        this.setTargetZIndex(kg);
        kd[kg] = kd[kh];
        kd[kh] = null;
      } else {
        this.setTargetZIndex(kg);
        kd[kg] = kd[kh];
        kd[kh] = null;
        this.doOnceDraw();
        return;
      }
      var ke = kg + 1;
      while (ke) {
        var e = kj(ke);
        if (kd[ke] && e) {
          T.push(e);
          kf.push(kd[ke]);
          T.shift().setTargetZIndex(ke);
          kd[ke] = kf.shift();
          ke += 1;
        } else {
          T.shift().setTargetZIndex(ke);
          kd[ke] = kf.shift();
          ke = 0;
        }
      }
      this.doOnceDraw();
    },
    setOpacity: function (e) {
      if (isNaN(Number(e))) {
        return;
      }
      this.opacity = Math.max(0, Math.min(1, Number(e)));
      this.doOnceDraw();
    },
    getOpacity: function () {
      return this.opacity;
    },
    setZIndexTop: function () {
      var e = this.map._featureMgr.result.bkData;
      e[e.length] = e[this.zIndex];
      e[this.zIndex] = null;
      this.setTargetZIndex(e.length - 1);
      this.doOnceDraw();
    },
    setUpLevel: function () {
      var e = this._getAdjoinZIndex("up");
      if (this.zIndex !== e) {
        this.setZIndex(e);
      }
    },
    setDownLevel: function () {
      var e = this._getAdjoinZIndex("down");
      if (this.zIndex !== e) {
        this.setZIndex(e);
      }
    },
    onAdd: function (e, i) {
      throw new Error("用户未实现onAdd方法");
    },
    preRender: function (i, e) {},
    rgbToIndex: function (kd) {
      var kg = kd.length / 4;
      var kc = Math.floor(kg / 2);
      const T = function (ki) {
        return kd[ki] + kd[ki + 1] * 256 + kd[ki + 2] * 65536 - 1;
      };
      for (var kf = 0;; kf++) {
        var ke = kc + kf;
        var kh = kc - kf;
        if (ke === kh) {
          var e = T(ke * 4);
          if (e > -1) {
            return e;
          }
          continue;
        }
        if (ke < kg) {
          var e = T(ke * 4);
          if (e > -1) {
            return e;
          }
        }
        if (kh >= 0) {
          var e = T(kh * 4);
          if (e > -1) {
            return e;
          }
        }
        if (ke >= kg && kh < 0) {
          break;
        }
      }
      return -1;
    },
    pick: function (kg, kf, kc) {
      var T = this.gl;
      var kh = this.map.config.ratio;
      this.map._normalLayerMgr.saveFramebuffer();
      this.map._normalLayerMgr.bindFramebuffer(this.map._normalLayerMgr.pickFBO);
      this.map._normalLayerMgr.clear();
      var i = this.map._webglPainter._camera._modelViewMatrixLayer;
      var ke = mat4.create(Float64Array);
      mat4.multiply(ke, this.map._webglPainter.projMatrix, i);
      this.render(T, ke, {
        isPickRender: true
      });
      var e = new Uint8Array(4 * this.pickWidth * this.pickHeight);
      T.readPixels(kg * kh - Math.floor(this.pickWidth / 2), T.canvas.height - kf * kh - Math.floor(this.pickHeight / 2), this.pickWidth, this.pickHeight, T.RGBA, T.UNSIGNED_BYTE, e);
      var kd = this.rgbToIndex(e);
      if (this.getPickedItem) {
        var ki = this.getPickedItem(kd, kc);
      }
      this.map._normalLayerMgr.restoreFramebuffer();
      return ki;
    },
    render: function (T, e, i) {
      throw new Error("用户未实现render方法");
    },
    afterRender: function (i, e) {},
    onDestroy: function (e, i) {},
    onHide: function (e, i) {},
    onShow: function (e, i) {},
    doOnceDraw: function () {
      if (this.map) {
        var e = new fJ("onupdate");
        this.map.dispatchEvent(e);
      }
    },
    doRender: function () {
      var e = this.map.getZoom();
      if (this.visible) {
        if (e >= this.minZoom && e <= this.maxZoom) {
          if (!this._status) {
            this.onShow(this.map, this.gl);
            this._status = 1;
          }
          return true;
        }
      }
      if (this._status) {
        this.onHide(this.map, this.gl);
        this._status = 0;
      }
      return false;
    },
    getZIndex: function () {
      if (this.zIndex === undefined) {
        throw new Error("图层未添加到地图");
      }
    },
    getVisible: function () {
      return this.visible;
    },
    setVisible: function (e) {
      this.visible = e;
      this.doOnceDraw();
    },
    getMinZoom: function () {
      return this.minZoom;
    },
    setMinZoom: function (e) {
      if (e <= this.maxZoom) {
        this.minZoom = e;
      }
    },
    getMaxZoom: function () {
      return this.maxZoom;
    },
    setMaxZoom: function (e) {
      if (e >= this.minZoom) {
        this.maxZoom = e;
      }
    },
    dispatcher: function (kd, kc, T) {
      var i = new fJ(T);
      i.pixel = kd.pixel;
      i.latLng = kd.latlng;
      i.value = kc;
      this.dispatchEvent(i);
    },
    hasEvent: function (e) {
      if (this.enablePicked) {
        if (e.substr(0, 2) !== "on") {
          e += "on";
        }
        if (this._listeners && this._listeners[e] && Object.keys(this._listeners[e]).length > 0) {
          return true;
        }
        return false;
      }
      return false;
    },
    toString: function () {
      return "normal";
    }
  });
  function d1(e) {
    e = e || {};
    cm.call(this, e);
    this.base_opt = {
      idKey: "id",
      crs: "BD09LL",
      isFlat: true,
      drawPart: 1,
      selectedIndex: -1,
      selectedColor: "rgba(20, 20, 200, 1.0)"
    };
    this.setBaseOptions(e);
    this.loadModule = false;
    this._stateCube = {};
    this.def = [];
    this.DEL_COUNT = 100;
    this.delIndexs = [];
    var i = this;
    g2.load("mvtParse", function () {
      i._async();
    }, true);
    this.select_color = this.getColorStyleForGL(this.base_opt.selectedColor);
  }
  d1.inherits(cm, "FeatureLayer");
  eX.extend(d1.prototype, {
    _async: function () {
      this.loadModule = true;
      this.resolveStyle();
      this.parseData();
    },
    compileExpress: function (i, e) {
      var i = d8.ExpressParse.normalizePropertyExpression(i, e);
      return i;
    },
    resolveStyle: function () {
      var e = this.style_opt || {};
      if (e && this.type && cZ[this.type]) {
        var T = {};
        for (var i in e) {
          var kd = cZ[this.type][i];
          if (e.hasOwnProperty(i) && kd !== undefined) {
            var kc = this.compileExpress(e[i], kd);
            T[i] = kc;
          }
        }
        this.styleExpress = T;
      }
    },
    evaluateContext: function (e, T) {
      var i = T.id || e;
      var kc = this._stateCube[i];
      return {
        properties: function () {
          return T && T.properties;
        },
        featureState: kc || {}
      };
    },
    evaluates: function (i, kc) {
      if (!this.styleExpress) {
        return null;
      }
      var ke = this.styleExpress;
      var e = {};
      for (var T in ke) {
        if (ke.hasOwnProperty(T)) {
          var kd = ke[T].evaluate(this.evaluateContext(i, kc));
          e[T] = kd;
        }
      }
      return e;
    },
    _updateState: function (T, i, e) {
      if (e) {
        this._set(i, this._stateCube, T);
      } else {
        this._stateCube[T] = i;
      }
    },
    _set: function (i, kd, T) {
      var kc = kd[T] || (kd[T] = {});
      for (var e in i) {
        kc[e] = i[e];
      }
    },
    updateState: function (kd, ke, e) {
      var T = JSON.stringify(this._stateCube);
      if (!(ke && typeof ke === "object" && Object.keys(ke).length > 0)) {
        return;
      }
      if (!e) {
        this._stateCube = {};
      }
      if (kd instanceof Array) {
        for (var kc = 0; kc < kd.length; kc++) {
          this._updateState(kd[kc], ke, e);
        }
      } else {
        this._updateState(kd, ke, e);
      }
      var kf = JSON.stringify(this._stateCube);
      if (T !== kf) {
        this.parseData();
      }
      if (this.attach) {
        this.attach.updateState(kd, ke, e);
      }
    },
    replaceAllState: function (e) {
      var i = JSON.stringify(this._stateCube);
      this._stateCube = e;
      var T = JSON.stringify(this._stateCube);
      if (i !== T) {
        this.parseData();
      }
    },
    getAllState: function () {
      return this._stateCube;
    },
    removeState: function (kc) {
      var e = JSON.stringify(this._stateCube);
      if (kc instanceof Array) {
        for (var T = 0; T < kc.length; T++) {
          delete this._stateCube[kc[T]];
        }
      } else {
        delete this._stateCube[kc];
      }
      var kd = JSON.stringify(this._stateCube);
      if (e !== kd) {
        this.parseData();
      }
    },
    clearState: function () {
      var e = JSON.stringify(this._stateCube);
      if (e !== "{}") {
        this._stateCube = {};
        this.parseData();
      }
    },
    getType: function () {
      return "feature";
    },
    setData: function (e, i) {
      i = i || {};
      this.data = e;
      this.delIndexs = [];
      this._stateCube = {};
      if (this.parseData) {
        this.parseData();
      }
    },
    getData: function () {
      return this.data;
    },
    addDelIndex: function (T) {
      if (this.delIndexs.length >= this.DEL_COUNT) {
        new Error("超出" + this.DEL_COUNT + "个限制");
      }
      var e = false;
      for (var kc = 0; kc < this.delIndexs.length; kc++) {
        if (this.delIndexs[kc] === T) {
          e = true;
          break;
        }
      }
      if (!e) {
        this.delIndexs.push(T);
        this.doOnceDraw();
      }
      if (this.attach) {
        this.attach.addDelIndex(T);
      }
    },
    removeDelIndex: function (e) {
      for (var T = 0; T < this.delIndexs.length; T++) {
        if (this.delIndexs[T] === e) {
          this.delIndexs.splice(T, 1);
          this.doOnceDraw();
          return;
        }
      }
      if (this.attach) {
        this.attach.removeDelIndex(e);
      }
    },
    clearDelIndex: function () {
      this.delIndexs = [];
      this.doOnceDraw();
      if (this.attach) {
        this.attach.clearDelIndex();
      }
    },
    setBaseOptions: function (i) {
      i = i || {};
      var e = Object.assign({}, this.getBaseOptions());
      Object.assign(this.base_opt, i);
      if (this.onOptionsChanged) {
        this.onOptionsChanged(this.getBaseOptions(), e);
      }
      if (i.data) {
        this.setData(i.data);
        delete i.data;
      }
    },
    setStyleOptions: function (i) {
      i = i || {};
      var e = Object.assign({}, this.getStyleOptions());
      Object.assign(this.style_opt, i);
      if (this.onOptionsChanged) {
        this.onOptionsChanged(this.getStyleOptions(), e);
      }
      if (i.data) {
        this.setData(i.data);
        delete i.data;
      } else if (i.autoRender !== false) {}
    },
    getBaseOptions: function () {
      return this.base_opt || {};
    },
    getStyleOptions: function () {
      return this.style_opt || {};
    },
    getProperty: function (e, kc, T) {
      if (Object.prototype.toString.call(kc) === "[object Function]") {
        return kc(T);
      } else {
        var i = T[e] || kc;
        if ("properties" in T && e in T.properties) {
          i = T.properties[e];
        }
        return i;
      }
    },
    getPickedItem: function (i, e) {
      if (this.autoSelect) {
        if (e === "onmousemove") {
          this.selectedIndex = i;
        } else {
          this.selectedIndex = -1;
        }
      }
      if (e === "onclick" && this.enablePicked) {
        this.selectedIndex = i;
      }
      var T = this.dataset ? this.dataset.normal : [];
      return {
        dataIndex: i,
        dataItem: T[i]
      };
    },
    formatData: function (i) {
      var e = new gw({
        reference: this.base_opt.crs
      });
      var T = e.readFeaturesFromObject(i, {
        isPoints: true
      });
      return {
        normal: i.features,
        inner: T
      };
    },
    getColorStyleForGL: function (kc, e, T) {
      var i = hB.formatColorCssToRgbaArray(kc, e, T);
      return i;
    },
    _toFormatPolGeometry: function (kd, e) {
      var kc = [];
      if (!e) {
        kc[0] = this._toFormatCoords(kd);
      } else {
        for (var T = 0; T < kd.length; T++) {
          kc.push(this._toFormatCoords(kd[T]));
        }
      }
      return kc;
    },
    _toFormatCoords: function (ki) {
      var kh = [];
      var ke = [];
      kh.pointsArray = ke;
      var kj = i9.convertLL2MC(ki[0]);
      var e = this.map._normalLayerMgr.base;
      var kg = [kj.lng - e.lng, kj.lat - e.lat];
      kh.push(kg);
      ke.push(kg[0], kg[1]);
      for (var kd = 1, kc = 1, T = ki.length; kd < T; kd++) {
        kj = i9.convertLL2MC(ki[kd]);
        var kf = [kj.lng - e.lng, kj.lat - e.lat];
        if (kf[0] !== kh[kc - 1][0] || kf[1] !== kh[kc - 1][1]) {
          kh.push(kf);
          ke.push(kf[0], kf[1]);
          kc++;
        }
      }
      return kh;
    },
    onDestroy: function () {
      this.data = null;
      this._stateCube = {};
      this.delIndexs.length = 0;
    },
    toString: function () {
      return "FeatureLayer";
    }
  });
  function bS(e) {
    e = e || {};
    this.type = "polyline";
    this.style_opt = {
      sequence: false,
      marginLength: 16,
      traceControl: null,
      traceColor: [],
      traceDisappear: false,
      linksLine: false,
      strokeColorControl: null,
      strokeColor: "rgba(25, 25, 250, 1)",
      strokeWeight: 2,
      borderCovered: true,
      borderColor: "rgba(27, 142, 236, 1)",
      borderWeight: 0,
      borderMask: true,
      strokeOpacity: 1,
      strokeLineJoin: "round",
      strokeLineCap: "square",
      strokeTextureUrl: "",
      strokeTextureWidth: 16,
      strokeTextureHeight: 16,
      strokeStyle: "solid",
      dashArray: [8, 4]
    };
    this.setStyleOptions(e.style || {});
    this._bufferArray = [];
    this._texture = {};
    d1.call(this, e);
  }
  bS.inherits(d1, "LineLayer");
  eX.extend(bS.prototype, {
    onAdd: function (e, i) {
      if (!this.map) {
        this.map = e;
        this.gl = i;
      }
      if (!this.buffer) {
        this.parseData();
      }
    },
    parseData: function () {
      if (!this.loadModule || !this.styleExpress || !this.map || !this.map._normalLayerMgr) {
        return;
      }
      var i = this.getData();
      if (!i) {
        return;
      }
      var T = this.dataset = this.formatData(i);
      this.dispatchEvent(new fJ("ondataparsed"));
      var e = this.linesParse(T.inner);
      this.lines = this.combineLine(e);
      this.buffer = this.createBufferData(this.lines);
      this.doOnceDraw();
    },
    linesParse: function (kn) {
      var kf = [[], []];
      var kd = 0;
      var kj = -1;
      for (var kr = 0; kr < kn.length; kr++) {
        var kt = kn[kr].points;
        var ke = false;
        if (!(kt[0] instanceof cx)) {
          ke = true;
        }
        var kh = kn[kr].properties || {};
        var kc = kh.hasOwnProperty(this.base_opt.idKey) ? kh[this.base_opt.idKey] : false;
        var kg = kr;
        var kl = -1;
        if (kn[kr].index !== undefined) {
          kg = kn[kr].index;
        }
        if (kn[kr].brotherIndex !== undefined) {
          kl = kn[kr].brotherIndex;
        }
        if (kj !== kg) {
          kj = kg;
          kd = 0;
        }
        var ks = this.evaluates(kg, {
          properties: kh,
          id: kc
        });
        ks = Object.assign(JSON.parse(JSON.stringify(cs[this.type])), ks || {});
        if (ks.borderWeight !== 0) {
          var e = this.getColorStyleForGL(ks.borderColor, undefined, false);
          if (ks.borderWeight < 0) {
            this.style_opt.borderMask = false;
          }
          var ki = ks.strokeWeight / 2 + ks.borderWeight;
          if (ki > 0) {
            var kq = this.buildLineVertex(ks, kn[kr], ke, ki, e, kd);
            kf[0][kf[0].length] = {
              index: kg,
              styleData: kq,
              textureKey: -1,
              texture: null,
              textureSize: null,
              zoomWithMap: true,
              overlay: {
                _config: {
                  textureRepeat: true
                },
                _totalDashLen: null
              }
            };
          }
        }
        var ko = ks.strokeWeight / 2;
        var kp = this.getColorStyleForGL(ks.strokeColor, ks.strokeOpacity, false);
        if (kl > -1 && this.style_opt.linksLine && this.style_opt.strokeColorControl instanceof Function) {
          var kk = this.style_opt.strokeColorControl(kg, kl);
          kp = this.getColorStyleForGL(kk, undefined, false);
        }
        var kq = this.buildLineVertex(ks, kn[kr], ke, ko, kp, kd);
        var kk = this._generateTexture(ks) || {};
        var km = kk.value || null;
        var T = {
          index: kg,
          styleData: kq,
          textureKey: kk.key || -1,
          texture: km ? km.texture : null,
          textureSize: km ? km.textureSize : null,
          zoomWithMap: true,
          overlay: {
            _config: {
              textureRepeat: true
            },
            _totalDashLen: km ? km.totalDashLen : null
          }
        };
        if (this.style_opt.borderCovered) {
          kf[1][kf[1].length] = T;
        } else {
          kf[0][kf[0].length] = T;
        }
        if (kq[0] && kq[0][0] instanceof Array) {
          kd = kq[0][0][kq[0][0].length - 1] / 10 || 0;
        }
      }
      return kf;
    },
    combineLine: function (ke) {
      var e = [];
      for (var T = 0; T < ke.length; T++) {
        var kd = {};
        var kf = ke[T];
        for (var kc = 0; kc < kf.length; kc++) {
          if (!kd[kf[kc].textureKey]) {
            kd[kf[kc].textureKey] = [{
              style: [],
              styleData: [[], []],
              index: []
            }];
          }
          this._mergeOnePolylineData(kd[kf[kc].textureKey], kf[kc]);
        }
        e.push(kd);
      }
      return e;
    },
    _mergeOnePolylineData: function (e, kn) {
      var kl = e.length - 1;
      var kd = e[kl];
      var i = e[kl].styleData[0];
      var ki = e[kl].styleData[1];
      var kj = 10;
      for (var kc = 0; kc < kn.styleData.length; kc++) {
        var T = kn.styleData[kc];
        var km = T[0];
        var kf = T[1];
        var kh = i.length / kj;
        var kk = km.length / (kj - 1);
        if (kh + kk > 65536) {
          kl++;
          kd = e[kl] = {
            style: [],
            styleData: [[], []],
            index: [],
            texture: null,
            textureSize: null,
            zoomWithMap: null,
            overlay: null
          };
          i = kd.styleData[0];
          ki = kd.styleData[1];
          kh = 0;
        }
        if (kd.styleData[0].length === 0) {
          kd.texture = kn.texture;
          kd.textureSize = kn.textureSize;
          kd.zoomWithMap = kn.zoomWithMap;
          kd.overlay = kn.overlay;
        }
        kd.index[kd.index.length] = kn.index;
        for (var kg = 0; kg < kk; kg++) {
          i[i.length] = km[kg * (kj - 1)];
          i[i.length] = km[kg * (kj - 1) + 1];
          i[i.length] = km[kg * (kj - 1) + 2];
          i[i.length] = km[kg * (kj - 1) + 3];
          i[i.length] = km[kg * (kj - 1) + 4];
          i[i.length] = km[kg * (kj - 1) + 5];
          i[i.length] = km[kg * (kj - 1) + 6];
          i[i.length] = km[kg * (kj - 1) + 7];
          i[i.length] = km[kg * (kj - 1) + 8];
          i[i.length] = kn.index;
        }
        for (var ke = 0; ke < kf.length; ke++) {
          ki[ki.length] = kf[ke] + kh;
        }
      }
    },
    buildLineVertex: function (T, kp, kc, kd, kg, kf) {
      var ki = [];
      var km = [];
      var ko = [];
      var kj = kp.points;
      var kn = T.strokeLineCap;
      var e = T.strokeLineJoin;
      var ke = iz.JOININDEX[e];
      var kl = iz.CAPINDEX[kn];
      var kk = this._toFormatPolGeometry(kj, kc);
      for (var kh = 0; kh < kk.length; kh++) {
        if (kk[kh].length < 2) {
          continue;
        }
        if (ki.length / 6 + gm.getVertexCount(kk[kh].length) > 65536) {
          ko.push([ki, km]);
          ki = [];
          km = [];
        }
        gm.buildData(kk[kh], ke, kl, ki, km, kg, kd, undefined, kf);
      }
      ko.push([ki, km]);
      return ko;
    },
    createBuffer: function (i) {
      var T = 13;
      var e = [{
        name: "a_pos",
        components: 2,
        offset: 0,
        type: "Float32"
      }, {
        name: "a_normal",
        components: 2,
        offset: 8,
        type: "Float32"
      }, {
        name: "a_color",
        components: 4,
        offset: 16,
        type: "Uint8",
        normalize: true
      }, {
        name: "a_data",
        components: 4,
        offset: 20,
        type: "Float32"
      }, {
        name: "a_id",
        components: 1,
        offset: 36,
        type: "Float32"
      }];
      return new w(i, {
        components: T,
        members: e
      }, w.BufferType.VERTEX);
    },
    createBufferData: function (kl) {
      var ki = [];
      var kj = 0;
      for (var kf = 0; kf < kl.length; kf++) {
        var km = kl[kf];
        var kk = [];
        for (var ko in km) {
          if (!km.hasOwnProperty(ko)) {
            continue;
          }
          var kh = km[ko];
          for (var kg = 0; kg < kh.length; kg++) {
            var kd = kh[kg].styleData[0];
            var ke = kh[kg].styleData[1];
            if (!kd || !kd.length) {
              continue;
            }
            if (!this._bufferArray[kk.length + kj]) {
              this._bufferArray[kk.length + kj] = {
                vertex: null,
                element1: null,
                vao1: null
              };
            }
            var kn = this._bufferArray[kk.length + kj];
            kn.textureKey = ko;
            kn.index = kh[kg].index;
            if (!kn.vertex) {
              var kc = new Float32Array(kd.length);
              kc.set(kd);
              kn.vertex = this.createBuffer(kc);
            }
            var T = new Uint16Array(ke.length);
            T.set(ke);
            if (!kn.element1) {
              kn.element1 = new w(T, {
                components: 1
              }, w.BufferType.ELEMENT, ke.length);
            }
            if (!kn.vao1) {
              kn.vao1 = new dO();
            }
            var e = new Float32Array(kd);
            e.set(kd);
            kn.vao1.update(this.gl, kn.vertex, e, kd.length, kn.element1, T, ke.length);
            kk.push(kn);
          }
        }
        kj += kk.length;
        ki.push(kk);
      }
      return ki;
    },
    _generateTexture: function (kc) {
      if (kc.strokeTextureUrl) {
        var kd = kc.strokeTextureUrl + "_" + kc.strokeWeight;
        if (this._texture[kd]) {
          return {
            key: kd,
            value: this._texture[kd]
          };
        }
        var kf = kc.strokeTextureUrl;
        var ke = kc.strokeTextureWidth || 16;
        var i = kc.strokeTextureHeight || 16;
        var kg = kc.strokeWeight * Math.round(i / ke);
        var e = {
          totalDashLen: kg,
          texture: kf,
          textureSize: [ke, i]
        };
        this._texture[kd] = e;
        return {
          key: kd,
          value: e
        };
      }
      if (kc.strokeStyle === "dashed" || kc.strokeStyle === "dotted") {
        var kd = [kc.strokeStyle, kc.strokeWeight, kc.strokeColor, kc.strokeOpacity, kc.dashArray.join(",")];
        kd = kd.join("-");
        if (this._texture[kd]) {
          return {
            key: kd,
            value: this._texture[kd]
          };
        }
        kc.sync = true;
        var T = this;
        d8._generateTexture(null, kc, function (ki, kh) {
          T._texture[kd] = kh;
        });
        return {
          key: kd,
          value: this._texture[kd]
        };
      }
      return null;
    },
    preRender: function (T, i, e) {},
    render: function (kf, kc, ke) {
      if (!this.buffer) {
        return;
      }
      ke = ke || {};
      this.pickModel = ke.isPickRender || false;
      var T = this.map._webglPainter;
      var e = T._state;
      if (this.buffer[0].length > 0) {
        if (this.style_opt.borderMask && this.style_opt.borderCovered) {
          kf.clear(kf.STENCIL_BUFFER_BIT);
          kf.stencilFunc(kf.ALWAYS, 1, 255);
          e.stencilOp(kf.KEEP, kf.KEEP, kf.REPLACE);
          kf.stencilMask(255);
          e.colorMask(false, false, false, false);
          for (var kd = 0; kd < this.buffer[1].length; kd++) {
            this.drawLine(T, this.buffer[1][kd], true);
          }
          kf.stencilFunc(kf.NOTEQUAL, 1, 255);
          kf.stencilMask(0);
          e.stencilOp(kf.KEEP, kf.KEEP, kf.KEEP);
          e.colorMask(true, true, true, true);
          for (var kd = 0; kd < this.buffer[0].length; kd++) {
            this.drawLine(T, this.buffer[0][kd], false);
          }
          kf.clear(kf.STENCIL_BUFFER_BIT);
          kf.stencilMask(255);
          kf.stencilFunc(kf.ALWAYS, 1, 255);
          for (var kd = 0; kd < this.buffer[1].length; kd++) {
            this.drawLine(T, this.buffer[1][kd], false, true);
          }
          return;
        } else {
          for (var kd = 0; kd < this.buffer[0].length; kd++) {
            this.drawLine(T, this.buffer[0][kd], false);
          }
        }
      }
      for (var kd = 0; kd < this.buffer[1].length; kd++) {
        this.drawLine(T, this.buffer[1][kd], false);
      }
    },
    traceControl: function (i) {
      if (this.style_opt.traceControl instanceof Function) {
        var e = this.style_opt.traceControl(i);
        if (e instanceof Array && e.length === i.length) {
          return e;
        }
      }
      return [];
    },
    _formatArrayBuffer: function (kc, i) {
      var e;
      if (i) {
        e = new Int32Array(this.DEL_COUNT);
      } else {
        e = new Int16Array(this.DEL_COUNT);
      }
      if (kc.length) {
        var T = 0;
        for (; T < kc.length && T < this.DEL_COUNT; T++) {
          e[T] = parseInt(kc[T]);
        }
        if (T < this.DEL_COUNT) {
          e[T] = -1;
        }
      } else {
        e[0] = -1;
      }
      return e;
    },
    drawLine: function (kw, kp, kt, ky) {
      if (kp.element1 && kp.element1.length === 0) {
        return;
      }
      var ku = kw.gl;
      var ke = kw.programMgr.useProgram("linelayer", {
        def: this.def
      });
      var kj = this._texture[kp.textureKey];
      var kk = null;
      var kx = 0;
      var km = this.map.getZoom();
      var kl = this;
      if (kj) {
        var kn = kj.texture;
        if (kn instanceof HTMLCanvasElement || window.ImageBitmap && kn instanceof window.ImageBitmap) {
          if (!kj.glTexture) {
            kj.glTexture = dS.utils.createTexture(ku, kn, {
              flipY: false,
              wrap: ku.REPEAT,
              mipmap: true,
              unpackAlpha: true
            });
          }
          kk = kj.glTexture;
        } else {
          if (!kj.glTexture) {
            kj.glTexture = {
              status: "init"
            };
            var kA = new Image();
            kA.crossOrigin = "anonymous";
            kA.onload = function () {
              kj.glTexture.texture = dS.utils.createTexture(ku, this, {
                flipY: false,
                wrap: ku.REPEAT,
                mipmap: true,
                unpackAlpha: true
              });
              kj.glTexture.status = "done";
              kl.doOnceDraw();
            };
            kA.src = kn;
          }
          if (kj.glTexture.status !== "done") {
            return;
          }
          kk = kj.glTexture.texture;
        }
        kw._state.activeTexture(ku.TEXTURE4);
        ku.bindTexture(ku.TEXTURE_2D, kk);
        if (ke.uniforms.lastSampler !== 4) {
          ku.uniform1i(ke.uniforms.u_image, 4);
          ke.uniforms.lastSampler = 4;
        }
        kx = kj.totalDashLen;
      }
      var kc = this.opacity;
      if (ke.lastState.opacity !== kc) {
        ku.uniform1f(ke.uniforms.u_opacity, kc);
        ke.lastState.opacity = kc;
      }
      var kf = this.style_opt.sequence;
      if (ke.lastState.sequence !== kf) {
        ku.uniform1i(ke.uniforms.u_sequence, kf);
        ke.lastState.sequence = kf;
      }
      var T = this.style_opt.marginLength;
      if (ke.lastState.marginLength !== T) {
        ku.uniform1f(ke.uniforms.u_margin_length, T);
        ke.lastState.marginLength = T;
      }
      if (ke.lastState.dash !== kx) {
        ku.uniform1f(ke.uniforms.u_dash_length, kx);
        ke.lastState.dash = kx;
      }
      if (ke.lastState.mapZoom !== km) {
        ku.uniform1f(ke.uniforms.u_map_zoom, km);
        ke.lastState.mapZoom = km;
      }
      var kq = kw._camera._modelViewMatrixLayer;
      if (!ke.lastState.projMatrix) {
        ku.uniformMatrix4fv(ke.uniforms.u_proj_matrix, false, kw.projMatrix);
        ke.lastState.projMatrix = true;
      }
      ku.uniformMatrix4fv(ke.uniforms.u_mv_matrix, false, kq);
      var kz = Math.pow(2, 18 - this.map.getZoom());
      if (ke.lastState.scale !== kz) {
        ku.uniform1f(ke.uniforms.u_scale, kz);
        ke.lastState.scale = kz;
      }
      var ki = this.base_opt.isFlat;
      if (ke.lastState.isFlat !== ki) {
        ku.uniform1i(ke.uniforms.u_flat, ki);
        ke.lastState.isFlat = ki;
      }
      var ks = this.base_opt.drawPart || 1;
      if (ke.lastState.drawPart !== ks) {
        ku.uniform1i(ke.uniforms.u_draw_part, ks);
        ke.lastState.drawPart = ks;
      }
      var kg = kw._camera._far || 4000;
      if (ke.lastState.cameraFar !== kg) {
        ku.uniform1f(ke.uniforms.u_camera_far, kg);
        ke.lastState.cameraFar = kg;
      }
      ku.uniform1i(ke.uniforms.u_no_gradual, ky || false);
      var ko;
      if (!(this.style_opt.traceColor instanceof Array) || this.style_opt.traceColor.length < 3) {
        ko = [153, 153, 153];
      } else {
        ko = this.style_opt.traceColor.slice(0, 3);
      }
      ku.uniform3fv(ke.uniforms.u_trace_color, ko);
      ku.uniform1i(ke.uniforms.u_trace_disappear, this.style_opt.traceDisappear || false);
      ku.uniform1i(ke.uniforms.u_pick_model, kt || this.pickModel);
      if (ke.lastState.selectColor !== this.select_color) {
        ku.uniform4fv(ke.uniforms.u_pick_color, this.select_color);
        ke.lastState.selectColor = this.select_color;
      }
      if (ke.lastState.pickTag !== this.selectedIndex) {
        ku.uniform1i(ke.uniforms.u_pick_tag, this.selectedIndex + 1);
        ke.lastState.pickTag = this.selectedIndex;
      }
      var kv = new Int16Array(this.DEL_COUNT);
      if (this.delIndexs.length) {
        for (var kr = 0; kr < this.delIndexs.length && kr < this.DEL_COUNT; kr++) {
          kv[kr] = this.delIndexs[kr];
        }
      }
      ku.uniform1iv(ke.uniforms["u_del_tags[0]"], kv);
      var kd = this._formatArrayBuffer(kp.index);
      ku.uniform1iv(ke.uniforms["u_trace_index[0]"], kd);
      var e = this.traceControl(kp.index);
      var kh = this._formatArrayBuffer(e, true);
      ku.uniform1iv(ke.uniforms["u_trace_len[0]"], kh);
      kp.vao1.bind(ku, ke, kp.vertex, kp.element1);
      ku.drawElements(ku.TRIANGLES, kp.element1.length, ku.UNSIGNED_SHORT, 0);
      tags = null;
    },
    onDestroy: function (e, i) {
      this.lines = null;
      this.buffer = null;
      this._bufferArray = [];
      this._texture = {};
      d1.prototype.onDestroy.call(this);
    },
    toString: function () {
      return "LineLayer";
    }
  });
  function d0(e) {
    e = e || {};
    this.type = "polygon";
    this.style_opt = {
      fillColor: "#142655",
      fillOpacity: 1,
      pattern: false,
      patternMask: true,
      patternUrl: "",
      patternMapping: "0, 0, 32, 32",
      patternScale: 1,
      patternOffset: "0, 0"
    };
    this.setStyleOptions(e.style || {});
    this._bufferArray = [];
    this._texture = null;
    d1.call(this, e);
    e.border = e.border === undefined ? true : e.border;
    if (e.border) {
      var i = JSON.parse(JSON.stringify(e));
      i = Object.assign(i, {
        enablePicked: false,
        autoSelect: false
      });
      this.attach = new bS(i);
    }
  }
  d0.inherits(d1, "FillLayer");
  eX.extend(d0.prototype, {
    onAdd: function (e, i) {
      if (this.attach) {
        this.attach.onAdd(e, i);
      }
      if (!this.map) {
        this.map = e;
        this.gl = i;
      }
      if (!this.buffer) {
        this.parseData();
      }
    },
    parseData: function () {
      if (!this.loadModule || !this.styleExpress || !this.map || !this.map._normalLayerMgr) {
        return;
      }
      var i = this.getData();
      if (!i) {
        return;
      }
      if (this.attach) {
        this.attach.setData(i);
      }
      var T = this.dataset = this.formatData(i);
      this.dispatchEvent(new fJ("ondataparsed"));
      var e = this.fillsParse(T.inner);
      this.fills = this.combineFill(e);
      this.buffer = this.createBufferData(this.fills);
      this.doOnceDraw();
    },
    fillsParse: function (kj) {
      var kq = [];
      for (var ki = 0; ki < kj.length; ki++) {
        var kh = kj[ki].points;
        var T = false;
        if (!(kh[0] instanceof cx)) {
          T = true;
        }
        var kn = kj[ki].properties || {};
        var kp = kn.hasOwnProperty(this.base_opt.idKey) ? kn[this.base_opt.idKey] : false;
        var ke = ki;
        if (kj[ki].index !== undefined) {
          ke = kj[ki].index;
        }
        var e = this.evaluates(ke, {
          properties: kn,
          id: kp
        });
        e = Object.assign(JSON.parse(JSON.stringify(cs[this.type])), e || {});
        var ko = this.getColorStyleForGL(e.fillColor, e.fillOpacity, true).join(",");
        var km = [];
        if (this.style_opt.pattern && this.style_opt.patternUrl) {
          km = [e.patternMapping.split(","), e.patternScale, e.patternOffset.split(",")];
        }
        var kd = this.buildFillVertex(kh, T);
        var kl = kd[0].length / 2 * 3;
        var kf = new Float32Array(kl);
        var kk = 0;
        for (var kg = 0; kg < kd[0].length; kg++) {
          kf[kk] = kd[0][kg];
          kk++;
          if ((kg + 1) % 2 === 0) {
            kf[kk] = ke;
            kk++;
          }
        }
        var kc = [ko, kf, kd[1], km];
        kc.hasMultipleParts = T;
        kq.push(kc);
      }
      return kq;
    },
    buildFillVertex: function (kc, e) {
      var ki = this._toFormatPolGeometry(kc, e);
      var kj = [];
      var kf;
      var kg = [];
      var ke = 0;
      for (var kd = 0; kd < ki.length; kd++) {
        if (kd > 0) {
          ke += ki[kd - 1].length;
        }
        kf = hC(ki[kd].pointsArray, null, null, ke);
        for (var T = 0, kh = kf.length; T < kh; T += 3) {
          kj.push(kf[T], kf[T + 1], kf[T + 2]);
        }
        kg = kg.concat(ki[kd].pointsArray);
      }
      var kk = [new Float32Array(kg), new Uint16Array(kj)];
      return kk;
    },
    combineFill: function (T) {
      var kh = {};
      var e = [];
      for (var ke = 0; ke < T.length; ke++) {
        var kg = this._cloneFill(T[ke]);
        if (kg.hasMultipleParts) {
          e.push(kg);
        } else {
          var kd = kg[0] + "_" + kg[3].join("-");
          if (kh[kd]) {
            if ((kh[kd][1].length + kg[1].length) / 3 < 65536) {
              this.mergeDataItem(kh[kd], kg, kh[kd][1].length / 3);
            } else {
              e.push(this._cloneFill(kh[kd]));
              kh[kd] = kg;
            }
          } else {
            kh[kd] = kg;
          }
        }
      }
      var kf = Object.keys(kh);
      for (var kc = 0; kc < kf.length; kc++) {
        e.push(kh[kf[kc]]);
      }
      return e;
    },
    _cloneFill: function (kd) {
      var kc = kd[1].constructor;
      var i = new kc(kd[1].length);
      i.set(kd[1], 0);
      var ke = kd[2].constructor;
      var T = new ke(kd[2].length);
      T.set(kd[2], 0);
      var e = [kd[0], i, T, kd[3]];
      if (kd.hasMultipleParts) {
        e.hasMultipleParts = kd.hasMultipleParts;
      }
      return e;
    },
    mergeDataItem: function (e, ke, T) {
      var i = e[1];
      var kd = ke[1];
      var kc = e[2];
      var kf = ke[2];
      e[1] = this.concatTypedArray(i, kd);
      e[2] = this.concatTypedArray(kc, kf, T);
      return e;
    },
    concatTypedArray: function (e, kf, ke) {
      if (e.constructor === ArrayBuffer) {
        var kc = new Uint8Array(e.byteLength + kf.byteLength);
        kc.set(new Uint8Array(e), 0);
        kc.set(new Uint8Array(kf), e.byteLength);
        return kc.buffer;
      } else {
        var kd = e.constructor;
        var kc = new kd(e.length + kf.length);
        kc.set(e, 0);
        if (ke) {
          for (var T = 0; T < kf.length; T++) {
            kf[T] += ke;
          }
        }
        kc.set(kf, e.length);
        return kc;
      }
    },
    createBuffer: function (i) {
      var T = 3;
      var e = [{
        name: "a_pos",
        components: 2,
        offset: 0,
        type: "Float32"
      }, {
        name: "a_id",
        components: 1,
        offset: 8,
        type: "Float32"
      }];
      return new w(i, {
        components: T,
        members: e
      }, w.BufferType.VERTEX);
    },
    createBufferData: function (ke) {
      var kf = [];
      for (var T = 0; T < ke.length; T++) {
        var kd = ke[T][1];
        var e = ke[T][2];
        if (!kd || !kd.length) {
          continue;
        }
        if (!this._bufferArray[kf.length]) {
          this._bufferArray[kf.length] = {
            vertex: null,
            element1: null,
            vao1: null
          };
          var kc = this._bufferArray[kf.length];
          kc.vertex = this.createBuffer(kd);
          kc.element1 = new w(e, {
            components: 1
          }, w.BufferType.ELEMENT, e.length);
          kc.vao1 = new dO();
        } else {
          var kc = this._bufferArray[kf.length];
          kc.vao1.update(this.gl, kc.vertex, kd, kd.length, kc.element1, e, e.length);
        }
        kf.push(kc);
      }
      return kf;
    },
    preRender: function (T, i, e) {},
    render: function (ke, kg, e) {
      if (!this.buffer) {
        return;
      }
      e = e || {};
      if (this.style_opt.pattern && this.style_opt.patternUrl) {
        if (!this._texture) {
          this._texture = {
            status: "init"
          };
          var ki = this;
          var kd = new Image();
          kd.crossOrigin = "anonymous";
          kd.onload = function () {
            ki._texture = dS.utils.createTexture(ke, this, {
              flipY: true,
              wrap: ke.REPEAT,
              mipmap: false,
              unpackAlpha: true
            });
            ki._texture.size = [this.width, this.height];
            ki._texture.status = "done";
            ki.doOnceDraw();
          };
          kd.src = this.style_opt.patternUrl;
        }
        if (this._texture.status !== "done") {
          return;
        }
      }
      this.pickModel = e.isPickRender || false;
      var kh = this.map._webglPainter;
      var kj = kh._state;
      for (var kc = 0; kc < this.buffer.length; kc++) {
        var T = this.fills[kc][0];
        T = T.split(",");
        T = [T[0] / 255, T[1] / 255, T[2] / 255, parseFloat(T[3])];
        var kf = this.fills[kc][3];
        if (this.fills[kc].hasMultipleParts) {
          ke.clear(ke.STENCIL_BUFFER_BIT);
          ke.stencilFunc(ke.NEVER, 0, 255);
          kj.stencilOp(ke.INVERT, ke.INVERT, ke.INVERT);
          ke.stencilMask(255);
          kj.colorMask(false, false, false, false);
          this.drawFill(kh, this.buffer[kc], T, kf);
          ke.stencilFunc(ke.EQUAL, 255, 255);
          ke.stencilMask(0);
          kj.stencilOp(ke.KEEP, ke.KEEP, ke.KEEP);
          kj.colorMask(true, true, true, true);
          this.drawFill(kh, this.buffer[kc], T, kf);
          ke.clear(ke.STENCIL_BUFFER_BIT);
          ke.stencilMask(255);
          ke.stencilFunc(ke.ALWAYS, 1, 255);
        } else {
          this.drawFill(kh, this.buffer[kc], T, kf);
        }
      }
      if (this.attach) {
        this.attach.render(ke, kg, e);
      }
    },
    drawFill: function (ks, kk, kl, kq) {
      if (kk.element1 && kk.element1.length === 0) {
        return;
      }
      var kp = ks.gl;
      var ke = ks.programMgr.useProgram("filllayer", {
        def: this.def
      });
      var km = ks._camera._modelViewMatrixLayer;
      if (!ke.lastState.projMatrix) {
        kp.uniformMatrix4fv(ke.uniforms.u_proj_matrix, false, ks.projMatrix);
        ke.lastState.projMatrix = true;
      }
      kp.uniformMatrix4fv(ke.uniforms.u_mv_matrix, false, km);
      kp.uniform4fv(ke.uniforms.u_color, kl);
      var T = this.opacity;
      if (ke.lastState.opacity !== T) {
        kp.uniform1f(ke.uniforms.u_opacity, T);
        ke.lastState.opacity = T;
      }
      var kf = this.style_opt.pattern;
      if (kf && this._texture) {
        ks._state.activeTexture(kp.TEXTURE5);
        kp.bindTexture(kp.TEXTURE_2D, this._texture);
        if (ke.uniforms.lastSampler !== 5) {
          kp.uniform1i(ke.uniforms.u_image, 5);
          ke.uniforms.lastSampler = 5;
        }
        var ki = this._texture.size;
        if (ke.lastState.size !== ki) {
          kp.uniform2fv(ke.uniforms.u_size, ki);
          ke.lastState.size = ki;
        }
      }
      if (ke.lastState.pattern !== kf) {
        kp.uniform1i(ke.uniforms.u_pattern, kf);
        ke.lastState.pattern = kf;
      }
      var kc = this.style_opt.patternMask;
      if (ke.lastState.patternMask !== kc) {
        kp.uniform1i(ke.uniforms.u_pattern_mask, kc);
        ke.lastState.patternMask = kc;
      }
      var kj = this.map.getZoom();
      if (ke.lastState.mapZoom !== kj) {
        kp.uniform1f(ke.uniforms.u_map_zoom, kj);
        ke.lastState.mapZoom = kj;
      }
      var e = kq.length >= 3 ? kq[0] : [0, 0, 0, 0];
      if (ke.lastState.bound !== e) {
        kp.uniform4fv(ke.uniforms.u_bound, e);
        ke.lastState.bound = e;
      }
      var kt = kq.length >= 3 ? kq[1] : 0;
      if (ke.lastState.scale !== kt) {
        kp.uniform1f(ke.uniforms.u_scale, kt);
        ke.lastState.scale = kt;
      }
      var kd = kq.length >= 3 ? kq[2] : [0, 0];
      if (ke.lastState.offset !== kd) {
        kp.uniform2fv(ke.uniforms.u_offset, kd);
        ke.lastState.offset = kd;
      }
      var kh = this.base_opt.isFlat;
      if (ke.lastState.isFlat !== kh) {
        kp.uniform1i(ke.uniforms.u_flat, kh);
        ke.lastState.isFlat = kh;
      }
      var ko = this.base_opt.drawPart || 1;
      if (ke.lastState.drawPart !== ko) {
        kp.uniform1i(ke.uniforms.u_draw_part, ko);
        ke.lastState.drawPart = ko;
      }
      var kg = ks._camera._far || 4000;
      if (ke.lastState.cameraFar !== kg) {
        kp.uniform1f(ke.uniforms.u_camera_far, kg);
        ke.lastState.cameraFar = kg;
      }
      kp.uniform1i(ke.uniforms.u_pick_model, this.pickModel);
      if (ke.lastState.selectColor !== this.select_color) {
        kp.uniform4fv(ke.uniforms.u_pick_color, this.select_color);
        ke.lastState.selectColor = this.select_color;
      }
      if (ke.lastState.pickTag !== this.selectedIndex) {
        kp.uniform1i(ke.uniforms.u_pick_tag, this.selectedIndex + 1);
        ke.lastState.pickTag = this.selectedIndex;
      }
      var kr = new Int16Array(this.DEL_COUNT);
      if (this.delIndexs.length) {
        for (var kn = 0; kn < this.delIndexs.length && kn < this.DEL_COUNT; kn++) {
          kr[kn] = this.delIndexs[kn];
        }
      }
      kp.uniform1iv(ke.uniforms["u_del_tags[0]"], kr);
      kk.vao1.bind(kp, ke, kk.vertex, kk.element1);
      kp.drawElements(kp.TRIANGLES, kk.element1.length, kp.UNSIGNED_SHORT, 0);
      tags = null;
    },
    onDestroy: function (e, i) {
      this.fills = null;
      this.buffer = null;
      this._bufferArray = [];
      this._texture = null;
      d1.prototype.onDestroy.call(this);
      if (this.attach) {
        this.attach.onDestroy();
      }
    },
    toString: function () {
      return "FillLayer";
    }
  });
  var gZ = null;
  bx.register(function (i) {
    if (i.config && i.config.isOverviewMap) {
      return;
    }
    if (i.isLoaded()) {
      J(i);
      gZ = jj(i);
    } else {
      i.addEventListener("load", function () {
        J(this);
        gZ = jj(this);
      });
    }
    i.cityName = "中国";
    i.cCode = "1";
    var e = {};
    e.enableRequest = true;
    e.request = function () {
      if (e.enableRequest) {
        e.enableRequest = false;
        setTimeout(function () {
          e._request();
        }, 500);
      }
    };
    e._request = function () {
      var kc = i.getBoundsIn();
      if (!kc) {
        return;
      }
      var ke = i.getZoom();
      var T = kc.getSouthWest();
      var kd = kc.getNorthEast();
      jV.request(function (ki) {
        if (ki.current_city.code >= 9000 && ki.current_city.code <= 9378) {
          ki.current_city.name = "台湾省";
        }
        if (ki.current_city.code >= 20000 && ki.current_city.code <= 20499) {
          ki.current_city.name = "新加坡";
        }
        if (ki.current_city.code >= 20500 && ki.current_city.code <= 25999) {
          ki.current_city.name = "泰国";
        }
        if (ki.current_city.code >= 26000 && ki.current_city.code <= 29999) {
          ki.current_city.name = "日本";
        }
        if (ki.current_city.code >= 30000 && ki.current_city.code <= 30999) {
          ki.current_city.name = "韩国";
        }
        if (ki.current_city.code >= 31000 && ki.current_city.code <= 37000) {
          ki.current_city.name = "亚太";
        }
        if (ki.current_city.code >= 46609 && ki.current_city.code <= 52505) {
          ki.current_city.name = "欧洲";
        }
        if (ki.current_city.code >= 39509 && ki.current_city.code <= 53500) {
          ki.current_city.name = "南美洲";
        }
        if (ki.current_city.code >= 54000 && ki.current_city.code <= 70000) {
          ki.current_city.name = "北美洲";
        }
        if (ki.current_city.code === 54003 && ki.current_city.code >= 60731 && ki.current_city.code <= 61123) {
          ki.current_city.name = "美国";
        }
        if (ki.current_city.code === 54015 || ki.current_city.code >= 57970 && ki.current_city.code <= 60223) {
          ki.current_city.name = "加拿大";
        }
        if (ki.current_city.code === 54025 || ki.current_city.code >= 54338 && ki.current_city.code <= 57374) {
          ki.current_city.name = "墨西哥";
        }
        e.enableRequest = true;
        if (ki && ki.current_city) {
          var kh = ki.current_city.name;
          var kg = ki.current_city.code;
          if (kg !== i.cCode) {
            var kf = new fJ("oncitychange");
            kf.name = kh;
            kf.code = kg;
            i.dispatchEvent(kf);
          }
          i.cityName = kh;
          i.cCode = kg;
          if (!bW()) {
            c1(i);
          }
        }
      }, {
        qt: "cen",
        b: T.lng + "," + T.lat + ";" + kd.lng + "," + kd.lat,
        l: ke
      }, "", "", true);
    };
    i.addEventListener("load", function (T) {
      e.request();
    });
    i.addEventListener("moveend", function (T) {
      e.request();
    });
    i.addEventListener("zoomend", function (T) {
      e.request();
    });
    e.request();
  });
  function jj(T) {
    var e = {};
    var i = new jT(e);
    T.addControl(i);
    return i;
  }
  function J(i) {
    if (i.temp.copyadded) {
      return;
    }
    i.temp.copyadded = true;
    if (!i.cpyCtrl) {
      var kc = new i0(2, 2);
      i.config.cpyCtrlOffset = kc;
      if (bW()) {
        kc.width = 72;
        kc.height = 0;
      }
      var T = new f5({
        offset: kc,
        printable: true
      });
      i.cpyCtrl = T;
    }
    if (!bW()) {
      c1(i);
      i.addEventListener("maptypechange", function () {
        c1(i);
      });
    }
    i.addControl(T);
    var e = new bA();
    e._opts = {
      printable: true
    };
    i.logoCtrl = e;
    i.addControl(e);
    i.addEventListener("resize", function () {
      if (this.getSize().width >= 300 && i.getSize().height >= 100) {
        e.show();
        T.setOffset(i.config.cpyCtrlOffset);
      } else {
        e.hide();
        T.setOffset(new i0(4, 2));
      }
    });
    if (i.getSize().width >= 300 && i.getSize().height >= 100) {
      e.show();
    } else {
      e.hide();
      T.setOffset(new i0(4, 2));
    }
    i.addEventListener("oncopyrightoffsetchange", function (kd) {
      i.logoCtrl.setOffset(kd.target.logo);
      i.cpyCtrl.setOffset(kd.target.cpy);
    });
    i.dispatchEvent(new fJ("oncopyrightaddend"));
  }
  function c1(kr) {
    if (!kr.cpyCtrl) {
      var kz = new i0(2, 2);
      if (bW()) {
        kz.width = 72;
        kz.height = 0;
      }
      var ku = new f5({
        offset: kz,
        printable: true
      });
      kr.cpyCtrl = ku;
    }
    var kI = kr.cityName || "中国";
    var ks = kr.getMapType();
    var kt = ["常州市", "南昌市", "乌鲁木齐市", "无锡市", "福州市", "泉州市", "珠海市", "贵阳市"];
    var kl = ["北京市", "上海市", "广州市", "深圳市", "宁波市", "石家庄市", "沈阳市", "长春市", "青岛市", "温州市", "台州市", "金华市", "佛山市", "中山市", "昆明市", "南宁市", "苏州市", "西安市", "济南市", "郑州市", "合肥市", "呼和浩特市", "杭州市", "成都市", "武汉市", "长沙市", "天津市", "南京市", "重庆市", "大连市", "东莞市", "厦门市"];
    var kn = ["香港特别行政区"];
    var kh = ["台湾省"];
    var kA = ["日本"];
    var kG = ["韩国"];
    var kv = ["泰国"];
    var ky = ["亚太"];
    var ki = ["新加坡"];
    var kH = ["欧洲"];
    var kc = ["南美洲"];
    var kD = ["北美洲"];
    var T = ["美国"];
    var kx = ["墨西哥"];
    var kf = ["加拿大"];
    for (var kE in kt) {
      if (kt[kE] === kI) {
        var ko = true;
        break;
      }
    }
    for (var kE in kl) {
      if (kl[kE] === kI) {
        var kd = true;
        break;
      }
    }
    for (var kE in kn) {
      if (kn[kE] === kI) {
        var kK = true;
        break;
      }
    }
    if (kh[0] === kI) {
      var kC = true;
    }
    if (ki[0] === kI) {
      var i = true;
    }
    if (kA[0] === kI) {
      var kk = true;
    }
    if (kG[0] === kI) {
      var kq = true;
    }
    if (kv[0] === kI) {
      var kp = true;
    }
    if (ky[0] === kI) {
      var kg = true;
    }
    if (kH[0] === kI) {
      var km = true;
    }
    if (kc[0] === kI) {
      var kj = true;
    }
    if (kD[0] === kI) {
      var e = true;
    }
    if (T[0] === kI) {
      var kF = true;
    }
    if (kf[0] === kI) {
      var kB = true;
    }
    if (kx[0] === kI) {
      var ke = true;
    }
    var kJ = ["&copy;&nbsp;2023 Baidu - GS(2021)6026号 - 甲测资字11111342 - 京ICP证030173号 - Data &copy; "];
    var kw = "rgba(255, 255, 255, 0.701961)";
    if (kr.getZoom() <= 9) {
      kJ = ["&copy;&nbsp;2023 Baidu - GS(2021)6026号 - 甲测资字11111342 - 京ICP证030173号 - Data &copy; "];
    } else if (kC) {
      kJ = ["&copy;&nbsp;2023 Baidu - GS(2021)6026号 - 甲测资字11111342 - 京ICP证030173号 - Data &copy; "];
    } else if (kk || kq) {
      kJ = ["&copy;&nbsp;2023 Baidu - GS(2021)6026号 - 甲测资字11111342 - 京ICP证030173号 - Data &copy; "];
    } else if (i || kp) {
      kJ = ["&copy;&nbsp;2023 Baidu - GS(2021)6026号 - 甲测资字11111342 - 京ICP证030173号 - Data &copy; "];
    } else if (kg) {
      kJ = ["&copy;&nbsp;2023 Baidu - GS(2021)6026号 - 甲测资字11111342 - 京ICP证030173号 - Data &copy; "];
    } else if (km) {
      kJ = ["&copy;&nbsp;2023 Baidu - GS(2021)6026号 - 甲测资字11111342 - 京ICP证030173号 - Data &copy; "];
    } else if (kj) {
      kJ = ["&copy;&nbsp;2023 Baidu - GS(2021)6026号 - 甲测资字11111342 - 京ICP证030173号 - Data &copy; "];
    } else if (e) {
      kJ = ["&copy;&nbsp;2023 Baidu - GS(2021)6026号 - 甲测资字11111342 - 京ICP证030173号 - Data &copy; "];
    }
    if (kr.getZoom() <= 9) {
      kJ.push("百度智图");
      kJ.push(" &amp; <a target=\"_blank\" href=\"http://www.openstreetmap.org/\">OpenStreetMap</a>");
      kJ.push(" &amp; <a target=\"_blank\" href=\"http://corporate.navteq.com/supplier_terms.html\">HERE</a>");
      if (ks === BMAP_SATELLITE_MAP || ks === BMAP_HYBRID_MAP) {
        kJ.push(" &amp; <a target=\"_blank\" href=\"http://www.eso.org/public/\">ESO</a>");
        kw = "rgba(0,0,0,.7)";
      }
    } else if (kk || kq) {
      kJ.push("<a target=\"_blank\" href=\"http://www.openstreetmap.org/\">OpenStreetMap</a>");
    } else if (i || kp) {
      kJ.push("<a target=\"_blank\" href=\"http://corporate.navteq.com/supplier_terms.html\">HERE</a>");
    } else if (kg) {
      kJ.push("<a target=\"_blank\" href=\"http://corporate.navteq.com/supplier_terms.html\">HERE</a>");
      kJ.push(" &amp; <a target=\"_blank\" href=\"https://www.mapbox.com/\">Mapbox</a>");
    } else if (km) {
      kJ.push("<a target=\"_blank\" href=\"http://www.openstreetmap.org/\">OpenStreetMap</a>");
      kJ.push(" &amp; <a target=\"_blank\" href=\"https://www.mapbox.com/\">Mapbox</a>");
    } else if (kj) {
      kJ.push("<a target=\"_blank\" href=\"http://www.openstreetmap.org/\">OpenStreetMap</a>");
      kJ.push(" &amp; <a target=\"_blank\" href=\"https://www.mapbox.com/\">Mapbox</a>");
    } else if (kF || ke || kB) {
      kJ.push("<a target=\"_blank\" href=\"http://corporate.navteq.com/supplier_terms.html\">HERE</a>");
      kJ.push(" &amp; <a target=\"_blank\" href=\"https://www.mapbox.com/\">Mapbox</a>");
    } else if (e) {
      kJ.push("<a target=\"_blank\" href=\"http://www.openstreetmap.org/\">OpenStreetMap</a>");
      kJ.push(" &amp; <a target=\"_blank\" href=\"https://www.mapbox.com/\">Mapbox</a>");
    } else {
      kJ.push("百度智图");
      if (ko) {
        kJ.push(" &amp; <a target=\"_blank\" href=\"http://www.palmcity.cn/palmcity/\">PalmCity</a>");
      }
      if (kK) {
        kJ.push(" &amp; <a target=\"_blank\" href=\"http://www.mapking.com/HongKong/eng/home/MapKing_Webmap.html\">MapKing</a>");
      }
      if (kC) {
        kJ.push(" &amp; <a target=\"_blank\" href=\"http://corporate.navteq.com/supplier_terms.html\">HERE</a>");
        kJ.push(" &amp; <a target=\"_blank\" href=\"http://www.localking.com.tw/about/localking.aspx\">樂客LocalKing</a>");
      }
      if (ks === BMAP_SATELLITE_MAP || ks === BMAP_HYBRID_MAP) {
        kw = "rgba(0,0,0,.7)";
      }
    }
    kJ.unshift("<span style=\"background: " + kw + ";padding: 0px 1px;line-height: 16px;display: inline;height: 16px;\">");
    kJ.push("</span>");
    kJ = kJ.join("");
    kr.cpyCtrl.addCopyright({
      id: 1,
      content: kJ
    });
  }
  function jT(e) {
    this.defaultAnchor = BMAP_ANCHOR_TOP_RIGHT;
    this.defaultOffset = e.defaultOffset || new i0(90, 6);
    this._cZIndex = 9999;
    this._visible = false;
  }
  jT.prototype = new gH();
  jT.prototype.initialize = function (kd) {
    this._map = kd;
    var kc = this;
    var e = bX("div");
    var i = e.style;
    i.left = i.top = "50%";
    i.display = "none";
    i.padding = "24px";
    i.overflow = "visible";
    i.position = "absolute";
    i.width = "50%";
    i.maxWidth = "360px";
    i.transform = "translate(-50% , -50%)";
    i.zIndex = "9999";
    i.background = "#fff";
    i.userSelect = "none";
    var ke = bX("span", {
      style: "margin-top: 12px;\n    margin-bottom: -12px;\n    margin-left: calc(100% - 48px);\n    width: 56px;\n    height: 32px;\n    font-size: 14px;\n    text-align: center;\n    line-height: 32px;\n    display: block;\n    cursor: pointer;\n    background: #3894FF;\n    border: solid 1px #3f51b53b;\n    color: #fff;\n    border-radius: 3px;"
    });
    ke.innerText = "确定";
    ke.addEventListener("click", function () {
      kc.hide();
    });
    var T = bX("div");
    var kf = T.style;
    kf.position = "relative";
    kf.width = "100%";
    kf.height = "100%";
    kf.color = "#000";
    kf.fontSize = "14px";
    kf.wordBreak = "break-all";
    e.appendChild(T);
    e.appendChild(ke);
    kd.getContainer().appendChild(e);
    return e;
  };
  jT.prototype._setPosition = function () {};
  jT.prototype.update = function (e) {
    if (!this.isVisible()) {
      this._container.firstChild.innerText = e;
      this.show();
    }
  };
  window.BMAP_STATUS_SUCCESS = 0;
  window.BMAP_STATUS_CITY_LIST = 1;
  window.BMAP_STATUS_UNKNOWN_LOCATION = 2;
  window.BMAP_STATUS_UNKNOWN_ROUTE = 3;
  window.BMAP_STATUS_INVALID_KEY = 4;
  window.BMAP_STATUS_INVALID_REQUEST = 5;
  window.BMAP_STATUS_PERMISSION_DENIED = 6;
  window.BMAP_STATUS_SERVICE_UNAVAILABLE = 7;
  window.BMAP_STATUS_TIMEOUT = 8;
  window.BMAP_ROUTE_TYPE_WALKING = 2;
  window.BMAP_ROUTE_TYPE_DRIVING = 3;
  window.BMAP_ROUTE_TYPE_RIDING = 6;
  window.BMAP_ROUTE_STATUS_NORMAL = 0;
  window.BMAP_ROUTE_STATUS_EMPTY = 1;
  window.BMAP_ROUTE_STATUS_ADDRESS = 2;
  var de = "cur";
  var Z = "cen";
  var I = "s";
  var dw = "con";
  var dn = "bd";
  var cR = "nb";
  var gY = "bt";
  var aO = "nav";
  var h7 = "walk";
  var fQ = "gc";
  var dU = "rgc";
  var K = "dec";
  var ip = "iploc";
  var gI = "bse";
  var ge = "nse";
  var db = "bl";
  var en = "bsl";
  var fN = "bda";
  var ek = "sa";
  var a7 = "nba";
  var ie = "drag";
  var i1 = "ext";
  var jF = "exts";
  var jI = "hip";
  var hz = "ride";
  var jS = "drct";
  var b1 = "ldt";
  var fo = 2;
  var be = 4;
  var fX = 7;
  var ig = 11;
  var b8 = 12;
  var eS = 14;
  var cO = 15;
  var eb = 18;
  var aA = 20;
  var a6 = 21;
  var H = 19;
  var a = 23;
  var iC = 26;
  var aC = 28;
  var gf = 31;
  var e4 = 35;
  var iq = 44;
  var bc = 45;
  var ax = 46;
  var jD = 47;
  var gk = -1;
  var a9 = 0;
  var bw = 1;
  var i6 = 2;
  var dM = 3;
  window.BMAP_POI_TYPE_NORMAL = 0;
  var cB = 1;
  var ii = 2;
  BMapGL.I = eX.I;
  var bG = {};
  bG.removeHtml = function (e) {
    e = e.replace(/<\/?[^>]*>/g, "");
    e = e.replace(/[ | ]* /g, " ");
    return e;
  };
  bG.parseGeoExtReg1 = function (e) {
    return e.replace(/([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0|[1-9]\d*),([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0|[1-9]\d*)(,)/g, "$1,$2;");
  };
  bG.parseGeoExtReg2 = function (i, e) {
    var T = new RegExp("(((-?\\d+)(\\.\\d+)?),((-?\\d+)(\\.\\d+)?);)(((-?\\d+)(\\.\\d+)?),((-?\\d+)(\\.\\d+)?);){" + e + "}", "ig");
    return i.replace(T, "$1");
  };
  var dE = 0;
  var dd = 1;
  var S = 2;
  bG.unique = function (T) {
    var ke = false;
    var kd = [];
    var kf = {};
    for (var kc = 0, e = T.length; kc < e; kc++) {
      if (!kf[T[kc]]) {
        kf[T[kc]] = true;
        kd.push(T[kc]);
      }
    }
    return kd;
  };
  bG.getBestLevel = function (T, i) {
    if (i) {
      var e = Math.min(i.width / 1100, i.height / 660);
      T = Math.round(T + Math.log(e) / Math.log(2));
    }
    if (T < 1) {
      T = 1;
    }
    if (T > 21) {
      T = 21;
    }
    return T;
  };
  bG.parseGeo = function (kf, ki) {
    if (typeof kf != "string" || !kf) {
      return;
    }
    var kk = kf.split("|");
    var e;
    var kd;
    var T;
    if (kk.length == 1) {
      e = b2(kf);
    } else {
      e = b2(kk[2]);
      kd = b2(kk[0]);
      T = b2(kk[1]);
      if (!ki) {
        return e;
      }
    }
    var kg = {
      type: e.geoType
    };
    if (ki) {
      switch (kg.type) {
        case S:
          var kh = new cx(e.geo[0][0], e.geo[0][1]);
          var kj = i9.convertMC2LL(kh);
          kg.point = kj;
          kg.points = [kj];
          break;
        case dd:
          kg.points = [];
          var kl = e.geo[0];
          for (var ke = 0, kc = kl.length - 1; ke < kc; ke += 2) {
            var km = new cx(kl[ke], kl[ke + 1]);
            km = i9.convertMC2LL(km);
            kg.points.push(km);
          }
          kd = new cx(kd.geo[0][0], kd.geo[0][1]);
          T = new cx(T.geo[0][0], T.geo[0][1]);
          kd = i9.convertMC2LL(kd);
          T = i9.convertMC2LL(T);
          kg.bounds = new hY(kd, T);
          break;
        default:
          break;
      }
    }
    return kg;
  };
  bG.parseGeoExt = function (kv, km) {
    if (!km) {
      km = 0;
    } else if (km < 0.25) {
      km = 0;
    } else if (km > 0.25 && km < 1) {
      km = 1;
    } else if (km > 32) {
      km = 32;
    }
    var kh = kv.split("|");
    if (kh.length == 1) {
      var kc = b2(kh[0]);
      return {
        type: kc.type,
        bound: "",
        points: kc.geo.join(",")
      };
    } else if (kh.length > 1) {
      var kn = kv.split(";.=");
      var kj = [];
      var kd = [];
      var ko = 0;
      var ks = kn.length;
      for (var kp = 0; kp < ks; kp++) {
        var ku = kn[kp];
        if (ks > 1) {
          if (kp == 0) {
            ku = ku + ";";
          }
          if (kp > 0 && kp < ks - 1) {
            ku = ".=" + ku + ";";
          }
          if (kp == ks - 1) {
            ku = ".=" + ku;
          }
        }
        var ke = ku.split("|");
        var kr = b2(ke[0]);
        var kq = b2(ke[1]);
        kj.push(kr.geo.join(","));
        kj.push(kq.geo.join(","));
        var kc = b2(ke[2]);
        ko = kc.type;
        var kt = kc.geo.join(",");
        kt = bG.parseGeoExtReg1(kt);
        if (km > 0) {
          kt = bG.parseGeoExtReg2(kt, km);
        }
        kd.push(kt);
      }
      if (ks <= 1) {
        kd = kd.join(";");
      }
      if (ks == 2) {
        var T = kd[0] + ";" + kd[1];
        var kf = T.split(";");
        var e = [];
        for (var kp = 0; kp < kf.length; kp++) {
          var ki = kf[kp].split(",")[0];
          var kg = kf[kp].split(",")[1];
          var kk = new cx(ki, kg);
          var kl = i9.convertMC2LL(kk);
          e.push(kl);
        }
        kd = e;
      }
      return {
        type: ko,
        bound: kj.join(";"),
        points: kd
      };
    }
  };
  bG.getPoiPoint = function (e) {
    var T = [];
    var i = null;
    if (e.toString() == "Point") {
      i = e;
    } else {
      if (typeof e == "string") {
        T = eX.trim(e).split(",");
        if (T.length < 2) {
          return;
        }
        T[0] = parseFloat(eX.trim(T[0]));
        T[1] = parseFloat(eX.trim(T[1]));
      } else {
        T = e.slice(0);
        if (T.length < 2) {
          return;
        }
      }
      i = new BMap.Point(T[0], T[1]);
    }
    return i;
  };
  bG.parseGeoStr = function (T) {
    var i = T.split(",");
    var e = new cx(i[0], i[1]);
    return i9.convertMC2LL(e);
  };
  bG.level = {
    country: 4,
    province: 11,
    city: 12,
    area: 13
  };
  var hc = ["=", ".", "-", "*"];
  var c9 = 1 << 23;
  function b2(ki) {
    var kh = hU(ki.charAt(0));
    var T = ki.substr(1);
    var kk = 0;
    var e = T.length;
    var kl = [];
    var kf = [];
    var kg = [];
    while (kk < e) {
      if (T.charAt(kk) == hc[0]) {
        if (e - kk < 13) {
          return 0;
        }
        kg = ea(T.substr(kk, 13), kl);
        if (kg < 0) {
          return 0;
        }
        kk += 13;
      } else if (T.charAt(kk) == ";") {
        kf.push(kl.slice(0));
        kl.length = 0;
        ++kk;
      } else {
        if (e - kk < 8) {
          return 0;
        }
        kg = ce(T.substr(kk, 8), kl);
        if (kg < 0) {
          return 0;
        }
        kk += 8;
      }
    }
    for (var ke = 0, kc = kf.length; ke < kc; ke++) {
      for (var kd = 0, kj = kf[ke].length; kd < kj; kd++) {
        kf[ke][kd] /= 100;
      }
    }
    return {
      geoType: kh,
      geo: kf
    };
  }
  function hU(i) {
    var e = -1;
    if (i == hc[1]) {
      e = S;
    } else if (i == hc[2]) {
      e = dd;
    } else if (i == hc[3]) {
      e = dE;
    }
    return e;
  }
  function ea(kd, T) {
    var e = 0;
    var kf = 0;
    var ke = 0;
    for (var kc = 0; kc < 6; kc++) {
      ke = dv(kd.substr(1 + kc, 1));
      if (ke < 0) {
        return -1 - kc;
      }
      e += ke << 6 * kc;
      ke = dv(kd.substr(7 + kc, 1));
      if (ke < 0) {
        return -7 - kc;
      }
      kf += ke << 6 * kc;
    }
    T.push(e);
    T.push(kf);
    return 0;
  }
  function ce(ke, kc) {
    var T = kc.length;
    if (T < 2) {
      return -1;
    }
    var e = 0;
    var kg = 0;
    var kf = 0;
    for (var kd = 0; kd < 4; kd++) {
      kf = dv(ke.substr(kd, 1));
      if (kf < 0) {
        return -1 - kd;
      }
      e += kf << 6 * kd;
      kf = dv(ke.substr(4 + kd, 1));
      if (kf < 0) {
        return -5 - kd;
      }
      kg += kf << 6 * kd;
    }
    if (e > c9) {
      e = c9 - e;
    }
    if (kg > c9) {
      kg = c9 - kg;
    }
    kc.push(kc[T - 2] + e);
    kc.push(kc[T - 1] + kg);
    return 0;
  }
  function dv(i) {
    var e = i.charCodeAt(0);
    if (i >= "A" && i <= "Z") {
      return e - "A".charCodeAt(0);
    } else if (i >= "a" && i <= "z") {
      return 26 + e - "a".charCodeAt(0);
    } else if (i >= "0" && i <= "9") {
      return 52 + e - "0".charCodeAt(0);
    } else if (i == "+") {
      return 62;
    } else if (i == "/") {
      return 63;
    }
    return -1;
  }
  bG.pathToPoints = function (ke) {
    var kc = [];
    if (typeof ke !== "string") {
      return kc;
    } else {
      var kd = ke.split(";");
      for (var T = 0; T < kd.length; T++) {
        var e = kd[T].split(",");
        kc.push(new cx(e[0], e[1]));
      }
    }
    return kc;
  };
  bG.pointsToString = function (kd) {
    var kc = "";
    if (typeof kd !== "object") {
      return kd;
    } else {
      for (var T = 0; T < kd.length; T++) {
        var e = kd[T].lat + "," + kd[T].lng;
        if (T !== kd.length - 1) {
          kc = kc + e + "|";
        } else {
          kc = kc + e;
        }
      }
    }
    return kc;
  };
  bG.stringToPoints = function (ke) {
    var kc = [];
    if (typeof ke !== "string" || !ke) {
      return kc;
    } else {
      var kd = ke.split("|");
      for (var T = 0; T < kd.length; T++) {
        var e = kd[T].split(",");
        kc.push(new cx(e[1], e[0]));
      }
    }
    return kc;
  };
  window.BMAP_POI_TYPE_NORMAL = 0;
  window.BMAP_POI_TYPE_BUSSTOP = 1;
  window.BMAP_POI_TYPE_BUSLINE = 2;
  window.BMAP_POI_TYPE_SUBSTOP = 3;
  window.BMAP_POI_TYPE_SUBLINE = 4;
  var Q = 0;
  var hE = 1;
  var fD = {};
  window.APIPack = fD;
  function aH(i, e) {
    c8.call(this);
    this._loc = {};
    this.setLocation(i);
    e = e || {};
    e.renderOptions = e.renderOptions || {};
    this._opts = {
      renderOptions: {
        panel: e.renderOptions.panel || null,
        map: e.renderOptions.map || null,
        autoViewport: e.renderOptions.autoViewport || true,
        selectFirstResult: e.renderOptions.selectFirstResult,
        highlightMode: e.renderOptions.highlightMode,
        enableDragging: e.renderOptions.enableDragging || false
      },
      onSearchComplete: e.onSearchComplete || function () {},
      onMarkersSet: e.onMarkersSet || function () {},
      onInfoHtmlSet: e.onInfoHtmlSet || function () {},
      onResultsHtmlSet: e.onResultsHtmlSet || function () {},
      onGetBusListComplete: e.onGetBusListComplete || function () {},
      onGetBusLineComplete: e.onGetBusLineComplete || function () {},
      onBusListHtmlSet: e.onBusListHtmlSet || function () {},
      onBusLineHtmlSet: e.onBusLineHtmlSet || function () {},
      onPolylinesSet: e.onPolylinesSet || function () {},
      reqFrom: e.reqFrom || ""
    };
    if (typeof e != "undefined" && typeof e.renderOptions != "undefined" && typeof e.renderOptions.autoViewport != "undefined") {
      this._opts.renderOptions.autoViewport = e.renderOptions.autoViewport;
    } else {
      this._opts.renderOptions.autoViewport = true;
    }
    this._opts.renderOptions.panel = eX.G(this._opts.renderOptions.panel);
  }
  aH.inherits(c8, "BaseSearch");
  eX.extend(aH.prototype, {
    getResults: function () {
      if (!this._isMultiKey) {
        return this._results;
      } else {
        return this._arrResults;
      }
    },
    enableAutoViewport: function () {
      this._opts.renderOptions.autoViewport = true;
    },
    disableAutoViewport: function () {
      this._opts.renderOptions.autoViewport = false;
    },
    setLocation: function (e) {
      if (!e) {
        return;
      }
      this._loc.src = e;
    },
    setSearchCompleteCallback: function (e) {
      this._opts.onSearchComplete = e || function () {};
    },
    setMarkersSetCallback: function (e) {
      this._opts.onMarkersSet = e || function () {};
    },
    setPolylinesSetCallback: function (e) {
      this._opts.onPolylinesSet = e || function () {};
    },
    setInfoHtmlSetCallback: function (e) {
      this._opts.onInfoHtmlSet = e || function () {};
    },
    setResultsHtmlSetCallback: function (e) {
      this._opts.onResultsHtmlSet = e || function () {};
    },
    getStatus: function () {
      return this._status;
    }
  });
  var cA = function (T, i) {
    aH.call(this, T, i);
    i = i || {};
    i.renderOptions = i.renderOptions || {};
    this.setPageCapacity(i.pageCapacity);
    if (typeof i.renderOptions.selectFirstResult != "undefined" && !i.renderOptions.selectFirstResult) {
      this.disableFirstResultSelection();
    } else {
      this.enableFirstResultSelection();
    }
    this._overlays = [];
    this._arrPois = [];
    this._curIndex = -1;
    this._queryList = [];
    var e = this;
    g2.load("localSearch", function () {
      e._check();
    }, true);
  };
  cA.inherits(aH, "LocalSearch");
  cA.DEFAULT_PAGE_CAPACITY = 10;
  cA.MIN_PAGE_CAPACITY = 1;
  cA.MAX_PAGE_CAPACITY = 100;
  cA.DEFAULT_RADIUS = 2000;
  cA.MAX_RADIUS = 100000;
  eX.extend(cA.prototype, {
    search: function (e, i) {
      this._queryList.push({
        method: "search",
        arguments: [e, i]
      });
    },
    searchInBounds: function (e, T, i) {
      this._queryList.push({
        method: "searchInBounds",
        arguments: [e, T, i]
      });
    },
    searchNearby: function (T, i, e, kc) {
      this._queryList.push({
        method: "searchNearby",
        arguments: [T, i, e, kc]
      });
    },
    clearResults: function () {
      delete this._json;
      delete this._status;
      delete this._results;
      delete this._ud;
      this._curIndex = -1;
      this._setStatus();
      if (this._opts.renderOptions.panel) {
        this._opts.renderOptions.panel.innerHTML = "";
      }
    },
    gotoPage: function () {},
    enableFirstResultSelection: function () {
      this._opts.renderOptions.selectFirstResult = true;
    },
    disableFirstResultSelection: function () {
      this._opts.renderOptions.selectFirstResult = false;
    },
    setPageCapacity: function (e) {
      if (typeof e == "number" && !isNaN(e)) {
        this._opts.pageCapacity = e < 1 ? cA.DEFAULT_PAGE_CAPACITY : e > cA.MAX_PAGE_CAPACITY ? cA.DEFAULT_PAGE_CAPACITY : e;
      } else {
        this._opts.pageCapacity = cA.DEFAULT_PAGE_CAPACITY;
      }
    },
    getPageCapacity: function () {
      return this._opts.pageCapacity;
    },
    toString: function () {
      return "LocalSearch";
    }
  });
  function bf(i) {
    this._opts = {};
    eX.extend(this._opts, i);
    this._queryList = [];
    var e = this;
    g2.load("otherSearch", function () {
      e._asyncSearch();
    });
  }
  bf.inherits(c8, "Geocoder");
  eX.extend(bf.prototype, {
    getPoint: function (e, T, i) {
      this._queryList.push({
        method: "getPoint",
        arguments: [e, T, i]
      });
    },
    getLocation: function (e, T, i) {
      this._queryList.push({
        method: "getLocation",
        arguments: [e, T, i]
      });
    },
    toString: function () {
      return "Geocoder";
    }
  });
  function cW(e) {
    e = e || {};
    this.config = {
      timeout: e.timeout || 10000,
      maximumAge: e.maximumAge || 0,
      enableHighAccuracy: e.enableHighAccuracy === undefined ? true : e.enableHighAccuracy,
      SDKLocation: e.SDKLocation || false
    };
    this._pendingCalls = [];
    var i = this;
    g2.load("otherSearch", function () {
      var T = i._pendingCalls.length;
      for (var kc = 0; kc < T; kc++) {
        var kd = i._pendingCalls[kc];
        i[kd.method].apply(i, kd.arguments);
      }
    });
  }
  eX.extend(cW.prototype, {
    getCurrentPosition: function (e, i) {
      this._pendingCalls.push({
        method: "getCurrentPosition",
        arguments: arguments
      });
    },
    getStatus: function () {
      return BMAP_STATUS_UNKNOWN_LOCATION;
    },
    enableSDKLocation: function () {
      if (bW()) {
        this.config.SDKLocation = true;
      }
    },
    disableSDKLocation: function () {
      this.config.SDKLocation = false;
    }
  });
  function fk() {
    this._queryList = [];
    var e = this;
    g2.load("otherSearch", function () {
      e._asyncSearch();
    });
  }
  fk.inherits(c8, "Boundary");
  eX.extend(fk.prototype, {
    get: function (i, e) {
      this._queryList.push({
        method: "get",
        arguments: [i, e]
      });
    },
    toString: function () {
      return "Boundary";
    },
    parsebdStr: function (i, e) {}
  });
  function fd(i) {
    i = i || {};
    i.renderOptions = i.renderOptions || {};
    this._opts = {
      renderOptions: {
        map: i.renderOptions.map || null
      }
    };
    this._queryList = [];
    var e = this;
    g2.load("otherSearch", function () {
      e._asyncSearch();
    });
  }
  fd.inherits(c8, "LocalCity");
  eX.extend(fd.prototype, {
    get: function (e) {
      this._queryList.push({
        method: "get",
        arguments: [e]
      });
    },
    toString: function () {
      return "LocalCity";
    }
  });
  function hf(e, T) {
    c8.call(this);
    this.markersList = [];
    this.destList = [];
    this.pointsList = [];
    this._opts = T;
    this.json = e;
    this.map = this._opts.renderOptions.map || null;
    this.sType = this._opts.sType;
    this.infoWindow = null;
    this.curPointIndex = 0;
    this.startName = "";
    this.endIndex = 1;
    this.endName = "";
    this.resCity = [0, 0, 0, 0, 0, 0, 0];
    this.locPois = [];
    this.curPageIndex = [1, 1, 1, 1, 1, 1, 1];
    this.totalPage = [1, 1, 1, 1, 1, 1, 1];
    this.resCount = [0, 0, 0, 0, 0, 0, 0];
    this.resType = [0, 0, 0, 0, 0, 0, 0];
    this.qInfo = [{
      n: "",
      c: 0,
      u: 0,
      x: 0,
      y: 0,
      t: -1
    }, {
      n: "",
      c: 0,
      u: 0,
      x: 0,
      y: 0,
      t: -1
    }, {
      n: "",
      c: 0,
      u: 0,
      x: 0,
      y: 0,
      t: -1
    }, {
      n: "",
      c: 0,
      u: 0,
      x: 0,
      y: 0,
      t: -1
    }, {
      n: "",
      c: 0,
      u: 0,
      x: 0,
      y: 0,
      t: -1
    }, {
      n: "",
      c: 0,
      u: 0,
      x: 0,
      y: 0,
      t: -1
    }, {
      n: "",
      c: 0,
      u: 0,
      x: 0,
      y: 0,
      t: -1
    }];
    this.curSelectedIndex = -1;
    this.tpList = [];
    this.tpListInMap = [];
    var i = this;
    g2.load("route", function () {});
  }
  hf.inherits(c8, "RouteAddr");
  function ex(T, i) {
    aH.call(this, T, i);
    this.QUERY_TYPE_BUSLIST = db;
    this.RETURN_TYPE_BUSLIST = cO;
    this.QUERY_TYPE_BUSLINE = en;
    this.RETURN_TYPE_BUSLINE = eb;
    this._queryList = [];
    var e = this;
    g2.load("buslineSearch", function () {
      e._asyncSearch();
    });
  }
  var fB = B.staticHost + "/wolfman/static/common/images/";
  ex._iconOpen = B.apiIMG + "/iw_plus.gif";
  ex._iconClose = B.apiIMG + "/iw_minus.gif";
  ex._stopUrl = fB + "new/bus-stop-1x_ddd4723.png";
  ex.inherits(aH, "BusLineSearch");
  eX.extend(ex.prototype, {
    getBusList: function (e) {
      this._queryList.push({
        method: "getBusList",
        arguments: [e]
      });
    },
    getBusLine: function (e) {
      this._queryList.push({
        method: "getBusLine",
        arguments: [e]
      });
    },
    setGetBusListCompleteCallback: function (e) {
      this._opts.onGetBusListComplete = e || function () {};
    },
    setGetBusLineCompleteCallback: function (e) {
      this._opts.onGetBusLineComplete = e || function () {};
    },
    setBusListHtmlSetCallback: function (e) {
      this._opts.onBusListHtmlSet = e || function () {};
    },
    setBusLineHtmlSetCallback: function (e) {
      this._opts.onBusLineHtmlSet = e || function () {};
    },
    setPolylinesSetCallback: function (e) {
      this._opts.onPolylinesSet = e || function () {};
    }
  });
  function i2(i) {
    aH.call(this, i);
    i = i || {};
    this._options = {
      input: i.input || null,
      baseDom: i.baseDom || null,
      types: i.types || [],
      onSearchComplete: i.onSearchComplete || function () {}
    };
    this._loc.src = i.location || "全国";
    this._word = "";
    this._show = false;
    this._suggestion = null;
    this._inputValue = "";
    this._initialize();
    var e = this;
    g2.load("autocomplete", function () {
      e._asyncSearch();
    }, true);
  }
  i2.inherits(aH, "Autocomplete");
  eX.extend(i2.prototype, {
    _initialize: function () {},
    show: function () {
      this._show = true;
    },
    hide: function () {
      this._show = false;
    },
    setTypes: function (e) {
      this._options.types = e;
    },
    setLocation: function (e) {
      this._loc.src = e;
    },
    search: function (e) {
      this._word = e;
    },
    setInputValue: function (e) {
      this._inputValue = e;
    },
    setSearchCompleteCallback: function (e) {
      this._options.onSearchComplete = e;
    }
  });
  var jK = function (i, e) {
    aH.call(this, i, e);
  };
  eX.inherit(jK, aH, "BaseRoute");
  eX.extend(jK.prototype, {
    clearResults: function () {}
  });
  window.BMAP_TRANSIT_POLICY_RECOMMEND = 0;
  window.BMAP_TRANSIT_POLICY_LEAST_TIME = 4;
  window.BMAP_TRANSIT_POLICY_LEAST_TRANSFER = 1;
  window.BMAP_TRANSIT_POLICY_LEAST_WALKING = 2;
  window.BMAP_TRANSIT_POLICY_AVOID_SUBWAYS = 3;
  window.BMAP_TRANSIT_POLICY_FIRST_SUBWAYS = 5;
  window.BMAP_LINE_TYPE_BUS = 0;
  window.BMAP_LINE_TYPE_SUBWAY = 1;
  window.BMAP_LINE_TYPE_FERRY = 2;
  window.BMAP_LINE_TYPE_TRAIN = 3;
  window.BMAP_LINE_TYPE_AIRPLANE = 4;
  window.BMAP_LINE_TYPE_COACH = 5;
  var ij = 3;
  var d9 = 4;
  var ag = 1;
  var ih = 2;
  var aV = 5;
  var cQ = 6;
  window.BMAP_TRANSIT_TYPE_IN_CITY = 0;
  window.BMAP_TRANSIT_TYPE_CROSS_CITY = 1;
  window.BMAP_TRANSIT_PLAN_TYPE_ROUTE = 0;
  window.BMAP_TRANSIT_PLAN_TYPE_LINE = 1;
  window.BMAP_TRANSIT_TYPE_POLICY_TRAIN = 0;
  window.BMAP_TRANSIT_TYPE_POLICY_AIRPLANE = 1;
  window.BMAP_TRANSIT_TYPE_POLICY_COACH = 2;
  window.BMAP_INTERCITY_POLICY_LEAST_TIME = 0;
  window.BMAP_INTERCITY_POLICY_EARLY_START = 1;
  window.BMAP_INTERCITY_POLICY_CHEAP_PRICE = 2;
  function eM(T, i) {
    jK.call(this, T, i);
    i = i || {};
    this.setPolicy(i.policy);
    this.setIntercityPolicy(i.intercityPolicy);
    this.setTransitTypePolicy(i.transitTypePolicy);
    this.setPageCapacity(i.pageCapacity);
    this.QUERY_TYPE = gY;
    this.RETURN_TYPE = eS;
    this.ROUTE_TYPE = hE;
    this._overlays = [];
    this._curIndex = -1;
    this._opts._enableTraffic = i.enableTraffic || false;
    this._queryList = [];
    var e = this;
    g2.load("route", function () {
      e._asyncSearch();
    }, true);
  }
  eM.MAX_PAGE_CAPACITY = 100;
  eM.LINE_TYPE_MAPPING = [0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 1];
  eM.LINE_TYPE_MAPPING_CROSS_CITY = [0, 3, 4, 0, 0, 0, 5];
  eX.inherit(eM, jK, "TransitRoute");
  eX.extend(eM.prototype, {
    setPolicy: function (e) {
      if (e >= BMAP_TRANSIT_POLICY_RECOMMEND && e <= BMAP_TRANSIT_POLICY_FIRST_SUBWAYS) {
        this._opts.policy = e;
      } else {
        this._opts.policy = BMAP_TRANSIT_POLICY_RECOMMEND;
      }
    },
    setIntercityPolicy: function (e) {
      if (e >= BMAP_INTERCITY_POLICY_LEAST_TIME && e <= BMAP_INTERCITY_POLICY_CHEAP_PRICE) {
        this._opts.intercityPolicy = e;
      } else {
        this._opts.intercityPolicy = BMAP_INTERCITY_POLICY_LEAST_TIME;
      }
    },
    setTransitTypePolicy: function (e) {
      if (e >= BMAP_TRANSIT_TYPE_POLICY_TRAIN && e <= BMAP_TRANSIT_TYPE_POLICY_COACH) {
        this._opts.transitTypePolicy = e;
      } else {
        this._opts.transitTypePolicy = BMAP_TRANSIT_TYPE_POLICY_TRAIN;
      }
    },
    _internalSearch: function (i, e) {
      this._queryList.push({
        method: "_internalSearch",
        arguments: [i, e]
      });
    },
    search: function (i, e) {
      this._queryList.push({
        method: "search",
        arguments: [i, e]
      });
    },
    setPageCapacity: function (e) {
      if (typeof e === "string") {
        e = parseInt(e, 10);
        if (isNaN(e)) {
          this._opts.pageCapacity = eM.MAX_PAGE_CAPACITY;
          return;
        }
      }
      if (typeof e !== "number") {
        this._opts.pageCapacity = eM.MAX_PAGE_CAPACITY;
        return;
      }
      if (e >= 1 && e <= eM.MAX_PAGE_CAPACITY) {
        this._opts.pageCapacity = Math.round(e);
      } else {
        this._opts.pageCapacity = eM.MAX_PAGE_CAPACITY;
      }
    },
    toString: function () {
      return "TransitRoute";
    },
    _shortTitle: function (e) {
      return e.replace(/\(.*\)/, "");
    }
  });
  window.BMAP_HIGHLIGHT_STEP = 1;
  window.BMAP_HIGHLIGHT_ROUTE = 2;
  var cF = function (e, kc) {
    jK.call(this, e, kc);
    this._overlays = [];
    this._curIndex = -1;
    this._queryList = [];
    var T = this;
    var i = this._opts.renderOptions;
    if (i.highlightMode !== BMAP_HIGHLIGHT_STEP && i.highlightMode !== BMAP_HIGHLIGHT_ROUTE) {
      i.highlightMode = BMAP_HIGHLIGHT_STEP;
    }
    this._enableDragging = this._opts.renderOptions.enableDragging ? true : false;
    g2.load("route", function () {
      T._asyncSearch();
    }, true);
    if (this.init_d) {
      this.init_d();
    }
  };
  cF.ROAD_TYPE = ["", "环岛", "无属性道路", "主路", "高速连接路", "交叉点内路段", "连接道路", "停车场内部道路", "服务区内部道路", "桥", "步行街", "辅路", "匝道", "全封闭道路", "未定义交通区域", "POI连接路", "隧道", "步行道", "公交专用道", "提前右转道"];
  eX.inherit(cF, jK, "DWRoute");
  eX.extend(cF.prototype, {
    search: function (T, e, i) {
      this._queryList.push({
        method: "search",
        arguments: [T, e, i]
      });
    }
  });
  var iK = function (e, T) {
    jK.call(this, e, T);
    this._overlays = [];
    this._queryList = [];
    var i = this;
    this.map = T.renderOptions.map;
    this._enableDragging = this._opts.renderOptions.enableDragging ? true : false;
    this._menu = new BMapGL.ContextMenu();
    this._menu.addItem(new hW("删除该点", function (ke, kd, kc) {
      i._deleteVia(kc.curNo - 1);
    }, 60));
    this.map.addContextMenu(this._menu, true);
    g2.load("route", function () {
      i._asyncSearch();
    }, true);
    if (this.init_d) {
      this.init_d();
    }
  };
  eX.inherit(iK, jK, "LineLayerRoute");
  eX.extend(iK.prototype, {
    search: function (T, e, i) {
      this._queryList.push({
        method: "search",
        arguments: [T, e, i]
      });
    }
  });
  window.BMAP_DRIVING_POLICY_DEFAULT = 0;
  window.BMAP_DRIVING_POLICY_AVOID_HIGHWAYS = 3;
  window.BMAP_DRIVING_POLICY_FIRST_HIGHWAYS = 4;
  window.BMAP_DRIVING_POLICY_AVOID_CONGESTION = 5;
  window.BMAP_TRAFFICE_STATUS_NONE = 0;
  window.BMAP_TRAFFICE_STATUS_NORMAL = 1;
  window.BMAP_TRAFFICE_STATUS_SLOW = 2;
  window.BMAP_TRAFFICE_STATUS_JAM = 3;
  function cq(e, i) {
    cF.call(this, e, i);
    i = i || {};
    this._opts._enableTraffic = i.enableTraffic || false;
    this.setPolicy(i.policy);
    this.QUERY_TYPE = aO;
    this.RETURN_TYPE = aA;
    this.ROUTE_TYPE = BMAP_ROUTE_TYPE_DRIVING;
  }
  function fZ(e, i) {
    iK.call(this, e, i);
    i = i || {};
    this.setPolicy(i.policy);
    this.QUERY_TYPE = aO;
  }
  eX.inherit(fZ, iK, "DrivingRouteLine");
  eX.inherit(cq, cF, "DrivingRoute");
  cq.prototype.setPolicy = function (e) {
    if (e >= BMAP_DRIVING_POLICY_DEFAULT && e <= BMAP_DRIVING_POLICY_AVOID_CONGESTION) {
      this._opts.policy = e;
    } else {
      this._opts.policy = BMAP_DRIVING_POLICY_DEFAULT;
    }
  };
  fZ.prototype.setPolicy = function (e) {
    if (e >= BMAP_DRIVING_POLICY_DEFAULT && e <= BMAP_DRIVING_POLICY_AVOID_CONGESTION) {
      this._opts.policy = e;
    } else {
      this._opts.policy = BMAP_DRIVING_POLICY_DEFAULT;
    }
  };
  function fp(e, i) {
    cF.call(this, e, i);
    this.QUERY_TYPE = h7;
    this.RETURN_TYPE = gf;
    this.ROUTE_TYPE = BMAP_ROUTE_TYPE_WALKING;
    this._enableDragging = false;
  }
  eX.inherit(fp, cF, "WalkingRoute");
  function c4(e, i) {
    cF.call(this, e, i);
    this.QUERY_TYPE = hz;
    this.ROUTE_TYPE = BMAP_ROUTE_TYPE_RIDING;
    this._enableDragging = false;
  }
  eX.inherit(c4, cF, "RidingRoute");
  function W(e, i) {
    iK.call(this, e, i);
    i = i || {};
    this.QUERY_TYPE = b1;
    this.setPolicy(i.policy);
  }
  eX.inherit(W, iK, "TruckRoute");
  W.prototype.setPolicy = function (e) {
    if (e >= BMAP_DRIVING_POLICY_DEFAULT && e <= BMAP_DRIVING_POLICY_AVOID_CONGESTION) {
      this._opts.policy = e;
    } else {
      this._opts.policy = BMAP_DRIVING_POLICY_DEFAULT;
    }
  };
  window.BMAP_MODE_DRIVING = "driving";
  window.BMAP_MODE_TRANSIT = "transit";
  window.BMAP_MODE_WALKING = "walking";
  window.BMAP_MODE_NAVIGATION = "navigation";
  var a1 = {
    web: "//api.map.baidu.com/direction?",
    android: "bdapp://map/direction?",
    ios: "baidumap://map/direction?"
  };
  function iH(e) {
    this.opts = e || {};
  }
  eX.extend(iH.prototype, {
    routeCall: function (kc, e, T) {
      var i = this;
      g2.load("route", function () {
        i._asyncSearch(kc, e, T);
      });
    }
  });
  function d7() {
    return Pano.getStreetViewCoverageLayer(bx);
  }
  function eO() {
    Pano.PanoramaService.call(this);
  }
  eX.inherit(eO, Pano.PanoramaService, "PanoramaService");
  eX.extend(eO.prototype, {
    getPanoramaById: function (T, i) {
      var e = this;
      this.getPanoById(T, function (kc) {
        if (i) {
          i(e._makeData(kc));
        }
      });
    },
    getPanoramaByLocation: function (e, T) {
      e = i9.convertLL2MC(e);
      var i = this;
      this.getPanoByLocation(e, 50, function (kc) {
        if (T) {
          T(i._makeData(kc));
        }
      });
    },
    _makeData: function (T) {
      if (!T) {
        return null;
      }
      var i = {};
      var e = T.content[0];
      i.description = e.Rname || e.Info || "";
      i.id = e.ID;
      i.pointX = e.X / 100;
      i.pointY = e.Y / 100;
      i.position = i9.convertMC2LL(new cx(i.pointX, i.pointY));
      return i;
    }
  });
  function ff() {
    if (window.PANORAMA_URL) {
      return Pano.getPanoControl(bx, {
        imgPath: B.imgPath,
        tileBaseUrl: B.panoTilePath
      });
    }
    return Pano.getPanoControl(bx);
  }
  function O(T, e) {
    if (!e) {
      return;
    }
    this.content = T;
    if (e.position && !Array.isArray(e.position)) {
      e.position = i9.convertLL2MC(e.position);
      this.position = e.position;
      this.hideDistance = !!e.hideDistance;
    } else {
      this.hideDistance = true;
    }
    var i = this._createDom();
    Pano.PanoOverlay.call(this, e.position, {
      dom: i,
      altitude: e.altitude
    });
  }
  eX.inherit(O, Pano.PanoOverlay, "PanoramaLabel");
  eX.extend(O.prototype, {
    init: function (e) {
      var i = this;
      this._pano = e;
      this.updatedDistance();
      Pano.PanoOverlay.prototype.init.call(this, e);
      this._pano.on("dataload", function (T) {
        i.updatedDistance();
      });
    },
    _createDom: function () {
      var kc = this.content;
      var kf = document.createElement("div");
      var i = kf.style;
      i.position = "absolute";
      i.backgroundColor = "rgba(29, 29, 29, 0.8)";
      i.padding = "7px 0";
      i.height = "19px";
      i.font = "16px arial";
      i.color = "white";
      i.whiteSpace = "nowrap";
      i.borderRadius = "4px";
      var e = document.createElement("div");
      e.style.float = "left";
      e.style.lineHeight = "19px";
      kf.appendChild(e);
      var T = document.createElement("span");
      T.style.margin = "0 14px";
      T.innerText = kc;
      e.appendChild(T);
      if (!this.hideDistance) {
        var ke = document.createElement("span");
        ke.style.color = "color:rgba(255,255,255,0.3)";
        ke.innerText = "|";
        e.appendChild(ke);
        var kd = document.createElement("span");
        kd.style.margin = "0 8px";
        kd.style.color = "#60c7fa";
        kd.style.fontSize = "12px";
        kd.innerText = "0米";
        e.appendChild(kd);
        this._distanceDom = kd;
      }
      this._dom = kf;
      this._titleDom = T;
      return kf;
    },
    updatedDistance: function () {
      if (this.hideDistance) {
        return;
      }
      var T = 0;
      if (this._pano) {
        var i = this._pano.position;
        var e = this.position;
        if (i && !i.equals(e)) {
          T = i9.getDistanceByMC(i, e);
        }
      }
      if (T > 100) {
        T = T / 1000;
        T = T < 100 ? T.toFixed(2) : T.toFixed(0);
        T += "公里";
      } else {
        T = T < 100 ? T.toFixed(2) : T.toFixed(0);
        T += "米";
      }
      this._distanceDom.innerText = T;
    }
  });
  function d(i) {
    if (typeof i === "string" && /^(?!#)(\w)*/.test(i)) {
      i = "#" + i;
    }
    var kc = {};
    if (window.PANORAMA_URL) {
      kc.imgPath = B.imgPath;
      kc.tileBaseUrls = [B.panoTilePath];
    }
    var e = Pano.init(i, kc);
    var T = e.setPosition;
    e.setPosition = function (ke) {
      var kf = i9.convertLL2MC(ke);
      T.call(e, kf);
    };
    var kd = e.addEventListener;
    e.addEventListener = function (ke, kf) {
      if (ke === "position_changed") {
        kd.call(e, ke, function (kg) {
          var kh = i9.convertMC2LL(kg);
          kf(kh);
        });
      } else {
        kd.call(e, ke, kf);
      }
    };
    return e;
  }
  bx.Map = hK;
  bx.MapType = ej;
  bx.Point = cx;
  bx.Pixel = fi;
  bx.Size = i0;
  bx.Bounds = hY;
  bx.PrivateRegionDataModel = cM;
  bx.TileLayer = hv;
  bx.Copyright = m;
  bx.Projection = bx.Project = i9;
  bx.XYZProjection = bx.XYZProject = dB;
  bx.Convertor = fS;
  bx.RenderTypeUtils = c6;
  bx.Overlay = aR;
  bx.Label = hR;
  bx.Marker = s;
  bx.Symbol = fg;
  bx.SVGSymbol = dK;
  bx.Icon = jt;
  bx.Polyline = bl;
  bx.BezierCurve = cH;
  bx.PolylineMultipart = el;
  bx.Polygon = iG;
  bx.MapMask = jY;
  bx.Prism = br;
  bx.Marker3D = ec;
  bx.GroundOverlay = fY;
  bx.CustomOverlay = bL;
  bx.CustomHtmlLayer = dx;
  bx.InfoWindow = d2;
  bx.SimpleInfoWindow = h1;
  bx.Circle = aU;
  bx.Control = gH;
  bx.NavigationControl = jH;
  bx.NavigationControl3D = eZ;
  bx.CopyrightControl = f5;
  bx.ScaleControl = kb;
  bx.CityListControl = bs;
  bx.MapTypeControl = v;
  bx.ZoomControl = jc;
  bx.LocationControl = go;
  bx.LogoControl = bA;
  bx.DistanceTool = cf;
  bx.ContextMenu = hm;
  bx.MenuItem = hW;
  bx.OperationMask = aj;
  bx.Animation = fy;
  bx.ViewAnimation = q;
  bx.Transitions = gA;
  bx.Event = fJ;
  bx.trafficLayer = jE;
  bx.TrafficLayer = jg;
  bx.GeoJSONLayer = aN;
  bx.XYZLayer = jZ;
  bx.PixelLayer = dr;
  bx.GeoJSONParse = gw;
  bx.NormalLayer = cm;
  bx.LineLayer = bS;
  bx.FillLayer = d0;
  bx.Entity = ja;
  bx.MVTLayer = d8;
  bx.BaiduLayer = U;
  bx.Geolocation = cW;
  bx.Geocoder = bf;
  bx.Boundary = fk;
  bx.DistrictLayer = dX;
  bx.LocalCity = fd;
  bx.LocalSearch = cA;
  bx.Autocomplete = i2;
  bx.BusLineSearch = ex;
  bx.WalkingRoute = fp;
  bx.RidingRoute = c4;
  bx.DrivingRoute = cq;
  bx.DrivingRouteLine = fZ;
  bx.TransitRoute = eM;
  bx.RouteSearch = iH;
  bx.TruckRoute = W;
  bx.PanoramaCoverageLayer = d7;
  bx.PanoramaControl = ff;
  bx.PanoramaService = eO;
  bx.PanoramaLabel = O;
  bx.Panorama = d;
  function hd(e, i) {
    for (var T in i) {
      e[T] = i[T];
    }
  }
  if (bx.fetchDebug) {
    bx.fetchDebug.init();
  }
  bx.verify();
  bx.apiLoad();
  bx.frequency();
  bx.getSeckeyCid();
  window._layer = 1;
  eX.extend(dX.prototype, {
    _asyncSearch: function () {
      for (var T = 0, e = this._queryList.length; T < e; T++) {
        var kc = this._queryList[T];
        this[kc.method].apply(this, kc.arguments);
      }
      delete this._queryList;
    },
    addDistrict: function () {
      if (this._opts.districts) {
        var e = this._opts.districts;
        if (typeof e === "string") {
          this.getDistrictData(e);
        } else if (Object.prototype.toString.call(e) === "[object Array]") {
          var i = this.parseArrayParams(e);
          this.getDistrictData(i);
        }
      }
    },
    parseArrayParams: function (e) {
      var kd = "";
      for (var kc = 0; kc < e.length; kc++) {
        if (e[kc] instanceof Array) {
          kd += "(";
          for (var T = 0; T < e.length; T++) {
            kd += e[T];
          }
          kd += ")";
        } else {
          kd += "(" + e[kc] + ")";
        }
      }
      return kd;
    },
    getDistrictData: function (e) {
      var i = this;
      jV.request(function (kc) {
        var T = i._parseGeoData(kc);
        i._drawToMap(i, T);
      }, {
        qt: jF,
        adnames: e,
        level: i._opts.kind
      });
    },
    _drawToMap: function (kl, kh) {
      var kk = kh.boundaries.length;
      if (kk === 0) {
        alert("未能获取当前输入行政区域");
        return;
      }
      var km = this._config.fillColor;
      var ke = this._config.fillOpacity;
      var T = this._config.strokeColor;
      var e = this._config.strokeOpacity;
      var ki = this._config.strokeWeight;
      if (typeof km === "string") {
        var kc = km;
        var kn = [];
        for (var kg = 0; kg < kk; kg++) {
          var kj = new BMapGL.Polygon(kh.boundaries[kg], {
            strokeWeight: ki,
            strokeColor: T,
            strokeOpacity: e,
            fillColor: kc,
            fillOpacity: ke
          });
          kj.style = {
            strokeWeight: ki,
            strokecolor: T,
            strokeOpacity: e,
            fillColor: kc,
            fillOpacity: ke
          };
          this.disOverlays.push(kj);
          this.addEventListenerIn();
          kl._map.addOverlay(kj);
          kn = kn.concat(kj.getPath());
        }
        if (this._config.viewport) {
          kl._map.setViewport(kn);
        }
      } else if (Object.prototype.toString.call(km) === "[object Array]") {
        var kn = [];
        var kf = km.length;
        if (kf < kk) {
          for (var kg = 0, kd = 0; kg < kk - kf; kg++) {
            if (kd < kf - 1) {
              km.push(km[kd++]);
            } else {
              km.push(km[0]);
            }
          }
        }
        for (var kg = 0; kg < kk; kg++) {
          var kc = km[kg];
          var kj = new BMapGL.Polygon(kh.boundaries[kg], {
            strokeWeight: ki,
            strokeColor: T,
            strokeOpacity: e,
            fillColor: kc,
            fillOpacity: ke
          });
          kj.style = {
            strokeWeight: ki,
            strokecolor: T,
            strokeOpacity: e,
            fillColor: kc,
            fillOpacity: ke
          };
          this.disOverlays.push(kj);
          this.addEventListenerIn();
          kl._map.addOverlay(kj);
          kn = kn.concat(kj.getPath());
        }
        if (this._config.viewport) {
          kl._map.setViewport(kn);
        }
      }
    },
    _parseGeoData: function (kl) {
      var ko = {};
      ko.boundaries = [];
      if (kl && kl.content && kl.content.geo) {
        for (var kt = 0; kt < kl.content.geo.length; kt++) {
          var kc = bG.parseGeo(kl.content.geo[kt], false);
          if (kc.geo && kc.geo.length && kc.geo.length > 0) {
            var kr = kc.geo.length;
            for (jo = 0; jo < kr; jo++) {
              var T = kc.geo[jo];
              if (T && T.length && T.length > 0) {
                var kj = T.length - 1;
                var kq = [];
                var ki = false;
                var kp = 0;
                var kn = 0;
                for (var ks = 0; ks < kj; ks += 2) {
                  var kg = T[ks];
                  var ke = T[ks + 1];
                  var km = new cx(kg, ke);
                  km = i9.convertMC2LL(km);
                  if (ks < kj - 3) {
                    var i = T[ks + 2];
                    var e = T[ks + 3];
                    var kk = new cx(i, e);
                    kk = i9.convertMC2LL(kk);
                  }
                  kq.push(km.lng + ", " + km.lat);
                }
                if (ki === true) {
                  if (kp > kn) {
                    var ku = kp;
                    kp = kn;
                    kn = ku;
                  }
                  var kh = kq;
                  var kf = kq.splice(kp + 1);
                  var kd = kf.splice(kn - kp);
                  kh = kh.concat(kd);
                  ko.boundaries.push(kh.join(";"));
                  ko.boundaries.push(kf.join(";"));
                  ki = false;
                  continue;
                }
                if (kq.length !== 0) {
                  ko.boundaries.push(kq.join(";"));
                }
              }
            }
          }
        }
      }
      return ko;
    },
    deleteDistrict: function (kc) {
      var T = kc.disOverlays;
      for (var e = 0; e < T.length; e++) {
        this._map.removeOverlay(T[e]);
      }
    },
    addEventListener: function (e, i) {
      this.eventAndCallback[e] = i;
    },
    addEventListenerIn: function () {
      var kc = this;
      var ke = Object.keys(kc.eventAndCallback);
      if (ke.length > 0) {
        for (var T = 0; T < ke.length; T++) {
          var kd = kc.eventAndCallback[ke[T]];
          for (var e = 0; e < kc.disOverlays.length; e++) {
            kc.disOverlays[e].addEventListener(ke[T], kd);
          }
        }
      }
    },
    searchBoundary: function (i, kd) {
      i = i || {};
      var e = i.name || "";
      var T = i.kind || 0;
      var kc = this;
      jV.request(function (kf) {
        var ke = kc._parseGeoData(kf);
        if (kd) {
          kd(ke);
        }
      }, {
        qt: jF,
        adnames: e,
        level: T
      });
    }
  });
  window._layer = 2;
})(BMapGL, "BMapGL");
